!function(n){function I(I){for(var t,e,i=I[0],C=I[1],B=I[2],Q=0,b=[];Q<i.length;Q++)e=i[Q],Object.prototype.hasOwnProperty.call(l,e)&&l[e]&&b.push(l[e][0]),l[e]=0;for(t in C)Object.prototype.hasOwnProperty.call(C,t)&&(n[t]=C[t]);for(a&&a(I);b.length;)b.shift()();return c.push.apply(c,B||[]),g()}function g(){for(var n,I=0;I<c.length;I++){for(var g=c[I],t=!0,i=1;i<g.length;i++){var C=g[i];0!==l[C]&&(t=!1)}t&&(c.splice(I--,1),n=e(e.s=g[0]))}return n}var t={},l={app:0},c=[];function e(I){if(t[I])return t[I].exports;var g=t[I]={i:I,l:!1,exports:{}};return n[I].call(g.exports,g,g.exports,e),g.l=!0,g.exports}e.m=n,e.c=t,e.d=function(n,I,g){e.o(n,I)||Object.defineProperty(n,I,{enumerable:!0,get:g})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,I){if(1&I&&(n=e(n)),8&I)return n;if(4&I&&"object"==typeof n&&n&&n.__esModule)return n;var g=Object.create(null);if(e.r(g),Object.defineProperty(g,"default",{enumerable:!0,value:n}),2&I&&"string"!=typeof n)for(var t in n)e.d(g,t,function(I){return n[I]}.bind(null,t));return g},e.n=function(n){var I=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(I,"a",I),I},e.o=function(n,I){return Object.prototype.hasOwnProperty.call(n,I)},e.p="";var i=window.webpackJsonp=window.webpackJsonp||[],C=i.push.bind(i);i.push=I,i=i.slice();for(var B=0;B<i.length;B++)I(i[B]);var a=C;c.push([0,"element-ui","leaflet"]),g()}({0:function(n,I,g){n.exports=g("56d7")},"0e15":function(module,exports,__webpack_require__){eval('/* eslint-disable no-undefined */\n\nvar throttle = __webpack_require__("597f");\n\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {Boolean}  [atBegin]     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @return {Function} A new, debounced function.\n */\nmodule.exports = function ( delay, atBegin, callback ) {\n\treturn callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvZGVib3VuY2UuanM/MGUxNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxlQUFlLG1CQUFPLENBQUMsTUFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjBlMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cblxudmFyIHRocm90dGxlID0gcmVxdWlyZSgnLi90aHJvdHRsZScpO1xuXG4vKipcbiAqIERlYm91bmNlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBEZWJvdW5jaW5nLCB1bmxpa2UgdGhyb3R0bGluZyxcbiAqIGd1YXJhbnRlZXMgdGhhdCBhIGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgYSBzaW5nbGUgdGltZSwgZWl0aGVyIGF0IHRoZVxuICogdmVyeSBiZWdpbm5pbmcgb2YgYSBzZXJpZXMgb2YgY2FsbHMsIG9yIGF0IHRoZSB2ZXJ5IGVuZC5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgZGVsYXkgICAgICAgICBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudCBjYWxsYmFja3MsIHZhbHVlcyBhcm91bmQgMTAwIG9yIDI1MCAob3IgZXZlbiBoaWdoZXIpIGFyZSBtb3N0IHVzZWZ1bC5cbiAqIEBwYXJhbSAge0Jvb2xlYW59ICBbYXRCZWdpbl0gICAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgYXRCZWdpbiBpcyBmYWxzZSBvciB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGBkZWxheWAgbWlsbGlzZWNvbmRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC4gSWYgYXRCZWdpbiBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgYXQgdGhlIGZpcnN0IGRlYm91bmNlZC1mdW5jdGlvbiBjYWxsLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgIEEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzLiBUaGUgYHRoaXNgIGNvbnRleHQgYW5kIGFsbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLCBhcy1pcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGBjYWxsYmFja2Agd2hlbiB0aGUgZGVib3VuY2VkLWZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggZGVsYXksIGF0QmVnaW4sIGNhbGxiYWNrICkge1xuXHRyZXR1cm4gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IHRocm90dGxlKGRlbGF5LCBhdEJlZ2luLCBmYWxzZSkgOiB0aHJvdHRsZShkZWxheSwgY2FsbGJhY2ssIGF0QmVnaW4gIT09IGZhbHNlKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0e15\n')},"0f91":function(module,exports){eval('module.exports = "data:image/png;base64,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"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdlcy93YXJuLnBuZz9mZTg1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIwZjkxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBWUFBQUJ6ZW5yMEFBQUFBWE5TUjBJQXJzNGM2UUFBQmtoSlJFRlVXRWZGVndsc1ZFVVkvbVozMjkwdDI3dlMwb0lVUllNQkxTU2cyS0lJSHRCanV4VWtnRW81UkhwNEFLVVVCRlRBbGdBQ1Zvd0ZSSUVXQlltaTlBREVnMHZCVmhJUlJEUUVJb2lVdHJUZGJidnQzanRtcG5tUDk5N3VBc1lZL3VSbHMvLzg4ODgzTTk5ODh3L0JMVmk5MFJpaUptUWNWWGxIRVVxR1VDQ1JBSkdTcmg2QU5oR296b1BnWjYrSEhvcXJycTY4aGRRZ053cHFTa3VMZzBhOWdCTGtBdERkU2tJaGhnSXRLbUNUemUxZDAzZnZYbk9ndmdFQk5HWm01QUprRFFoNi9KdUJsYkVVTUFPMEtLNnk1a04vZWZ3Q2FNektLQU1sZWY5bFlEOTl5MklycTE5UytuMEFOSnFNbndCNDF0L2dLb01CdXNkR1FadWNERlZFQkZTUlVUek1hMjZGdDlVTSs1SERjSjQrQlU5all5RHNPMklycTUrVE5zb0FOSnFNN3dQSTkwR3AweUVrd3dqZDJGU29ZMkp1dWpDMnJ3L0FkdUFBM0JmTys4WVN1aUYyVDQwNGhnaWd3WlF4azRCc1Z2YlFQVG9TSWVPZmdhWnZYOTdrcUt1RjgvUnBlSzVjZ2Z2aW45eW42WnNJVGI5KzBDUW1RanY4WVJCZE4xK3QyeXZRdGZ0elh4Q1U1c1ZXMVd4a0RSekFwZlQwU0sxR2RVRnh0QkNTYVlKaHhnczhnZTNiYjJBL2VCQ3VzNytKQ1h0TW1veXUzYnRCWFU3Ung0Q0U1dVFoYU1BQTd1djhkQ2YvWkViUlNkeWUvajMzN1d2Z0FKcE14aElLTEpJR2FSOThDRDJ5czZIcDNRZnV5MytoZmZWcS9pc1lHNXg5VFZtWmZyY2tORGNQK3JHcHZLM3Q3VlZ3SERzbWl5TVVwVDJycXVkeUFBMG1Zek1Cb3FVUlBmZFVvYlZnRHNJSzV2bUFDRTRhaklobHl6bWcxbGRlRHNpSjhNV3ZRenRzR0c5dm5WZWc1SVRkNDBVMGFUQWFUVVNGUGRJcyt2UU1oTDQ0Qy9halI5QzE1MHNmRVByMGRENDdUM016V21iT0NBaUFOVVNYYllRNlBoNk1tQjFsak9NU28yUUthY3JLTEtXVXpoYmM2bDY5RUwxaEUvOXJYcmdBcmo5KzV5UUxtejlmWEFuYTJTWHVzYm1vRUs1ejUyUjV0Y09IdzFGYnkzM0JTVWtJWC9JR1NGQVFXdkx6NEttL0lzWlNRcmVRSmxQbVVRcjZpT0ExWkU5RnlManhjSnc0Z2JhU3Q4UmdUV0kvaEJVV2NoRFViaGVacmlSWjFOcDFzS3dvZ2JlbFJld2JObWN1MXcvcjFpM29xcFF0OWtuU2FNcW9CMGd2SVRwOC9nSm9VMUxRc1dramJQdjN5V2JHU0tjZE1ZS0RFSXk2M2JBc1dzaFhRZWlySkdaSTF0TXdUSnNPMTVrek1DKzV6blVtMDZUUlpIUURVQXNKMlF3MGQvZUhaY2xpT00vOEtnTmdtRG9OMU9XQ0xqa0Y2dDY5eFRiSFQzVm9XMUVDUmx4bVNnREJnNGNnWXVreXZ2eHNHNlRHQUZDcDQ0NlBkNEFZREdpZU9nWGV0alpaY05pcnM4R09wMlhsQ2tRV3I1QzFzV1BHVm80Wk94blNJOHRrTzJaYkJhak5obXVUSjk0RXdNNWRJSG85bXFkbHcydXhpTUdxcUNoRXJWa0g5bXRldkFpUkpYSUEwcXhLWHFqQ3d4RlR2aDNVYXNXMTUrWFhqTThXUkpkdGdEbytBWmFsYjhMNXkwa3hyeUE4ekdFLytCMTBveC9uYmZiRGh6akJwS2JVaCtCQjl5T2l1SVRyQU5NRHhSYklTY2dDV1FmcnRxMWNBNWhKWjg5bTRiNTRFVUdEQnZHMjl2WHZRcCthaXFCNzdwVWxsbkpJbjVxRzBKeGNyb1pNRlVVQ014SXFqMkdJS1F1RzZUUDR6TnBMMytHeDdGeUhMK3htcjdlakEzQTY0Zmp4T0xUSktXZ3RMRUNQaVpPZ1NlZ3RnbUp4MG0wUUZMSHJpOTJ3VnBSTGdaNzBGYUw0QkxCdFlHeHZLMTRPNTZsVFhQV1l0Z3ZtdVhvVjV0Y1dJR2pnUUQ2cmlPWEZjUHp3UFVMenI5Y2JBb0NnQWZjaGNtWDNyRnZ5Y3NENmlpdkFoTWlmRkxORStxZkd3Rk5majViOFhIN3BzRTh3Mjk0YWRHeitRTVlQdHI5c3BvSzUvNzZNOWxXckVESmhBdGlWenVKWlA1a3hLV1lPNVdYRWRJRHBBVE5CRVdQS0s2QUtqK0ErUHhjTDl3djhZU1RVOUxrVEhNUzZ0WWhhVitydjF1eStqRmhIdjlkeFNncFhOZzZpdGhhZG4rMUM1TXJWM1pxdVdFcGhWa3diMk5aWnQzeUVzS0lpRVVSblJRV1lXRWxOZGgwSEtraWtTKysrZEFrZDc2MUg4TkNoY0J3L0RzL1ZlajZZWUxyUm93R1hDNDY2T2hobTVVRC94Sk84aVlIcHFsSThFWlFGU2ZjMitDL0pXRGxtbUpMTmsxR25FNTBWNVhDZVBRdHF0M0ZsWTZicGR4YzBDUWxnTjZrK0xaMzdHR0JXanJFcjNjZVVKWmtRRUtnb1paelFqeG5EaVhrell6V0MvYXY5NktxcDVyZW1qd1VxU2lVZ0FwYmw2dGhZQkQrUUJPM0lrVkJIUmNuTGNvdUZidzNURDYvVkdnam5qY3R5RWNUdGZKaUlJTmpUakpBMXdHMTRtZ2tnbWlha3hjRnhteDZuMGszOFA1L24vd0E4TC92eE51VnUzQUFBQUFCSlJVNUVya0pnZ2c9PVwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0f91\n')},"12bd":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9UYWJsZS9pbmRleC52dWU/NDhjNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxMmJkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12bd\n")},"146a":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\n/**\n * @this {Promise}\n */\nfunction finallyConstructor(callback) {\n  var constructor = this.constructor;\n  return this.then(\n    function(value) {\n      // @ts-ignore\n      return constructor.resolve(callback()).then(function() {\n        return value;\n      });\n    },\n    function(reason) {\n      // @ts-ignore\n      return constructor.resolve(callback()).then(function() {\n        // @ts-ignore\n        return constructor.reject(reason);\n      });\n    }\n  );\n}\n\nfunction allSettled(arr) {\n  var P = this;\n  return new P(function(resolve, reject) {\n    if (!(arr && typeof arr.length !== 'undefined')) {\n      return reject(\n        new TypeError(\n          typeof arr +\n            ' ' +\n            arr +\n            ' is not iterable(cannot read property Symbol(Symbol.iterator))'\n        )\n      );\n    }\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        var then = val.then;\n        if (typeof then === 'function') {\n          then.call(\n            val,\n            function(val) {\n              res(i, val);\n            },\n            function(e) {\n              args[i] = { status: 'rejected', reason: e };\n              if (--remaining === 0) {\n                resolve(args);\n              }\n            }\n          );\n          return;\n        }\n      }\n      args[i] = { status: 'fulfilled', value: val };\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n}\n\n// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction isArray(x) {\n  return Boolean(x && typeof x.length !== 'undefined');\n}\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function() {\n    fn.apply(thisArg, arguments);\n  };\n}\n\n/**\n * @constructor\n * @param {Function} fn\n */\nfunction Promise(fn) {\n  if (!(this instanceof Promise))\n    throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  /** @type {!number} */\n  this._state = 0;\n  /** @type {!boolean} */\n  this._handled = false;\n  /** @type {Promise|undefined} */\n  this._value = undefined;\n  /** @type {!Array<!Function>} */\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise._immediateFn(function() {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError('A promise cannot be resolved with itself.');\n    if (\n      newValue &&\n      (typeof newValue === 'object' || typeof newValue === 'function')\n    ) {\n      var then = newValue.then;\n      if (newValue instanceof Promise) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise._immediateFn(function() {\n      if (!self._handled) {\n        Promise._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\n/**\n * @constructor\n */\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(\n      function(value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      },\n      function(reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      }\n    );\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise.prototype['catch'] = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  // @ts-ignore\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise.prototype['finally'] = finallyConstructor;\n\nPromise.all = function(arr) {\n  return new Promise(function(resolve, reject) {\n    if (!isArray(arr)) {\n      return reject(new TypeError('Promise.all accepts an array'));\n    }\n\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(\n              val,\n              function(val) {\n                res(i, val);\n              },\n              reject\n            );\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.allSettled = allSettled;\n\nPromise.resolve = function(value) {\n  if (value && typeof value === 'object' && value.constructor === Promise) {\n    return value;\n  }\n\n  return new Promise(function(resolve) {\n    resolve(value);\n  });\n};\n\nPromise.reject = function(value) {\n  return new Promise(function(resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function(arr) {\n  return new Promise(function(resolve, reject) {\n    if (!isArray(arr)) {\n      return reject(new TypeError('Promise.race accepts an array'));\n    }\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      Promise.resolve(arr[i]).then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise._immediateFn =\n  // @ts-ignore\n  (typeof setImmediate === 'function' &&\n    function(fn) {\n      // @ts-ignore\n      setImmediate(fn);\n    }) ||\n  function(fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\nPromise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\n/** @suppress {undefinedVars} */\nvar globalNS = (function() {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  throw new Error('unable to locate global object');\n})();\n\n// Expose the polyfill if Promise is undefined or set to a\n// non-function value. The latter can be due to a named HTMLElement\n// being exposed by browsers for legacy reasons.\n// https://github.com/taylorhakes/promise-polyfill/issues/114\nif (typeof globalNS['Promise'] !== 'function') {\n  globalNS['Promise'] = Promise;\n} else {\n  if (!globalNS.Promise.prototype['finally']) {\n    globalNS.Promise.prototype['finally'] = finallyConstructor;\n  } \n  if (!globalNS.Promise.allSettled) {\n    globalNS.Promise.allSettled = allSettled;\n  }\n}\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"c8ba\")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9kaXN0L3BvbHlmaWxsLmpzPzE0NmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxDQUFDLEtBQTREO0FBQzdELENBQUMsU0FDVztBQUNaLENBQUMscUJBQXFCOztBQUV0QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBOztBQUVBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwiZmlsZSI6IjE0NmEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEB0aGlzIHtQcm9taXNlfVxuICovXG5mdW5jdGlvbiBmaW5hbGx5Q29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBhbGxTZXR0bGVkKGFycikge1xuICB2YXIgUCA9IHRoaXM7XG4gIHJldHVybiBuZXcgUChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoIShhcnIgJiYgdHlwZW9mIGFyci5sZW5ndGggIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICB0eXBlb2YgYXJyICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBhcnIgK1xuICAgICAgICAgICAgJyBpcyBub3QgaXRlcmFibGUoY2Fubm90IHJlYWQgcHJvcGVydHkgU3ltYm9sKFN5bWJvbC5pdGVyYXRvcikpJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgYXJnc1tpXSA9IHsgc3RhdHVzOiAncmVqZWN0ZWQnLCByZWFzb246IGUgfTtcbiAgICAgICAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzW2ldID0geyBzdGF0dXM6ICdmdWxmaWxsZWQnLCB2YWx1ZTogdmFsIH07XG4gICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG52YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBpc0FycmF5KHgpIHtcbiAgcmV0dXJuIEJvb2xlYW4oeCAmJiB0eXBlb2YgeC5sZW5ndGggIT09ICd1bmRlZmluZWQnKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2UpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICAvKiogQHR5cGUgeyFudW1iZXJ9ICovXG4gIHRoaXMuX3N0YXRlID0gMDtcbiAgLyoqIEB0eXBlIHshYm9vbGVhbn0gKi9cbiAgdGhpcy5faGFuZGxlZCA9IGZhbHNlO1xuICAvKiogQHR5cGUge1Byb21pc2V8dW5kZWZpbmVkfSAqL1xuICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgLyoqIEB0eXBlIHshQXJyYXk8IUZ1bmN0aW9uPn0gKi9cbiAgdGhpcy5fZGVmZXJyZWRzID0gW107XG5cbiAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gIHdoaWxlIChzZWxmLl9zdGF0ZSA9PT0gMykge1xuICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgfVxuICBpZiAoc2VsZi5fc3RhdGUgPT09IDApIHtcbiAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICB2YXIgY2IgPSBzZWxmLl9zdGF0ZSA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgcmV0ID0gY2Ioc2VsZi5fdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICB0cnkge1xuICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICBpZiAoXG4gICAgICBuZXdWYWx1ZSAmJlxuICAgICAgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuICAgICAgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBzZWxmLl9zdGF0ZSA9IDM7XG4gICAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkb1Jlc29sdmUoYmluZCh0aGVuLCBuZXdWYWx1ZSksIHNlbGYpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuX3N0YXRlID0gMTtcbiAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIGZpbmFsZShzZWxmKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChzZWxmLCBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgc2VsZi5fc3RhdGUgPSAyO1xuICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICBmaW5hbGUoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gIGlmIChzZWxmLl9zdGF0ZSA9PT0gMiAmJiBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoID09PSAwKSB7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oc2VsZi5fdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuX2RlZmVycmVkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICB9XG4gIHNlbGYuX2RlZmVycmVkcyA9IG51bGw7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2UpIHtcbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICovXG5mdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHNlbGYpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBmbihcbiAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlamVjdChzZWxmLCByZWFzb24pO1xuICAgICAgfVxuICAgICk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3Qoc2VsZiwgZXgpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24ob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgdmFyIHByb20gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgcmV0dXJuIHByb207XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddID0gZmluYWxseUNvbnN0cnVjdG9yO1xuXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uKGFycikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFpc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignUHJvbWlzZS5hbGwgYWNjZXB0cyBhbiBhcnJheScpKTtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJlamVjdChleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgfVxuICB9KTtcbn07XG5cblByb21pc2UuYWxsU2V0dGxlZCA9IGFsbFNldHRsZWQ7XG5cblByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBQcm9taXNlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uKGFycikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFpc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignUHJvbWlzZS5yYWNlIGFjY2VwdHMgYW4gYXJyYXknKSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKGFycltpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBVc2UgcG9seWZpbGwgZm9yIHNldEltbWVkaWF0ZSBmb3IgcGVyZm9ybWFuY2UgZ2FpbnNcblByb21pc2UuX2ltbWVkaWF0ZUZuID1cbiAgLy8gQHRzLWlnbm9yZVxuICAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH0pIHx8XG4gIGZ1bmN0aW9uKGZuKSB7XG4gICAgc2V0VGltZW91dEZ1bmMoZm4sIDApO1xuICB9O1xuXG5Qcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF91bmhhbmRsZWRSZWplY3Rpb25GbihlcnIpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlKSB7XG4gICAgY29uc29sZS53YXJuKCdQb3NzaWJsZSBVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246JywgZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIH1cbn07XG5cbi8qKiBAc3VwcHJlc3Mge3VuZGVmaW5lZFZhcnN9ICovXG52YXIgZ2xvYmFsTlMgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIHRoZSBvbmx5IHJlbGlhYmxlIG1lYW5zIHRvIGdldCB0aGUgZ2xvYmFsIG9iamVjdCBpc1xuICAvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcbiAgLy8gSG93ZXZlciwgdGhpcyBjYXVzZXMgQ1NQIHZpb2xhdGlvbnMgaW4gQ2hyb21lIGFwcHMuXG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn0pKCk7XG5cbi8vIEV4cG9zZSB0aGUgcG9seWZpbGwgaWYgUHJvbWlzZSBpcyB1bmRlZmluZWQgb3Igc2V0IHRvIGFcbi8vIG5vbi1mdW5jdGlvbiB2YWx1ZS4gVGhlIGxhdHRlciBjYW4gYmUgZHVlIHRvIGEgbmFtZWQgSFRNTEVsZW1lbnRcbi8vIGJlaW5nIGV4cG9zZWQgYnkgYnJvd3NlcnMgZm9yIGxlZ2FjeSByZWFzb25zLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RheWxvcmhha2VzL3Byb21pc2UtcG9seWZpbGwvaXNzdWVzLzExNFxuaWYgKHR5cGVvZiBnbG9iYWxOU1snUHJvbWlzZSddICE9PSAnZnVuY3Rpb24nKSB7XG4gIGdsb2JhbE5TWydQcm9taXNlJ10gPSBQcm9taXNlO1xufSBlbHNlIHtcbiAgaWYgKCFnbG9iYWxOUy5Qcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddKSB7XG4gICAgZ2xvYmFsTlMuUHJvbWlzZS5wcm90b3R5cGVbJ2ZpbmFsbHknXSA9IGZpbmFsbHlDb25zdHJ1Y3RvcjtcbiAgfSBcbiAgaWYgKCFnbG9iYWxOUy5Qcm9taXNlLmFsbFNldHRsZWQpIHtcbiAgICBnbG9iYWxOUy5Qcm9taXNlLmFsbFNldHRsZWQgPSBhbGxTZXR0bGVkO1xuICB9XG59XG5cbn0pKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///146a\n")},"222c":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_2de3a101_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("12bd");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_2de3a101_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_2de3a101_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9UYWJsZS9pbmRleC52dWU/MzZlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUEiLCJmaWxlIjoiMjIyYy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS0xMS1vbmVPZi0xLTAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTEtb25lT2YtMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTExLW9uZU9mLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTEtb25lT2YtMS0zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1yZXNvdXJjZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xMS1vbmVPZi0xLTQhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0yZGUzYTEwMSZwcm9kJnNjb3BlZD10cnVlJmxhbmc9bGVzcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///222c\n')},"2b0e":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EffectScope\", function() { return EffectScope; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computed\", function() { return computed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"customRef\", function() { return customRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Vue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineAsyncComponent\", function() { return defineAsyncComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineComponent\", function() { return defineComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"del\", function() { return del; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"effectScope\", function() { return effectScope; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCurrentInstance\", function() { return getCurrentInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCurrentScope\", function() { return getCurrentScope; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inject\", function() { return inject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isProxy\", function() { return isProxy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isReactive\", function() { return isReactive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isReadonly\", function() { return isReadonly; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isRef\", function() { return isRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isShallow\", function() { return isShallow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"markRaw\", function() { return markRaw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeDefaults\", function() { return mergeDefaults; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nextTick\", function() { return nextTick; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onActivated\", function() { return onActivated; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onBeforeMount\", function() { return onBeforeMount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onBeforeUnmount\", function() { return onBeforeUnmount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onBeforeUpdate\", function() { return onBeforeUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onDeactivated\", function() { return onDeactivated; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onErrorCaptured\", function() { return onErrorCaptured; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onMounted\", function() { return onMounted; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onRenderTracked\", function() { return onRenderTracked; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onRenderTriggered\", function() { return onRenderTriggered; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onScopeDispose\", function() { return onScopeDispose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onServerPrefetch\", function() { return onServerPrefetch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onUnmounted\", function() { return onUnmounted; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onUpdated\", function() { return onUpdated; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"provide\", function() { return provide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"proxyRefs\", function() { return proxyRefs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reactive\", function() { return reactive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"readonly\", function() { return readonly; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ref\", function() { return ref$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shallowReactive\", function() { return shallowReactive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shallowReadonly\", function() { return shallowReadonly; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shallowRef\", function() { return shallowRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRaw\", function() { return toRaw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRef\", function() { return toRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRefs\", function() { return toRefs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"triggerRef\", function() { return triggerRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unref\", function() { return unref; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useAttrs\", function() { return useAttrs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useCssModule\", function() { return useCssModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useCssVars\", function() { return useCssVars; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useListeners\", function() { return useListeners; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useSlots\", function() { return useSlots; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"watch\", function() { return watch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"watchEffect\", function() { return watchEffect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"watchPostEffect\", function() { return watchPostEffect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"watchSyncEffect\", function() { return watchSyncEffect; });\n/*!\n * Vue.js v2.7.9\n * (c) 2014-2022 Evan You\n * Released under the MIT License.\n */\nvar emptyObject = Object.freeze({});\r\nvar isArray = Array.isArray;\r\n// These helpers produce better VM code in JS engines due to their\r\n// explicitness and function inlining.\r\nfunction isUndef(v) {\r\n    return v === undefined || v === null;\r\n}\r\nfunction isDef(v) {\r\n    return v !== undefined && v !== null;\r\n}\r\nfunction isTrue(v) {\r\n    return v === true;\r\n}\r\nfunction isFalse(v) {\r\n    return v === false;\r\n}\r\n/**\r\n * Check if value is primitive.\r\n */\r\nfunction isPrimitive(value) {\r\n    return (typeof value === 'string' ||\r\n        typeof value === 'number' ||\r\n        // $flow-disable-line\r\n        typeof value === 'symbol' ||\r\n        typeof value === 'boolean');\r\n}\r\nfunction isFunction(value) {\r\n    return typeof value === 'function';\r\n}\r\n/**\r\n * Quick object check - this is primarily used to tell\r\n * objects from primitive values when we know the value\r\n * is a JSON-compliant type.\r\n */\r\nfunction isObject(obj) {\r\n    return obj !== null && typeof obj === 'object';\r\n}\r\n/**\r\n * Get the raw type string of a value, e.g., [object Object].\r\n */\r\nvar _toString = Object.prototype.toString;\r\nfunction toRawType(value) {\r\n    return _toString.call(value).slice(8, -1);\r\n}\r\n/**\r\n * Strict object type check. Only returns true\r\n * for plain JavaScript objects.\r\n */\r\nfunction isPlainObject(obj) {\r\n    return _toString.call(obj) === '[object Object]';\r\n}\r\nfunction isRegExp(v) {\r\n    return _toString.call(v) === '[object RegExp]';\r\n}\r\n/**\r\n * Check if val is a valid array index.\r\n */\r\nfunction isValidArrayIndex(val) {\r\n    var n = parseFloat(String(val));\r\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\r\n}\r\nfunction isPromise(val) {\r\n    return (isDef(val) &&\r\n        typeof val.then === 'function' &&\r\n        typeof val.catch === 'function');\r\n}\r\n/**\r\n * Convert a value to a string that is actually rendered.\r\n */\r\nfunction toString(val) {\r\n    return val == null\r\n        ? ''\r\n        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\r\n            ? JSON.stringify(val, null, 2)\r\n            : String(val);\r\n}\r\n/**\r\n * Convert an input value to a number for persistence.\r\n * If the conversion fails, return original string.\r\n */\r\nfunction toNumber(val) {\r\n    var n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n}\r\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    var map = Object.create(null);\r\n    var list = str.split(',');\r\n    for (var i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };\r\n}\r\n/**\r\n * Check if a tag is a built-in tag.\r\n */\r\nvar isBuiltInTag = makeMap('slot,component', true);\r\n/**\r\n * Check if an attribute is a reserved attribute.\r\n */\r\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\r\n/**\r\n * Remove an item from an array.\r\n */\r\nfunction remove$2(arr, item) {\r\n    if (arr.length) {\r\n        var index = arr.indexOf(item);\r\n        if (index > -1) {\r\n            return arr.splice(index, 1);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Check whether an object has the property.\r\n */\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwn(obj, key) {\r\n    return hasOwnProperty.call(obj, key);\r\n}\r\n/**\r\n * Create a cached version of a pure function.\r\n */\r\nfunction cached(fn) {\r\n    var cache = Object.create(null);\r\n    return function cachedFn(str) {\r\n        var hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    };\r\n}\r\n/**\r\n * Camelize a hyphen-delimited string.\r\n */\r\nvar camelizeRE = /-(\\w)/g;\r\nvar camelize = cached(function (str) {\r\n    return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });\r\n});\r\n/**\r\n * Capitalize a string.\r\n */\r\nvar capitalize = cached(function (str) {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n});\r\n/**\r\n * Hyphenate a camelCase string.\r\n */\r\nvar hyphenateRE = /\\B([A-Z])/g;\r\nvar hyphenate = cached(function (str) {\r\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\r\n});\r\n/**\r\n * Simple bind polyfill for environments that do not support it,\r\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\r\n * since native bind is now performant enough in most browsers.\r\n * But removing it would mean breaking code that was able to run in\r\n * PhantomJS 1.x, so this must be kept for backward compatibility.\r\n */\r\n/* istanbul ignore next */\r\nfunction polyfillBind(fn, ctx) {\r\n    function boundFn(a) {\r\n        var l = arguments.length;\r\n        return l\r\n            ? l > 1\r\n                ? fn.apply(ctx, arguments)\r\n                : fn.call(ctx, a)\r\n            : fn.call(ctx);\r\n    }\r\n    boundFn._length = fn.length;\r\n    return boundFn;\r\n}\r\nfunction nativeBind(fn, ctx) {\r\n    return fn.bind(ctx);\r\n}\r\n// @ts-expect-error bind cannot be `undefined`\r\nvar bind = Function.prototype.bind ? nativeBind : polyfillBind;\r\n/**\r\n * Convert an Array-like object to a real Array.\r\n */\r\nfunction toArray(list, start) {\r\n    start = start || 0;\r\n    var i = list.length - start;\r\n    var ret = new Array(i);\r\n    while (i--) {\r\n        ret[i] = list[i + start];\r\n    }\r\n    return ret;\r\n}\r\n/**\r\n * Mix properties into target object.\r\n */\r\nfunction extend(to, _from) {\r\n    for (var key in _from) {\r\n        to[key] = _from[key];\r\n    }\r\n    return to;\r\n}\r\n/**\r\n * Merge an Array of Objects into a single Object.\r\n */\r\nfunction toObject(arr) {\r\n    var res = {};\r\n    for (var i = 0; i < arr.length; i++) {\r\n        if (arr[i]) {\r\n            extend(res, arr[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n/* eslint-disable no-unused-vars */\r\n/**\r\n * Perform no operation.\r\n * Stubbing args to make Flow happy without leaving useless transpiled code\r\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\r\n */\r\nfunction noop(a, b, c) { }\r\n/**\r\n * Always return false.\r\n */\r\nvar no = function (a, b, c) { return false; };\r\n/* eslint-enable no-unused-vars */\r\n/**\r\n * Return the same value.\r\n */\r\nvar identity = function (_) { return _; };\r\n/**\r\n * Check if two values are loosely equal - that is,\r\n * if they are plain objects, do they have the same shape?\r\n */\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    var isObjectA = isObject(a);\r\n    var isObjectB = isObject(b);\r\n    if (isObjectA && isObjectB) {\r\n        try {\r\n            var isArrayA = Array.isArray(a);\r\n            var isArrayB = Array.isArray(b);\r\n            if (isArrayA && isArrayB) {\r\n                return (a.length === b.length &&\r\n                    a.every(function (e, i) {\r\n                        return looseEqual(e, b[i]);\r\n                    }));\r\n            }\r\n            else if (a instanceof Date && b instanceof Date) {\r\n                return a.getTime() === b.getTime();\r\n            }\r\n            else if (!isArrayA && !isArrayB) {\r\n                var keysA = Object.keys(a);\r\n                var keysB = Object.keys(b);\r\n                return (keysA.length === keysB.length &&\r\n                    keysA.every(function (key) {\r\n                        return looseEqual(a[key], b[key]);\r\n                    }));\r\n            }\r\n            else {\r\n                /* istanbul ignore next */\r\n                return false;\r\n            }\r\n        }\r\n        catch (e) {\r\n            /* istanbul ignore next */\r\n            return false;\r\n        }\r\n    }\r\n    else if (!isObjectA && !isObjectB) {\r\n        return String(a) === String(b);\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Return the first index at which a loosely equal value can be\r\n * found in the array (if value is a plain object, the array must\r\n * contain an object of the same shape), or -1 if it is not present.\r\n */\r\nfunction looseIndexOf(arr, val) {\r\n    for (var i = 0; i < arr.length; i++) {\r\n        if (looseEqual(arr[i], val))\r\n            return i;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Ensure a function is called only once.\r\n */\r\nfunction once(fn) {\r\n    var called = false;\r\n    return function () {\r\n        if (!called) {\r\n            called = true;\r\n            fn.apply(this, arguments);\r\n        }\r\n    };\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill\r\nfunction hasChanged(x, y) {\r\n    if (x === y) {\r\n        return x === 0 && 1 / x !== 1 / y;\r\n    }\r\n    else {\r\n        return x === x || y === y;\r\n    }\r\n}\n\nvar SSR_ATTR = 'data-server-rendered';\r\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\r\nvar LIFECYCLE_HOOKS = [\r\n    'beforeCreate',\r\n    'created',\r\n    'beforeMount',\r\n    'mounted',\r\n    'beforeUpdate',\r\n    'updated',\r\n    'beforeDestroy',\r\n    'destroyed',\r\n    'activated',\r\n    'deactivated',\r\n    'errorCaptured',\r\n    'serverPrefetch',\r\n    'renderTracked',\r\n    'renderTriggered'\r\n];\n\nvar config = {\r\n    /**\r\n     * Option merge strategies (used in core/util/options)\r\n     */\r\n    // $flow-disable-line\r\n    optionMergeStrategies: Object.create(null),\r\n    /**\r\n     * Whether to suppress warnings.\r\n     */\r\n    silent: false,\r\n    /**\r\n     * Show production mode tip message on boot?\r\n     */\r\n    productionTip: \"production\" !== 'production',\r\n    /**\r\n     * Whether to enable devtools\r\n     */\r\n    devtools: \"production\" !== 'production',\r\n    /**\r\n     * Whether to record perf\r\n     */\r\n    performance: false,\r\n    /**\r\n     * Error handler for watcher errors\r\n     */\r\n    errorHandler: null,\r\n    /**\r\n     * Warn handler for watcher warns\r\n     */\r\n    warnHandler: null,\r\n    /**\r\n     * Ignore certain custom elements\r\n     */\r\n    ignoredElements: [],\r\n    /**\r\n     * Custom user key aliases for v-on\r\n     */\r\n    // $flow-disable-line\r\n    keyCodes: Object.create(null),\r\n    /**\r\n     * Check if a tag is reserved so that it cannot be registered as a\r\n     * component. This is platform-dependent and may be overwritten.\r\n     */\r\n    isReservedTag: no,\r\n    /**\r\n     * Check if an attribute is reserved so that it cannot be used as a component\r\n     * prop. This is platform-dependent and may be overwritten.\r\n     */\r\n    isReservedAttr: no,\r\n    /**\r\n     * Check if a tag is an unknown element.\r\n     * Platform-dependent.\r\n     */\r\n    isUnknownElement: no,\r\n    /**\r\n     * Get the namespace of an element\r\n     */\r\n    getTagNamespace: noop,\r\n    /**\r\n     * Parse the real tag name for the specific platform.\r\n     */\r\n    parsePlatformTagName: identity,\r\n    /**\r\n     * Check if an attribute must be bound using property, e.g. value\r\n     * Platform-dependent.\r\n     */\r\n    mustUseProp: no,\r\n    /**\r\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\r\n     * This will significantly reduce performance if set to false.\r\n     */\r\n    async: true,\r\n    /**\r\n     * Exposed for legacy reasons\r\n     */\r\n    _lifecycleHooks: LIFECYCLE_HOOKS\r\n};\n\n/**\r\n * unicode letters used for parsing html tags, component names and property paths.\r\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\r\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\r\n */\r\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\r\n/**\r\n * Check if a string starts with $ or _\r\n */\r\nfunction isReserved(str) {\r\n    var c = (str + '').charCodeAt(0);\r\n    return c === 0x24 || c === 0x5f;\r\n}\r\n/**\r\n * Define a property.\r\n */\r\nfunction def(obj, key, val, enumerable) {\r\n    Object.defineProperty(obj, key, {\r\n        value: val,\r\n        enumerable: !!enumerable,\r\n        writable: true,\r\n        configurable: true\r\n    });\r\n}\r\n/**\r\n * Parse simple path.\r\n */\r\nvar bailRE = new RegExp(\"[^\".concat(unicodeRegExp.source, \".$_\\\\d]\"));\r\nfunction parsePath(path) {\r\n    if (bailRE.test(path)) {\r\n        return;\r\n    }\r\n    var segments = path.split('.');\r\n    return function (obj) {\r\n        for (var i = 0; i < segments.length; i++) {\r\n            if (!obj)\r\n                return;\r\n            obj = obj[segments[i]];\r\n        }\r\n        return obj;\r\n    };\r\n}\n\n// can we use __proto__?\r\nvar hasProto = '__proto__' in {};\r\n// Browser environment sniffing\r\nvar inBrowser = typeof window !== 'undefined';\r\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\r\nvar isIE = UA && /msie|trident/.test(UA);\r\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\r\nvar isEdge = UA && UA.indexOf('edge/') > 0;\r\nUA && UA.indexOf('android') > 0;\r\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\r\nUA && /chrome\\/\\d+/.test(UA) && !isEdge;\r\nUA && /phantomjs/.test(UA);\r\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\r\n// Firefox has a \"watch\" function on Object.prototype...\r\n// @ts-expect-error firebox support\r\nvar nativeWatch = {}.watch;\r\nvar supportsPassive = false;\r\nif (inBrowser) {\r\n    try {\r\n        var opts = {};\r\n        Object.defineProperty(opts, 'passive', {\r\n            get: function () {\r\n                /* istanbul ignore next */\r\n                supportsPassive = true;\r\n            }\r\n        }); // https://github.com/facebook/flow/issues/285\r\n        window.addEventListener('test-passive', null, opts);\r\n    }\r\n    catch (e) { }\r\n}\r\n// this needs to be lazy-evaled because vue may be required before\r\n// vue-server-renderer can set VUE_ENV\r\nvar _isServer;\r\nvar isServerRendering = function () {\r\n    if (_isServer === undefined) {\r\n        /* istanbul ignore if */\r\n        if (!inBrowser && typeof global !== 'undefined') {\r\n            // detect presence of vue-server-renderer and avoid\r\n            // Webpack shimming the process\r\n            _isServer =\r\n                global['process'] && global['process'].env.VUE_ENV === 'server';\r\n        }\r\n        else {\r\n            _isServer = false;\r\n        }\r\n    }\r\n    return _isServer;\r\n};\r\n// detect devtools\r\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\r\n/* istanbul ignore next */\r\nfunction isNative(Ctor) {\r\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\r\n}\r\nvar hasSymbol = typeof Symbol !== 'undefined' &&\r\n    isNative(Symbol) &&\r\n    typeof Reflect !== 'undefined' &&\r\n    isNative(Reflect.ownKeys);\r\nvar _Set; // $flow-disable-line\r\n/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {\r\n    // use native Set when available.\r\n    _Set = Set;\r\n}\r\nelse {\r\n    // a non-standard Set polyfill that only works with primitive keys.\r\n    _Set = /** @class */ (function () {\r\n        function Set() {\r\n            this.set = Object.create(null);\r\n        }\r\n        Set.prototype.has = function (key) {\r\n            return this.set[key] === true;\r\n        };\r\n        Set.prototype.add = function (key) {\r\n            this.set[key] = true;\r\n        };\r\n        Set.prototype.clear = function () {\r\n            this.set = Object.create(null);\r\n        };\r\n        return Set;\r\n    }());\r\n}\n\nvar currentInstance = null;\r\n/**\r\n * This is exposed for compatibility with v3 (e.g. some functions in VueUse\r\n * relies on it). Do not use this internally, just use `currentInstance`.\r\n *\r\n * @internal this function needs manual type declaration because it relies\r\n * on previously manually authored types from Vue 2\r\n */\r\nfunction getCurrentInstance() {\r\n    return currentInstance && { proxy: currentInstance };\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction setCurrentInstance(vm) {\r\n    if (vm === void 0) { vm = null; }\r\n    if (!vm)\r\n        currentInstance && currentInstance._scope.off();\r\n    currentInstance = vm;\r\n    vm && vm._scope.on();\r\n}\n\n/**\r\n * @internal\r\n */\r\nvar VNode = /** @class */ (function () {\r\n    function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\r\n        this.tag = tag;\r\n        this.data = data;\r\n        this.children = children;\r\n        this.text = text;\r\n        this.elm = elm;\r\n        this.ns = undefined;\r\n        this.context = context;\r\n        this.fnContext = undefined;\r\n        this.fnOptions = undefined;\r\n        this.fnScopeId = undefined;\r\n        this.key = data && data.key;\r\n        this.componentOptions = componentOptions;\r\n        this.componentInstance = undefined;\r\n        this.parent = undefined;\r\n        this.raw = false;\r\n        this.isStatic = false;\r\n        this.isRootInsert = true;\r\n        this.isComment = false;\r\n        this.isCloned = false;\r\n        this.isOnce = false;\r\n        this.asyncFactory = asyncFactory;\r\n        this.asyncMeta = undefined;\r\n        this.isAsyncPlaceholder = false;\r\n    }\r\n    Object.defineProperty(VNode.prototype, \"child\", {\r\n        // DEPRECATED: alias for componentInstance for backwards compat.\r\n        /* istanbul ignore next */\r\n        get: function () {\r\n            return this.componentInstance;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return VNode;\r\n}());\r\nvar createEmptyVNode = function (text) {\r\n    if (text === void 0) { text = ''; }\r\n    var node = new VNode();\r\n    node.text = text;\r\n    node.isComment = true;\r\n    return node;\r\n};\r\nfunction createTextVNode(val) {\r\n    return new VNode(undefined, undefined, undefined, String(val));\r\n}\r\n// optimized shallow clone\r\n// used for static nodes and slot nodes because they may be reused across\r\n// multiple renders, cloning them avoids errors when DOM manipulations rely\r\n// on their elm reference.\r\nfunction cloneVNode(vnode) {\r\n    var cloned = new VNode(vnode.tag, vnode.data, \r\n    // #7975\r\n    // clone children array to avoid mutating original in case of cloning\r\n    // a child.\r\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\r\n    cloned.ns = vnode.ns;\r\n    cloned.isStatic = vnode.isStatic;\r\n    cloned.key = vnode.key;\r\n    cloned.isComment = vnode.isComment;\r\n    cloned.fnContext = vnode.fnContext;\r\n    cloned.fnOptions = vnode.fnOptions;\r\n    cloned.fnScopeId = vnode.fnScopeId;\r\n    cloned.asyncMeta = vnode.asyncMeta;\r\n    cloned.isCloned = true;\r\n    return cloned;\r\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar uid$2 = 0;\r\n/**\r\n * A dep is an observable that can have multiple\r\n * directives subscribing to it.\r\n * @internal\r\n */\r\nvar Dep = /** @class */ (function () {\r\n    function Dep() {\r\n        this.id = uid$2++;\r\n        this.subs = [];\r\n    }\r\n    Dep.prototype.addSub = function (sub) {\r\n        this.subs.push(sub);\r\n    };\r\n    Dep.prototype.removeSub = function (sub) {\r\n        remove$2(this.subs, sub);\r\n    };\r\n    Dep.prototype.depend = function (info) {\r\n        if (Dep.target) {\r\n            Dep.target.addDep(this);\r\n            if (false) {}\r\n        }\r\n    };\r\n    Dep.prototype.notify = function (info) {\r\n        // stabilize the subscriber list first\r\n        var subs = this.subs.slice();\r\n        if (false) {}\r\n        for (var i = 0, l = subs.length; i < l; i++) {\r\n            if (false) { var sub; }\r\n            subs[i].update();\r\n        }\r\n    };\r\n    return Dep;\r\n}());\r\n// The current target watcher being evaluated.\r\n// This is globally unique because only one watcher\r\n// can be evaluated at a time.\r\nDep.target = null;\r\nvar targetStack = [];\r\nfunction pushTarget(target) {\r\n    targetStack.push(target);\r\n    Dep.target = target;\r\n}\r\nfunction popTarget() {\r\n    targetStack.pop();\r\n    Dep.target = targetStack[targetStack.length - 1];\r\n}\n\n/*\r\n * not type checking this file because flow doesn't play well with\r\n * dynamically accessing methods on Array prototype\r\n */\r\nvar arrayProto = Array.prototype;\r\nvar arrayMethods = Object.create(arrayProto);\r\nvar methodsToPatch = [\r\n    'push',\r\n    'pop',\r\n    'shift',\r\n    'unshift',\r\n    'splice',\r\n    'sort',\r\n    'reverse'\r\n];\r\n/**\r\n * Intercept mutating methods and emit events\r\n */\r\nmethodsToPatch.forEach(function (method) {\r\n    // cache original method\r\n    var original = arrayProto[method];\r\n    def(arrayMethods, method, function mutator() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var result = original.apply(this, args);\r\n        var ob = this.__ob__;\r\n        var inserted;\r\n        switch (method) {\r\n            case 'push':\r\n            case 'unshift':\r\n                inserted = args;\r\n                break;\r\n            case 'splice':\r\n                inserted = args.slice(2);\r\n                break;\r\n        }\r\n        if (inserted)\r\n            ob.observeArray(inserted);\r\n        // notify change\r\n        if (false) {}\r\n        else {\r\n            ob.dep.notify();\r\n        }\r\n        return result;\r\n    });\r\n});\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\r\nvar NO_INIITIAL_VALUE = {};\r\n/**\r\n * In some cases we may want to disable observation inside a component's\r\n * update computation.\r\n */\r\nvar shouldObserve = true;\r\nfunction toggleObserving(value) {\r\n    shouldObserve = value;\r\n}\r\n// ssr mock dep\r\nvar mockDep = {\r\n    notify: noop,\r\n    depend: noop,\r\n    addSub: noop,\r\n    removeSub: noop\r\n};\r\n/**\r\n * Observer class that is attached to each observed\r\n * object. Once attached, the observer converts the target\r\n * object's property keys into getter/setters that\r\n * collect dependencies and dispatch updates.\r\n */\r\nvar Observer = /** @class */ (function () {\r\n    function Observer(value, shallow, mock) {\r\n        if (shallow === void 0) { shallow = false; }\r\n        if (mock === void 0) { mock = false; }\r\n        this.value = value;\r\n        this.shallow = shallow;\r\n        this.mock = mock;\r\n        // this.value = value\r\n        this.dep = mock ? mockDep : new Dep();\r\n        this.vmCount = 0;\r\n        def(value, '__ob__', this);\r\n        if (isArray(value)) {\r\n            if (!mock) {\r\n                if (hasProto) {\r\n                    value.__proto__ = arrayMethods;\r\n                    /* eslint-enable no-proto */\r\n                }\r\n                else {\r\n                    for (var i = 0, l = arrayKeys.length; i < l; i++) {\r\n                        var key = arrayKeys[i];\r\n                        def(value, key, arrayMethods[key]);\r\n                    }\r\n                }\r\n            }\r\n            if (!shallow) {\r\n                this.observeArray(value);\r\n            }\r\n        }\r\n        else {\r\n            /**\r\n             * Walk through all properties and convert them into\r\n             * getter/setters. This method should only be called when\r\n             * value type is Object.\r\n             */\r\n            var keys = Object.keys(value);\r\n            for (var i = 0; i < keys.length; i++) {\r\n                var key = keys[i];\r\n                defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Observe a list of Array items.\r\n     */\r\n    Observer.prototype.observeArray = function (value) {\r\n        for (var i = 0, l = value.length; i < l; i++) {\r\n            observe(value[i], false, this.mock);\r\n        }\r\n    };\r\n    return Observer;\r\n}());\r\n// helpers\r\n/**\r\n * Attempt to create an observer instance for a value,\r\n * returns the new observer if successfully observed,\r\n * or the existing observer if the value already has one.\r\n */\r\nfunction observe(value, shallow, ssrMockReactivity) {\r\n    if (!isObject(value) || isRef(value) || value instanceof VNode) {\r\n        return;\r\n    }\r\n    var ob;\r\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\r\n        ob = value.__ob__;\r\n    }\r\n    else if (shouldObserve &&\r\n        (ssrMockReactivity || !isServerRendering()) &&\r\n        (isArray(value) || isPlainObject(value)) &&\r\n        Object.isExtensible(value) &&\r\n        !value.__v_skip /* ReactiveFlags.SKIP */) {\r\n        ob = new Observer(value, shallow, ssrMockReactivity);\r\n    }\r\n    return ob;\r\n}\r\n/**\r\n * Define a reactive property on an Object.\r\n */\r\nfunction defineReactive(obj, key, val, customSetter, shallow, mock) {\r\n    var dep = new Dep();\r\n    var property = Object.getOwnPropertyDescriptor(obj, key);\r\n    if (property && property.configurable === false) {\r\n        return;\r\n    }\r\n    // cater for pre-defined getter/setters\r\n    var getter = property && property.get;\r\n    var setter = property && property.set;\r\n    if ((!getter || setter) &&\r\n        (val === NO_INIITIAL_VALUE || arguments.length === 2)) {\r\n        val = obj[key];\r\n    }\r\n    var childOb = !shallow && observe(val, false, mock);\r\n    Object.defineProperty(obj, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function reactiveGetter() {\r\n            var value = getter ? getter.call(obj) : val;\r\n            if (Dep.target) {\r\n                if (false) {}\r\n                else {\r\n                    dep.depend();\r\n                }\r\n                if (childOb) {\r\n                    childOb.dep.depend();\r\n                    if (isArray(value)) {\r\n                        dependArray(value);\r\n                    }\r\n                }\r\n            }\r\n            return isRef(value) && !shallow ? value.value : value;\r\n        },\r\n        set: function reactiveSetter(newVal) {\r\n            var value = getter ? getter.call(obj) : val;\r\n            if (!hasChanged(value, newVal)) {\r\n                return;\r\n            }\r\n            if (false) {}\r\n            if (setter) {\r\n                setter.call(obj, newVal);\r\n            }\r\n            else if (getter) {\r\n                // #7981: for accessor properties without setter\r\n                return;\r\n            }\r\n            else if (!shallow && isRef(value) && !isRef(newVal)) {\r\n                value.value = newVal;\r\n                return;\r\n            }\r\n            else {\r\n                val = newVal;\r\n            }\r\n            childOb = !shallow && observe(newVal, false, mock);\r\n            if (false) {}\r\n            else {\r\n                dep.notify();\r\n            }\r\n        }\r\n    });\r\n    return dep;\r\n}\r\nfunction set(target, key, val) {\r\n    if (false) {}\r\n    if (isReadonly(target)) {\r\n         false && false;\r\n        return;\r\n    }\r\n    var ob = target.__ob__;\r\n    if (isArray(target) && isValidArrayIndex(key)) {\r\n        target.length = Math.max(target.length, key);\r\n        target.splice(key, 1, val);\r\n        // when mocking for SSR, array methods are not hijacked\r\n        if (ob && !ob.shallow && ob.mock) {\r\n            observe(val, false, true);\r\n        }\r\n        return val;\r\n    }\r\n    if (key in target && !(key in Object.prototype)) {\r\n        target[key] = val;\r\n        return val;\r\n    }\r\n    if (target._isVue || (ob && ob.vmCount)) {\r\n         false &&\r\n            false;\r\n        return val;\r\n    }\r\n    if (!ob) {\r\n        target[key] = val;\r\n        return val;\r\n    }\r\n    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);\r\n    if (false) {}\r\n    else {\r\n        ob.dep.notify();\r\n    }\r\n    return val;\r\n}\r\nfunction del(target, key) {\r\n    if (false) {}\r\n    if (isArray(target) && isValidArrayIndex(key)) {\r\n        target.splice(key, 1);\r\n        return;\r\n    }\r\n    var ob = target.__ob__;\r\n    if (target._isVue || (ob && ob.vmCount)) {\r\n         false &&\r\n            false;\r\n        return;\r\n    }\r\n    if (isReadonly(target)) {\r\n         false &&\r\n            false;\r\n        return;\r\n    }\r\n    if (!hasOwn(target, key)) {\r\n        return;\r\n    }\r\n    delete target[key];\r\n    if (!ob) {\r\n        return;\r\n    }\r\n    if (false) {}\r\n    else {\r\n        ob.dep.notify();\r\n    }\r\n}\r\n/**\r\n * Collect dependencies on array elements when the array is touched, since\r\n * we cannot intercept array element access like property getters.\r\n */\r\nfunction dependArray(value) {\r\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\r\n        e = value[i];\r\n        if (e && e.__ob__) {\r\n            e.__ob__.dep.depend();\r\n        }\r\n        if (isArray(e)) {\r\n            dependArray(e);\r\n        }\r\n    }\r\n}\n\nfunction reactive(target) {\r\n    makeReactive(target, false);\r\n    return target;\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    makeReactive(target, true);\r\n    def(target, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\r\n    return target;\r\n}\r\nfunction makeReactive(target, shallow) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (!isReadonly(target)) {\r\n        if (false) { var existingOb; }\r\n        var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);\r\n        if (false) {}\r\n    }\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\r\n    }\r\n    return !!(value && value.__ob__);\r\n}\r\nfunction isShallow(value) {\r\n    return !!(value && value.__v_isShallow);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value.__v_isReadonly);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    var raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n    return raw ? toRaw(raw) : observed;\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\r\n    return value;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction isCollectionType(value) {\r\n    var type = toRawType(value);\r\n    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');\r\n}\n\n/**\r\n * @internal\r\n */\r\nvar RefFlag = \"__v_isRef\";\r\nfunction isRef(r) {\r\n    return !!(r && r.__v_isRef === true);\r\n}\r\nfunction ref$1(value) {\r\n    return createRef(value, false);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nfunction createRef(rawValue, shallow) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    var ref = {};\r\n    def(ref, RefFlag, true);\r\n    def(ref, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, shallow);\r\n    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));\r\n    return ref;\r\n}\r\nfunction triggerRef(ref) {\r\n    if (false) {}\r\n    if (false) {}\r\n    else {\r\n        ref.dep && ref.dep.notify();\r\n    }\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nfunction proxyRefs(objectWithRefs) {\r\n    if (isReactive(objectWithRefs)) {\r\n        return objectWithRefs;\r\n    }\r\n    var proxy = {};\r\n    var keys = Object.keys(objectWithRefs);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);\r\n    }\r\n    return proxy;\r\n}\r\nfunction proxyWithRefUnwrap(target, source, key) {\r\n    Object.defineProperty(target, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function () {\r\n            var val = source[key];\r\n            if (isRef(val)) {\r\n                return val.value;\r\n            }\r\n            else {\r\n                var ob = val && val.__ob__;\r\n                if (ob)\r\n                    ob.dep.depend();\r\n                return val;\r\n            }\r\n        },\r\n        set: function (value) {\r\n            var oldValue = source[key];\r\n            if (isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n            }\r\n            else {\r\n                source[key] = value;\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction customRef(factory) {\r\n    var dep = new Dep();\r\n    var _a = factory(function () {\r\n        if (false) {}\r\n        else {\r\n            dep.depend();\r\n        }\r\n    }, function () {\r\n        if (false) {}\r\n        else {\r\n            dep.notify();\r\n        }\r\n    }), get = _a.get, set = _a.set;\r\n    var ref = {\r\n        get value() {\r\n            return get();\r\n        },\r\n        set value(newVal) {\r\n            set(newVal);\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    return ref;\r\n}\r\nfunction toRefs(object) {\r\n    if (false) {}\r\n    var ret = isArray(object) ? new Array(object.length) : {};\r\n    for (var key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nfunction toRef(object, key, defaultValue) {\r\n    var val = object[key];\r\n    if (isRef(val)) {\r\n        return val;\r\n    }\r\n    var ref = {\r\n        get value() {\r\n            var val = object[key];\r\n            return val === undefined ? defaultValue : val;\r\n        },\r\n        set value(newVal) {\r\n            object[key] = newVal;\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    return ref;\r\n}\n\nvar rawToReadonlyFlag = \"__v_rawToReadonly\";\r\nvar rawToShallowReadonlyFlag = \"__v_rawToShallowReadonly\";\r\nfunction readonly(target) {\r\n    return createReadonly(target, false);\r\n}\r\nfunction createReadonly(target, shallow) {\r\n    if (!isPlainObject(target)) {\r\n        if (false) {}\r\n        return target;\r\n    }\r\n    // already a readonly object\r\n    if (isReadonly(target)) {\r\n        return target;\r\n    }\r\n    // already has a readonly proxy\r\n    var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;\r\n    var existingProxy = target[existingFlag];\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    var proxy = Object.create(Object.getPrototypeOf(target));\r\n    def(target, existingFlag, proxy);\r\n    def(proxy, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, true);\r\n    def(proxy, \"__v_raw\" /* ReactiveFlags.RAW */, target);\r\n    if (isRef(target)) {\r\n        def(proxy, RefFlag, true);\r\n    }\r\n    if (shallow || isShallow(target)) {\r\n        def(proxy, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\r\n    }\r\n    var keys = Object.keys(target);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        defineReadonlyProperty(proxy, target, keys[i], shallow);\r\n    }\r\n    return proxy;\r\n}\r\nfunction defineReadonlyProperty(proxy, target, key, shallow) {\r\n    Object.defineProperty(proxy, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function () {\r\n            var val = target[key];\r\n            return shallow || !isPlainObject(val) ? val : readonly(val);\r\n        },\r\n        set: function () {\r\n             false &&\r\n                false;\r\n        }\r\n    });\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReadonly(target, true);\r\n}\n\nfunction computed(getterOrOptions, debugOptions) {\r\n    var getter;\r\n    var setter;\r\n    var onlyGetter = isFunction(getterOrOptions);\r\n    if (onlyGetter) {\r\n        getter = getterOrOptions;\r\n        setter =  false\r\n            ? undefined\r\n            : noop;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    var watcher = isServerRendering()\r\n        ? null\r\n        : new Watcher(currentInstance, getter, noop, { lazy: true });\r\n    if (false) {}\r\n    var ref = {\r\n        // some libs rely on the presence effect for checking computed refs\r\n        // from normal refs, but the implementation doesn't matter\r\n        effect: watcher,\r\n        get value() {\r\n            if (watcher) {\r\n                if (watcher.dirty) {\r\n                    watcher.evaluate();\r\n                }\r\n                if (Dep.target) {\r\n                    if (false) {}\r\n                    watcher.depend();\r\n                }\r\n                return watcher.value;\r\n            }\r\n            else {\r\n                return getter();\r\n            }\r\n        },\r\n        set value(newVal) {\r\n            setter(newVal);\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    def(ref, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, onlyGetter);\r\n    return ref;\r\n}\n\nvar WATCHER = \"watcher\";\r\nvar WATCHER_CB = \"\".concat(WATCHER, \" callback\");\r\nvar WATCHER_GETTER = \"\".concat(WATCHER, \" getter\");\r\nvar WATCHER_CLEANUP = \"\".concat(WATCHER, \" cleanup\");\r\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\nfunction watchPostEffect(effect, options) {\r\n    return doWatch(effect, null, ( false\r\n        ? undefined : { flush: 'post' }));\r\n}\r\nfunction watchSyncEffect(effect, options) {\r\n    return doWatch(effect, null, ( false\r\n        ? undefined : { flush: 'sync' }));\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nvar INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    if (false) {}\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, _a) {\r\n    var _b = _a === void 0 ? emptyObject : _a, immediate = _b.immediate, deep = _b.deep, _c = _b.flush, flush = _c === void 0 ? 'pre' : _c, onTrack = _b.onTrack, onTrigger = _b.onTrigger;\r\n    if (false) {}\r\n    var warnInvalidSource = function (s) {\r\n        warn(\"Invalid watch source: \".concat(s, \". A watch source can only be a getter/effect \") +\r\n            \"function, a ref, a reactive object, or an array of these types.\");\r\n    };\r\n    var instance = currentInstance;\r\n    var call = function (fn, type, args) {\r\n        if (args === void 0) { args = null; }\r\n        return invokeWithErrorHandling(fn, null, args, instance, type);\r\n    };\r\n    var getter;\r\n    var forceTrigger = false;\r\n    var isMultiSource = false;\r\n    if (isRef(source)) {\r\n        getter = function () { return source.value; };\r\n        forceTrigger = isShallow(source);\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = function () {\r\n            source.__ob__.dep.depend();\r\n            return source;\r\n        };\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        isMultiSource = true;\r\n        forceTrigger = source.some(function (s) { return isReactive(s) || isShallow(s); });\r\n        getter = function () {\r\n            return source.map(function (s) {\r\n                if (isRef(s)) {\r\n                    return s.value;\r\n                }\r\n                else if (isReactive(s)) {\r\n                    return traverse(s);\r\n                }\r\n                else if (isFunction(s)) {\r\n                    return call(s, WATCHER_GETTER);\r\n                }\r\n                else {\r\n                     false && false;\r\n                }\r\n            });\r\n        };\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = function () { return call(source, WATCHER_GETTER); };\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = function () {\r\n                if (instance && instance._isDestroyed) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return call(source, WATCHER, [onCleanup]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = noop;\r\n         false && false;\r\n    }\r\n    if (cb && deep) {\r\n        var baseGetter_1 = getter;\r\n        getter = function () { return traverse(baseGetter_1()); };\r\n    }\r\n    var cleanup;\r\n    var onCleanup = function (fn) {\r\n        cleanup = watcher.onStop = function () {\r\n            call(fn, WATCHER_CLEANUP);\r\n        };\r\n    };\r\n    // in SSR there is no need to setup an actual effect, and it should be noop\r\n    // unless it's eager\r\n    if (isServerRendering()) {\r\n        // we will also not call the invalidate callback (+ runner is not set up)\r\n        onCleanup = noop;\r\n        if (!cb) {\r\n            getter();\r\n        }\r\n        else if (immediate) {\r\n            call(cb, WATCHER_CB, [\r\n                getter(),\r\n                isMultiSource ? [] : undefined,\r\n                onCleanup\r\n            ]);\r\n        }\r\n        return noop;\r\n    }\r\n    var watcher = new Watcher(currentInstance, getter, noop, {\r\n        lazy: true\r\n    });\r\n    watcher.noRecurse = !cb;\r\n    var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\r\n    // overwrite default run\r\n    watcher.run = function () {\r\n        if (!watcher.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            var newValue = watcher.get();\r\n            if (deep ||\r\n                forceTrigger ||\r\n                (isMultiSource\r\n                    ? newValue.some(function (v, i) {\r\n                        return hasChanged(v, oldValue[i]);\r\n                    })\r\n                    : hasChanged(newValue, oldValue))) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                call(cb, WATCHER_CB, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onCleanup\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            watcher.get();\r\n        }\r\n    };\r\n    if (flush === 'sync') {\r\n        watcher.update = watcher.run;\r\n    }\r\n    else if (flush === 'post') {\r\n        watcher.post = true;\r\n        watcher.update = function () { return queueWatcher(watcher); };\r\n    }\r\n    else {\r\n        // pre\r\n        watcher.update = function () {\r\n            if (instance && instance === currentInstance && !instance._isMounted) {\r\n                // pre-watcher triggered before\r\n                var buffer = instance._preWatchers || (instance._preWatchers = []);\r\n                if (buffer.indexOf(watcher) < 0)\r\n                    buffer.push(watcher);\r\n            }\r\n            else {\r\n                queueWatcher(watcher);\r\n            }\r\n        };\r\n    }\r\n    if (false) {}\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            watcher.run();\r\n        }\r\n        else {\r\n            oldValue = watcher.get();\r\n        }\r\n    }\r\n    else if (flush === 'post' && instance) {\r\n        instance.$once('hook:mounted', function () { return watcher.get(); });\r\n    }\r\n    else {\r\n        watcher.get();\r\n    }\r\n    return function () {\r\n        watcher.teardown();\r\n    };\r\n}\n\nvar activeEffectScope;\r\nvar EffectScope = /** @class */ (function () {\r\n    function EffectScope(detached) {\r\n        if (detached === void 0) { detached = false; }\r\n        /**\r\n         * @internal\r\n         */\r\n        this.active = true;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.effects = [];\r\n        /**\r\n         * @internal\r\n         */\r\n        this.cleanups = [];\r\n        if (!detached && activeEffectScope) {\r\n            this.parent = activeEffectScope;\r\n            this.index =\r\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\r\n        }\r\n    }\r\n    EffectScope.prototype.run = function (fn) {\r\n        if (this.active) {\r\n            var currentEffectScope = activeEffectScope;\r\n            try {\r\n                activeEffectScope = this;\r\n                return fn();\r\n            }\r\n            finally {\r\n                activeEffectScope = currentEffectScope;\r\n            }\r\n        }\r\n        else if (false) {}\r\n    };\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    EffectScope.prototype.on = function () {\r\n        activeEffectScope = this;\r\n    };\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    EffectScope.prototype.off = function () {\r\n        activeEffectScope = this.parent;\r\n    };\r\n    EffectScope.prototype.stop = function (fromParent) {\r\n        if (this.active) {\r\n            var i = void 0, l = void 0;\r\n            for (i = 0, l = this.effects.length; i < l; i++) {\r\n                this.effects[i].teardown();\r\n            }\r\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n                this.cleanups[i]();\r\n            }\r\n            if (this.scopes) {\r\n                for (i = 0, l = this.scopes.length; i < l; i++) {\r\n                    this.scopes[i].stop(true);\r\n                }\r\n            }\r\n            // nested scope, dereference from parent to avoid memory leaks\r\n            if (this.parent && !fromParent) {\r\n                // optimized O(1) removal\r\n                var last = this.parent.scopes.pop();\r\n                if (last && last !== this) {\r\n                    this.parent.scopes[this.index] = last;\r\n                    last.index = this.index;\r\n                }\r\n            }\r\n            this.active = false;\r\n        }\r\n    };\r\n    return EffectScope;\r\n}());\r\nfunction effectScope(detached) {\r\n    return new EffectScope(detached);\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction recordEffectScope(effect, scope) {\r\n    if (scope === void 0) { scope = activeEffectScope; }\r\n    if (scope && scope.active) {\r\n        scope.effects.push(effect);\r\n    }\r\n}\r\nfunction getCurrentScope() {\r\n    return activeEffectScope;\r\n}\r\nfunction onScopeDispose(fn) {\r\n    if (activeEffectScope) {\r\n        activeEffectScope.cleanups.push(fn);\r\n    }\r\n    else if (false) {}\r\n}\n\nfunction provide(key, value) {\r\n    if (!currentInstance) {\r\n        if (false) {}\r\n    }\r\n    else {\r\n        // TS doesn't allow symbol as index type\r\n        resolveProvided(currentInstance)[key] = value;\r\n    }\r\n}\r\nfunction resolveProvided(vm) {\r\n    // by default an instance inherits its parent's provides object\r\n    // but when it needs to provide values of its own, it creates its\r\n    // own provides object using parent provides object as prototype.\r\n    // this way in `inject` we can simply look up injections from direct\r\n    // parent and let the prototype chain do the work.\r\n    var existing = vm._provided;\r\n    var parentProvides = vm.$parent && vm.$parent._provided;\r\n    if (parentProvides === existing) {\r\n        return (vm._provided = Object.create(parentProvides));\r\n    }\r\n    else {\r\n        return existing;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory) {\r\n    if (treatDefaultAsFactory === void 0) { treatDefaultAsFactory = false; }\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    var instance = currentInstance;\r\n    if (instance) {\r\n        // #2400\r\n        // to support `app.use` plugins,\r\n        // fallback to appContext's `provides` if the instance is at root\r\n        var provides = instance.$parent && instance.$parent._provided;\r\n        if (provides && key in provides) {\r\n            // TS doesn't allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && isFunction(defaultValue)\r\n                ? defaultValue.call(instance)\r\n                : defaultValue;\r\n        }\r\n        else if (false) {}\r\n    }\r\n    else if (false) {}\r\n}\n\nvar normalizeEvent = cached(function (name) {\r\n    var passive = name.charAt(0) === '&';\r\n    name = passive ? name.slice(1) : name;\r\n    var once = name.charAt(0) === '~'; // Prefixed last, checked first\r\n    name = once ? name.slice(1) : name;\r\n    var capture = name.charAt(0) === '!';\r\n    name = capture ? name.slice(1) : name;\r\n    return {\r\n        name: name,\r\n        once: once,\r\n        capture: capture,\r\n        passive: passive\r\n    };\r\n});\r\nfunction createFnInvoker(fns, vm) {\r\n    function invoker() {\r\n        var fns = invoker.fns;\r\n        if (isArray(fns)) {\r\n            var cloned = fns.slice();\r\n            for (var i = 0; i < cloned.length; i++) {\r\n                invokeWithErrorHandling(cloned[i], null, arguments, vm, \"v-on handler\");\r\n            }\r\n        }\r\n        else {\r\n            // return handler return value for single handlers\r\n            return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\r\n        }\r\n    }\r\n    invoker.fns = fns;\r\n    return invoker;\r\n}\r\nfunction updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {\r\n    var name, cur, old, event;\r\n    for (name in on) {\r\n        cur = on[name];\r\n        old = oldOn[name];\r\n        event = normalizeEvent(name);\r\n        if (isUndef(cur)) {\r\n             false &&\r\n                false;\r\n        }\r\n        else if (isUndef(old)) {\r\n            if (isUndef(cur.fns)) {\r\n                cur = on[name] = createFnInvoker(cur, vm);\r\n            }\r\n            if (isTrue(event.once)) {\r\n                cur = on[name] = createOnceHandler(event.name, cur, event.capture);\r\n            }\r\n            add(event.name, cur, event.capture, event.passive, event.params);\r\n        }\r\n        else if (cur !== old) {\r\n            old.fns = cur;\r\n            on[name] = old;\r\n        }\r\n    }\r\n    for (name in oldOn) {\r\n        if (isUndef(on[name])) {\r\n            event = normalizeEvent(name);\r\n            remove(event.name, oldOn[name], event.capture);\r\n        }\r\n    }\r\n}\n\nfunction mergeVNodeHook(def, hookKey, hook) {\r\n    if (def instanceof VNode) {\r\n        def = def.data.hook || (def.data.hook = {});\r\n    }\r\n    var invoker;\r\n    var oldHook = def[hookKey];\r\n    function wrappedHook() {\r\n        hook.apply(this, arguments);\r\n        // important: remove merged hook to ensure it's called only once\r\n        // and prevent memory leak\r\n        remove$2(invoker.fns, wrappedHook);\r\n    }\r\n    if (isUndef(oldHook)) {\r\n        // no existing hook\r\n        invoker = createFnInvoker([wrappedHook]);\r\n    }\r\n    else {\r\n        /* istanbul ignore if */\r\n        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\r\n            // already a merged invoker\r\n            invoker = oldHook;\r\n            invoker.fns.push(wrappedHook);\r\n        }\r\n        else {\r\n            // existing plain hook\r\n            invoker = createFnInvoker([oldHook, wrappedHook]);\r\n        }\r\n    }\r\n    invoker.merged = true;\r\n    def[hookKey] = invoker;\r\n}\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\r\n    // we are only extracting raw values here.\r\n    // validation and default values are handled in the child\r\n    // component itself.\r\n    var propOptions = Ctor.options.props;\r\n    if (isUndef(propOptions)) {\r\n        return;\r\n    }\r\n    var res = {};\r\n    var attrs = data.attrs, props = data.props;\r\n    if (isDef(attrs) || isDef(props)) {\r\n        for (var key in propOptions) {\r\n            var altKey = hyphenate(key);\r\n            if (false) { var keyInLowerCase; }\r\n            checkProp(res, props, key, altKey, true) ||\r\n                checkProp(res, attrs, key, altKey, false);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction checkProp(res, hash, key, altKey, preserve) {\r\n    if (isDef(hash)) {\r\n        if (hasOwn(hash, key)) {\r\n            res[key] = hash[key];\r\n            if (!preserve) {\r\n                delete hash[key];\r\n            }\r\n            return true;\r\n        }\r\n        else if (hasOwn(hash, altKey)) {\r\n            res[key] = hash[altKey];\r\n            if (!preserve) {\r\n                delete hash[altKey];\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n// The template compiler attempts to minimize the need for normalization by\r\n// statically analyzing the template at compile time.\r\n//\r\n// For plain HTML markup, normalization can be completely skipped because the\r\n// generated render function is guaranteed to return Array<VNode>. There are\r\n// two cases where extra normalization is needed:\r\n// 1. When the children contains components - because a functional component\r\n// may return an Array instead of a single root. In this case, just a simple\r\n// normalization is needed - if any child is an Array, we flatten the whole\r\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\r\n// because functional components already normalize their own children.\r\nfunction simpleNormalizeChildren(children) {\r\n    for (var i = 0; i < children.length; i++) {\r\n        if (isArray(children[i])) {\r\n            return Array.prototype.concat.apply([], children);\r\n        }\r\n    }\r\n    return children;\r\n}\r\n// 2. When the children contains constructs that always generated nested Arrays,\r\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\r\n// with hand-written render functions / JSX. In such cases a full normalization\r\n// is needed to cater to all possible types of children values.\r\nfunction normalizeChildren(children) {\r\n    return isPrimitive(children)\r\n        ? [createTextVNode(children)]\r\n        : isArray(children)\r\n            ? normalizeArrayChildren(children)\r\n            : undefined;\r\n}\r\nfunction isTextNode(node) {\r\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\r\n}\r\nfunction normalizeArrayChildren(children, nestedIndex) {\r\n    var res = [];\r\n    var i, c, lastIndex, last;\r\n    for (i = 0; i < children.length; i++) {\r\n        c = children[i];\r\n        if (isUndef(c) || typeof c === 'boolean')\r\n            continue;\r\n        lastIndex = res.length - 1;\r\n        last = res[lastIndex];\r\n        //  nested\r\n        if (isArray(c)) {\r\n            if (c.length > 0) {\r\n                c = normalizeArrayChildren(c, \"\".concat(nestedIndex || '', \"_\").concat(i));\r\n                // merge adjacent text nodes\r\n                if (isTextNode(c[0]) && isTextNode(last)) {\r\n                    res[lastIndex] = createTextVNode(last.text + c[0].text);\r\n                    c.shift();\r\n                }\r\n                res.push.apply(res, c);\r\n            }\r\n        }\r\n        else if (isPrimitive(c)) {\r\n            if (isTextNode(last)) {\r\n                // merge adjacent text nodes\r\n                // this is necessary for SSR hydration because text nodes are\r\n                // essentially merged when rendered to HTML strings\r\n                res[lastIndex] = createTextVNode(last.text + c);\r\n            }\r\n            else if (c !== '') {\r\n                // convert primitive to vnode\r\n                res.push(createTextVNode(c));\r\n            }\r\n        }\r\n        else {\r\n            if (isTextNode(c) && isTextNode(last)) {\r\n                // merge adjacent text nodes\r\n                res[lastIndex] = createTextVNode(last.text + c.text);\r\n            }\r\n            else {\r\n                // default key for nested array children (likely generated by v-for)\r\n                if (isTrue(children._isVList) &&\r\n                    isDef(c.tag) &&\r\n                    isUndef(c.key) &&\r\n                    isDef(nestedIndex)) {\r\n                    c.key = \"__vlist\".concat(nestedIndex, \"_\").concat(i, \"__\");\r\n                }\r\n                res.push(c);\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\n\n/**\r\n * Runtime helper for rendering v-for lists.\r\n */\r\nfunction renderList(val, render) {\r\n    var ret = null, i, l, keys, key;\r\n    if (isArray(val) || typeof val === 'string') {\r\n        ret = new Array(val.length);\r\n        for (i = 0, l = val.length; i < l; i++) {\r\n            ret[i] = render(val[i], i);\r\n        }\r\n    }\r\n    else if (typeof val === 'number') {\r\n        ret = new Array(val);\r\n        for (i = 0; i < val; i++) {\r\n            ret[i] = render(i + 1, i);\r\n        }\r\n    }\r\n    else if (isObject(val)) {\r\n        if (hasSymbol && val[Symbol.iterator]) {\r\n            ret = [];\r\n            var iterator = val[Symbol.iterator]();\r\n            var result = iterator.next();\r\n            while (!result.done) {\r\n                ret.push(render(result.value, ret.length));\r\n                result = iterator.next();\r\n            }\r\n        }\r\n        else {\r\n            keys = Object.keys(val);\r\n            ret = new Array(keys.length);\r\n            for (i = 0, l = keys.length; i < l; i++) {\r\n                key = keys[i];\r\n                ret[i] = render(val[key], key, i);\r\n            }\r\n        }\r\n    }\r\n    if (!isDef(ret)) {\r\n        ret = [];\r\n    }\r\n    ret._isVList = true;\r\n    return ret;\r\n}\n\n/**\r\n * Runtime helper for rendering <slot>\r\n */\r\nfunction renderSlot(name, fallbackRender, props, bindObject) {\r\n    var scopedSlotFn = this.$scopedSlots[name];\r\n    var nodes;\r\n    if (scopedSlotFn) {\r\n        // scoped slot\r\n        props = props || {};\r\n        if (bindObject) {\r\n            if (false) {}\r\n            props = extend(extend({}, bindObject), props);\r\n        }\r\n        nodes =\r\n            scopedSlotFn(props) ||\r\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\r\n    }\r\n    else {\r\n        nodes =\r\n            this.$slots[name] ||\r\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\r\n    }\r\n    var target = props && props.slot;\r\n    if (target) {\r\n        return this.$createElement('template', { slot: target }, nodes);\r\n    }\r\n    else {\r\n        return nodes;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for resolving filters\r\n */\r\nfunction resolveFilter(id) {\r\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\r\n}\n\nfunction isKeyNotMatch(expect, actual) {\r\n    if (isArray(expect)) {\r\n        return expect.indexOf(actual) === -1;\r\n    }\r\n    else {\r\n        return expect !== actual;\r\n    }\r\n}\r\n/**\r\n * Runtime helper for checking keyCodes from config.\r\n * exposed as Vue.prototype._k\r\n * passing in eventKeyName as last argument separately for backwards compat\r\n */\r\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\r\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\r\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\r\n        return isKeyNotMatch(builtInKeyName, eventKeyName);\r\n    }\r\n    else if (mappedKeyCode) {\r\n        return isKeyNotMatch(mappedKeyCode, eventKeyCode);\r\n    }\r\n    else if (eventKeyName) {\r\n        return hyphenate(eventKeyName) !== key;\r\n    }\r\n    return eventKeyCode === undefined;\r\n}\n\n/**\r\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\r\n */\r\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\r\n    if (value) {\r\n        if (!isObject(value)) {\r\n             false &&\r\n                false;\r\n        }\r\n        else {\r\n            if (isArray(value)) {\r\n                value = toObject(value);\r\n            }\r\n            var hash = void 0;\r\n            var _loop_1 = function (key) {\r\n                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\r\n                    hash = data;\r\n                }\r\n                else {\r\n                    var type = data.attrs && data.attrs.type;\r\n                    hash =\r\n                        asProp || config.mustUseProp(tag, type, key)\r\n                            ? data.domProps || (data.domProps = {})\r\n                            : data.attrs || (data.attrs = {});\r\n                }\r\n                var camelizedKey = camelize(key);\r\n                var hyphenatedKey = hyphenate(key);\r\n                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\r\n                    hash[key] = value[key];\r\n                    if (isSync) {\r\n                        var on = data.on || (data.on = {});\r\n                        on[\"update:\".concat(key)] = function ($event) {\r\n                            value[key] = $event;\r\n                        };\r\n                    }\r\n                }\r\n            };\r\n            for (var key in value) {\r\n                _loop_1(key);\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}\n\n/**\r\n * Runtime helper for rendering static trees.\r\n */\r\nfunction renderStatic(index, isInFor) {\r\n    var cached = this._staticTrees || (this._staticTrees = []);\r\n    var tree = cached[index];\r\n    // if has already-rendered static tree and not inside v-for,\r\n    // we can reuse the same tree.\r\n    if (tree && !isInFor) {\r\n        return tree;\r\n    }\r\n    // otherwise, render a fresh tree.\r\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates\r\n    );\r\n    markStatic(tree, \"__static__\".concat(index), false);\r\n    return tree;\r\n}\r\n/**\r\n * Runtime helper for v-once.\r\n * Effectively it means marking the node as static with a unique key.\r\n */\r\nfunction markOnce(tree, index, key) {\r\n    markStatic(tree, \"__once__\".concat(index).concat(key ? \"_\".concat(key) : \"\"), true);\r\n    return tree;\r\n}\r\nfunction markStatic(tree, key, isOnce) {\r\n    if (isArray(tree)) {\r\n        for (var i = 0; i < tree.length; i++) {\r\n            if (tree[i] && typeof tree[i] !== 'string') {\r\n                markStaticNode(tree[i], \"\".concat(key, \"_\").concat(i), isOnce);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        markStaticNode(tree, key, isOnce);\r\n    }\r\n}\r\nfunction markStaticNode(node, key, isOnce) {\r\n    node.isStatic = true;\r\n    node.key = key;\r\n    node.isOnce = isOnce;\r\n}\n\nfunction bindObjectListeners(data, value) {\r\n    if (value) {\r\n        if (!isPlainObject(value)) {\r\n             false && false;\r\n        }\r\n        else {\r\n            var on = (data.on = data.on ? extend({}, data.on) : {});\r\n            for (var key in value) {\r\n                var existing = on[key];\r\n                var ours = value[key];\r\n                on[key] = existing ? [].concat(existing, ours) : ours;\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}\n\nfunction resolveScopedSlots(fns, res, \r\n// the following are added in 2.6\r\nhasDynamicKeys, contentHashKey) {\r\n    res = res || { $stable: !hasDynamicKeys };\r\n    for (var i = 0; i < fns.length; i++) {\r\n        var slot = fns[i];\r\n        if (isArray(slot)) {\r\n            resolveScopedSlots(slot, res, hasDynamicKeys);\r\n        }\r\n        else if (slot) {\r\n            // marker for reverse proxying v-slot without scope on this.$slots\r\n            // @ts-expect-error\r\n            if (slot.proxy) {\r\n                // @ts-expect-error\r\n                slot.fn.proxy = true;\r\n            }\r\n            res[slot.key] = slot.fn;\r\n        }\r\n    }\r\n    if (contentHashKey) {\r\n        res.$key = contentHashKey;\r\n    }\r\n    return res;\r\n}\n\n// helper to process dynamic keys for dynamic arguments in v-bind and v-on.\r\nfunction bindDynamicKeys(baseObj, values) {\r\n    for (var i = 0; i < values.length; i += 2) {\r\n        var key = values[i];\r\n        if (typeof key === 'string' && key) {\r\n            baseObj[values[i]] = values[i + 1];\r\n        }\r\n        else if (false) {}\r\n    }\r\n    return baseObj;\r\n}\r\n// helper to dynamically append modifier runtime markers to event names.\r\n// ensure only append when value is already string, otherwise it will be cast\r\n// to string and cause the type check to miss.\r\nfunction prependModifier(value, symbol) {\r\n    return typeof value === 'string' ? symbol + value : value;\r\n}\n\nfunction installRenderHelpers(target) {\r\n    target._o = markOnce;\r\n    target._n = toNumber;\r\n    target._s = toString;\r\n    target._l = renderList;\r\n    target._t = renderSlot;\r\n    target._q = looseEqual;\r\n    target._i = looseIndexOf;\r\n    target._m = renderStatic;\r\n    target._f = resolveFilter;\r\n    target._k = checkKeyCodes;\r\n    target._b = bindObjectProps;\r\n    target._v = createTextVNode;\r\n    target._e = createEmptyVNode;\r\n    target._u = resolveScopedSlots;\r\n    target._g = bindObjectListeners;\r\n    target._d = bindDynamicKeys;\r\n    target._p = prependModifier;\r\n}\n\n/**\r\n * Runtime helper for resolving raw children VNodes into a slot object.\r\n */\r\nfunction resolveSlots(children, context) {\r\n    if (!children || !children.length) {\r\n        return {};\r\n    }\r\n    var slots = {};\r\n    for (var i = 0, l = children.length; i < l; i++) {\r\n        var child = children[i];\r\n        var data = child.data;\r\n        // remove slot attribute if the node is resolved as a Vue slot node\r\n        if (data && data.attrs && data.attrs.slot) {\r\n            delete data.attrs.slot;\r\n        }\r\n        // named slots should only be respected if the vnode was rendered in the\r\n        // same context.\r\n        if ((child.context === context || child.fnContext === context) &&\r\n            data &&\r\n            data.slot != null) {\r\n            var name_1 = data.slot;\r\n            var slot = slots[name_1] || (slots[name_1] = []);\r\n            if (child.tag === 'template') {\r\n                slot.push.apply(slot, child.children || []);\r\n            }\r\n            else {\r\n                slot.push(child);\r\n            }\r\n        }\r\n        else {\r\n            (slots.default || (slots.default = [])).push(child);\r\n        }\r\n    }\r\n    // ignore slots that contains only whitespace\r\n    for (var name_2 in slots) {\r\n        if (slots[name_2].every(isWhitespace)) {\r\n            delete slots[name_2];\r\n        }\r\n    }\r\n    return slots;\r\n}\r\nfunction isWhitespace(node) {\r\n    return (node.isComment && !node.asyncFactory) || node.text === ' ';\r\n}\n\nfunction isAsyncPlaceholder(node) {\r\n    // @ts-expect-error not really boolean type\r\n    return node.isComment && node.asyncFactory;\r\n}\n\nfunction normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {\r\n    var res;\r\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\r\n    var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;\r\n    var key = scopedSlots && scopedSlots.$key;\r\n    if (!scopedSlots) {\r\n        res = {};\r\n    }\r\n    else if (scopedSlots._normalized) {\r\n        // fast path 1: child component re-render only, parent did not change\r\n        return scopedSlots._normalized;\r\n    }\r\n    else if (isStable &&\r\n        prevScopedSlots &&\r\n        prevScopedSlots !== emptyObject &&\r\n        key === prevScopedSlots.$key &&\r\n        !hasNormalSlots &&\r\n        !prevScopedSlots.$hasNormal) {\r\n        // fast path 2: stable scoped slots w/ no normal slots to proxy,\r\n        // only need to normalize once\r\n        return prevScopedSlots;\r\n    }\r\n    else {\r\n        res = {};\r\n        for (var key_1 in scopedSlots) {\r\n            if (scopedSlots[key_1] && key_1[0] !== '$') {\r\n                res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);\r\n            }\r\n        }\r\n    }\r\n    // expose normal slots on scopedSlots\r\n    for (var key_2 in normalSlots) {\r\n        if (!(key_2 in res)) {\r\n            res[key_2] = proxyNormalSlot(normalSlots, key_2);\r\n        }\r\n    }\r\n    // avoriaz seems to mock a non-extensible $scopedSlots object\r\n    // and when that is passed down this would cause an error\r\n    if (scopedSlots && Object.isExtensible(scopedSlots)) {\r\n        scopedSlots._normalized = res;\r\n    }\r\n    def(res, '$stable', isStable);\r\n    def(res, '$key', key);\r\n    def(res, '$hasNormal', hasNormalSlots);\r\n    return res;\r\n}\r\nfunction normalizeScopedSlot(vm, normalSlots, key, fn) {\r\n    var normalized = function () {\r\n        var cur = currentInstance;\r\n        setCurrentInstance(vm);\r\n        var res = arguments.length ? fn.apply(null, arguments) : fn({});\r\n        res =\r\n            res && typeof res === 'object' && !isArray(res)\r\n                ? [res] // single vnode\r\n                : normalizeChildren(res);\r\n        var vnode = res && res[0];\r\n        setCurrentInstance(cur);\r\n        return res &&\r\n            (!vnode ||\r\n                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391\r\n            ? undefined\r\n            : res;\r\n    };\r\n    // this is a slot using the new v-slot syntax without scope. although it is\r\n    // compiled as a scoped slot, render fn users would expect it to be present\r\n    // on this.$slots because the usage is semantically a normal slot.\r\n    if (fn.proxy) {\r\n        Object.defineProperty(normalSlots, key, {\r\n            get: normalized,\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n    }\r\n    return normalized;\r\n}\r\nfunction proxyNormalSlot(slots, key) {\r\n    return function () { return slots[key]; };\r\n}\n\nfunction initSetup(vm) {\r\n    var options = vm.$options;\r\n    var setup = options.setup;\r\n    if (setup) {\r\n        var ctx = (vm._setupContext = createSetupContext(vm));\r\n        setCurrentInstance(vm);\r\n        pushTarget();\r\n        var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, \"setup\");\r\n        popTarget();\r\n        setCurrentInstance();\r\n        if (isFunction(setupResult)) {\r\n            // render function\r\n            // @ts-ignore\r\n            options.render = setupResult;\r\n        }\r\n        else if (isObject(setupResult)) {\r\n            // bindings\r\n            if (false) {}\r\n            vm._setupState = setupResult;\r\n            // __sfc indicates compiled bindings from <script setup>\r\n            if (!setupResult.__sfc) {\r\n                for (var key in setupResult) {\r\n                    if (!isReserved(key)) {\r\n                        proxyWithRefUnwrap(vm, setupResult, key);\r\n                    }\r\n                    else if (false) {}\r\n                }\r\n            }\r\n            else {\r\n                // exposed for compiled render fn\r\n                var proxy = (vm._setupProxy = {});\r\n                for (var key in setupResult) {\r\n                    if (key !== '__sfc') {\r\n                        proxyWithRefUnwrap(proxy, setupResult, key);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (false) {}\r\n    }\r\n}\r\nfunction createSetupContext(vm) {\r\n    var exposeCalled = false;\r\n    return {\r\n        get attrs() {\r\n            if (!vm._attrsProxy) {\r\n                var proxy = (vm._attrsProxy = {});\r\n                def(proxy, '_v_attr_proxy', true);\r\n                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');\r\n            }\r\n            return vm._attrsProxy;\r\n        },\r\n        get listeners() {\r\n            if (!vm._listenersProxy) {\r\n                var proxy = (vm._listenersProxy = {});\r\n                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');\r\n            }\r\n            return vm._listenersProxy;\r\n        },\r\n        get slots() {\r\n            return initSlotsProxy(vm);\r\n        },\r\n        emit: bind(vm.$emit, vm),\r\n        expose: function (exposed) {\r\n            if (false) {}\r\n            if (exposed) {\r\n                Object.keys(exposed).forEach(function (key) {\r\n                    return proxyWithRefUnwrap(vm, exposed, key);\r\n                });\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction syncSetupProxy(to, from, prev, instance, type) {\r\n    var changed = false;\r\n    for (var key in from) {\r\n        if (!(key in to)) {\r\n            changed = true;\r\n            defineProxyAttr(to, key, instance, type);\r\n        }\r\n        else if (from[key] !== prev[key]) {\r\n            changed = true;\r\n        }\r\n    }\r\n    for (var key in to) {\r\n        if (!(key in from)) {\r\n            changed = true;\r\n            delete to[key];\r\n        }\r\n    }\r\n    return changed;\r\n}\r\nfunction defineProxyAttr(proxy, key, instance, type) {\r\n    Object.defineProperty(proxy, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function () {\r\n            return instance[type][key];\r\n        }\r\n    });\r\n}\r\nfunction initSlotsProxy(vm) {\r\n    if (!vm._slotsProxy) {\r\n        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);\r\n    }\r\n    return vm._slotsProxy;\r\n}\r\nfunction syncSetupSlots(to, from) {\r\n    for (var key in from) {\r\n        to[key] = from[key];\r\n    }\r\n    for (var key in to) {\r\n        if (!(key in from)) {\r\n            delete to[key];\r\n        }\r\n    }\r\n}\r\n/**\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useSlots() {\r\n    return getContext().slots;\r\n}\r\n/**\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useAttrs() {\r\n    return getContext().attrs;\r\n}\r\n/**\r\n * Vue 2 only\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useListeners() {\r\n    return getContext().listeners;\r\n}\r\nfunction getContext() {\r\n    if (false) {}\r\n    var vm = currentInstance;\r\n    return vm._setupContext || (vm._setupContext = createSetupContext(vm));\r\n}\r\n/**\r\n * Runtime helper for merging default declarations. Imported by compiled code\r\n * only.\r\n * @internal\r\n */\r\nfunction mergeDefaults(raw, defaults) {\r\n    var props = isArray(raw)\r\n        ? raw.reduce(function (normalized, p) { return ((normalized[p] = {}), normalized); }, {})\r\n        : raw;\r\n    for (var key in defaults) {\r\n        var opt = props[key];\r\n        if (opt) {\r\n            if (isArray(opt) || isFunction(opt)) {\r\n                props[key] = { type: opt, default: defaults[key] };\r\n            }\r\n            else {\r\n                opt.default = defaults[key];\r\n            }\r\n        }\r\n        else if (opt === null) {\r\n            props[key] = { default: defaults[key] };\r\n        }\r\n        else if (false) {}\r\n    }\r\n    return props;\r\n}\n\nfunction initRender(vm) {\r\n    vm._vnode = null; // the root of the child tree\r\n    vm._staticTrees = null; // v-once cached trees\r\n    var options = vm.$options;\r\n    var parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree\r\n    var renderContext = parentVnode && parentVnode.context;\r\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\r\n    vm.$scopedSlots = parentVnode\r\n        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)\r\n        : emptyObject;\r\n    // bind the createElement fn to this instance\r\n    // so that we get proper render context inside it.\r\n    // args order: tag, data, children, normalizationType, alwaysNormalize\r\n    // internal version is used by render functions compiled from templates\r\n    // @ts-expect-error\r\n    vm._c = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, false); };\r\n    // normalization is always applied for the public version, used in\r\n    // user-written render functions.\r\n    // @ts-expect-error\r\n    vm.$createElement = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, true); };\r\n    // $attrs & $listeners are exposed for easier HOC creation.\r\n    // they need to be reactive so that HOCs using them are always updated\r\n    var parentData = parentVnode && parentVnode.data;\r\n    /* istanbul ignore else */\r\n    if (false) {}\r\n    else {\r\n        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, null, true);\r\n        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);\r\n    }\r\n}\r\nvar currentRenderingInstance = null;\r\nfunction renderMixin(Vue) {\r\n    // install runtime convenience helpers\r\n    installRenderHelpers(Vue.prototype);\r\n    Vue.prototype.$nextTick = function (fn) {\r\n        return nextTick(fn, this);\r\n    };\r\n    Vue.prototype._render = function () {\r\n        var vm = this;\r\n        var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;\r\n        if (_parentVnode && vm._isMounted) {\r\n            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\r\n            if (vm._slotsProxy) {\r\n                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);\r\n            }\r\n        }\r\n        // set parent vnode. this allows render functions to have access\r\n        // to the data on the placeholder node.\r\n        vm.$vnode = _parentVnode;\r\n        // render self\r\n        var vnode;\r\n        try {\r\n            // There's no need to maintain a stack because all render fns are called\r\n            // separately from one another. Nested component's render fns are called\r\n            // when parent component is patched.\r\n            setCurrentInstance(vm);\r\n            currentRenderingInstance = vm;\r\n            vnode = render.call(vm._renderProxy, vm.$createElement);\r\n        }\r\n        catch (e) {\r\n            handleError(e, vm, \"render\");\r\n            // return error render result,\r\n            // or previous vnode to prevent render error causing blank component\r\n            /* istanbul ignore else */\r\n            if (false) {}\r\n            else {\r\n                vnode = vm._vnode;\r\n            }\r\n        }\r\n        finally {\r\n            currentRenderingInstance = null;\r\n            setCurrentInstance();\r\n        }\r\n        // if the returned array contains only a single node, allow it\r\n        if (isArray(vnode) && vnode.length === 1) {\r\n            vnode = vnode[0];\r\n        }\r\n        // return empty vnode in case the render function errored out\r\n        if (!(vnode instanceof VNode)) {\r\n            if (false) {}\r\n            vnode = createEmptyVNode();\r\n        }\r\n        // set parent\r\n        vnode.parent = _parentVnode;\r\n        return vnode;\r\n    };\r\n}\n\nfunction ensureCtor(comp, base) {\r\n    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {\r\n        comp = comp.default;\r\n    }\r\n    return isObject(comp) ? base.extend(comp) : comp;\r\n}\r\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\r\n    var node = createEmptyVNode();\r\n    node.asyncFactory = factory;\r\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\r\n    return node;\r\n}\r\nfunction resolveAsyncComponent(factory, baseCtor) {\r\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\r\n        return factory.errorComp;\r\n    }\r\n    if (isDef(factory.resolved)) {\r\n        return factory.resolved;\r\n    }\r\n    var owner = currentRenderingInstance;\r\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\r\n        // already pending\r\n        factory.owners.push(owner);\r\n    }\r\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\r\n        return factory.loadingComp;\r\n    }\r\n    if (owner && !isDef(factory.owners)) {\r\n        var owners_1 = (factory.owners = [owner]);\r\n        var sync_1 = true;\r\n        var timerLoading_1 = null;\r\n        var timerTimeout_1 = null;\r\n        owner.$on('hook:destroyed', function () { return remove$2(owners_1, owner); });\r\n        var forceRender_1 = function (renderCompleted) {\r\n            for (var i = 0, l = owners_1.length; i < l; i++) {\r\n                owners_1[i].$forceUpdate();\r\n            }\r\n            if (renderCompleted) {\r\n                owners_1.length = 0;\r\n                if (timerLoading_1 !== null) {\r\n                    clearTimeout(timerLoading_1);\r\n                    timerLoading_1 = null;\r\n                }\r\n                if (timerTimeout_1 !== null) {\r\n                    clearTimeout(timerTimeout_1);\r\n                    timerTimeout_1 = null;\r\n                }\r\n            }\r\n        };\r\n        var resolve = once(function (res) {\r\n            // cache resolved\r\n            factory.resolved = ensureCtor(res, baseCtor);\r\n            // invoke callbacks only if this is not a synchronous resolve\r\n            // (async resolves are shimmed as synchronous during SSR)\r\n            if (!sync_1) {\r\n                forceRender_1(true);\r\n            }\r\n            else {\r\n                owners_1.length = 0;\r\n            }\r\n        });\r\n        var reject_1 = once(function (reason) {\r\n             false &&\r\n                false;\r\n            if (isDef(factory.errorComp)) {\r\n                factory.error = true;\r\n                forceRender_1(true);\r\n            }\r\n        });\r\n        var res_1 = factory(resolve, reject_1);\r\n        if (isObject(res_1)) {\r\n            if (isPromise(res_1)) {\r\n                // () => Promise\r\n                if (isUndef(factory.resolved)) {\r\n                    res_1.then(resolve, reject_1);\r\n                }\r\n            }\r\n            else if (isPromise(res_1.component)) {\r\n                res_1.component.then(resolve, reject_1);\r\n                if (isDef(res_1.error)) {\r\n                    factory.errorComp = ensureCtor(res_1.error, baseCtor);\r\n                }\r\n                if (isDef(res_1.loading)) {\r\n                    factory.loadingComp = ensureCtor(res_1.loading, baseCtor);\r\n                    if (res_1.delay === 0) {\r\n                        factory.loading = true;\r\n                    }\r\n                    else {\r\n                        // @ts-expect-error NodeJS timeout type\r\n                        timerLoading_1 = setTimeout(function () {\r\n                            timerLoading_1 = null;\r\n                            if (isUndef(factory.resolved) && isUndef(factory.error)) {\r\n                                factory.loading = true;\r\n                                forceRender_1(false);\r\n                            }\r\n                        }, res_1.delay || 200);\r\n                    }\r\n                }\r\n                if (isDef(res_1.timeout)) {\r\n                    // @ts-expect-error NodeJS timeout type\r\n                    timerTimeout_1 = setTimeout(function () {\r\n                        timerTimeout_1 = null;\r\n                        if (isUndef(factory.resolved)) {\r\n                            reject_1( false ? undefined : null);\r\n                        }\r\n                    }, res_1.timeout);\r\n                }\r\n            }\r\n        }\r\n        sync_1 = false;\r\n        // return in case resolved synchronously\r\n        return factory.loading ? factory.loadingComp : factory.resolved;\r\n    }\r\n}\n\nfunction getFirstComponentChild(children) {\r\n    if (isArray(children)) {\r\n        for (var i = 0; i < children.length; i++) {\r\n            var c = children[i];\r\n            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\r\n                return c;\r\n            }\r\n        }\r\n    }\r\n}\n\nvar SIMPLE_NORMALIZE = 1;\r\nvar ALWAYS_NORMALIZE = 2;\r\n// wrapper function for providing a more flexible interface\r\n// without getting yelled at by flow\r\nfunction createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {\r\n    if (isArray(data) || isPrimitive(data)) {\r\n        normalizationType = children;\r\n        children = data;\r\n        data = undefined;\r\n    }\r\n    if (isTrue(alwaysNormalize)) {\r\n        normalizationType = ALWAYS_NORMALIZE;\r\n    }\r\n    return _createElement(context, tag, data, children, normalizationType);\r\n}\r\nfunction _createElement(context, tag, data, children, normalizationType) {\r\n    if (isDef(data) && isDef(data.__ob__)) {\r\n         false &&\r\n            false;\r\n        return createEmptyVNode();\r\n    }\r\n    // object syntax in v-bind\r\n    if (isDef(data) && isDef(data.is)) {\r\n        tag = data.is;\r\n    }\r\n    if (!tag) {\r\n        // in case of component :is set to falsy value\r\n        return createEmptyVNode();\r\n    }\r\n    // warn against non-primitive key\r\n    if (false) {}\r\n    // support single function children as default scoped slot\r\n    if (isArray(children) && isFunction(children[0])) {\r\n        data = data || {};\r\n        data.scopedSlots = { default: children[0] };\r\n        children.length = 0;\r\n    }\r\n    if (normalizationType === ALWAYS_NORMALIZE) {\r\n        children = normalizeChildren(children);\r\n    }\r\n    else if (normalizationType === SIMPLE_NORMALIZE) {\r\n        children = simpleNormalizeChildren(children);\r\n    }\r\n    var vnode, ns;\r\n    if (typeof tag === 'string') {\r\n        var Ctor = void 0;\r\n        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\r\n        if (config.isReservedTag(tag)) {\r\n            // platform built-in elements\r\n            if (false) {}\r\n            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\r\n        }\r\n        else if ((!data || !data.pre) &&\r\n            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {\r\n            // component\r\n            vnode = createComponent(Ctor, data, context, children, tag);\r\n        }\r\n        else {\r\n            // unknown or unlisted namespaced elements\r\n            // check at runtime because it may get assigned a namespace when its\r\n            // parent normalizes children\r\n            vnode = new VNode(tag, data, children, undefined, undefined, context);\r\n        }\r\n    }\r\n    else {\r\n        // direct component options / constructor\r\n        vnode = createComponent(tag, data, context, children);\r\n    }\r\n    if (isArray(vnode)) {\r\n        return vnode;\r\n    }\r\n    else if (isDef(vnode)) {\r\n        if (isDef(ns))\r\n            applyNS(vnode, ns);\r\n        if (isDef(data))\r\n            registerDeepBindings(data);\r\n        return vnode;\r\n    }\r\n    else {\r\n        return createEmptyVNode();\r\n    }\r\n}\r\nfunction applyNS(vnode, ns, force) {\r\n    vnode.ns = ns;\r\n    if (vnode.tag === 'foreignObject') {\r\n        // use default namespace inside foreignObject\r\n        ns = undefined;\r\n        force = true;\r\n    }\r\n    if (isDef(vnode.children)) {\r\n        for (var i = 0, l = vnode.children.length; i < l; i++) {\r\n            var child = vnode.children[i];\r\n            if (isDef(child.tag) &&\r\n                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\r\n                applyNS(child, ns, force);\r\n            }\r\n        }\r\n    }\r\n}\r\n// ref #5318\r\n// necessary to ensure parent re-render when deep bindings like :style and\r\n// :class are used on slot nodes\r\nfunction registerDeepBindings(data) {\r\n    if (isObject(data.style)) {\r\n        traverse(data.style);\r\n    }\r\n    if (isObject(data.class)) {\r\n        traverse(data.class);\r\n    }\r\n}\n\n/**\r\n * @internal this function needs manual public type declaration because it relies\r\n * on previously manually authored types from Vue 2\r\n */\r\nfunction h(type, props, children) {\r\n    if (!currentInstance) {\r\n         false &&\r\n            false;\r\n    }\r\n    return createElement$1(currentInstance, type, props, children, 2, true);\r\n}\n\nfunction handleError(err, vm, info) {\r\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\r\n    // See: https://github.com/vuejs/vuex/issues/1505\r\n    pushTarget();\r\n    try {\r\n        if (vm) {\r\n            var cur = vm;\r\n            while ((cur = cur.$parent)) {\r\n                var hooks = cur.$options.errorCaptured;\r\n                if (hooks) {\r\n                    for (var i = 0; i < hooks.length; i++) {\r\n                        try {\r\n                            var capture = hooks[i].call(cur, err, vm, info) === false;\r\n                            if (capture)\r\n                                return;\r\n                        }\r\n                        catch (e) {\r\n                            globalHandleError(e, cur, 'errorCaptured hook');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        globalHandleError(err, vm, info);\r\n    }\r\n    finally {\r\n        popTarget();\r\n    }\r\n}\r\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\r\n    var res;\r\n    try {\r\n        res = args ? handler.apply(context, args) : handler.call(context);\r\n        if (res && !res._isVue && isPromise(res) && !res._handled) {\r\n            res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\r\n            res._handled = true;\r\n        }\r\n    }\r\n    catch (e) {\r\n        handleError(e, vm, info);\r\n    }\r\n    return res;\r\n}\r\nfunction globalHandleError(err, vm, info) {\r\n    if (config.errorHandler) {\r\n        try {\r\n            return config.errorHandler.call(null, err, vm, info);\r\n        }\r\n        catch (e) {\r\n            // if the user intentionally throws the original error in the handler,\r\n            // do not log it twice\r\n            if (e !== err) {\r\n                logError(e, null, 'config.errorHandler');\r\n            }\r\n        }\r\n    }\r\n    logError(err, vm, info);\r\n}\r\nfunction logError(err, vm, info) {\r\n    if (false) {}\r\n    /* istanbul ignore else */\r\n    if (inBrowser && typeof console !== 'undefined') {\r\n        console.error(err);\r\n    }\r\n    else {\r\n        throw err;\r\n    }\r\n}\n\n/* globals MutationObserver */\r\nvar isUsingMicroTask = false;\r\nvar callbacks = [];\r\nvar pending = false;\r\nfunction flushCallbacks() {\r\n    pending = false;\r\n    var copies = callbacks.slice(0);\r\n    callbacks.length = 0;\r\n    for (var i = 0; i < copies.length; i++) {\r\n        copies[i]();\r\n    }\r\n}\r\n// Here we have async deferring wrappers using microtasks.\r\n// In 2.5 we used (macro) tasks (in combination with microtasks).\r\n// However, it has subtle problems when state is changed right before repaint\r\n// (e.g. #6813, out-in transitions).\r\n// Also, using (macro) tasks in event handler would cause some weird behaviors\r\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\r\n// So we now use microtasks everywhere, again.\r\n// A major drawback of this tradeoff is that there are some scenarios\r\n// where microtasks have too high a priority and fire in between supposedly\r\n// sequential events (e.g. #4521, #6690, which have workarounds)\r\n// or even between bubbling of the same event (#6566).\r\nvar timerFunc;\r\n// The nextTick behavior leverages the microtask queue, which can be accessed\r\n// via either native Promise.then or MutationObserver.\r\n// MutationObserver has wider support, however it is seriously bugged in\r\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\r\n// completely stops working after triggering a few times... so, if native\r\n// Promise is available, we will use it:\r\n/* istanbul ignore next, $flow-disable-line */\r\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\r\n    var p_1 = Promise.resolve();\r\n    timerFunc = function () {\r\n        p_1.then(flushCallbacks);\r\n        // In problematic UIWebViews, Promise.then doesn't completely break, but\r\n        // it can get stuck in a weird state where callbacks are pushed into the\r\n        // microtask queue but the queue isn't being flushed, until the browser\r\n        // needs to do some other work, e.g. handle a timer. Therefore we can\r\n        // \"force\" the microtask queue to be flushed by adding an empty timer.\r\n        if (isIOS)\r\n            setTimeout(noop);\r\n    };\r\n    isUsingMicroTask = true;\r\n}\r\nelse if (!isIE &&\r\n    typeof MutationObserver !== 'undefined' &&\r\n    (isNative(MutationObserver) ||\r\n        // PhantomJS and iOS 7.x\r\n        MutationObserver.toString() === '[object MutationObserverConstructor]')) {\r\n    // Use MutationObserver where native Promise is not available,\r\n    // e.g. PhantomJS, iOS7, Android 4.4\r\n    // (#6466 MutationObserver is unreliable in IE11)\r\n    var counter_1 = 1;\r\n    var observer = new MutationObserver(flushCallbacks);\r\n    var textNode_1 = document.createTextNode(String(counter_1));\r\n    observer.observe(textNode_1, {\r\n        characterData: true\r\n    });\r\n    timerFunc = function () {\r\n        counter_1 = (counter_1 + 1) % 2;\r\n        textNode_1.data = String(counter_1);\r\n    };\r\n    isUsingMicroTask = true;\r\n}\r\nelse if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\r\n    // Fallback to setImmediate.\r\n    // Technically it leverages the (macro) task queue,\r\n    // but it is still a better choice than setTimeout.\r\n    timerFunc = function () {\r\n        setImmediate(flushCallbacks);\r\n    };\r\n}\r\nelse {\r\n    // Fallback to setTimeout.\r\n    timerFunc = function () {\r\n        setTimeout(flushCallbacks, 0);\r\n    };\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction nextTick(cb, ctx) {\r\n    var _resolve;\r\n    callbacks.push(function () {\r\n        if (cb) {\r\n            try {\r\n                cb.call(ctx);\r\n            }\r\n            catch (e) {\r\n                handleError(e, ctx, 'nextTick');\r\n            }\r\n        }\r\n        else if (_resolve) {\r\n            _resolve(ctx);\r\n        }\r\n    });\r\n    if (!pending) {\r\n        pending = true;\r\n        timerFunc();\r\n    }\r\n    // $flow-disable-line\r\n    if (!cb && typeof Promise !== 'undefined') {\r\n        return new Promise(function (resolve) {\r\n            _resolve = resolve;\r\n        });\r\n    }\r\n}\n\nfunction useCssModule(name) {\r\n    if (name === void 0) { name = '$style'; }\r\n    /* istanbul ignore else */\r\n    {\r\n        if (!currentInstance) {\r\n             false && false;\r\n            return emptyObject;\r\n        }\r\n        var mod = currentInstance[name];\r\n        if (!mod) {\r\n             false &&\r\n                false;\r\n            return emptyObject;\r\n        }\r\n        return mod;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for SFC's CSS variable injection feature.\r\n * @private\r\n */\r\nfunction useCssVars(getter) {\r\n    if (!inBrowser && !false)\r\n        return;\r\n    var instance = currentInstance;\r\n    if (!instance) {\r\n         false &&\r\n            false;\r\n        return;\r\n    }\r\n    watchPostEffect(function () {\r\n        var el = instance.$el;\r\n        var vars = getter(instance, instance._setupProxy);\r\n        if (el && el.nodeType === 1) {\r\n            var style = el.style;\r\n            for (var key in vars) {\r\n                style.setProperty(\"--\".concat(key), vars[key]);\r\n            }\r\n        }\r\n    });\r\n}\n\n/**\r\n * v3-compatible async component API.\r\n * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts\r\n * because it relies on existing manual types\r\n */\r\nfunction defineAsyncComponent(source) {\r\n    if (isFunction(source)) {\r\n        source = { loader: source };\r\n    }\r\n    var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _a = source.delay, delay = _a === void 0 ? 200 : _a, timeout = source.timeout, // undefined = never times out\r\n    _b = source.suspensible, // undefined = never times out\r\n    suspensible = _b === void 0 ? false : _b, // in Vue 3 default is true\r\n    userOnError = source.onError;\r\n    if (false) {}\r\n    var pendingRequest = null;\r\n    var retries = 0;\r\n    var retry = function () {\r\n        retries++;\r\n        pendingRequest = null;\r\n        return load();\r\n    };\r\n    var load = function () {\r\n        var thisRequest;\r\n        return (pendingRequest ||\r\n            (thisRequest = pendingRequest =\r\n                loader()\r\n                    .catch(function (err) {\r\n                    err = err instanceof Error ? err : new Error(String(err));\r\n                    if (userOnError) {\r\n                        return new Promise(function (resolve, reject) {\r\n                            var userRetry = function () { return resolve(retry()); };\r\n                            var userFail = function () { return reject(err); };\r\n                            userOnError(err, userRetry, userFail, retries + 1);\r\n                        });\r\n                    }\r\n                    else {\r\n                        throw err;\r\n                    }\r\n                })\r\n                    .then(function (comp) {\r\n                    if (thisRequest !== pendingRequest && pendingRequest) {\r\n                        return pendingRequest;\r\n                    }\r\n                    if (false) {}\r\n                    // interop module default\r\n                    if (comp &&\r\n                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\r\n                        comp = comp.default;\r\n                    }\r\n                    if (false) {}\r\n                    return comp;\r\n                })));\r\n    };\r\n    return function () {\r\n        var component = load();\r\n        return {\r\n            component: component,\r\n            delay: delay,\r\n            timeout: timeout,\r\n            error: errorComponent,\r\n            loading: loadingComponent\r\n        };\r\n    };\r\n}\n\nfunction createLifeCycle(hookName) {\r\n    return function (fn, target) {\r\n        if (target === void 0) { target = currentInstance; }\r\n        if (!target) {\r\n             false &&\r\n                false;\r\n            return;\r\n        }\r\n        return injectHook(target, hookName, fn);\r\n    };\r\n}\r\nfunction formatName(name) {\r\n    if (name === 'beforeDestroy') {\r\n        name = 'beforeUnmount';\r\n    }\r\n    else if (name === 'destroyed') {\r\n        name = 'unmounted';\r\n    }\r\n    return \"on\".concat(name[0].toUpperCase() + name.slice(1));\r\n}\r\nfunction injectHook(instance, hookName, fn) {\r\n    var options = instance.$options;\r\n    options[hookName] = mergeLifecycleHook(options[hookName], fn);\r\n}\r\nvar onBeforeMount = createLifeCycle('beforeMount');\r\nvar onMounted = createLifeCycle('mounted');\r\nvar onBeforeUpdate = createLifeCycle('beforeUpdate');\r\nvar onUpdated = createLifeCycle('updated');\r\nvar onBeforeUnmount = createLifeCycle('beforeDestroy');\r\nvar onUnmounted = createLifeCycle('destroyed');\r\nvar onActivated = createLifeCycle('activated');\r\nvar onDeactivated = createLifeCycle('deactivated');\r\nvar onServerPrefetch = createLifeCycle('serverPrefetch');\r\nvar onRenderTracked = createLifeCycle('renderTracked');\r\nvar onRenderTriggered = createLifeCycle('renderTriggered');\r\nvar injectErrorCapturedHook = createLifeCycle('errorCaptured');\r\nfunction onErrorCaptured(hook, target) {\r\n    if (target === void 0) { target = currentInstance; }\r\n    injectErrorCapturedHook(hook, target);\r\n}\n\n/**\r\n * Note: also update dist/vue.runtime.mjs when adding new exports to this file.\r\n */\r\nvar version = '2.7.9';\r\n/**\r\n * @internal type is manually declared in <root>/types/v3-define-component.d.ts\r\n */\r\nfunction defineComponent(options) {\r\n    return options;\r\n}\n\nvar seenObjects = new _Set();\r\n/**\r\n * Recursively traverse an object to evoke all converted\r\n * getters, so that every nested property inside the object\r\n * is collected as a \"deep\" dependency.\r\n */\r\nfunction traverse(val) {\r\n    _traverse(val, seenObjects);\r\n    seenObjects.clear();\r\n    return val;\r\n}\r\nfunction _traverse(val, seen) {\r\n    var i, keys;\r\n    var isA = isArray(val);\r\n    if ((!isA && !isObject(val)) ||\r\n        Object.isFrozen(val) ||\r\n        val instanceof VNode) {\r\n        return;\r\n    }\r\n    if (val.__ob__) {\r\n        var depId = val.__ob__.dep.id;\r\n        if (seen.has(depId)) {\r\n            return;\r\n        }\r\n        seen.add(depId);\r\n    }\r\n    if (isA) {\r\n        i = val.length;\r\n        while (i--)\r\n            _traverse(val[i], seen);\r\n    }\r\n    else if (isRef(val)) {\r\n        _traverse(val.value, seen);\r\n    }\r\n    else {\r\n        keys = Object.keys(val);\r\n        i = keys.length;\r\n        while (i--)\r\n            _traverse(val[keys[i]], seen);\r\n    }\r\n}\n\nvar uid$1 = 0;\r\n/**\r\n * A watcher parses an expression, collects dependencies,\r\n * and fires callback when the expression value changes.\r\n * This is used for both the $watch() api and directives.\r\n * @internal\r\n */\r\nvar Watcher = /** @class */ (function () {\r\n    function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\r\n        recordEffectScope(this, \r\n        // if the active effect scope is manually created (not a component scope),\r\n        // prioritize it\r\n        activeEffectScope && !activeEffectScope._vm\r\n            ? activeEffectScope\r\n            : vm\r\n                ? vm._scope\r\n                : undefined);\r\n        if ((this.vm = vm) && isRenderWatcher) {\r\n            vm._watcher = this;\r\n        }\r\n        // options\r\n        if (options) {\r\n            this.deep = !!options.deep;\r\n            this.user = !!options.user;\r\n            this.lazy = !!options.lazy;\r\n            this.sync = !!options.sync;\r\n            this.before = options.before;\r\n            if (false) {}\r\n        }\r\n        else {\r\n            this.deep = this.user = this.lazy = this.sync = false;\r\n        }\r\n        this.cb = cb;\r\n        this.id = ++uid$1; // uid for batching\r\n        this.active = true;\r\n        this.post = false;\r\n        this.dirty = this.lazy; // for lazy watchers\r\n        this.deps = [];\r\n        this.newDeps = [];\r\n        this.depIds = new _Set();\r\n        this.newDepIds = new _Set();\r\n        this.expression =  false ? undefined : '';\r\n        // parse expression for getter\r\n        if (isFunction(expOrFn)) {\r\n            this.getter = expOrFn;\r\n        }\r\n        else {\r\n            this.getter = parsePath(expOrFn);\r\n            if (!this.getter) {\r\n                this.getter = noop;\r\n                 false &&\r\n                    false;\r\n            }\r\n        }\r\n        this.value = this.lazy ? undefined : this.get();\r\n    }\r\n    /**\r\n     * Evaluate the getter, and re-collect dependencies.\r\n     */\r\n    Watcher.prototype.get = function () {\r\n        pushTarget(this);\r\n        var value;\r\n        var vm = this.vm;\r\n        try {\r\n            value = this.getter.call(vm, vm);\r\n        }\r\n        catch (e) {\r\n            if (this.user) {\r\n                handleError(e, vm, \"getter for watcher \\\"\".concat(this.expression, \"\\\"\"));\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        finally {\r\n            // \"touch\" every property so they are all tracked as\r\n            // dependencies for deep watching\r\n            if (this.deep) {\r\n                traverse(value);\r\n            }\r\n            popTarget();\r\n            this.cleanupDeps();\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * Add a dependency to this directive.\r\n     */\r\n    Watcher.prototype.addDep = function (dep) {\r\n        var id = dep.id;\r\n        if (!this.newDepIds.has(id)) {\r\n            this.newDepIds.add(id);\r\n            this.newDeps.push(dep);\r\n            if (!this.depIds.has(id)) {\r\n                dep.addSub(this);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Clean up for dependency collection.\r\n     */\r\n    Watcher.prototype.cleanupDeps = function () {\r\n        var i = this.deps.length;\r\n        while (i--) {\r\n            var dep = this.deps[i];\r\n            if (!this.newDepIds.has(dep.id)) {\r\n                dep.removeSub(this);\r\n            }\r\n        }\r\n        var tmp = this.depIds;\r\n        this.depIds = this.newDepIds;\r\n        this.newDepIds = tmp;\r\n        this.newDepIds.clear();\r\n        tmp = this.deps;\r\n        this.deps = this.newDeps;\r\n        this.newDeps = tmp;\r\n        this.newDeps.length = 0;\r\n    };\r\n    /**\r\n     * Subscriber interface.\r\n     * Will be called when a dependency changes.\r\n     */\r\n    Watcher.prototype.update = function () {\r\n        /* istanbul ignore else */\r\n        if (this.lazy) {\r\n            this.dirty = true;\r\n        }\r\n        else if (this.sync) {\r\n            this.run();\r\n        }\r\n        else {\r\n            queueWatcher(this);\r\n        }\r\n    };\r\n    /**\r\n     * Scheduler job interface.\r\n     * Will be called by the scheduler.\r\n     */\r\n    Watcher.prototype.run = function () {\r\n        if (this.active) {\r\n            var value = this.get();\r\n            if (value !== this.value ||\r\n                // Deep watchers and watchers on Object/Arrays should fire even\r\n                // when the value is the same, because the value may\r\n                // have mutated.\r\n                isObject(value) ||\r\n                this.deep) {\r\n                // set new value\r\n                var oldValue = this.value;\r\n                this.value = value;\r\n                if (this.user) {\r\n                    var info = \"callback for watcher \\\"\".concat(this.expression, \"\\\"\");\r\n                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\r\n                }\r\n                else {\r\n                    this.cb.call(this.vm, value, oldValue);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Evaluate the value of the watcher.\r\n     * This only gets called for lazy watchers.\r\n     */\r\n    Watcher.prototype.evaluate = function () {\r\n        this.value = this.get();\r\n        this.dirty = false;\r\n    };\r\n    /**\r\n     * Depend on all deps collected by this watcher.\r\n     */\r\n    Watcher.prototype.depend = function () {\r\n        var i = this.deps.length;\r\n        while (i--) {\r\n            this.deps[i].depend();\r\n        }\r\n    };\r\n    /**\r\n     * Remove self from all dependencies' subscriber list.\r\n     */\r\n    Watcher.prototype.teardown = function () {\r\n        if (this.vm && !this.vm._isBeingDestroyed) {\r\n            remove$2(this.vm._scope.effects, this);\r\n        }\r\n        if (this.active) {\r\n            var i = this.deps.length;\r\n            while (i--) {\r\n                this.deps[i].removeSub(this);\r\n            }\r\n            this.active = false;\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n        }\r\n    };\r\n    return Watcher;\r\n}());\n\nvar mark;\r\nvar measure;\r\nif (false) { var perf_1; }\n\nfunction initEvents(vm) {\r\n    vm._events = Object.create(null);\r\n    vm._hasHookEvent = false;\r\n    // init parent attached events\r\n    var listeners = vm.$options._parentListeners;\r\n    if (listeners) {\r\n        updateComponentListeners(vm, listeners);\r\n    }\r\n}\r\nvar target$1;\r\nfunction add$1(event, fn) {\r\n    target$1.$on(event, fn);\r\n}\r\nfunction remove$1(event, fn) {\r\n    target$1.$off(event, fn);\r\n}\r\nfunction createOnceHandler$1(event, fn) {\r\n    var _target = target$1;\r\n    return function onceHandler() {\r\n        var res = fn.apply(null, arguments);\r\n        if (res !== null) {\r\n            _target.$off(event, onceHandler);\r\n        }\r\n    };\r\n}\r\nfunction updateComponentListeners(vm, listeners, oldListeners) {\r\n    target$1 = vm;\r\n    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);\r\n    target$1 = undefined;\r\n}\r\nfunction eventsMixin(Vue) {\r\n    var hookRE = /^hook:/;\r\n    Vue.prototype.$on = function (event, fn) {\r\n        var vm = this;\r\n        if (isArray(event)) {\r\n            for (var i = 0, l = event.length; i < l; i++) {\r\n                vm.$on(event[i], fn);\r\n            }\r\n        }\r\n        else {\r\n            (vm._events[event] || (vm._events[event] = [])).push(fn);\r\n            // optimize hook:event cost by using a boolean flag marked at registration\r\n            // instead of a hash lookup\r\n            if (hookRE.test(event)) {\r\n                vm._hasHookEvent = true;\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n    Vue.prototype.$once = function (event, fn) {\r\n        var vm = this;\r\n        function on() {\r\n            vm.$off(event, on);\r\n            fn.apply(vm, arguments);\r\n        }\r\n        on.fn = fn;\r\n        vm.$on(event, on);\r\n        return vm;\r\n    };\r\n    Vue.prototype.$off = function (event, fn) {\r\n        var vm = this;\r\n        // all\r\n        if (!arguments.length) {\r\n            vm._events = Object.create(null);\r\n            return vm;\r\n        }\r\n        // array of events\r\n        if (isArray(event)) {\r\n            for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {\r\n                vm.$off(event[i_1], fn);\r\n            }\r\n            return vm;\r\n        }\r\n        // specific event\r\n        var cbs = vm._events[event];\r\n        if (!cbs) {\r\n            return vm;\r\n        }\r\n        if (!fn) {\r\n            vm._events[event] = null;\r\n            return vm;\r\n        }\r\n        // specific handler\r\n        var cb;\r\n        var i = cbs.length;\r\n        while (i--) {\r\n            cb = cbs[i];\r\n            if (cb === fn || cb.fn === fn) {\r\n                cbs.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n    Vue.prototype.$emit = function (event) {\r\n        var vm = this;\r\n        if (false) { var lowerCaseEvent; }\r\n        var cbs = vm._events[event];\r\n        if (cbs) {\r\n            cbs = cbs.length > 1 ? toArray(cbs) : cbs;\r\n            var args = toArray(arguments, 1);\r\n            var info = \"event handler for \\\"\".concat(event, \"\\\"\");\r\n            for (var i = 0, l = cbs.length; i < l; i++) {\r\n                invokeWithErrorHandling(cbs[i], vm, args, vm, info);\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n}\n\nvar activeInstance = null;\r\nvar isUpdatingChildComponent = false;\r\nfunction setActiveInstance(vm) {\r\n    var prevActiveInstance = activeInstance;\r\n    activeInstance = vm;\r\n    return function () {\r\n        activeInstance = prevActiveInstance;\r\n    };\r\n}\r\nfunction initLifecycle(vm) {\r\n    var options = vm.$options;\r\n    // locate first non-abstract parent\r\n    var parent = options.parent;\r\n    if (parent && !options.abstract) {\r\n        while (parent.$options.abstract && parent.$parent) {\r\n            parent = parent.$parent;\r\n        }\r\n        parent.$children.push(vm);\r\n    }\r\n    vm.$parent = parent;\r\n    vm.$root = parent ? parent.$root : vm;\r\n    vm.$children = [];\r\n    vm.$refs = {};\r\n    vm._provided = parent ? parent._provided : Object.create(null);\r\n    vm._watcher = null;\r\n    vm._inactive = null;\r\n    vm._directInactive = false;\r\n    vm._isMounted = false;\r\n    vm._isDestroyed = false;\r\n    vm._isBeingDestroyed = false;\r\n}\r\nfunction lifecycleMixin(Vue) {\r\n    Vue.prototype._update = function (vnode, hydrating) {\r\n        var vm = this;\r\n        var prevEl = vm.$el;\r\n        var prevVnode = vm._vnode;\r\n        var restoreActiveInstance = setActiveInstance(vm);\r\n        vm._vnode = vnode;\r\n        // Vue.prototype.__patch__ is injected in entry points\r\n        // based on the rendering backend used.\r\n        if (!prevVnode) {\r\n            // initial render\r\n            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\r\n        }\r\n        else {\r\n            // updates\r\n            vm.$el = vm.__patch__(prevVnode, vnode);\r\n        }\r\n        restoreActiveInstance();\r\n        // update __vue__ reference\r\n        if (prevEl) {\r\n            prevEl.__vue__ = null;\r\n        }\r\n        if (vm.$el) {\r\n            vm.$el.__vue__ = vm;\r\n        }\r\n        // if parent is an HOC, update its $el as well\r\n        if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\r\n            vm.$parent.$el = vm.$el;\r\n        }\r\n        // updated hook is called by the scheduler to ensure that children are\r\n        // updated in a parent's updated hook.\r\n    };\r\n    Vue.prototype.$forceUpdate = function () {\r\n        var vm = this;\r\n        if (vm._watcher) {\r\n            vm._watcher.update();\r\n        }\r\n    };\r\n    Vue.prototype.$destroy = function () {\r\n        var vm = this;\r\n        if (vm._isBeingDestroyed) {\r\n            return;\r\n        }\r\n        callHook$1(vm, 'beforeDestroy');\r\n        vm._isBeingDestroyed = true;\r\n        // remove self from parent\r\n        var parent = vm.$parent;\r\n        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\r\n            remove$2(parent.$children, vm);\r\n        }\r\n        // teardown scope. this includes both the render watcher and other\r\n        // watchers created\r\n        vm._scope.stop();\r\n        // remove reference from data ob\r\n        // frozen object may not have observer.\r\n        if (vm._data.__ob__) {\r\n            vm._data.__ob__.vmCount--;\r\n        }\r\n        // call the last hook...\r\n        vm._isDestroyed = true;\r\n        // invoke destroy hooks on current rendered tree\r\n        vm.__patch__(vm._vnode, null);\r\n        // fire destroyed hook\r\n        callHook$1(vm, 'destroyed');\r\n        // turn off all instance listeners.\r\n        vm.$off();\r\n        // remove __vue__ reference\r\n        if (vm.$el) {\r\n            vm.$el.__vue__ = null;\r\n        }\r\n        // release circular reference (#6759)\r\n        if (vm.$vnode) {\r\n            vm.$vnode.parent = null;\r\n        }\r\n    };\r\n}\r\nfunction mountComponent(vm, el, hydrating) {\r\n    vm.$el = el;\r\n    if (!vm.$options.render) {\r\n        // @ts-expect-error invalid type\r\n        vm.$options.render = createEmptyVNode;\r\n        if (false) {}\r\n    }\r\n    callHook$1(vm, 'beforeMount');\r\n    var updateComponent;\r\n    /* istanbul ignore if */\r\n    if (false) {}\r\n    else {\r\n        updateComponent = function () {\r\n            vm._update(vm._render(), hydrating);\r\n        };\r\n    }\r\n    var watcherOptions = {\r\n        before: function () {\r\n            if (vm._isMounted && !vm._isDestroyed) {\r\n                callHook$1(vm, 'beforeUpdate');\r\n            }\r\n        }\r\n    };\r\n    if (false) {}\r\n    // we set this to vm._watcher inside the watcher's constructor\r\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\r\n    // component's mounted hook), which relies on vm._watcher being already defined\r\n    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);\r\n    hydrating = false;\r\n    // flush buffer for flush: \"pre\" watchers queued in setup()\r\n    var preWatchers = vm._preWatchers;\r\n    if (preWatchers) {\r\n        for (var i = 0; i < preWatchers.length; i++) {\r\n            preWatchers[i].run();\r\n        }\r\n    }\r\n    // manually mounted instance, call mounted on self\r\n    // mounted is called for render-created child components in its inserted hook\r\n    if (vm.$vnode == null) {\r\n        vm._isMounted = true;\r\n        callHook$1(vm, 'mounted');\r\n    }\r\n    return vm;\r\n}\r\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\r\n    if (false) {}\r\n    // determine whether component has slot children\r\n    // we need to do this before overwriting $options._renderChildren.\r\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\r\n    // dynamic slot names). Static scoped slots compiled from template has the\r\n    // \"$stable\" marker.\r\n    var newScopedSlots = parentVnode.data.scopedSlots;\r\n    var oldScopedSlots = vm.$scopedSlots;\r\n    var hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||\r\n        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\r\n        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||\r\n        (!newScopedSlots && vm.$scopedSlots.$key));\r\n    // Any static slot children from the parent may have changed during parent's\r\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\r\n    // update is necessary to ensure correctness.\r\n    var needsForceUpdate = !!(renderChildren || // has new static slots\r\n        vm.$options._renderChildren || // has old static slots\r\n        hasDynamicScopedSlot);\r\n    var prevVNode = vm.$vnode;\r\n    vm.$options._parentVnode = parentVnode;\r\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\r\n    if (vm._vnode) {\r\n        // update child tree's parent\r\n        vm._vnode.parent = parentVnode;\r\n    }\r\n    vm.$options._renderChildren = renderChildren;\r\n    // update $attrs and $listeners hash\r\n    // these are also reactive so they may trigger child update if the child\r\n    // used them during render\r\n    var attrs = parentVnode.data.attrs || emptyObject;\r\n    if (vm._attrsProxy) {\r\n        // force update if attrs are accessed and has changed since it may be\r\n        // passed to a child component.\r\n        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {\r\n            needsForceUpdate = true;\r\n        }\r\n    }\r\n    vm.$attrs = attrs;\r\n    // update listeners\r\n    listeners = listeners || emptyObject;\r\n    var prevListeners = vm.$options._parentListeners;\r\n    if (vm._listenersProxy) {\r\n        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');\r\n    }\r\n    vm.$listeners = vm.$options._parentListeners = listeners;\r\n    updateComponentListeners(vm, listeners, prevListeners);\r\n    // update props\r\n    if (propsData && vm.$options.props) {\r\n        toggleObserving(false);\r\n        var props = vm._props;\r\n        var propKeys = vm.$options._propKeys || [];\r\n        for (var i = 0; i < propKeys.length; i++) {\r\n            var key = propKeys[i];\r\n            var propOptions = vm.$options.props; // wtf flow?\r\n            props[key] = validateProp(key, propOptions, propsData, vm);\r\n        }\r\n        toggleObserving(true);\r\n        // keep a copy of raw propsData\r\n        vm.$options.propsData = propsData;\r\n    }\r\n    // resolve slots + force update if has children\r\n    if (needsForceUpdate) {\r\n        vm.$slots = resolveSlots(renderChildren, parentVnode.context);\r\n        vm.$forceUpdate();\r\n    }\r\n    if (false) {}\r\n}\r\nfunction isInInactiveTree(vm) {\r\n    while (vm && (vm = vm.$parent)) {\r\n        if (vm._inactive)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction activateChildComponent(vm, direct) {\r\n    if (direct) {\r\n        vm._directInactive = false;\r\n        if (isInInactiveTree(vm)) {\r\n            return;\r\n        }\r\n    }\r\n    else if (vm._directInactive) {\r\n        return;\r\n    }\r\n    if (vm._inactive || vm._inactive === null) {\r\n        vm._inactive = false;\r\n        for (var i = 0; i < vm.$children.length; i++) {\r\n            activateChildComponent(vm.$children[i]);\r\n        }\r\n        callHook$1(vm, 'activated');\r\n    }\r\n}\r\nfunction deactivateChildComponent(vm, direct) {\r\n    if (direct) {\r\n        vm._directInactive = true;\r\n        if (isInInactiveTree(vm)) {\r\n            return;\r\n        }\r\n    }\r\n    if (!vm._inactive) {\r\n        vm._inactive = true;\r\n        for (var i = 0; i < vm.$children.length; i++) {\r\n            deactivateChildComponent(vm.$children[i]);\r\n        }\r\n        callHook$1(vm, 'deactivated');\r\n    }\r\n}\r\nfunction callHook$1(vm, hook, args, setContext) {\r\n    if (setContext === void 0) { setContext = true; }\r\n    // #7573 disable dep collection when invoking lifecycle hooks\r\n    pushTarget();\r\n    var prev = currentInstance;\r\n    setContext && setCurrentInstance(vm);\r\n    var handlers = vm.$options[hook];\r\n    var info = \"\".concat(hook, \" hook\");\r\n    if (handlers) {\r\n        for (var i = 0, j = handlers.length; i < j; i++) {\r\n            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);\r\n        }\r\n    }\r\n    if (vm._hasHookEvent) {\r\n        vm.$emit('hook:' + hook);\r\n    }\r\n    setContext && setCurrentInstance(prev);\r\n    popTarget();\r\n}\n\nvar MAX_UPDATE_COUNT = 100;\r\nvar queue = [];\r\nvar activatedChildren = [];\r\nvar has = {};\r\nvar circular = {};\r\nvar waiting = false;\r\nvar flushing = false;\r\nvar index = 0;\r\n/**\r\n * Reset the scheduler's state.\r\n */\r\nfunction resetSchedulerState() {\r\n    index = queue.length = activatedChildren.length = 0;\r\n    has = {};\r\n    if (false) {}\r\n    waiting = flushing = false;\r\n}\r\n// Async edge case #6566 requires saving the timestamp when event listeners are\r\n// attached. However, calling performance.now() has a perf overhead especially\r\n// if the page has thousands of event listeners. Instead, we take a timestamp\r\n// every time the scheduler flushes and use that for all event listeners\r\n// attached during that flush.\r\nvar currentFlushTimestamp = 0;\r\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nvar getNow = Date.now;\r\n// Determine what event timestamp the browser is using. Annoyingly, the\r\n// timestamp can either be hi-res (relative to page load) or low-res\r\n// (relative to UNIX epoch), so in order to compare time we have to use the\r\n// same timestamp type when saving the flush timestamp.\r\n// All IE versions use low-res event timestamps, and have problematic clock\r\n// implementations (#9632)\r\nif (inBrowser && !isIE) {\r\n    var performance_1 = window.performance;\r\n    if (performance_1 &&\r\n        typeof performance_1.now === 'function' &&\r\n        getNow() > document.createEvent('Event').timeStamp) {\r\n        // if the event timestamp, although evaluated AFTER the Date.now(), is\r\n        // smaller than it, it means the event is using a hi-res timestamp,\r\n        // and we need to use the hi-res version for event listener timestamps as\r\n        // well.\r\n        getNow = function () { return performance_1.now(); };\r\n    }\r\n}\r\nvar sortCompareFn = function (a, b) {\r\n    if (a.post) {\r\n        if (!b.post)\r\n            return 1;\r\n    }\r\n    else if (b.post) {\r\n        return -1;\r\n    }\r\n    return a.id - b.id;\r\n};\r\n/**\r\n * Flush both queues and run the watchers.\r\n */\r\nfunction flushSchedulerQueue() {\r\n    currentFlushTimestamp = getNow();\r\n    flushing = true;\r\n    var watcher, id;\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child)\r\n    // 2. A component's user watchers are run before its render watcher (because\r\n    //    user watchers are created before the render watcher)\r\n    // 3. If a component is destroyed during a parent component's watcher run,\r\n    //    its watchers can be skipped.\r\n    queue.sort(sortCompareFn);\r\n    // do not cache length because more watchers might be pushed\r\n    // as we run existing watchers\r\n    for (index = 0; index < queue.length; index++) {\r\n        watcher = queue[index];\r\n        if (watcher.before) {\r\n            watcher.before();\r\n        }\r\n        id = watcher.id;\r\n        has[id] = null;\r\n        watcher.run();\r\n        // in dev build, check and stop circular updates.\r\n        if (false) {}\r\n    }\r\n    // keep copies of post queues before resetting state\r\n    var activatedQueue = activatedChildren.slice();\r\n    var updatedQueue = queue.slice();\r\n    resetSchedulerState();\r\n    // call component updated and activated hooks\r\n    callActivatedHooks(activatedQueue);\r\n    callUpdatedHooks(updatedQueue);\r\n    // devtool hook\r\n    /* istanbul ignore if */\r\n    if (devtools && config.devtools) {\r\n        devtools.emit('flush');\r\n    }\r\n}\r\nfunction callUpdatedHooks(queue) {\r\n    var i = queue.length;\r\n    while (i--) {\r\n        var watcher = queue[i];\r\n        var vm = watcher.vm;\r\n        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\r\n            callHook$1(vm, 'updated');\r\n        }\r\n    }\r\n}\r\n/**\r\n * Queue a kept-alive component that was activated during patch.\r\n * The queue will be processed after the entire tree has been patched.\r\n */\r\nfunction queueActivatedComponent(vm) {\r\n    // setting _inactive to false here so that a render function can\r\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\r\n    vm._inactive = false;\r\n    activatedChildren.push(vm);\r\n}\r\nfunction callActivatedHooks(queue) {\r\n    for (var i = 0; i < queue.length; i++) {\r\n        queue[i]._inactive = true;\r\n        activateChildComponent(queue[i], true /* true */);\r\n    }\r\n}\r\n/**\r\n * Push a watcher into the watcher queue.\r\n * Jobs with duplicate IDs will be skipped unless it's\r\n * pushed when the queue is being flushed.\r\n */\r\nfunction queueWatcher(watcher) {\r\n    var id = watcher.id;\r\n    if (has[id] != null) {\r\n        return;\r\n    }\r\n    if (watcher === Dep.target && watcher.noRecurse) {\r\n        return;\r\n    }\r\n    has[id] = true;\r\n    if (!flushing) {\r\n        queue.push(watcher);\r\n    }\r\n    else {\r\n        // if already flushing, splice the watcher based on its id\r\n        // if already past its id, it will be run next immediately.\r\n        var i = queue.length - 1;\r\n        while (i > index && queue[i].id > watcher.id) {\r\n            i--;\r\n        }\r\n        queue.splice(i + 1, 0, watcher);\r\n    }\r\n    // queue the flush\r\n    if (!waiting) {\r\n        waiting = true;\r\n        if (false) {}\r\n        nextTick(flushSchedulerQueue);\r\n    }\r\n}\n\nfunction initProvide(vm) {\r\n    var provideOption = vm.$options.provide;\r\n    if (provideOption) {\r\n        var provided = isFunction(provideOption)\r\n            ? provideOption.call(vm)\r\n            : provideOption;\r\n        if (!isObject(provided)) {\r\n            return;\r\n        }\r\n        var source = resolveProvided(vm);\r\n        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to\r\n        // iterate the keys ourselves.\r\n        var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));\r\n        }\r\n    }\r\n}\r\nfunction initInjections(vm) {\r\n    var result = resolveInject(vm.$options.inject, vm);\r\n    if (result) {\r\n        toggleObserving(false);\r\n        Object.keys(result).forEach(function (key) {\r\n            /* istanbul ignore else */\r\n            if (false) {}\r\n            else {\r\n                defineReactive(vm, key, result[key]);\r\n            }\r\n        });\r\n        toggleObserving(true);\r\n    }\r\n}\r\nfunction resolveInject(inject, vm) {\r\n    if (inject) {\r\n        // inject is :any because flow is not smart enough to figure out cached\r\n        var result = Object.create(null);\r\n        var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            // #6574 in case the inject object is observed...\r\n            if (key === '__ob__')\r\n                continue;\r\n            var provideKey = inject[key].from;\r\n            if (provideKey in vm._provided) {\r\n                result[key] = vm._provided[provideKey];\r\n            }\r\n            else if ('default' in inject[key]) {\r\n                var provideDefault = inject[key].default;\r\n                result[key] = isFunction(provideDefault)\r\n                    ? provideDefault.call(vm)\r\n                    : provideDefault;\r\n            }\r\n            else if (false) {}\r\n        }\r\n        return result;\r\n    }\r\n}\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\r\n    var _this = this;\r\n    var options = Ctor.options;\r\n    // ensure the createElement function in functional components\r\n    // gets a unique context - this is necessary for correct named slot check\r\n    var contextVm;\r\n    if (hasOwn(parent, '_uid')) {\r\n        contextVm = Object.create(parent);\r\n        contextVm._original = parent;\r\n    }\r\n    else {\r\n        // the context vm passed in is a functional context as well.\r\n        // in this case we want to make sure we are able to get a hold to the\r\n        // real context instance.\r\n        contextVm = parent;\r\n        // @ts-ignore\r\n        parent = parent._original;\r\n    }\r\n    var isCompiled = isTrue(options._compiled);\r\n    var needNormalization = !isCompiled;\r\n    this.data = data;\r\n    this.props = props;\r\n    this.children = children;\r\n    this.parent = parent;\r\n    this.listeners = data.on || emptyObject;\r\n    this.injections = resolveInject(options.inject, parent);\r\n    this.slots = function () {\r\n        if (!_this.$slots) {\r\n            normalizeScopedSlots(parent, data.scopedSlots, (_this.$slots = resolveSlots(children, parent)));\r\n        }\r\n        return _this.$slots;\r\n    };\r\n    Object.defineProperty(this, 'scopedSlots', {\r\n        enumerable: true,\r\n        get: function () {\r\n            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());\r\n        }\r\n    });\r\n    // support for compiled functional template\r\n    if (isCompiled) {\r\n        // exposing $options for renderStatic()\r\n        this.$options = options;\r\n        // pre-resolve slots for renderSlot()\r\n        this.$slots = this.slots();\r\n        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);\r\n    }\r\n    if (options._scopeId) {\r\n        this._c = function (a, b, c, d) {\r\n            var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);\r\n            if (vnode && !isArray(vnode)) {\r\n                vnode.fnScopeId = options._scopeId;\r\n                vnode.fnContext = parent;\r\n            }\r\n            return vnode;\r\n        };\r\n    }\r\n    else {\r\n        this._c = function (a, b, c, d) {\r\n            return createElement$1(contextVm, a, b, c, d, needNormalization);\r\n        };\r\n    }\r\n}\r\ninstallRenderHelpers(FunctionalRenderContext.prototype);\r\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\r\n    var options = Ctor.options;\r\n    var props = {};\r\n    var propOptions = options.props;\r\n    if (isDef(propOptions)) {\r\n        for (var key in propOptions) {\r\n            props[key] = validateProp(key, propOptions, propsData || emptyObject);\r\n        }\r\n    }\r\n    else {\r\n        if (isDef(data.attrs))\r\n            mergeProps(props, data.attrs);\r\n        if (isDef(data.props))\r\n            mergeProps(props, data.props);\r\n    }\r\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\r\n    var vnode = options.render.call(null, renderContext._c, renderContext);\r\n    if (vnode instanceof VNode) {\r\n        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\r\n    }\r\n    else if (isArray(vnode)) {\r\n        var vnodes = normalizeChildren(vnode) || [];\r\n        var res = new Array(vnodes.length);\r\n        for (var i = 0; i < vnodes.length; i++) {\r\n            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\r\n        }\r\n        return res;\r\n    }\r\n}\r\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\r\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\r\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\r\n    // that should not be matched to match.\r\n    var clone = cloneVNode(vnode);\r\n    clone.fnContext = contextVm;\r\n    clone.fnOptions = options;\r\n    if (false) {}\r\n    if (data.slot) {\r\n        (clone.data || (clone.data = {})).slot = data.slot;\r\n    }\r\n    return clone;\r\n}\r\nfunction mergeProps(to, from) {\r\n    for (var key in from) {\r\n        to[camelize(key)] = from[key];\r\n    }\r\n}\n\nfunction getComponentName(options) {\r\n    return options.name || options.__name || options._componentTag;\r\n}\r\n// inline hooks to be invoked on component VNodes during patch\r\nvar componentVNodeHooks = {\r\n    init: function (vnode, hydrating) {\r\n        if (vnode.componentInstance &&\r\n            !vnode.componentInstance._isDestroyed &&\r\n            vnode.data.keepAlive) {\r\n            // kept-alive components, treat as a patch\r\n            var mountedNode = vnode; // work around flow\r\n            componentVNodeHooks.prepatch(mountedNode, mountedNode);\r\n        }\r\n        else {\r\n            var child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));\r\n            child.$mount(hydrating ? vnode.elm : undefined, hydrating);\r\n        }\r\n    },\r\n    prepatch: function (oldVnode, vnode) {\r\n        var options = vnode.componentOptions;\r\n        var child = (vnode.componentInstance = oldVnode.componentInstance);\r\n        updateChildComponent(child, options.propsData, // updated props\r\n        options.listeners, // updated listeners\r\n        vnode, // new parent vnode\r\n        options.children // new children\r\n        );\r\n    },\r\n    insert: function (vnode) {\r\n        var context = vnode.context, componentInstance = vnode.componentInstance;\r\n        if (!componentInstance._isMounted) {\r\n            componentInstance._isMounted = true;\r\n            callHook$1(componentInstance, 'mounted');\r\n        }\r\n        if (vnode.data.keepAlive) {\r\n            if (context._isMounted) {\r\n                // vue-router#1212\r\n                // During updates, a kept-alive component's child components may\r\n                // change, so directly walking the tree here may call activated hooks\r\n                // on incorrect children. Instead we push them into a queue which will\r\n                // be processed after the whole patch process ended.\r\n                queueActivatedComponent(componentInstance);\r\n            }\r\n            else {\r\n                activateChildComponent(componentInstance, true /* direct */);\r\n            }\r\n        }\r\n    },\r\n    destroy: function (vnode) {\r\n        var componentInstance = vnode.componentInstance;\r\n        if (!componentInstance._isDestroyed) {\r\n            if (!vnode.data.keepAlive) {\r\n                componentInstance.$destroy();\r\n            }\r\n            else {\r\n                deactivateChildComponent(componentInstance, true /* direct */);\r\n            }\r\n        }\r\n    }\r\n};\r\nvar hooksToMerge = Object.keys(componentVNodeHooks);\r\nfunction createComponent(Ctor, data, context, children, tag) {\r\n    if (isUndef(Ctor)) {\r\n        return;\r\n    }\r\n    var baseCtor = context.$options._base;\r\n    // plain options object: turn it into a constructor\r\n    if (isObject(Ctor)) {\r\n        Ctor = baseCtor.extend(Ctor);\r\n    }\r\n    // if at this stage it's not a constructor or an async component factory,\r\n    // reject.\r\n    if (typeof Ctor !== 'function') {\r\n        if (false) {}\r\n        return;\r\n    }\r\n    // async component\r\n    var asyncFactory;\r\n    // @ts-expect-error\r\n    if (isUndef(Ctor.cid)) {\r\n        asyncFactory = Ctor;\r\n        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\r\n        if (Ctor === undefined) {\r\n            // return a placeholder node for async component, which is rendered\r\n            // as a comment node but preserves all the raw information for the node.\r\n            // the information will be used for async server-rendering and hydration.\r\n            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\r\n        }\r\n    }\r\n    data = data || {};\r\n    // resolve constructor options in case global mixins are applied after\r\n    // component constructor creation\r\n    resolveConstructorOptions(Ctor);\r\n    // transform component v-model data into props & events\r\n    if (isDef(data.model)) {\r\n        // @ts-expect-error\r\n        transformModel(Ctor.options, data);\r\n    }\r\n    // extract props\r\n    // @ts-expect-error\r\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\r\n    // functional component\r\n    // @ts-expect-error\r\n    if (isTrue(Ctor.options.functional)) {\r\n        return createFunctionalComponent(Ctor, propsData, data, context, children);\r\n    }\r\n    // extract listeners, since these needs to be treated as\r\n    // child component listeners instead of DOM listeners\r\n    var listeners = data.on;\r\n    // replace with listeners with .native modifier\r\n    // so it gets processed during parent component patch.\r\n    data.on = data.nativeOn;\r\n    // @ts-expect-error\r\n    if (isTrue(Ctor.options.abstract)) {\r\n        // abstract components do not keep anything\r\n        // other than props & listeners & slot\r\n        // work around flow\r\n        var slot = data.slot;\r\n        data = {};\r\n        if (slot) {\r\n            data.slot = slot;\r\n        }\r\n    }\r\n    // install component management hooks onto the placeholder node\r\n    installComponentHooks(data);\r\n    // return a placeholder vnode\r\n    // @ts-expect-error\r\n    var name = getComponentName(Ctor.options) || tag;\r\n    var vnode = new VNode(\r\n    // @ts-expect-error\r\n    \"vue-component-\".concat(Ctor.cid).concat(name ? \"-\".concat(name) : ''), data, undefined, undefined, undefined, context, \r\n    // @ts-expect-error\r\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);\r\n    return vnode;\r\n}\r\nfunction createComponentInstanceForVnode(\r\n// we know it's MountedComponentVNode but flow doesn't\r\nvnode, \r\n// activeInstance in lifecycle state\r\nparent) {\r\n    var options = {\r\n        _isComponent: true,\r\n        _parentVnode: vnode,\r\n        parent: parent\r\n    };\r\n    // check inline-template render functions\r\n    var inlineTemplate = vnode.data.inlineTemplate;\r\n    if (isDef(inlineTemplate)) {\r\n        options.render = inlineTemplate.render;\r\n        options.staticRenderFns = inlineTemplate.staticRenderFns;\r\n    }\r\n    return new vnode.componentOptions.Ctor(options);\r\n}\r\nfunction installComponentHooks(data) {\r\n    var hooks = data.hook || (data.hook = {});\r\n    for (var i = 0; i < hooksToMerge.length; i++) {\r\n        var key = hooksToMerge[i];\r\n        var existing = hooks[key];\r\n        var toMerge = componentVNodeHooks[key];\r\n        // @ts-expect-error\r\n        if (existing !== toMerge && !(existing && existing._merged)) {\r\n            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;\r\n        }\r\n    }\r\n}\r\nfunction mergeHook(f1, f2) {\r\n    var merged = function (a, b) {\r\n        // flow complains about extra args which is why we use any\r\n        f1(a, b);\r\n        f2(a, b);\r\n    };\r\n    merged._merged = true;\r\n    return merged;\r\n}\r\n// transform component v-model info (value and callback) into\r\n// prop and event handler respectively.\r\nfunction transformModel(options, data) {\r\n    var prop = (options.model && options.model.prop) || 'value';\r\n    var event = (options.model && options.model.event) || 'input';\r\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\r\n    var on = data.on || (data.on = {});\r\n    var existing = on[event];\r\n    var callback = data.model.callback;\r\n    if (isDef(existing)) {\r\n        if (isArray(existing)\r\n            ? existing.indexOf(callback) === -1\r\n            : existing !== callback) {\r\n            on[event] = [callback].concat(existing);\r\n        }\r\n    }\r\n    else {\r\n        on[event] = callback;\r\n    }\r\n}\n\nvar warn = noop;\r\nvar tip = noop;\r\nvar generateComponentTrace; // work around flow check\r\nvar formatComponentName;\r\nif (false) { var repeat_1, classify_1, classifyRE_1, hasConsole_1; }\n\n/**\r\n * Option overwriting strategies are functions that handle\r\n * how to merge a parent option value and a child option\r\n * value into the final value.\r\n */\r\nvar strats = config.optionMergeStrategies;\r\n/**\r\n * Options with restrictions\r\n */\r\nif (false) {}\r\n/**\r\n * Helper that recursively merges two data objects together.\r\n */\r\nfunction mergeData(to, from) {\r\n    if (!from)\r\n        return to;\r\n    var key, toVal, fromVal;\r\n    var keys = hasSymbol\r\n        ? Reflect.ownKeys(from)\r\n        : Object.keys(from);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        key = keys[i];\r\n        // in case the object is already observed...\r\n        if (key === '__ob__')\r\n            continue;\r\n        toVal = to[key];\r\n        fromVal = from[key];\r\n        if (!hasOwn(to, key)) {\r\n            set(to, key, fromVal);\r\n        }\r\n        else if (toVal !== fromVal &&\r\n            isPlainObject(toVal) &&\r\n            isPlainObject(fromVal)) {\r\n            mergeData(toVal, fromVal);\r\n        }\r\n    }\r\n    return to;\r\n}\r\n/**\r\n * Data\r\n */\r\nfunction mergeDataOrFn(parentVal, childVal, vm) {\r\n    if (!vm) {\r\n        // in a Vue.extend merge, both should be functions\r\n        if (!childVal) {\r\n            return parentVal;\r\n        }\r\n        if (!parentVal) {\r\n            return childVal;\r\n        }\r\n        // when parentVal & childVal are both present,\r\n        // we need to return a function that returns the\r\n        // merged result of both functions... no need to\r\n        // check if parentVal is a function here because\r\n        // it has to be a function to pass previous merges.\r\n        return function mergedDataFn() {\r\n            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);\r\n        };\r\n    }\r\n    else {\r\n        return function mergedInstanceDataFn() {\r\n            // instance merge\r\n            var instanceData = isFunction(childVal)\r\n                ? childVal.call(vm, vm)\r\n                : childVal;\r\n            var defaultData = isFunction(parentVal)\r\n                ? parentVal.call(vm, vm)\r\n                : parentVal;\r\n            if (instanceData) {\r\n                return mergeData(instanceData, defaultData);\r\n            }\r\n            else {\r\n                return defaultData;\r\n            }\r\n        };\r\n    }\r\n}\r\nstrats.data = function (parentVal, childVal, vm) {\r\n    if (!vm) {\r\n        if (childVal && typeof childVal !== 'function') {\r\n             false &&\r\n                false;\r\n            return parentVal;\r\n        }\r\n        return mergeDataOrFn(parentVal, childVal);\r\n    }\r\n    return mergeDataOrFn(parentVal, childVal, vm);\r\n};\r\n/**\r\n * Hooks and props are merged as arrays.\r\n */\r\nfunction mergeLifecycleHook(parentVal, childVal) {\r\n    var res = childVal\r\n        ? parentVal\r\n            ? parentVal.concat(childVal)\r\n            : isArray(childVal)\r\n                ? childVal\r\n                : [childVal]\r\n        : parentVal;\r\n    return res ? dedupeHooks(res) : res;\r\n}\r\nfunction dedupeHooks(hooks) {\r\n    var res = [];\r\n    for (var i = 0; i < hooks.length; i++) {\r\n        if (res.indexOf(hooks[i]) === -1) {\r\n            res.push(hooks[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nLIFECYCLE_HOOKS.forEach(function (hook) {\r\n    strats[hook] = mergeLifecycleHook;\r\n});\r\n/**\r\n * Assets\r\n *\r\n * When a vm is present (instance creation), we need to do\r\n * a three-way merge between constructor options, instance\r\n * options and parent options.\r\n */\r\nfunction mergeAssets(parentVal, childVal, vm, key) {\r\n    var res = Object.create(parentVal || null);\r\n    if (childVal) {\r\n         false && false;\r\n        return extend(res, childVal);\r\n    }\r\n    else {\r\n        return res;\r\n    }\r\n}\r\nASSET_TYPES.forEach(function (type) {\r\n    strats[type + 's'] = mergeAssets;\r\n});\r\n/**\r\n * Watchers.\r\n *\r\n * Watchers hashes should not overwrite one\r\n * another, so we merge them as arrays.\r\n */\r\nstrats.watch = function (parentVal, childVal, vm, key) {\r\n    // work around Firefox's Object.prototype.watch...\r\n    //@ts-expect-error work around\r\n    if (parentVal === nativeWatch)\r\n        parentVal = undefined;\r\n    //@ts-expect-error work around\r\n    if (childVal === nativeWatch)\r\n        childVal = undefined;\r\n    /* istanbul ignore if */\r\n    if (!childVal)\r\n        return Object.create(parentVal || null);\r\n    if (false) {}\r\n    if (!parentVal)\r\n        return childVal;\r\n    var ret = {};\r\n    extend(ret, parentVal);\r\n    for (var key_1 in childVal) {\r\n        var parent_1 = ret[key_1];\r\n        var child = childVal[key_1];\r\n        if (parent_1 && !isArray(parent_1)) {\r\n            parent_1 = [parent_1];\r\n        }\r\n        ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];\r\n    }\r\n    return ret;\r\n};\r\n/**\r\n * Other object hashes.\r\n */\r\nstrats.props =\r\n    strats.methods =\r\n        strats.inject =\r\n            strats.computed =\r\n                function (parentVal, childVal, vm, key) {\r\n                    if (childVal && \"production\" !== 'production') {\r\n                        assertObjectType(key, childVal, vm);\r\n                    }\r\n                    if (!parentVal)\r\n                        return childVal;\r\n                    var ret = Object.create(null);\r\n                    extend(ret, parentVal);\r\n                    if (childVal)\r\n                        extend(ret, childVal);\r\n                    return ret;\r\n                };\r\nstrats.provide = mergeDataOrFn;\r\n/**\r\n * Default strategy.\r\n */\r\nvar defaultStrat = function (parentVal, childVal) {\r\n    return childVal === undefined ? parentVal : childVal;\r\n};\r\n/**\r\n * Validate component names\r\n */\r\nfunction checkComponents(options) {\r\n    for (var key in options.components) {\r\n        validateComponentName(key);\r\n    }\r\n}\r\nfunction validateComponentName(name) {\r\n    if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\".concat(unicodeRegExp.source, \"]*$\")).test(name)) {\r\n        warn('Invalid component name: \"' +\r\n            name +\r\n            '\". Component names ' +\r\n            'should conform to valid custom element name in html5 specification.');\r\n    }\r\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\r\n        warn('Do not use built-in or reserved HTML elements as component ' +\r\n            'id: ' +\r\n            name);\r\n    }\r\n}\r\n/**\r\n * Ensure all props option syntax are normalized into the\r\n * Object-based format.\r\n */\r\nfunction normalizeProps(options, vm) {\r\n    var props = options.props;\r\n    if (!props)\r\n        return;\r\n    var res = {};\r\n    var i, val, name;\r\n    if (isArray(props)) {\r\n        i = props.length;\r\n        while (i--) {\r\n            val = props[i];\r\n            if (typeof val === 'string') {\r\n                name = camelize(val);\r\n                res[name] = { type: null };\r\n            }\r\n            else if (false) {}\r\n        }\r\n    }\r\n    else if (isPlainObject(props)) {\r\n        for (var key in props) {\r\n            val = props[key];\r\n            name = camelize(key);\r\n            res[name] = isPlainObject(val) ? val : { type: val };\r\n        }\r\n    }\r\n    else if (false) {}\r\n    options.props = res;\r\n}\r\n/**\r\n * Normalize all injections into Object-based format\r\n */\r\nfunction normalizeInject(options, vm) {\r\n    var inject = options.inject;\r\n    if (!inject)\r\n        return;\r\n    var normalized = (options.inject = {});\r\n    if (isArray(inject)) {\r\n        for (var i = 0; i < inject.length; i++) {\r\n            normalized[inject[i]] = { from: inject[i] };\r\n        }\r\n    }\r\n    else if (isPlainObject(inject)) {\r\n        for (var key in inject) {\r\n            var val = inject[key];\r\n            normalized[key] = isPlainObject(val)\r\n                ? extend({ from: key }, val)\r\n                : { from: val };\r\n        }\r\n    }\r\n    else if (false) {}\r\n}\r\n/**\r\n * Normalize raw function directives into object format.\r\n */\r\nfunction normalizeDirectives$1(options) {\r\n    var dirs = options.directives;\r\n    if (dirs) {\r\n        for (var key in dirs) {\r\n            var def = dirs[key];\r\n            if (isFunction(def)) {\r\n                dirs[key] = { bind: def, update: def };\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction assertObjectType(name, value, vm) {\r\n    if (!isPlainObject(value)) {\r\n        warn(\"Invalid value for option \\\"\".concat(name, \"\\\": expected an Object, \") +\r\n            \"but got \".concat(toRawType(value), \".\"), vm);\r\n    }\r\n}\r\n/**\r\n * Merge two option objects into a new one.\r\n * Core utility used in both instantiation and inheritance.\r\n */\r\nfunction mergeOptions(parent, child, vm) {\r\n    if (false) {}\r\n    if (isFunction(child)) {\r\n        // @ts-expect-error\r\n        child = child.options;\r\n    }\r\n    normalizeProps(child, vm);\r\n    normalizeInject(child, vm);\r\n    normalizeDirectives$1(child);\r\n    // Apply extends and mixins on the child options,\r\n    // but only if it is a raw options object that isn't\r\n    // the result of another mergeOptions call.\r\n    // Only merged options has the _base property.\r\n    if (!child._base) {\r\n        if (child.extends) {\r\n            parent = mergeOptions(parent, child.extends, vm);\r\n        }\r\n        if (child.mixins) {\r\n            for (var i = 0, l = child.mixins.length; i < l; i++) {\r\n                parent = mergeOptions(parent, child.mixins[i], vm);\r\n            }\r\n        }\r\n    }\r\n    var options = {};\r\n    var key;\r\n    for (key in parent) {\r\n        mergeField(key);\r\n    }\r\n    for (key in child) {\r\n        if (!hasOwn(parent, key)) {\r\n            mergeField(key);\r\n        }\r\n    }\r\n    function mergeField(key) {\r\n        var strat = strats[key] || defaultStrat;\r\n        options[key] = strat(parent[key], child[key], vm, key);\r\n    }\r\n    return options;\r\n}\r\n/**\r\n * Resolve an asset.\r\n * This function is used because child instances need access\r\n * to assets defined in its ancestor chain.\r\n */\r\nfunction resolveAsset(options, type, id, warnMissing) {\r\n    /* istanbul ignore if */\r\n    if (typeof id !== 'string') {\r\n        return;\r\n    }\r\n    var assets = options[type];\r\n    // check local registration variations first\r\n    if (hasOwn(assets, id))\r\n        return assets[id];\r\n    var camelizedId = camelize(id);\r\n    if (hasOwn(assets, camelizedId))\r\n        return assets[camelizedId];\r\n    var PascalCaseId = capitalize(camelizedId);\r\n    if (hasOwn(assets, PascalCaseId))\r\n        return assets[PascalCaseId];\r\n    // fallback to prototype chain\r\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\r\n    if (false) {}\r\n    return res;\r\n}\n\nfunction validateProp(key, propOptions, propsData, vm) {\r\n    var prop = propOptions[key];\r\n    var absent = !hasOwn(propsData, key);\r\n    var value = propsData[key];\r\n    // boolean casting\r\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\r\n    if (booleanIndex > -1) {\r\n        if (absent && !hasOwn(prop, 'default')) {\r\n            value = false;\r\n        }\r\n        else if (value === '' || value === hyphenate(key)) {\r\n            // only cast empty string / same name to boolean if\r\n            // boolean has higher priority\r\n            var stringIndex = getTypeIndex(String, prop.type);\r\n            if (stringIndex < 0 || booleanIndex < stringIndex) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    // check default value\r\n    if (value === undefined) {\r\n        value = getPropDefaultValue(vm, prop, key);\r\n        // since the default value is a fresh copy,\r\n        // make sure to observe it.\r\n        var prevShouldObserve = shouldObserve;\r\n        toggleObserving(true);\r\n        observe(value);\r\n        toggleObserving(prevShouldObserve);\r\n    }\r\n    if (false) {}\r\n    return value;\r\n}\r\n/**\r\n * Get the default value of a prop.\r\n */\r\nfunction getPropDefaultValue(vm, prop, key) {\r\n    // no default, return undefined\r\n    if (!hasOwn(prop, 'default')) {\r\n        return undefined;\r\n    }\r\n    var def = prop.default;\r\n    // warn against non-factory defaults for Object & Array\r\n    if (false) {}\r\n    // the raw prop value was also undefined from previous render,\r\n    // return previous default value to avoid unnecessary watcher trigger\r\n    if (vm &&\r\n        vm.$options.propsData &&\r\n        vm.$options.propsData[key] === undefined &&\r\n        vm._props[key] !== undefined) {\r\n        return vm._props[key];\r\n    }\r\n    // call factory function for non-Function types\r\n    // a value is Function if its prototype is function even across different execution context\r\n    return isFunction(def) && getType(prop.type) !== 'Function'\r\n        ? def.call(vm)\r\n        : def;\r\n}\r\n/**\r\n * Assert whether a prop is valid.\r\n */\r\nfunction assertProp(prop, name, value, vm, absent) {\r\n    if (prop.required && absent) {\r\n        warn('Missing required prop: \"' + name + '\"', vm);\r\n        return;\r\n    }\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    var type = prop.type;\r\n    var valid = !type || type === true;\r\n    var expectedTypes = [];\r\n    if (type) {\r\n        if (!isArray(type)) {\r\n            type = [type];\r\n        }\r\n        for (var i = 0; i < type.length && !valid; i++) {\r\n            var assertedType = assertType(value, type[i], vm);\r\n            expectedTypes.push(assertedType.expectedType || '');\r\n            valid = assertedType.valid;\r\n        }\r\n    }\r\n    var haveExpectedTypes = expectedTypes.some(function (t) { return t; });\r\n    if (!valid && haveExpectedTypes) {\r\n        warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\r\n        return;\r\n    }\r\n    var validator = prop.validator;\r\n    if (validator) {\r\n        if (!validator(value)) {\r\n            warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\r\n        }\r\n    }\r\n}\r\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\r\nfunction assertType(value, type, vm) {\r\n    var valid;\r\n    var expectedType = getType(type);\r\n    if (simpleCheckRE.test(expectedType)) {\r\n        var t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === 'object') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === 'Object') {\r\n        valid = isPlainObject(value);\r\n    }\r\n    else if (expectedType === 'Array') {\r\n        valid = isArray(value);\r\n    }\r\n    else {\r\n        try {\r\n            valid = value instanceof type;\r\n        }\r\n        catch (e) {\r\n            warn('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\r\n            valid = false;\r\n        }\r\n    }\r\n    return {\r\n        valid: valid,\r\n        expectedType: expectedType\r\n    };\r\n}\r\nvar functionTypeCheckRE = /^\\s*function (\\w+)/;\r\n/**\r\n * Use function string name to check built-in types,\r\n * because a simple equality check will fail when running\r\n * across different vms / iframes.\r\n */\r\nfunction getType(fn) {\r\n    var match = fn && fn.toString().match(functionTypeCheckRE);\r\n    return match ? match[1] : '';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (!isArray(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\r\n        if (isSameType(expectedTypes[i], type)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    var message = \"Invalid prop: type check failed for prop \\\"\".concat(name, \"\\\".\") +\r\n        \" Expected \".concat(expectedTypes.map(capitalize).join(', '));\r\n    var expectedType = expectedTypes[0];\r\n    var receivedType = toRawType(value);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        isExplicable(typeof value) &&\r\n        !isBoolean(expectedType, receivedType)) {\r\n        message += \" with value \".concat(styleValue(value, expectedType));\r\n    }\r\n    message += \", got \".concat(receivedType, \" \");\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += \"with value \".concat(styleValue(value, receivedType), \".\");\r\n    }\r\n    return message;\r\n}\r\nfunction styleValue(value, type) {\r\n    if (type === 'String') {\r\n        return \"\\\"\".concat(value, \"\\\"\");\r\n    }\r\n    else if (type === 'Number') {\r\n        return \"\".concat(Number(value));\r\n    }\r\n    else {\r\n        return \"\".concat(value);\r\n    }\r\n}\r\nvar EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\r\nfunction isExplicable(value) {\r\n    return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; });\r\n}\r\nfunction isBoolean() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; });\r\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\r\nvar initProxy;\r\nif (false) { var getHandler_1, hasHandler_1, isBuiltInModifier_1, hasProxy_1, warnReservedPrefix_1, warnNonPresent_1, allowedGlobals_1; }\n\nvar sharedPropertyDefinition = {\r\n    enumerable: true,\r\n    configurable: true,\r\n    get: noop,\r\n    set: noop\r\n};\r\nfunction proxy(target, sourceKey, key) {\r\n    sharedPropertyDefinition.get = function proxyGetter() {\r\n        return this[sourceKey][key];\r\n    };\r\n    sharedPropertyDefinition.set = function proxySetter(val) {\r\n        this[sourceKey][key] = val;\r\n    };\r\n    Object.defineProperty(target, key, sharedPropertyDefinition);\r\n}\r\nfunction initState(vm) {\r\n    var opts = vm.$options;\r\n    if (opts.props)\r\n        initProps$1(vm, opts.props);\r\n    // Composition API\r\n    initSetup(vm);\r\n    if (opts.methods)\r\n        initMethods(vm, opts.methods);\r\n    if (opts.data) {\r\n        initData(vm);\r\n    }\r\n    else {\r\n        var ob = observe((vm._data = {}));\r\n        ob && ob.vmCount++;\r\n    }\r\n    if (opts.computed)\r\n        initComputed$1(vm, opts.computed);\r\n    if (opts.watch && opts.watch !== nativeWatch) {\r\n        initWatch(vm, opts.watch);\r\n    }\r\n}\r\nfunction initProps$1(vm, propsOptions) {\r\n    var propsData = vm.$options.propsData || {};\r\n    var props = (vm._props = shallowReactive({}));\r\n    // cache prop keys so that future props updates can iterate using Array\r\n    // instead of dynamic object key enumeration.\r\n    var keys = (vm.$options._propKeys = []);\r\n    var isRoot = !vm.$parent;\r\n    // root instance props should be converted\r\n    if (!isRoot) {\r\n        toggleObserving(false);\r\n    }\r\n    var _loop_1 = function (key) {\r\n        keys.push(key);\r\n        var value = validateProp(key, propsOptions, propsData, vm);\r\n        /* istanbul ignore else */\r\n        if (false) { var hyphenatedKey; }\r\n        else {\r\n            defineReactive(props, key, value);\r\n        }\r\n        // static props are already proxied on the component's prototype\r\n        // during Vue.extend(). We only need to proxy props defined at\r\n        // instantiation here.\r\n        if (!(key in vm)) {\r\n            proxy(vm, \"_props\", key);\r\n        }\r\n    };\r\n    for (var key in propsOptions) {\r\n        _loop_1(key);\r\n    }\r\n    toggleObserving(true);\r\n}\r\nfunction initData(vm) {\r\n    var data = vm.$options.data;\r\n    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};\r\n    if (!isPlainObject(data)) {\r\n        data = {};\r\n         false &&\r\n            false;\r\n    }\r\n    // proxy data on instance\r\n    var keys = Object.keys(data);\r\n    var props = vm.$options.props;\r\n    var methods = vm.$options.methods;\r\n    var i = keys.length;\r\n    while (i--) {\r\n        var key = keys[i];\r\n        if (false) {}\r\n        if (props && hasOwn(props, key)) {\r\n             false &&\r\n                false;\r\n        }\r\n        else if (!isReserved(key)) {\r\n            proxy(vm, \"_data\", key);\r\n        }\r\n    }\r\n    // observe data\r\n    var ob = observe(data);\r\n    ob && ob.vmCount++;\r\n}\r\nfunction getData(data, vm) {\r\n    // #7573 disable dep collection when invoking data getters\r\n    pushTarget();\r\n    try {\r\n        return data.call(vm, vm);\r\n    }\r\n    catch (e) {\r\n        handleError(e, vm, \"data()\");\r\n        return {};\r\n    }\r\n    finally {\r\n        popTarget();\r\n    }\r\n}\r\nvar computedWatcherOptions = { lazy: true };\r\nfunction initComputed$1(vm, computed) {\r\n    // $flow-disable-line\r\n    var watchers = (vm._computedWatchers = Object.create(null));\r\n    // computed properties are just getters during SSR\r\n    var isSSR = isServerRendering();\r\n    for (var key in computed) {\r\n        var userDef = computed[key];\r\n        var getter = isFunction(userDef) ? userDef : userDef.get;\r\n        if (false) {}\r\n        if (!isSSR) {\r\n            // create internal watcher for the computed property.\r\n            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\r\n        }\r\n        // component-defined computed properties are already defined on the\r\n        // component prototype. We only need to define computed properties defined\r\n        // at instantiation here.\r\n        if (!(key in vm)) {\r\n            defineComputed(vm, key, userDef);\r\n        }\r\n        else if (false) {}\r\n    }\r\n}\r\nfunction defineComputed(target, key, userDef) {\r\n    var shouldCache = !isServerRendering();\r\n    if (isFunction(userDef)) {\r\n        sharedPropertyDefinition.get = shouldCache\r\n            ? createComputedGetter(key)\r\n            : createGetterInvoker(userDef);\r\n        sharedPropertyDefinition.set = noop;\r\n    }\r\n    else {\r\n        sharedPropertyDefinition.get = userDef.get\r\n            ? shouldCache && userDef.cache !== false\r\n                ? createComputedGetter(key)\r\n                : createGetterInvoker(userDef.get)\r\n            : noop;\r\n        sharedPropertyDefinition.set = userDef.set || noop;\r\n    }\r\n    if (false) {}\r\n    Object.defineProperty(target, key, sharedPropertyDefinition);\r\n}\r\nfunction createComputedGetter(key) {\r\n    return function computedGetter() {\r\n        var watcher = this._computedWatchers && this._computedWatchers[key];\r\n        if (watcher) {\r\n            if (watcher.dirty) {\r\n                watcher.evaluate();\r\n            }\r\n            if (Dep.target) {\r\n                if (false) {}\r\n                watcher.depend();\r\n            }\r\n            return watcher.value;\r\n        }\r\n    };\r\n}\r\nfunction createGetterInvoker(fn) {\r\n    return function computedGetter() {\r\n        return fn.call(this, this);\r\n    };\r\n}\r\nfunction initMethods(vm, methods) {\r\n    var props = vm.$options.props;\r\n    for (var key in methods) {\r\n        if (false) {}\r\n        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\r\n    }\r\n}\r\nfunction initWatch(vm, watch) {\r\n    for (var key in watch) {\r\n        var handler = watch[key];\r\n        if (isArray(handler)) {\r\n            for (var i = 0; i < handler.length; i++) {\r\n                createWatcher(vm, key, handler[i]);\r\n            }\r\n        }\r\n        else {\r\n            createWatcher(vm, key, handler);\r\n        }\r\n    }\r\n}\r\nfunction createWatcher(vm, expOrFn, handler, options) {\r\n    if (isPlainObject(handler)) {\r\n        options = handler;\r\n        handler = handler.handler;\r\n    }\r\n    if (typeof handler === 'string') {\r\n        handler = vm[handler];\r\n    }\r\n    return vm.$watch(expOrFn, handler, options);\r\n}\r\nfunction stateMixin(Vue) {\r\n    // flow somehow has problems with directly declared definition object\r\n    // when using Object.defineProperty, so we have to procedurally build up\r\n    // the object here.\r\n    var dataDef = {};\r\n    dataDef.get = function () {\r\n        return this._data;\r\n    };\r\n    var propsDef = {};\r\n    propsDef.get = function () {\r\n        return this._props;\r\n    };\r\n    if (false) {}\r\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\r\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\r\n    Vue.prototype.$set = set;\r\n    Vue.prototype.$delete = del;\r\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\r\n        var vm = this;\r\n        if (isPlainObject(cb)) {\r\n            return createWatcher(vm, expOrFn, cb, options);\r\n        }\r\n        options = options || {};\r\n        options.user = true;\r\n        var watcher = new Watcher(vm, expOrFn, cb, options);\r\n        if (options.immediate) {\r\n            var info = \"callback for immediate watcher \\\"\".concat(watcher.expression, \"\\\"\");\r\n            pushTarget();\r\n            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\r\n            popTarget();\r\n        }\r\n        return function unwatchFn() {\r\n            watcher.teardown();\r\n        };\r\n    };\r\n}\n\nvar uid = 0;\r\nfunction initMixin$1(Vue) {\r\n    Vue.prototype._init = function (options) {\r\n        var vm = this;\r\n        // a uid\r\n        vm._uid = uid++;\r\n        var startTag, endTag;\r\n        /* istanbul ignore if */\r\n        if (false) {}\r\n        // a flag to mark this as a Vue instance without having to do instanceof\r\n        // check\r\n        vm._isVue = true;\r\n        // avoid instances from being observed\r\n        vm.__v_skip = true;\r\n        // effect scope\r\n        vm._scope = new EffectScope(true /* detached */);\r\n        vm._scope._vm = true;\r\n        // merge options\r\n        if (options && options._isComponent) {\r\n            // optimize internal component instantiation\r\n            // since dynamic options merging is pretty slow, and none of the\r\n            // internal component options needs special treatment.\r\n            initInternalComponent(vm, options);\r\n        }\r\n        else {\r\n            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\r\n        }\r\n        /* istanbul ignore else */\r\n        if (false) {}\r\n        else {\r\n            vm._renderProxy = vm;\r\n        }\r\n        // expose real self\r\n        vm._self = vm;\r\n        initLifecycle(vm);\r\n        initEvents(vm);\r\n        initRender(vm);\r\n        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);\r\n        initInjections(vm); // resolve injections before data/props\r\n        initState(vm);\r\n        initProvide(vm); // resolve provide after data/props\r\n        callHook$1(vm, 'created');\r\n        /* istanbul ignore if */\r\n        if (false) {}\r\n        if (vm.$options.el) {\r\n            vm.$mount(vm.$options.el);\r\n        }\r\n    };\r\n}\r\nfunction initInternalComponent(vm, options) {\r\n    var opts = (vm.$options = Object.create(vm.constructor.options));\r\n    // doing this because it's faster than dynamic enumeration.\r\n    var parentVnode = options._parentVnode;\r\n    opts.parent = options.parent;\r\n    opts._parentVnode = parentVnode;\r\n    var vnodeComponentOptions = parentVnode.componentOptions;\r\n    opts.propsData = vnodeComponentOptions.propsData;\r\n    opts._parentListeners = vnodeComponentOptions.listeners;\r\n    opts._renderChildren = vnodeComponentOptions.children;\r\n    opts._componentTag = vnodeComponentOptions.tag;\r\n    if (options.render) {\r\n        opts.render = options.render;\r\n        opts.staticRenderFns = options.staticRenderFns;\r\n    }\r\n}\r\nfunction resolveConstructorOptions(Ctor) {\r\n    var options = Ctor.options;\r\n    if (Ctor.super) {\r\n        var superOptions = resolveConstructorOptions(Ctor.super);\r\n        var cachedSuperOptions = Ctor.superOptions;\r\n        if (superOptions !== cachedSuperOptions) {\r\n            // super option changed,\r\n            // need to resolve new options.\r\n            Ctor.superOptions = superOptions;\r\n            // check if there are any late-modified/attached options (#4976)\r\n            var modifiedOptions = resolveModifiedOptions(Ctor);\r\n            // update base extend options\r\n            if (modifiedOptions) {\r\n                extend(Ctor.extendOptions, modifiedOptions);\r\n            }\r\n            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\r\n            if (options.name) {\r\n                options.components[options.name] = Ctor;\r\n            }\r\n        }\r\n    }\r\n    return options;\r\n}\r\nfunction resolveModifiedOptions(Ctor) {\r\n    var modified;\r\n    var latest = Ctor.options;\r\n    var sealed = Ctor.sealedOptions;\r\n    for (var key in latest) {\r\n        if (latest[key] !== sealed[key]) {\r\n            if (!modified)\r\n                modified = {};\r\n            modified[key] = latest[key];\r\n        }\r\n    }\r\n    return modified;\r\n}\n\nfunction Vue(options) {\r\n    if (false) {}\r\n    this._init(options);\r\n}\r\n//@ts-expect-error Vue has function type\r\ninitMixin$1(Vue);\r\n//@ts-expect-error Vue has function type\r\nstateMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\neventsMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\nlifecycleMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\nrenderMixin(Vue);\n\nfunction initUse(Vue) {\r\n    Vue.use = function (plugin) {\r\n        var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\r\n        if (installedPlugins.indexOf(plugin) > -1) {\r\n            return this;\r\n        }\r\n        // additional parameters\r\n        var args = toArray(arguments, 1);\r\n        args.unshift(this);\r\n        if (isFunction(plugin.install)) {\r\n            plugin.install.apply(plugin, args);\r\n        }\r\n        else if (isFunction(plugin)) {\r\n            plugin.apply(null, args);\r\n        }\r\n        installedPlugins.push(plugin);\r\n        return this;\r\n    };\r\n}\n\nfunction initMixin(Vue) {\r\n    Vue.mixin = function (mixin) {\r\n        this.options = mergeOptions(this.options, mixin);\r\n        return this;\r\n    };\r\n}\n\nfunction initExtend(Vue) {\r\n    /**\r\n     * Each instance constructor, including Vue, has a unique\r\n     * cid. This enables us to create wrapped \"child\r\n     * constructors\" for prototypal inheritance and cache them.\r\n     */\r\n    Vue.cid = 0;\r\n    var cid = 1;\r\n    /**\r\n     * Class inheritance\r\n     */\r\n    Vue.extend = function (extendOptions) {\r\n        extendOptions = extendOptions || {};\r\n        var Super = this;\r\n        var SuperId = Super.cid;\r\n        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\r\n        if (cachedCtors[SuperId]) {\r\n            return cachedCtors[SuperId];\r\n        }\r\n        var name = getComponentName(extendOptions) || getComponentName(Super.options);\r\n        if (false) {}\r\n        var Sub = function VueComponent(options) {\r\n            this._init(options);\r\n        };\r\n        Sub.prototype = Object.create(Super.prototype);\r\n        Sub.prototype.constructor = Sub;\r\n        Sub.cid = cid++;\r\n        Sub.options = mergeOptions(Super.options, extendOptions);\r\n        Sub['super'] = Super;\r\n        // For props and computed properties, we define the proxy getters on\r\n        // the Vue instances at extension time, on the extended prototype. This\r\n        // avoids Object.defineProperty calls for each instance created.\r\n        if (Sub.options.props) {\r\n            initProps(Sub);\r\n        }\r\n        if (Sub.options.computed) {\r\n            initComputed(Sub);\r\n        }\r\n        // allow further extension/mixin/plugin usage\r\n        Sub.extend = Super.extend;\r\n        Sub.mixin = Super.mixin;\r\n        Sub.use = Super.use;\r\n        // create asset registers, so extended classes\r\n        // can have their private assets too.\r\n        ASSET_TYPES.forEach(function (type) {\r\n            Sub[type] = Super[type];\r\n        });\r\n        // enable recursive self-lookup\r\n        if (name) {\r\n            Sub.options.components[name] = Sub;\r\n        }\r\n        // keep a reference to the super options at extension time.\r\n        // later at instantiation we can check if Super's options have\r\n        // been updated.\r\n        Sub.superOptions = Super.options;\r\n        Sub.extendOptions = extendOptions;\r\n        Sub.sealedOptions = extend({}, Sub.options);\r\n        // cache constructor\r\n        cachedCtors[SuperId] = Sub;\r\n        return Sub;\r\n    };\r\n}\r\nfunction initProps(Comp) {\r\n    var props = Comp.options.props;\r\n    for (var key in props) {\r\n        proxy(Comp.prototype, \"_props\", key);\r\n    }\r\n}\r\nfunction initComputed(Comp) {\r\n    var computed = Comp.options.computed;\r\n    for (var key in computed) {\r\n        defineComputed(Comp.prototype, key, computed[key]);\r\n    }\r\n}\n\nfunction initAssetRegisters(Vue) {\r\n    /**\r\n     * Create asset registration methods.\r\n     */\r\n    ASSET_TYPES.forEach(function (type) {\r\n        // @ts-expect-error function is not exact same type\r\n        Vue[type] = function (id, definition) {\r\n            if (!definition) {\r\n                return this.options[type + 's'][id];\r\n            }\r\n            else {\r\n                /* istanbul ignore if */\r\n                if (false) {}\r\n                if (type === 'component' && isPlainObject(definition)) {\r\n                    // @ts-expect-error\r\n                    definition.name = definition.name || id;\r\n                    definition = this.options._base.extend(definition);\r\n                }\r\n                if (type === 'directive' && isFunction(definition)) {\r\n                    definition = { bind: definition, update: definition };\r\n                }\r\n                this.options[type + 's'][id] = definition;\r\n                return definition;\r\n            }\r\n        };\r\n    });\r\n}\n\nfunction _getComponentName(opts) {\r\n    return opts && (getComponentName(opts.Ctor.options) || opts.tag);\r\n}\r\nfunction matches(pattern, name) {\r\n    if (isArray(pattern)) {\r\n        return pattern.indexOf(name) > -1;\r\n    }\r\n    else if (typeof pattern === 'string') {\r\n        return pattern.split(',').indexOf(name) > -1;\r\n    }\r\n    else if (isRegExp(pattern)) {\r\n        return pattern.test(name);\r\n    }\r\n    /* istanbul ignore next */\r\n    return false;\r\n}\r\nfunction pruneCache(keepAliveInstance, filter) {\r\n    var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;\r\n    for (var key in cache) {\r\n        var entry = cache[key];\r\n        if (entry) {\r\n            var name_1 = entry.name;\r\n            if (name_1 && !filter(name_1)) {\r\n                pruneCacheEntry(cache, key, keys, _vnode);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction pruneCacheEntry(cache, key, keys, current) {\r\n    var entry = cache[key];\r\n    if (entry && (!current || entry.tag !== current.tag)) {\r\n        // @ts-expect-error can be undefined\r\n        entry.componentInstance.$destroy();\r\n    }\r\n    cache[key] = null;\r\n    remove$2(keys, key);\r\n}\r\nvar patternTypes = [String, RegExp, Array];\r\n// TODO defineComponent\r\nvar KeepAlive = {\r\n    name: 'keep-alive',\r\n    abstract: true,\r\n    props: {\r\n        include: patternTypes,\r\n        exclude: patternTypes,\r\n        max: [String, Number]\r\n    },\r\n    methods: {\r\n        cacheVNode: function () {\r\n            var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;\r\n            if (vnodeToCache) {\r\n                var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;\r\n                cache[keyToCache] = {\r\n                    name: _getComponentName(componentOptions),\r\n                    tag: tag,\r\n                    componentInstance: componentInstance\r\n                };\r\n                keys.push(keyToCache);\r\n                // prune oldest entry\r\n                if (this.max && keys.length > parseInt(this.max)) {\r\n                    pruneCacheEntry(cache, keys[0], keys, this._vnode);\r\n                }\r\n                this.vnodeToCache = null;\r\n            }\r\n        }\r\n    },\r\n    created: function () {\r\n        this.cache = Object.create(null);\r\n        this.keys = [];\r\n    },\r\n    destroyed: function () {\r\n        for (var key in this.cache) {\r\n            pruneCacheEntry(this.cache, key, this.keys);\r\n        }\r\n    },\r\n    mounted: function () {\r\n        var _this = this;\r\n        this.cacheVNode();\r\n        this.$watch('include', function (val) {\r\n            pruneCache(_this, function (name) { return matches(val, name); });\r\n        });\r\n        this.$watch('exclude', function (val) {\r\n            pruneCache(_this, function (name) { return !matches(val, name); });\r\n        });\r\n    },\r\n    updated: function () {\r\n        this.cacheVNode();\r\n    },\r\n    render: function () {\r\n        var slot = this.$slots.default;\r\n        var vnode = getFirstComponentChild(slot);\r\n        var componentOptions = vnode && vnode.componentOptions;\r\n        if (componentOptions) {\r\n            // check pattern\r\n            var name_2 = _getComponentName(componentOptions);\r\n            var _a = this, include = _a.include, exclude = _a.exclude;\r\n            if (\r\n            // not included\r\n            (include && (!name_2 || !matches(include, name_2))) ||\r\n                // excluded\r\n                (exclude && name_2 && matches(exclude, name_2))) {\r\n                return vnode;\r\n            }\r\n            var _b = this, cache = _b.cache, keys = _b.keys;\r\n            var key = vnode.key == null\r\n                ? // same constructor may get registered as different local components\r\n                    // so cid alone is not enough (#3269)\r\n                    componentOptions.Ctor.cid +\r\n                        (componentOptions.tag ? \"::\".concat(componentOptions.tag) : '')\r\n                : vnode.key;\r\n            if (cache[key]) {\r\n                vnode.componentInstance = cache[key].componentInstance;\r\n                // make current key freshest\r\n                remove$2(keys, key);\r\n                keys.push(key);\r\n            }\r\n            else {\r\n                // delay setting the cache until update\r\n                this.vnodeToCache = vnode;\r\n                this.keyToCache = key;\r\n            }\r\n            // @ts-expect-error can vnode.data can be undefined\r\n            vnode.data.keepAlive = true;\r\n        }\r\n        return vnode || (slot && slot[0]);\r\n    }\r\n};\n\nvar builtInComponents = {\r\n    KeepAlive: KeepAlive\r\n};\n\nfunction initGlobalAPI(Vue) {\r\n    // config\r\n    var configDef = {};\r\n    configDef.get = function () { return config; };\r\n    if (false) {}\r\n    Object.defineProperty(Vue, 'config', configDef);\r\n    // exposed util methods.\r\n    // NOTE: these are not considered part of the public API - avoid relying on\r\n    // them unless you are aware of the risk.\r\n    Vue.util = {\r\n        warn: warn,\r\n        extend: extend,\r\n        mergeOptions: mergeOptions,\r\n        defineReactive: defineReactive\r\n    };\r\n    Vue.set = set;\r\n    Vue.delete = del;\r\n    Vue.nextTick = nextTick;\r\n    // 2.6 explicit observable API\r\n    Vue.observable = function (obj) {\r\n        observe(obj);\r\n        return obj;\r\n    };\r\n    Vue.options = Object.create(null);\r\n    ASSET_TYPES.forEach(function (type) {\r\n        Vue.options[type + 's'] = Object.create(null);\r\n    });\r\n    // this is used to identify the \"base\" constructor to extend all plain-object\r\n    // components with in Weex's multi-instance scenarios.\r\n    Vue.options._base = Vue;\r\n    extend(Vue.options.components, builtInComponents);\r\n    initUse(Vue);\r\n    initMixin(Vue);\r\n    initExtend(Vue);\r\n    initAssetRegisters(Vue);\r\n}\n\ninitGlobalAPI(Vue);\r\nObject.defineProperty(Vue.prototype, '$isServer', {\r\n    get: isServerRendering\r\n});\r\nObject.defineProperty(Vue.prototype, '$ssrContext', {\r\n    get: function () {\r\n        /* istanbul ignore next */\r\n        return this.$vnode && this.$vnode.ssrContext;\r\n    }\r\n});\r\n// expose FunctionalRenderContext for ssr runtime helper installation\r\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\r\n    value: FunctionalRenderContext\r\n});\r\nVue.version = version;\n\n// these are reserved for web because they are directly compiled away\r\n// during template compilation\r\nvar isReservedAttr = makeMap('style,class');\r\n// attributes that should be using props for binding\r\nvar acceptValue = makeMap('input,textarea,option,select,progress');\r\nvar mustUseProp = function (tag, type, attr) {\r\n    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||\r\n        (attr === 'selected' && tag === 'option') ||\r\n        (attr === 'checked' && tag === 'input') ||\r\n        (attr === 'muted' && tag === 'video'));\r\n};\r\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\r\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\r\nvar convertEnumeratedValue = function (key, value) {\r\n    return isFalsyAttrValue(value) || value === 'false'\r\n        ? 'false'\r\n        : // allow arbitrary string value for contenteditable\r\n            key === 'contenteditable' && isValidContentEditableValue(value)\r\n                ? value\r\n                : 'true';\r\n};\r\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\r\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\r\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\r\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\r\n    'required,reversed,scoped,seamless,selected,sortable,' +\r\n    'truespeed,typemustmatch,visible');\r\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\r\nvar isXlink = function (name) {\r\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\r\n};\r\nvar getXlinkProp = function (name) {\r\n    return isXlink(name) ? name.slice(6, name.length) : '';\r\n};\r\nvar isFalsyAttrValue = function (val) {\r\n    return val == null || val === false;\r\n};\n\nfunction genClassForVnode(vnode) {\r\n    var data = vnode.data;\r\n    var parentNode = vnode;\r\n    var childNode = vnode;\r\n    while (isDef(childNode.componentInstance)) {\r\n        childNode = childNode.componentInstance._vnode;\r\n        if (childNode && childNode.data) {\r\n            data = mergeClassData(childNode.data, data);\r\n        }\r\n    }\r\n    // @ts-expect-error parentNode.parent not VNodeWithData\r\n    while (isDef((parentNode = parentNode.parent))) {\r\n        if (parentNode && parentNode.data) {\r\n            data = mergeClassData(data, parentNode.data);\r\n        }\r\n    }\r\n    return renderClass(data.staticClass, data.class);\r\n}\r\nfunction mergeClassData(child, parent) {\r\n    return {\r\n        staticClass: concat(child.staticClass, parent.staticClass),\r\n        class: isDef(child.class) ? [child.class, parent.class] : parent.class\r\n    };\r\n}\r\nfunction renderClass(staticClass, dynamicClass) {\r\n    if (isDef(staticClass) || isDef(dynamicClass)) {\r\n        return concat(staticClass, stringifyClass(dynamicClass));\r\n    }\r\n    /* istanbul ignore next */\r\n    return '';\r\n}\r\nfunction concat(a, b) {\r\n    return a ? (b ? a + ' ' + b : a) : b || '';\r\n}\r\nfunction stringifyClass(value) {\r\n    if (Array.isArray(value)) {\r\n        return stringifyArray(value);\r\n    }\r\n    if (isObject(value)) {\r\n        return stringifyObject(value);\r\n    }\r\n    if (typeof value === 'string') {\r\n        return value;\r\n    }\r\n    /* istanbul ignore next */\r\n    return '';\r\n}\r\nfunction stringifyArray(value) {\r\n    var res = '';\r\n    var stringified;\r\n    for (var i = 0, l = value.length; i < l; i++) {\r\n        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {\r\n            if (res)\r\n                res += ' ';\r\n            res += stringified;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction stringifyObject(value) {\r\n    var res = '';\r\n    for (var key in value) {\r\n        if (value[key]) {\r\n            if (res)\r\n                res += ' ';\r\n            res += key;\r\n        }\r\n    }\r\n    return res;\r\n}\n\nvar namespaceMap = {\r\n    svg: 'http://www.w3.org/2000/svg',\r\n    math: 'http://www.w3.org/1998/Math/MathML'\r\n};\r\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +\r\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\r\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\r\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\r\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\r\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\r\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\r\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\r\n    'output,progress,select,textarea,' +\r\n    'details,dialog,menu,menuitem,summary,' +\r\n    'content,element,shadow,template,blockquote,iframe,tfoot');\r\n// this map is intentionally selective, only covering SVG elements that may\r\n// contain child elements.\r\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\r\n    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\r\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\r\nvar isReservedTag = function (tag) {\r\n    return isHTMLTag(tag) || isSVG(tag);\r\n};\r\nfunction getTagNamespace(tag) {\r\n    if (isSVG(tag)) {\r\n        return 'svg';\r\n    }\r\n    // basic support for MathML\r\n    // note it doesn't support other MathML elements being component roots\r\n    if (tag === 'math') {\r\n        return 'math';\r\n    }\r\n}\r\nvar unknownElementCache = Object.create(null);\r\nfunction isUnknownElement(tag) {\r\n    /* istanbul ignore if */\r\n    if (!inBrowser) {\r\n        return true;\r\n    }\r\n    if (isReservedTag(tag)) {\r\n        return false;\r\n    }\r\n    tag = tag.toLowerCase();\r\n    /* istanbul ignore if */\r\n    if (unknownElementCache[tag] != null) {\r\n        return unknownElementCache[tag];\r\n    }\r\n    var el = document.createElement(tag);\r\n    if (tag.indexOf('-') > -1) {\r\n        // http://stackoverflow.com/a/28210364/1070244\r\n        return (unknownElementCache[tag] =\r\n            el.constructor === window.HTMLUnknownElement ||\r\n                el.constructor === window.HTMLElement);\r\n    }\r\n    else {\r\n        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));\r\n    }\r\n}\r\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/**\r\n * Query an element selector if it's not an element already.\r\n */\r\nfunction query(el) {\r\n    if (typeof el === 'string') {\r\n        var selected = document.querySelector(el);\r\n        if (!selected) {\r\n             false && false;\r\n            return document.createElement('div');\r\n        }\r\n        return selected;\r\n    }\r\n    else {\r\n        return el;\r\n    }\r\n}\n\nfunction createElement(tagName, vnode) {\r\n    var elm = document.createElement(tagName);\r\n    if (tagName !== 'select') {\r\n        return elm;\r\n    }\r\n    // false or null will remove the attribute but undefined will not\r\n    if (vnode.data &&\r\n        vnode.data.attrs &&\r\n        vnode.data.attrs.multiple !== undefined) {\r\n        elm.setAttribute('multiple', 'multiple');\r\n    }\r\n    return elm;\r\n}\r\nfunction createElementNS(namespace, tagName) {\r\n    return document.createElementNS(namespaceMap[namespace], tagName);\r\n}\r\nfunction createTextNode(text) {\r\n    return document.createTextNode(text);\r\n}\r\nfunction createComment(text) {\r\n    return document.createComment(text);\r\n}\r\nfunction insertBefore(parentNode, newNode, referenceNode) {\r\n    parentNode.insertBefore(newNode, referenceNode);\r\n}\r\nfunction removeChild(node, child) {\r\n    node.removeChild(child);\r\n}\r\nfunction appendChild(node, child) {\r\n    node.appendChild(child);\r\n}\r\nfunction parentNode(node) {\r\n    return node.parentNode;\r\n}\r\nfunction nextSibling(node) {\r\n    return node.nextSibling;\r\n}\r\nfunction tagName(node) {\r\n    return node.tagName;\r\n}\r\nfunction setTextContent(node, text) {\r\n    node.textContent = text;\r\n}\r\nfunction setStyleScope(node, scopeId) {\r\n    node.setAttribute(scopeId, '');\r\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createElement: createElement,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\nvar ref = {\r\n    create: function (_, vnode) {\r\n        registerRef(vnode);\r\n    },\r\n    update: function (oldVnode, vnode) {\r\n        if (oldVnode.data.ref !== vnode.data.ref) {\r\n            registerRef(oldVnode, true);\r\n            registerRef(vnode);\r\n        }\r\n    },\r\n    destroy: function (vnode) {\r\n        registerRef(vnode, true);\r\n    }\r\n};\r\nfunction registerRef(vnode, isRemoval) {\r\n    var ref = vnode.data.ref;\r\n    if (!isDef(ref))\r\n        return;\r\n    var vm = vnode.context;\r\n    var refValue = vnode.componentInstance || vnode.elm;\r\n    var value = isRemoval ? null : refValue;\r\n    var $refsValue = isRemoval ? undefined : refValue;\r\n    if (isFunction(ref)) {\r\n        invokeWithErrorHandling(ref, vm, [value], vm, \"template ref function\");\r\n        return;\r\n    }\r\n    var isFor = vnode.data.refInFor;\r\n    var _isString = typeof ref === 'string' || typeof ref === 'number';\r\n    var _isRef = isRef(ref);\r\n    var refs = vm.$refs;\r\n    if (_isString || _isRef) {\r\n        if (isFor) {\r\n            var existing = _isString ? refs[ref] : ref.value;\r\n            if (isRemoval) {\r\n                isArray(existing) && remove$2(existing, refValue);\r\n            }\r\n            else {\r\n                if (!isArray(existing)) {\r\n                    if (_isString) {\r\n                        refs[ref] = [refValue];\r\n                        setSetupRef(vm, ref, refs[ref]);\r\n                    }\r\n                    else {\r\n                        ref.value = [refValue];\r\n                    }\r\n                }\r\n                else if (!existing.includes(refValue)) {\r\n                    existing.push(refValue);\r\n                }\r\n            }\r\n        }\r\n        else if (_isString) {\r\n            if (isRemoval && refs[ref] !== refValue) {\r\n                return;\r\n            }\r\n            refs[ref] = $refsValue;\r\n            setSetupRef(vm, ref, value);\r\n        }\r\n        else if (_isRef) {\r\n            if (isRemoval && ref.value !== refValue) {\r\n                return;\r\n            }\r\n            ref.value = value;\r\n        }\r\n        else if (false) {}\r\n    }\r\n}\r\nfunction setSetupRef(_a, key, val) {\r\n    var _setupState = _a._setupState;\r\n    if (_setupState && hasOwn(_setupState, key)) {\r\n        if (isRef(_setupState[key])) {\r\n            _setupState[key].value = val;\r\n        }\r\n        else {\r\n            _setupState[key] = val;\r\n        }\r\n    }\r\n}\n\n/**\r\n * Virtual DOM patching algorithm based on Snabbdom by\r\n * Simon Friis Vindum (@paldepind)\r\n * Licensed under the MIT License\r\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\r\n *\r\n * modified by Evan You (@yyx990803)\r\n *\r\n * Not type-checking this because this file is perf-critical and the cost\r\n * of making flow understand it is not worth it.\r\n */\r\nvar emptyNode = new VNode('', {}, []);\r\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\r\nfunction sameVnode(a, b) {\r\n    return (a.key === b.key &&\r\n        a.asyncFactory === b.asyncFactory &&\r\n        ((a.tag === b.tag &&\r\n            a.isComment === b.isComment &&\r\n            isDef(a.data) === isDef(b.data) &&\r\n            sameInputType(a, b)) ||\r\n            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));\r\n}\r\nfunction sameInputType(a, b) {\r\n    if (a.tag !== 'input')\r\n        return true;\r\n    var i;\r\n    var typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;\r\n    var typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;\r\n    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));\r\n}\r\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\r\n    var i, key;\r\n    var map = {};\r\n    for (i = beginIdx; i <= endIdx; ++i) {\r\n        key = children[i].key;\r\n        if (isDef(key))\r\n            map[key] = i;\r\n    }\r\n    return map;\r\n}\r\nfunction createPatchFunction(backend) {\r\n    var i, j;\r\n    var cbs = {};\r\n    var modules = backend.modules, nodeOps = backend.nodeOps;\r\n    for (i = 0; i < hooks.length; ++i) {\r\n        cbs[hooks[i]] = [];\r\n        for (j = 0; j < modules.length; ++j) {\r\n            if (isDef(modules[j][hooks[i]])) {\r\n                cbs[hooks[i]].push(modules[j][hooks[i]]);\r\n            }\r\n        }\r\n    }\r\n    function emptyNodeAt(elm) {\r\n        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\r\n    }\r\n    function createRmCb(childElm, listeners) {\r\n        function remove() {\r\n            if (--remove.listeners === 0) {\r\n                removeNode(childElm);\r\n            }\r\n        }\r\n        remove.listeners = listeners;\r\n        return remove;\r\n    }\r\n    function removeNode(el) {\r\n        var parent = nodeOps.parentNode(el);\r\n        // element may have already been removed due to v-html / v-text\r\n        if (isDef(parent)) {\r\n            nodeOps.removeChild(parent, el);\r\n        }\r\n    }\r\n    function isUnknownElement(vnode, inVPre) {\r\n        return (!inVPre &&\r\n            !vnode.ns &&\r\n            !(config.ignoredElements.length &&\r\n                config.ignoredElements.some(function (ignore) {\r\n                    return isRegExp(ignore)\r\n                        ? ignore.test(vnode.tag)\r\n                        : ignore === vnode.tag;\r\n                })) &&\r\n            config.isUnknownElement(vnode.tag));\r\n    }\r\n    var creatingElmInVPre = 0;\r\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\r\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\r\n            // This vnode was used in a previous render!\r\n            // now it's used as a new node, overwriting its elm would cause\r\n            // potential patch errors down the road when it's used as an insertion\r\n            // reference node. Instead, we clone the node on-demand before creating\r\n            // associated DOM element for it.\r\n            vnode = ownerArray[index] = cloneVNode(vnode);\r\n        }\r\n        vnode.isRootInsert = !nested; // for transition enter check\r\n        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\r\n            return;\r\n        }\r\n        var data = vnode.data;\r\n        var children = vnode.children;\r\n        var tag = vnode.tag;\r\n        if (isDef(tag)) {\r\n            if (false) {}\r\n            vnode.elm = vnode.ns\r\n                ? nodeOps.createElementNS(vnode.ns, tag)\r\n                : nodeOps.createElement(tag, vnode);\r\n            setScope(vnode);\r\n            createChildren(vnode, children, insertedVnodeQueue);\r\n            if (isDef(data)) {\r\n                invokeCreateHooks(vnode, insertedVnodeQueue);\r\n            }\r\n            insert(parentElm, vnode.elm, refElm);\r\n            if (false) {}\r\n        }\r\n        else if (isTrue(vnode.isComment)) {\r\n            vnode.elm = nodeOps.createComment(vnode.text);\r\n            insert(parentElm, vnode.elm, refElm);\r\n        }\r\n        else {\r\n            vnode.elm = nodeOps.createTextNode(vnode.text);\r\n            insert(parentElm, vnode.elm, refElm);\r\n        }\r\n    }\r\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\r\n        var i = vnode.data;\r\n        if (isDef(i)) {\r\n            var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\r\n            if (isDef((i = i.hook)) && isDef((i = i.init))) {\r\n                i(vnode, false /* hydrating */);\r\n            }\r\n            // after calling the init hook, if the vnode is a child component\r\n            // it should've created a child instance and mounted it. the child\r\n            // component also has set the placeholder vnode's elm.\r\n            // in that case we can just return the element and be done.\r\n            if (isDef(vnode.componentInstance)) {\r\n                initComponent(vnode, insertedVnodeQueue);\r\n                insert(parentElm, vnode.elm, refElm);\r\n                if (isTrue(isReactivated)) {\r\n                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    function initComponent(vnode, insertedVnodeQueue) {\r\n        if (isDef(vnode.data.pendingInsert)) {\r\n            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\r\n            vnode.data.pendingInsert = null;\r\n        }\r\n        vnode.elm = vnode.componentInstance.$el;\r\n        if (isPatchable(vnode)) {\r\n            invokeCreateHooks(vnode, insertedVnodeQueue);\r\n            setScope(vnode);\r\n        }\r\n        else {\r\n            // empty component root.\r\n            // skip all element-related modules except for ref (#3455)\r\n            registerRef(vnode);\r\n            // make sure to invoke the insert hook\r\n            insertedVnodeQueue.push(vnode);\r\n        }\r\n    }\r\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\r\n        var i;\r\n        // hack for #4339: a reactivated component with inner transition\r\n        // does not trigger because the inner node's created hooks are not called\r\n        // again. It's not ideal to involve module-specific logic in here but\r\n        // there doesn't seem to be a better way to do it.\r\n        var innerNode = vnode;\r\n        while (innerNode.componentInstance) {\r\n            innerNode = innerNode.componentInstance._vnode;\r\n            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {\r\n                for (i = 0; i < cbs.activate.length; ++i) {\r\n                    cbs.activate[i](emptyNode, innerNode);\r\n                }\r\n                insertedVnodeQueue.push(innerNode);\r\n                break;\r\n            }\r\n        }\r\n        // unlike a newly created component,\r\n        // a reactivated keep-alive component doesn't insert itself\r\n        insert(parentElm, vnode.elm, refElm);\r\n    }\r\n    function insert(parent, elm, ref) {\r\n        if (isDef(parent)) {\r\n            if (isDef(ref)) {\r\n                if (nodeOps.parentNode(ref) === parent) {\r\n                    nodeOps.insertBefore(parent, elm, ref);\r\n                }\r\n            }\r\n            else {\r\n                nodeOps.appendChild(parent, elm);\r\n            }\r\n        }\r\n    }\r\n    function createChildren(vnode, children, insertedVnodeQueue) {\r\n        if (isArray(children)) {\r\n            if (false) {}\r\n            for (var i_1 = 0; i_1 < children.length; ++i_1) {\r\n                createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);\r\n            }\r\n        }\r\n        else if (isPrimitive(vnode.text)) {\r\n            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\r\n        }\r\n    }\r\n    function isPatchable(vnode) {\r\n        while (vnode.componentInstance) {\r\n            vnode = vnode.componentInstance._vnode;\r\n        }\r\n        return isDef(vnode.tag);\r\n    }\r\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\r\n        for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {\r\n            cbs.create[i_2](emptyNode, vnode);\r\n        }\r\n        i = vnode.data.hook; // Reuse variable\r\n        if (isDef(i)) {\r\n            if (isDef(i.create))\r\n                i.create(emptyNode, vnode);\r\n            if (isDef(i.insert))\r\n                insertedVnodeQueue.push(vnode);\r\n        }\r\n    }\r\n    // set scope id attribute for scoped CSS.\r\n    // this is implemented as a special case to avoid the overhead\r\n    // of going through the normal attribute patching process.\r\n    function setScope(vnode) {\r\n        var i;\r\n        if (isDef((i = vnode.fnScopeId))) {\r\n            nodeOps.setStyleScope(vnode.elm, i);\r\n        }\r\n        else {\r\n            var ancestor = vnode;\r\n            while (ancestor) {\r\n                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {\r\n                    nodeOps.setStyleScope(vnode.elm, i);\r\n                }\r\n                ancestor = ancestor.parent;\r\n            }\r\n        }\r\n        // for slot content they should also get the scopeId from the host instance.\r\n        if (isDef((i = activeInstance)) &&\r\n            i !== vnode.context &&\r\n            i !== vnode.fnContext &&\r\n            isDef((i = i.$options._scopeId))) {\r\n            nodeOps.setStyleScope(vnode.elm, i);\r\n        }\r\n    }\r\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\r\n        for (; startIdx <= endIdx; ++startIdx) {\r\n            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\r\n        }\r\n    }\r\n    function invokeDestroyHook(vnode) {\r\n        var i, j;\r\n        var data = vnode.data;\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.destroy)))\r\n                i(vnode);\r\n            for (i = 0; i < cbs.destroy.length; ++i)\r\n                cbs.destroy[i](vnode);\r\n        }\r\n        if (isDef((i = vnode.children))) {\r\n            for (j = 0; j < vnode.children.length; ++j) {\r\n                invokeDestroyHook(vnode.children[j]);\r\n            }\r\n        }\r\n    }\r\n    function removeVnodes(vnodes, startIdx, endIdx) {\r\n        for (; startIdx <= endIdx; ++startIdx) {\r\n            var ch = vnodes[startIdx];\r\n            if (isDef(ch)) {\r\n                if (isDef(ch.tag)) {\r\n                    removeAndInvokeRemoveHook(ch);\r\n                    invokeDestroyHook(ch);\r\n                }\r\n                else {\r\n                    // Text node\r\n                    removeNode(ch.elm);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function removeAndInvokeRemoveHook(vnode, rm) {\r\n        if (isDef(rm) || isDef(vnode.data)) {\r\n            var i_3;\r\n            var listeners = cbs.remove.length + 1;\r\n            if (isDef(rm)) {\r\n                // we have a recursively passed down rm callback\r\n                // increase the listeners count\r\n                rm.listeners += listeners;\r\n            }\r\n            else {\r\n                // directly removing\r\n                rm = createRmCb(vnode.elm, listeners);\r\n            }\r\n            // recursively invoke hooks on child component root node\r\n            if (isDef((i_3 = vnode.componentInstance)) &&\r\n                isDef((i_3 = i_3._vnode)) &&\r\n                isDef(i_3.data)) {\r\n                removeAndInvokeRemoveHook(i_3, rm);\r\n            }\r\n            for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {\r\n                cbs.remove[i_3](vnode, rm);\r\n            }\r\n            if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {\r\n                i_3(vnode, rm);\r\n            }\r\n            else {\r\n                rm();\r\n            }\r\n        }\r\n        else {\r\n            removeNode(vnode.elm);\r\n        }\r\n    }\r\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\r\n        var oldStartIdx = 0;\r\n        var newStartIdx = 0;\r\n        var oldEndIdx = oldCh.length - 1;\r\n        var oldStartVnode = oldCh[0];\r\n        var oldEndVnode = oldCh[oldEndIdx];\r\n        var newEndIdx = newCh.length - 1;\r\n        var newStartVnode = newCh[0];\r\n        var newEndVnode = newCh[newEndIdx];\r\n        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\r\n        // removeOnly is a special flag used only by <transition-group>\r\n        // to ensure removed elements stay in correct relative positions\r\n        // during leaving transitions\r\n        var canMove = !removeOnly;\r\n        if (false) {}\r\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n            if (isUndef(oldStartVnode)) {\r\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\r\n            }\r\n            else if (isUndef(oldEndVnode)) {\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n            }\r\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                oldStartVnode = oldCh[++oldStartIdx];\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n                newEndVnode = newCh[--newEndIdx];\r\n            }\r\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\r\n                // Vnode moved right\r\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\r\n                canMove &&\r\n                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\r\n                oldStartVnode = oldCh[++oldStartIdx];\r\n                newEndVnode = newCh[--newEndIdx];\r\n            }\r\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\r\n                // Vnode moved left\r\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                canMove &&\r\n                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n            else {\r\n                if (isUndef(oldKeyToIdx))\r\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\r\n                idxInOld = isDef(newStartVnode.key)\r\n                    ? oldKeyToIdx[newStartVnode.key]\r\n                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\r\n                if (isUndef(idxInOld)) {\r\n                    // New element\r\n                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\r\n                }\r\n                else {\r\n                    vnodeToMove = oldCh[idxInOld];\r\n                    if (sameVnode(vnodeToMove, newStartVnode)) {\r\n                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                        oldCh[idxInOld] = undefined;\r\n                        canMove &&\r\n                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\r\n                    }\r\n                    else {\r\n                        // same key but different element. treat as new element\r\n                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\r\n                    }\r\n                }\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n        }\r\n        if (oldStartIdx > oldEndIdx) {\r\n            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\r\n            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\r\n        }\r\n        else if (newStartIdx > newEndIdx) {\r\n            removeVnodes(oldCh, oldStartIdx, oldEndIdx);\r\n        }\r\n    }\r\n    function checkDuplicateKeys(children) {\r\n        var seenKeys = {};\r\n        for (var i_4 = 0; i_4 < children.length; i_4++) {\r\n            var vnode = children[i_4];\r\n            var key = vnode.key;\r\n            if (isDef(key)) {\r\n                if (seenKeys[key]) {\r\n                    warn(\"Duplicate keys detected: '\".concat(key, \"'. This may cause an update error.\"), vnode.context);\r\n                }\r\n                else {\r\n                    seenKeys[key] = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function findIdxInOld(node, oldCh, start, end) {\r\n        for (var i_5 = start; i_5 < end; i_5++) {\r\n            var c = oldCh[i_5];\r\n            if (isDef(c) && sameVnode(node, c))\r\n                return i_5;\r\n        }\r\n    }\r\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\r\n        if (oldVnode === vnode) {\r\n            return;\r\n        }\r\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\r\n            // clone reused vnode\r\n            vnode = ownerArray[index] = cloneVNode(vnode);\r\n        }\r\n        var elm = (vnode.elm = oldVnode.elm);\r\n        if (isTrue(oldVnode.isAsyncPlaceholder)) {\r\n            if (isDef(vnode.asyncFactory.resolved)) {\r\n                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\r\n            }\r\n            else {\r\n                vnode.isAsyncPlaceholder = true;\r\n            }\r\n            return;\r\n        }\r\n        // reuse element for static trees.\r\n        // note we only do this if the vnode is cloned -\r\n        // if the new node is not cloned it means the render functions have been\r\n        // reset by the hot-reload-api and we need to do a proper re-render.\r\n        if (isTrue(vnode.isStatic) &&\r\n            isTrue(oldVnode.isStatic) &&\r\n            vnode.key === oldVnode.key &&\r\n            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\r\n            vnode.componentInstance = oldVnode.componentInstance;\r\n            return;\r\n        }\r\n        var i;\r\n        var data = vnode.data;\r\n        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {\r\n            i(oldVnode, vnode);\r\n        }\r\n        var oldCh = oldVnode.children;\r\n        var ch = vnode.children;\r\n        if (isDef(data) && isPatchable(vnode)) {\r\n            for (i = 0; i < cbs.update.length; ++i)\r\n                cbs.update[i](oldVnode, vnode);\r\n            if (isDef((i = data.hook)) && isDef((i = i.update)))\r\n                i(oldVnode, vnode);\r\n        }\r\n        if (isUndef(vnode.text)) {\r\n            if (isDef(oldCh) && isDef(ch)) {\r\n                if (oldCh !== ch)\r\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\r\n            }\r\n            else if (isDef(ch)) {\r\n                if (false) {}\r\n                if (isDef(oldVnode.text))\r\n                    nodeOps.setTextContent(elm, '');\r\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\r\n            }\r\n            else if (isDef(oldCh)) {\r\n                removeVnodes(oldCh, 0, oldCh.length - 1);\r\n            }\r\n            else if (isDef(oldVnode.text)) {\r\n                nodeOps.setTextContent(elm, '');\r\n            }\r\n        }\r\n        else if (oldVnode.text !== vnode.text) {\r\n            nodeOps.setTextContent(elm, vnode.text);\r\n        }\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))\r\n                i(oldVnode, vnode);\r\n        }\r\n    }\r\n    function invokeInsertHook(vnode, queue, initial) {\r\n        // delay insert hooks for component root nodes, invoke them after the\r\n        // element is really inserted\r\n        if (isTrue(initial) && isDef(vnode.parent)) {\r\n            vnode.parent.data.pendingInsert = queue;\r\n        }\r\n        else {\r\n            for (var i_6 = 0; i_6 < queue.length; ++i_6) {\r\n                queue[i_6].data.hook.insert(queue[i_6]);\r\n            }\r\n        }\r\n    }\r\n    var hydrationBailed = false;\r\n    // list of modules that can skip create hook during hydration because they\r\n    // are already rendered on the client or has no need for initialization\r\n    // Note: style is excluded because it relies on initial clone for future\r\n    // deep updates (#7063).\r\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\r\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\r\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\r\n        var i;\r\n        var tag = vnode.tag, data = vnode.data, children = vnode.children;\r\n        inVPre = inVPre || (data && data.pre);\r\n        vnode.elm = elm;\r\n        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\r\n            vnode.isAsyncPlaceholder = true;\r\n            return true;\r\n        }\r\n        // assert node match\r\n        if (false) {}\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.init)))\r\n                i(vnode, true /* hydrating */);\r\n            if (isDef((i = vnode.componentInstance))) {\r\n                // child component. it should have hydrated its own tree.\r\n                initComponent(vnode, insertedVnodeQueue);\r\n                return true;\r\n            }\r\n        }\r\n        if (isDef(tag)) {\r\n            if (isDef(children)) {\r\n                // empty element, allow client to pick up and populate children\r\n                if (!elm.hasChildNodes()) {\r\n                    createChildren(vnode, children, insertedVnodeQueue);\r\n                }\r\n                else {\r\n                    // v-html and domProps: innerHTML\r\n                    if (isDef((i = data)) &&\r\n                        isDef((i = i.domProps)) &&\r\n                        isDef((i = i.innerHTML))) {\r\n                        if (i !== elm.innerHTML) {\r\n                            /* istanbul ignore if */\r\n                            if (false) {}\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // iterate and compare children lists\r\n                        var childrenMatch = true;\r\n                        var childNode = elm.firstChild;\r\n                        for (var i_7 = 0; i_7 < children.length; i_7++) {\r\n                            if (!childNode ||\r\n                                !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {\r\n                                childrenMatch = false;\r\n                                break;\r\n                            }\r\n                            childNode = childNode.nextSibling;\r\n                        }\r\n                        // if childNode is not null, it means the actual childNodes list is\r\n                        // longer than the virtual children list.\r\n                        if (!childrenMatch || childNode) {\r\n                            /* istanbul ignore if */\r\n                            if (false) {}\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isDef(data)) {\r\n                var fullInvoke = false;\r\n                for (var key in data) {\r\n                    if (!isRenderedModule(key)) {\r\n                        fullInvoke = true;\r\n                        invokeCreateHooks(vnode, insertedVnodeQueue);\r\n                        break;\r\n                    }\r\n                }\r\n                if (!fullInvoke && data['class']) {\r\n                    // ensure collecting deps for deep class bindings for future updates\r\n                    traverse(data['class']);\r\n                }\r\n            }\r\n        }\r\n        else if (elm.data !== vnode.text) {\r\n            elm.data = vnode.text;\r\n        }\r\n        return true;\r\n    }\r\n    function assertNodeMatch(node, vnode, inVPre) {\r\n        if (isDef(vnode.tag)) {\r\n            return (vnode.tag.indexOf('vue-component') === 0 ||\r\n                (!isUnknownElement(vnode, inVPre) &&\r\n                    vnode.tag.toLowerCase() ===\r\n                        (node.tagName && node.tagName.toLowerCase())));\r\n        }\r\n        else {\r\n            return node.nodeType === (vnode.isComment ? 8 : 3);\r\n        }\r\n    }\r\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\r\n        if (isUndef(vnode)) {\r\n            if (isDef(oldVnode))\r\n                invokeDestroyHook(oldVnode);\r\n            return;\r\n        }\r\n        var isInitialPatch = false;\r\n        var insertedVnodeQueue = [];\r\n        if (isUndef(oldVnode)) {\r\n            // empty mount (likely as component), create new root element\r\n            isInitialPatch = true;\r\n            createElm(vnode, insertedVnodeQueue);\r\n        }\r\n        else {\r\n            var isRealElement = isDef(oldVnode.nodeType);\r\n            if (!isRealElement && sameVnode(oldVnode, vnode)) {\r\n                // patch existing root node\r\n                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\r\n            }\r\n            else {\r\n                if (isRealElement) {\r\n                    // mounting to a real element\r\n                    // check if this is server-rendered content and if we can perform\r\n                    // a successful hydration.\r\n                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\r\n                        oldVnode.removeAttribute(SSR_ATTR);\r\n                        hydrating = true;\r\n                    }\r\n                    if (isTrue(hydrating)) {\r\n                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\r\n                            invokeInsertHook(vnode, insertedVnodeQueue, true);\r\n                            return oldVnode;\r\n                        }\r\n                        else if (false) {}\r\n                    }\r\n                    // either not server-rendered, or hydration failed.\r\n                    // create an empty node and replace it\r\n                    oldVnode = emptyNodeAt(oldVnode);\r\n                }\r\n                // replacing existing element\r\n                var oldElm = oldVnode.elm;\r\n                var parentElm = nodeOps.parentNode(oldElm);\r\n                // create new node\r\n                createElm(vnode, insertedVnodeQueue, \r\n                // extremely rare edge case: do not insert if old element is in a\r\n                // leaving transition. Only happens when combining transition +\r\n                // keep-alive + HOCs. (#4590)\r\n                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));\r\n                // update parent placeholder node element, recursively\r\n                if (isDef(vnode.parent)) {\r\n                    var ancestor = vnode.parent;\r\n                    var patchable = isPatchable(vnode);\r\n                    while (ancestor) {\r\n                        for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {\r\n                            cbs.destroy[i_8](ancestor);\r\n                        }\r\n                        ancestor.elm = vnode.elm;\r\n                        if (patchable) {\r\n                            for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {\r\n                                cbs.create[i_9](emptyNode, ancestor);\r\n                            }\r\n                            // #6513\r\n                            // invoke insert hooks that may have been merged by create hooks.\r\n                            // e.g. for directives that uses the \"inserted\" hook.\r\n                            var insert_1 = ancestor.data.hook.insert;\r\n                            if (insert_1.merged) {\r\n                                // start at index 1 to avoid re-invoking component mounted hook\r\n                                for (var i_10 = 1; i_10 < insert_1.fns.length; i_10++) {\r\n                                    insert_1.fns[i_10]();\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            registerRef(ancestor);\r\n                        }\r\n                        ancestor = ancestor.parent;\r\n                    }\r\n                }\r\n                // destroy old node\r\n                if (isDef(parentElm)) {\r\n                    removeVnodes([oldVnode], 0, 0);\r\n                }\r\n                else if (isDef(oldVnode.tag)) {\r\n                    invokeDestroyHook(oldVnode);\r\n                }\r\n            }\r\n        }\r\n        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\r\n        return vnode.elm;\r\n    };\r\n}\n\nvar directives = {\r\n    create: updateDirectives,\r\n    update: updateDirectives,\r\n    destroy: function unbindDirectives(vnode) {\r\n        // @ts-expect-error emptyNode is not VNodeWithData\r\n        updateDirectives(vnode, emptyNode);\r\n    }\r\n};\r\nfunction updateDirectives(oldVnode, vnode) {\r\n    if (oldVnode.data.directives || vnode.data.directives) {\r\n        _update(oldVnode, vnode);\r\n    }\r\n}\r\nfunction _update(oldVnode, vnode) {\r\n    var isCreate = oldVnode === emptyNode;\r\n    var isDestroy = vnode === emptyNode;\r\n    var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);\r\n    var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);\r\n    var dirsWithInsert = [];\r\n    var dirsWithPostpatch = [];\r\n    var key, oldDir, dir;\r\n    for (key in newDirs) {\r\n        oldDir = oldDirs[key];\r\n        dir = newDirs[key];\r\n        if (!oldDir) {\r\n            // new directive, bind\r\n            callHook(dir, 'bind', vnode, oldVnode);\r\n            if (dir.def && dir.def.inserted) {\r\n                dirsWithInsert.push(dir);\r\n            }\r\n        }\r\n        else {\r\n            // existing directive, update\r\n            dir.oldValue = oldDir.value;\r\n            dir.oldArg = oldDir.arg;\r\n            callHook(dir, 'update', vnode, oldVnode);\r\n            if (dir.def && dir.def.componentUpdated) {\r\n                dirsWithPostpatch.push(dir);\r\n            }\r\n        }\r\n    }\r\n    if (dirsWithInsert.length) {\r\n        var callInsert = function () {\r\n            for (var i = 0; i < dirsWithInsert.length; i++) {\r\n                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);\r\n            }\r\n        };\r\n        if (isCreate) {\r\n            mergeVNodeHook(vnode, 'insert', callInsert);\r\n        }\r\n        else {\r\n            callInsert();\r\n        }\r\n    }\r\n    if (dirsWithPostpatch.length) {\r\n        mergeVNodeHook(vnode, 'postpatch', function () {\r\n            for (var i = 0; i < dirsWithPostpatch.length; i++) {\r\n                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\r\n            }\r\n        });\r\n    }\r\n    if (!isCreate) {\r\n        for (key in oldDirs) {\r\n            if (!newDirs[key]) {\r\n                // no longer present, unbind\r\n                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\r\n            }\r\n        }\r\n    }\r\n}\r\nvar emptyModifiers = Object.create(null);\r\nfunction normalizeDirectives(dirs, vm) {\r\n    var res = Object.create(null);\r\n    if (!dirs) {\r\n        // $flow-disable-line\r\n        return res;\r\n    }\r\n    var i, dir;\r\n    for (i = 0; i < dirs.length; i++) {\r\n        dir = dirs[i];\r\n        if (!dir.modifiers) {\r\n            // $flow-disable-line\r\n            dir.modifiers = emptyModifiers;\r\n        }\r\n        res[getRawDirName(dir)] = dir;\r\n        if (vm._setupState && vm._setupState.__sfc) {\r\n            var setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);\r\n            if (typeof setupDef === 'function') {\r\n                dir.def = {\r\n                    bind: setupDef,\r\n                    update: setupDef,\r\n                };\r\n            }\r\n            else {\r\n                dir.def = setupDef;\r\n            }\r\n        }\r\n        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);\r\n    }\r\n    // $flow-disable-line\r\n    return res;\r\n}\r\nfunction getRawDirName(dir) {\r\n    return (dir.rawName || \"\".concat(dir.name, \".\").concat(Object.keys(dir.modifiers || {}).join('.')));\r\n}\r\nfunction callHook(dir, hook, vnode, oldVnode, isDestroy) {\r\n    var fn = dir.def && dir.def[hook];\r\n    if (fn) {\r\n        try {\r\n            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\r\n        }\r\n        catch (e) {\r\n            handleError(e, vnode.context, \"directive \".concat(dir.name, \" \").concat(hook, \" hook\"));\r\n        }\r\n    }\r\n}\n\nvar baseModules = [ref, directives];\n\nfunction updateAttrs(oldVnode, vnode) {\r\n    var opts = vnode.componentOptions;\r\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\r\n        return;\r\n    }\r\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\r\n        return;\r\n    }\r\n    var key, cur, old;\r\n    var elm = vnode.elm;\r\n    var oldAttrs = oldVnode.data.attrs || {};\r\n    var attrs = vnode.data.attrs || {};\r\n    // clone observed objects, as the user probably wants to mutate it\r\n    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {\r\n        attrs = vnode.data.attrs = extend({}, attrs);\r\n    }\r\n    for (key in attrs) {\r\n        cur = attrs[key];\r\n        old = oldAttrs[key];\r\n        if (old !== cur) {\r\n            setAttr(elm, key, cur, vnode.data.pre);\r\n        }\r\n    }\r\n    // #4391: in IE9, setting type can reset value for input[type=radio]\r\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\r\n    /* istanbul ignore if */\r\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\r\n        setAttr(elm, 'value', attrs.value);\r\n    }\r\n    for (key in oldAttrs) {\r\n        if (isUndef(attrs[key])) {\r\n            if (isXlink(key)) {\r\n                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\r\n            }\r\n            else if (!isEnumeratedAttr(key)) {\r\n                elm.removeAttribute(key);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction setAttr(el, key, value, isInPre) {\r\n    if (isInPre || el.tagName.indexOf('-') > -1) {\r\n        baseSetAttr(el, key, value);\r\n    }\r\n    else if (isBooleanAttr(key)) {\r\n        // set attribute for blank value\r\n        // e.g. <option disabled>Select one</option>\r\n        if (isFalsyAttrValue(value)) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            // technically allowfullscreen is a boolean attribute for <iframe>,\r\n            // but Flash expects a value of \"true\" when used on <embed> tag\r\n            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\r\n            el.setAttribute(key, value);\r\n        }\r\n    }\r\n    else if (isEnumeratedAttr(key)) {\r\n        el.setAttribute(key, convertEnumeratedValue(key, value));\r\n    }\r\n    else if (isXlink(key)) {\r\n        if (isFalsyAttrValue(value)) {\r\n            el.removeAttributeNS(xlinkNS, getXlinkProp(key));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        baseSetAttr(el, key, value);\r\n    }\r\n}\r\nfunction baseSetAttr(el, key, value) {\r\n    if (isFalsyAttrValue(value)) {\r\n        el.removeAttribute(key);\r\n    }\r\n    else {\r\n        // #7138: IE10 & 11 fires input event when setting placeholder on\r\n        // <textarea>... block the first input event and remove the blocker\r\n        // immediately.\r\n        /* istanbul ignore if */\r\n        if (isIE &&\r\n            !isIE9 &&\r\n            el.tagName === 'TEXTAREA' &&\r\n            key === 'placeholder' &&\r\n            value !== '' &&\r\n            !el.__ieph) {\r\n            var blocker_1 = function (e) {\r\n                e.stopImmediatePropagation();\r\n                el.removeEventListener('input', blocker_1);\r\n            };\r\n            el.addEventListener('input', blocker_1);\r\n            // $flow-disable-line\r\n            el.__ieph = true; /* IE placeholder patched */\r\n        }\r\n        el.setAttribute(key, value);\r\n    }\r\n}\r\nvar attrs = {\r\n    create: updateAttrs,\r\n    update: updateAttrs\r\n};\n\nfunction updateClass(oldVnode, vnode) {\r\n    var el = vnode.elm;\r\n    var data = vnode.data;\r\n    var oldData = oldVnode.data;\r\n    if (isUndef(data.staticClass) &&\r\n        isUndef(data.class) &&\r\n        (isUndef(oldData) ||\r\n            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {\r\n        return;\r\n    }\r\n    var cls = genClassForVnode(vnode);\r\n    // handle transition classes\r\n    var transitionClass = el._transitionClasses;\r\n    if (isDef(transitionClass)) {\r\n        cls = concat(cls, stringifyClass(transitionClass));\r\n    }\r\n    // set the class\r\n    if (cls !== el._prevClass) {\r\n        el.setAttribute('class', cls);\r\n        el._prevClass = cls;\r\n    }\r\n}\r\nvar klass = {\r\n    create: updateClass,\r\n    update: updateClass\r\n};\n\n// in some cases, the event used has to be determined at runtime\r\n// so we used some reserved tokens during compile.\r\nvar RANGE_TOKEN = '__r';\r\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\n// normalize v-model event tokens that can only be determined at runtime.\r\n// it's important to place the event as the first in the array because\r\n// the whole point is ensuring the v-model callback gets called before\r\n// user-attached handlers.\r\nfunction normalizeEvents(on) {\r\n    /* istanbul ignore if */\r\n    if (isDef(on[RANGE_TOKEN])) {\r\n        // IE input[type=range] only supports `change` event\r\n        var event_1 = isIE ? 'change' : 'input';\r\n        on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);\r\n        delete on[RANGE_TOKEN];\r\n    }\r\n    // This was originally intended to fix #4521 but no longer necessary\r\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\r\n    /* istanbul ignore if */\r\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\r\n        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\r\n        delete on[CHECKBOX_RADIO_TOKEN];\r\n    }\r\n}\r\nvar target;\r\nfunction createOnceHandler(event, handler, capture) {\r\n    var _target = target; // save current target element in closure\r\n    return function onceHandler() {\r\n        var res = handler.apply(null, arguments);\r\n        if (res !== null) {\r\n            remove(event, onceHandler, capture, _target);\r\n        }\r\n    };\r\n}\r\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\r\n// implementation and does not fire microtasks in between event propagation, so\r\n// safe to exclude.\r\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\r\nfunction add(name, handler, capture, passive) {\r\n    // async edge case #6566: inner click event triggers patch, event handler\r\n    // attached to outer element during patch, and triggered again. This\r\n    // happens because browsers fire microtask ticks between event propagation.\r\n    // the solution is simple: we save the timestamp when a handler is attached,\r\n    // and the handler would only fire if the event passed to it was fired\r\n    // AFTER it was attached.\r\n    if (useMicrotaskFix) {\r\n        var attachedTimestamp_1 = currentFlushTimestamp;\r\n        var original_1 = handler;\r\n        //@ts-expect-error\r\n        handler = original_1._wrapper = function (e) {\r\n            if (\r\n            // no bubbling, should always fire.\r\n            // this is just a safety net in case event.timeStamp is unreliable in\r\n            // certain weird environments...\r\n            e.target === e.currentTarget ||\r\n                // event is fired after handler attachment\r\n                e.timeStamp >= attachedTimestamp_1 ||\r\n                // bail for environments that have buggy event.timeStamp implementations\r\n                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\r\n                // #9681 QtWebEngine event.timeStamp is negative value\r\n                e.timeStamp <= 0 ||\r\n                // #9448 bail if event is fired in another document in a multi-page\r\n                // electron/nw.js app, since event.timeStamp will be using a different\r\n                // starting reference\r\n                e.target.ownerDocument !== document) {\r\n                return original_1.apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n    target.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);\r\n}\r\nfunction remove(name, handler, capture, _target) {\r\n    (_target || target).removeEventListener(name, \r\n    //@ts-expect-error\r\n    handler._wrapper || handler, capture);\r\n}\r\nfunction updateDOMListeners(oldVnode, vnode) {\r\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\r\n        return;\r\n    }\r\n    var on = vnode.data.on || {};\r\n    var oldOn = oldVnode.data.on || {};\r\n    // vnode is empty when removing all listeners,\r\n    // and use old vnode dom element\r\n    target = vnode.elm || oldVnode.elm;\r\n    normalizeEvents(on);\r\n    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);\r\n    target = undefined;\r\n}\r\nvar events = {\r\n    create: updateDOMListeners,\r\n    update: updateDOMListeners,\r\n    // @ts-expect-error emptyNode has actually data\r\n    destroy: function (vnode) { return updateDOMListeners(vnode, emptyNode); }\r\n};\n\nvar svgContainer;\r\nfunction updateDOMProps(oldVnode, vnode) {\r\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\r\n        return;\r\n    }\r\n    var key, cur;\r\n    var elm = vnode.elm;\r\n    var oldProps = oldVnode.data.domProps || {};\r\n    var props = vnode.data.domProps || {};\r\n    // clone observed objects, as the user probably wants to mutate it\r\n    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {\r\n        props = vnode.data.domProps = extend({}, props);\r\n    }\r\n    for (key in oldProps) {\r\n        if (!(key in props)) {\r\n            elm[key] = '';\r\n        }\r\n    }\r\n    for (key in props) {\r\n        cur = props[key];\r\n        // ignore children if the node has textContent or innerHTML,\r\n        // as these will throw away existing DOM nodes and cause removal errors\r\n        // on subsequent patches (#3360)\r\n        if (key === 'textContent' || key === 'innerHTML') {\r\n            if (vnode.children)\r\n                vnode.children.length = 0;\r\n            if (cur === oldProps[key])\r\n                continue;\r\n            // #6601 work around Chrome version <= 55 bug where single textNode\r\n            // replaced by innerHTML/textContent retains its parentNode property\r\n            if (elm.childNodes.length === 1) {\r\n                elm.removeChild(elm.childNodes[0]);\r\n            }\r\n        }\r\n        if (key === 'value' && elm.tagName !== 'PROGRESS') {\r\n            // store value as _value as well since\r\n            // non-string values will be stringified\r\n            elm._value = cur;\r\n            // avoid resetting cursor position when value is the same\r\n            var strCur = isUndef(cur) ? '' : String(cur);\r\n            if (shouldUpdateValue(elm, strCur)) {\r\n                elm.value = strCur;\r\n            }\r\n        }\r\n        else if (key === 'innerHTML' &&\r\n            isSVG(elm.tagName) &&\r\n            isUndef(elm.innerHTML)) {\r\n            // IE doesn't support innerHTML for SVG elements\r\n            svgContainer = svgContainer || document.createElement('div');\r\n            svgContainer.innerHTML = \"<svg>\".concat(cur, \"</svg>\");\r\n            var svg = svgContainer.firstChild;\r\n            while (elm.firstChild) {\r\n                elm.removeChild(elm.firstChild);\r\n            }\r\n            while (svg.firstChild) {\r\n                elm.appendChild(svg.firstChild);\r\n            }\r\n        }\r\n        else if (\r\n        // skip the update if old and new VDOM state is the same.\r\n        // `value` is handled separately because the DOM value may be temporarily\r\n        // out of sync with VDOM state due to focus, composition and modifiers.\r\n        // This  #4521 by skipping the unnecessary `checked` update.\r\n        cur !== oldProps[key]) {\r\n            // some property updates can throw\r\n            // e.g. `value` on <progress> w/ non-finite value\r\n            try {\r\n                elm[key] = cur;\r\n            }\r\n            catch (e) { }\r\n        }\r\n    }\r\n}\r\nfunction shouldUpdateValue(elm, checkVal) {\r\n    return (\r\n    //@ts-expect-error\r\n    !elm.composing &&\r\n        (elm.tagName === 'OPTION' ||\r\n            isNotInFocusAndDirty(elm, checkVal) ||\r\n            isDirtyWithModifiers(elm, checkVal)));\r\n}\r\nfunction isNotInFocusAndDirty(elm, checkVal) {\r\n    // return true when textbox (.number and .trim) loses focus and its value is\r\n    // not equal to the updated value\r\n    var notInFocus = true;\r\n    // #6157\r\n    // work around IE bug when accessing document.activeElement in an iframe\r\n    try {\r\n        notInFocus = document.activeElement !== elm;\r\n    }\r\n    catch (e) { }\r\n    return notInFocus && elm.value !== checkVal;\r\n}\r\nfunction isDirtyWithModifiers(elm, newVal) {\r\n    var value = elm.value;\r\n    var modifiers = elm._vModifiers; // injected by v-model runtime\r\n    if (isDef(modifiers)) {\r\n        if (modifiers.number) {\r\n            return toNumber(value) !== toNumber(newVal);\r\n        }\r\n        if (modifiers.trim) {\r\n            return value.trim() !== newVal.trim();\r\n        }\r\n    }\r\n    return value !== newVal;\r\n}\r\nvar domProps = {\r\n    create: updateDOMProps,\r\n    update: updateDOMProps\r\n};\n\nvar parseStyleText = cached(function (cssText) {\r\n    var res = {};\r\n    var listDelimiter = /;(?![^(]*\\))/g;\r\n    var propertyDelimiter = /:(.+)/;\r\n    cssText.split(listDelimiter).forEach(function (item) {\r\n        if (item) {\r\n            var tmp = item.split(propertyDelimiter);\r\n            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return res;\r\n});\r\n// merge static and dynamic style data on the same vnode\r\nfunction normalizeStyleData(data) {\r\n    var style = normalizeStyleBinding(data.style);\r\n    // static style is pre-processed into an object during compilation\r\n    // and is always a fresh object, so it's safe to merge into it\r\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\r\n}\r\n// normalize possible array / string values into Object\r\nfunction normalizeStyleBinding(bindingStyle) {\r\n    if (Array.isArray(bindingStyle)) {\r\n        return toObject(bindingStyle);\r\n    }\r\n    if (typeof bindingStyle === 'string') {\r\n        return parseStyleText(bindingStyle);\r\n    }\r\n    return bindingStyle;\r\n}\r\n/**\r\n * parent component style should be after child's\r\n * so that parent component's style could override it\r\n */\r\nfunction getStyle(vnode, checkChild) {\r\n    var res = {};\r\n    var styleData;\r\n    if (checkChild) {\r\n        var childNode = vnode;\r\n        while (childNode.componentInstance) {\r\n            childNode = childNode.componentInstance._vnode;\r\n            if (childNode &&\r\n                childNode.data &&\r\n                (styleData = normalizeStyleData(childNode.data))) {\r\n                extend(res, styleData);\r\n            }\r\n        }\r\n    }\r\n    if ((styleData = normalizeStyleData(vnode.data))) {\r\n        extend(res, styleData);\r\n    }\r\n    var parentNode = vnode;\r\n    // @ts-expect-error parentNode.parent not VNodeWithData\r\n    while ((parentNode = parentNode.parent)) {\r\n        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\r\n            extend(res, styleData);\r\n        }\r\n    }\r\n    return res;\r\n}\n\nvar cssVarRE = /^--/;\r\nvar importantRE = /\\s*!important$/;\r\nvar setProp = function (el, name, val) {\r\n    /* istanbul ignore if */\r\n    if (cssVarRE.test(name)) {\r\n        el.style.setProperty(name, val);\r\n    }\r\n    else if (importantRE.test(val)) {\r\n        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\r\n    }\r\n    else {\r\n        var normalizedName = normalize(name);\r\n        if (Array.isArray(val)) {\r\n            // Support values array created by autoprefixer, e.g.\r\n            // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\r\n            // Set them one by one, and the browser will only set those it can recognize\r\n            for (var i = 0, len = val.length; i < len; i++) {\r\n                el.style[normalizedName] = val[i];\r\n            }\r\n        }\r\n        else {\r\n            el.style[normalizedName] = val;\r\n        }\r\n    }\r\n};\r\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\r\nvar emptyStyle;\r\nvar normalize = cached(function (prop) {\r\n    emptyStyle = emptyStyle || document.createElement('div').style;\r\n    prop = camelize(prop);\r\n    if (prop !== 'filter' && prop in emptyStyle) {\r\n        return prop;\r\n    }\r\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\r\n    for (var i = 0; i < vendorNames.length; i++) {\r\n        var name_1 = vendorNames[i] + capName;\r\n        if (name_1 in emptyStyle) {\r\n            return name_1;\r\n        }\r\n    }\r\n});\r\nfunction updateStyle(oldVnode, vnode) {\r\n    var data = vnode.data;\r\n    var oldData = oldVnode.data;\r\n    if (isUndef(data.staticStyle) &&\r\n        isUndef(data.style) &&\r\n        isUndef(oldData.staticStyle) &&\r\n        isUndef(oldData.style)) {\r\n        return;\r\n    }\r\n    var cur, name;\r\n    var el = vnode.elm;\r\n    var oldStaticStyle = oldData.staticStyle;\r\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\r\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\r\n    var oldStyle = oldStaticStyle || oldStyleBinding;\r\n    var style = normalizeStyleBinding(vnode.data.style) || {};\r\n    // store normalized style under a different key for next diff\r\n    // make sure to clone it if it's reactive, since the user likely wants\r\n    // to mutate it.\r\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\r\n    var newStyle = getStyle(vnode, true);\r\n    for (name in oldStyle) {\r\n        if (isUndef(newStyle[name])) {\r\n            setProp(el, name, '');\r\n        }\r\n    }\r\n    for (name in newStyle) {\r\n        cur = newStyle[name];\r\n        if (cur !== oldStyle[name]) {\r\n            // ie9 setting to null has no effect, must use empty string\r\n            setProp(el, name, cur == null ? '' : cur);\r\n        }\r\n    }\r\n}\r\nvar style = {\r\n    create: updateStyle,\r\n    update: updateStyle\r\n};\n\nvar whitespaceRE = /\\s+/;\r\n/**\r\n * Add class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\r\nfunction addClass(el, cls) {\r\n    /* istanbul ignore if */\r\n    if (!cls || !(cls = cls.trim())) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (el.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\r\n        }\r\n        else {\r\n            el.classList.add(cls);\r\n        }\r\n    }\r\n    else {\r\n        var cur = \" \".concat(el.getAttribute('class') || '', \" \");\r\n        if (cur.indexOf(' ' + cls + ' ') < 0) {\r\n            el.setAttribute('class', (cur + cls).trim());\r\n        }\r\n    }\r\n}\r\n/**\r\n * Remove class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\r\nfunction removeClass(el, cls) {\r\n    /* istanbul ignore if */\r\n    if (!cls || !(cls = cls.trim())) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (el.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\r\n        }\r\n        else {\r\n            el.classList.remove(cls);\r\n        }\r\n        if (!el.classList.length) {\r\n            el.removeAttribute('class');\r\n        }\r\n    }\r\n    else {\r\n        var cur = \" \".concat(el.getAttribute('class') || '', \" \");\r\n        var tar = ' ' + cls + ' ';\r\n        while (cur.indexOf(tar) >= 0) {\r\n            cur = cur.replace(tar, ' ');\r\n        }\r\n        cur = cur.trim();\r\n        if (cur) {\r\n            el.setAttribute('class', cur);\r\n        }\r\n        else {\r\n            el.removeAttribute('class');\r\n        }\r\n    }\r\n}\n\nfunction resolveTransition(def) {\r\n    if (!def) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (typeof def === 'object') {\r\n        var res = {};\r\n        if (def.css !== false) {\r\n            extend(res, autoCssTransition(def.name || 'v'));\r\n        }\r\n        extend(res, def);\r\n        return res;\r\n    }\r\n    else if (typeof def === 'string') {\r\n        return autoCssTransition(def);\r\n    }\r\n}\r\nvar autoCssTransition = cached(function (name) {\r\n    return {\r\n        enterClass: \"\".concat(name, \"-enter\"),\r\n        enterToClass: \"\".concat(name, \"-enter-to\"),\r\n        enterActiveClass: \"\".concat(name, \"-enter-active\"),\r\n        leaveClass: \"\".concat(name, \"-leave\"),\r\n        leaveToClass: \"\".concat(name, \"-leave-to\"),\r\n        leaveActiveClass: \"\".concat(name, \"-leave-active\")\r\n    };\r\n});\r\nvar hasTransition = inBrowser && !isIE9;\r\nvar TRANSITION = 'transition';\r\nvar ANIMATION = 'animation';\r\n// Transition property/event sniffing\r\nvar transitionProp = 'transition';\r\nvar transitionEndEvent = 'transitionend';\r\nvar animationProp = 'animation';\r\nvar animationEndEvent = 'animationend';\r\nif (hasTransition) {\r\n    /* istanbul ignore if */\r\n    if (window.ontransitionend === undefined &&\r\n        window.onwebkittransitionend !== undefined) {\r\n        transitionProp = 'WebkitTransition';\r\n        transitionEndEvent = 'webkitTransitionEnd';\r\n    }\r\n    if (window.onanimationend === undefined &&\r\n        window.onwebkitanimationend !== undefined) {\r\n        animationProp = 'WebkitAnimation';\r\n        animationEndEvent = 'webkitAnimationEnd';\r\n    }\r\n}\r\n// binding to window is necessary to make hot reload work in IE in strict mode\r\nvar raf = inBrowser\r\n    ? window.requestAnimationFrame\r\n        ? window.requestAnimationFrame.bind(window)\r\n        : setTimeout\r\n    : /* istanbul ignore next */ function (/* istanbul ignore next */ fn) { return fn(); };\r\nfunction nextFrame(fn) {\r\n    raf(function () {\r\n        // @ts-expect-error\r\n        raf(fn);\r\n    });\r\n}\r\nfunction addTransitionClass(el, cls) {\r\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\r\n    if (transitionClasses.indexOf(cls) < 0) {\r\n        transitionClasses.push(cls);\r\n        addClass(el, cls);\r\n    }\r\n}\r\nfunction removeTransitionClass(el, cls) {\r\n    if (el._transitionClasses) {\r\n        remove$2(el._transitionClasses, cls);\r\n    }\r\n    removeClass(el, cls);\r\n}\r\nfunction whenTransitionEnds(el, expectedType, cb) {\r\n    var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;\r\n    if (!type)\r\n        return cb();\r\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\r\n    var ended = 0;\r\n    var end = function () {\r\n        el.removeEventListener(event, onEnd);\r\n        cb();\r\n    };\r\n    var onEnd = function (e) {\r\n        if (e.target === el) {\r\n            if (++ended >= propCount) {\r\n                end();\r\n            }\r\n        }\r\n    };\r\n    setTimeout(function () {\r\n        if (ended < propCount) {\r\n            end();\r\n        }\r\n    }, timeout + 1);\r\n    el.addEventListener(event, onEnd);\r\n}\r\nvar transformRE = /\\b(transform|all)(,|$)/;\r\nfunction getTransitionInfo(el, expectedType) {\r\n    var styles = window.getComputedStyle(el);\r\n    // JSDOM may return undefined for transition properties\r\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\r\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\r\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\r\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\r\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\r\n    var type;\r\n    var timeout = 0;\r\n    var propCount = 0;\r\n    /* istanbul ignore if */\r\n    if (expectedType === TRANSITION) {\r\n        if (transitionTimeout > 0) {\r\n            type = TRANSITION;\r\n            timeout = transitionTimeout;\r\n            propCount = transitionDurations.length;\r\n        }\r\n    }\r\n    else if (expectedType === ANIMATION) {\r\n        if (animationTimeout > 0) {\r\n            type = ANIMATION;\r\n            timeout = animationTimeout;\r\n            propCount = animationDurations.length;\r\n        }\r\n    }\r\n    else {\r\n        timeout = Math.max(transitionTimeout, animationTimeout);\r\n        type =\r\n            timeout > 0\r\n                ? transitionTimeout > animationTimeout\r\n                    ? TRANSITION\r\n                    : ANIMATION\r\n                : null;\r\n        propCount = type\r\n            ? type === TRANSITION\r\n                ? transitionDurations.length\r\n                : animationDurations.length\r\n            : 0;\r\n    }\r\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\r\n    return {\r\n        type: type,\r\n        timeout: timeout,\r\n        propCount: propCount,\r\n        hasTransform: hasTransform\r\n    };\r\n}\r\nfunction getTimeout(delays, durations) {\r\n    /* istanbul ignore next */\r\n    while (delays.length < durations.length) {\r\n        delays = delays.concat(delays);\r\n    }\r\n    return Math.max.apply(null, durations.map(function (d, i) {\r\n        return toMs(d) + toMs(delays[i]);\r\n    }));\r\n}\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\r\n// in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\r\n// as a floor function) causing unexpected behaviors\r\nfunction toMs(s) {\r\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\r\n}\n\nfunction enter(vnode, toggleDisplay) {\r\n    var el = vnode.elm;\r\n    // call leave callback now\r\n    if (isDef(el._leaveCb)) {\r\n        el._leaveCb.cancelled = true;\r\n        el._leaveCb();\r\n    }\r\n    var data = resolveTransition(vnode.data.transition);\r\n    if (isUndef(data)) {\r\n        return;\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\r\n        return;\r\n    }\r\n    var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;\r\n    // activeInstance will always be the <transition> component managing this\r\n    // transition. One edge case to check is when the <transition> is placed\r\n    // as the root node of a child component. In that case we need to check\r\n    // <transition>'s parent for appear check.\r\n    var context = activeInstance;\r\n    var transitionNode = activeInstance.$vnode;\r\n    while (transitionNode && transitionNode.parent) {\r\n        context = transitionNode.context;\r\n        transitionNode = transitionNode.parent;\r\n    }\r\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\r\n    if (isAppear && !appear && appear !== '') {\r\n        return;\r\n    }\r\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\r\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\r\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\r\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\r\n    var enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;\r\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\r\n    var enterCancelledHook = isAppear\r\n        ? appearCancelled || enterCancelled\r\n        : enterCancelled;\r\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\r\n    if (false) {}\r\n    var expectsCSS = css !== false && !isIE9;\r\n    var userWantsControl = getHookArgumentsLength(enterHook);\r\n    var cb = (el._enterCb = once(function () {\r\n        if (expectsCSS) {\r\n            removeTransitionClass(el, toClass);\r\n            removeTransitionClass(el, activeClass);\r\n        }\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            if (expectsCSS) {\r\n                removeTransitionClass(el, startClass);\r\n            }\r\n            enterCancelledHook && enterCancelledHook(el);\r\n        }\r\n        else {\r\n            afterEnterHook && afterEnterHook(el);\r\n        }\r\n        el._enterCb = null;\r\n    }));\r\n    if (!vnode.data.show) {\r\n        // remove pending leave element on enter by injecting an insert hook\r\n        mergeVNodeHook(vnode, 'insert', function () {\r\n            var parent = el.parentNode;\r\n            var pendingNode = parent && parent._pending && parent._pending[vnode.key];\r\n            if (pendingNode &&\r\n                pendingNode.tag === vnode.tag &&\r\n                pendingNode.elm._leaveCb) {\r\n                pendingNode.elm._leaveCb();\r\n            }\r\n            enterHook && enterHook(el, cb);\r\n        });\r\n    }\r\n    // start enter transition\r\n    beforeEnterHook && beforeEnterHook(el);\r\n    if (expectsCSS) {\r\n        addTransitionClass(el, startClass);\r\n        addTransitionClass(el, activeClass);\r\n        nextFrame(function () {\r\n            removeTransitionClass(el, startClass);\r\n            // @ts-expect-error\r\n            if (!cb.cancelled) {\r\n                addTransitionClass(el, toClass);\r\n                if (!userWantsControl) {\r\n                    if (isValidDuration(explicitEnterDuration)) {\r\n                        setTimeout(cb, explicitEnterDuration);\r\n                    }\r\n                    else {\r\n                        whenTransitionEnds(el, type, cb);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    if (vnode.data.show) {\r\n        toggleDisplay && toggleDisplay();\r\n        enterHook && enterHook(el, cb);\r\n    }\r\n    if (!expectsCSS && !userWantsControl) {\r\n        cb();\r\n    }\r\n}\r\nfunction leave(vnode, rm) {\r\n    var el = vnode.elm;\r\n    // call enter callback now\r\n    if (isDef(el._enterCb)) {\r\n        el._enterCb.cancelled = true;\r\n        el._enterCb();\r\n    }\r\n    var data = resolveTransition(vnode.data.transition);\r\n    if (isUndef(data) || el.nodeType !== 1) {\r\n        return rm();\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isDef(el._leaveCb)) {\r\n        return;\r\n    }\r\n    var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;\r\n    var expectsCSS = css !== false && !isIE9;\r\n    var userWantsControl = getHookArgumentsLength(leave);\r\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\r\n    if (false) {}\r\n    var cb = (el._leaveCb = once(function () {\r\n        if (el.parentNode && el.parentNode._pending) {\r\n            el.parentNode._pending[vnode.key] = null;\r\n        }\r\n        if (expectsCSS) {\r\n            removeTransitionClass(el, leaveToClass);\r\n            removeTransitionClass(el, leaveActiveClass);\r\n        }\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            if (expectsCSS) {\r\n                removeTransitionClass(el, leaveClass);\r\n            }\r\n            leaveCancelled && leaveCancelled(el);\r\n        }\r\n        else {\r\n            rm();\r\n            afterLeave && afterLeave(el);\r\n        }\r\n        el._leaveCb = null;\r\n    }));\r\n    if (delayLeave) {\r\n        delayLeave(performLeave);\r\n    }\r\n    else {\r\n        performLeave();\r\n    }\r\n    function performLeave() {\r\n        // the delayed leave may have already been cancelled\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            return;\r\n        }\r\n        // record leaving element\r\n        if (!vnode.data.show && el.parentNode) {\r\n            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =\r\n                vnode;\r\n        }\r\n        beforeLeave && beforeLeave(el);\r\n        if (expectsCSS) {\r\n            addTransitionClass(el, leaveClass);\r\n            addTransitionClass(el, leaveActiveClass);\r\n            nextFrame(function () {\r\n                removeTransitionClass(el, leaveClass);\r\n                // @ts-expect-error\r\n                if (!cb.cancelled) {\r\n                    addTransitionClass(el, leaveToClass);\r\n                    if (!userWantsControl) {\r\n                        if (isValidDuration(explicitLeaveDuration)) {\r\n                            setTimeout(cb, explicitLeaveDuration);\r\n                        }\r\n                        else {\r\n                            whenTransitionEnds(el, type, cb);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        leave && leave(el, cb);\r\n        if (!expectsCSS && !userWantsControl) {\r\n            cb();\r\n        }\r\n    }\r\n}\r\n// only used in dev mode\r\nfunction checkDuration(val, name, vnode) {\r\n    if (typeof val !== 'number') {\r\n        warn(\"<transition> explicit \".concat(name, \" duration is not a valid number - \") +\r\n            \"got \".concat(JSON.stringify(val), \".\"), vnode.context);\r\n    }\r\n    else if (isNaN(val)) {\r\n        warn(\"<transition> explicit \".concat(name, \" duration is NaN - \") +\r\n            'the duration expression might be incorrect.', vnode.context);\r\n    }\r\n}\r\nfunction isValidDuration(val) {\r\n    return typeof val === 'number' && !isNaN(val);\r\n}\r\n/**\r\n * Normalize a transition hook's argument length. The hook may be:\r\n * - a merged hook (invoker) with the original in .fns\r\n * - a wrapped component method (check ._length)\r\n * - a plain function (.length)\r\n */\r\nfunction getHookArgumentsLength(fn) {\r\n    if (isUndef(fn)) {\r\n        return false;\r\n    }\r\n    // @ts-expect-error\r\n    var invokerFns = fn.fns;\r\n    if (isDef(invokerFns)) {\r\n        // invoker\r\n        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\r\n    }\r\n    else {\r\n        // @ts-expect-error\r\n        return (fn._length || fn.length) > 1;\r\n    }\r\n}\r\nfunction _enter(_, vnode) {\r\n    if (vnode.data.show !== true) {\r\n        enter(vnode);\r\n    }\r\n}\r\nvar transition = inBrowser\r\n    ? {\r\n        create: _enter,\r\n        activate: _enter,\r\n        remove: function (vnode, rm) {\r\n            /* istanbul ignore else */\r\n            if (vnode.data.show !== true) {\r\n                // @ts-expect-error\r\n                leave(vnode, rm);\r\n            }\r\n            else {\r\n                rm();\r\n            }\r\n        }\r\n    }\r\n    : {};\n\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n\n// the directive module should be applied last, after all\r\n// built-in modules have been applied.\r\nvar modules = platformModules.concat(baseModules);\r\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\r\n * Not type checking this file because flow doesn't like attaching\r\n * properties to Elements.\r\n */\r\n/* istanbul ignore if */\r\nif (isIE9) {\r\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\r\n    document.addEventListener('selectionchange', function () {\r\n        var el = document.activeElement;\r\n        // @ts-expect-error\r\n        if (el && el.vmodel) {\r\n            trigger(el, 'input');\r\n        }\r\n    });\r\n}\r\nvar directive = {\r\n    inserted: function (el, binding, vnode, oldVnode) {\r\n        if (vnode.tag === 'select') {\r\n            // #6903\r\n            if (oldVnode.elm && !oldVnode.elm._vOptions) {\r\n                mergeVNodeHook(vnode, 'postpatch', function () {\r\n                    directive.componentUpdated(el, binding, vnode);\r\n                });\r\n            }\r\n            else {\r\n                setSelected(el, binding, vnode.context);\r\n            }\r\n            el._vOptions = [].map.call(el.options, getValue);\r\n        }\r\n        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\r\n            el._vModifiers = binding.modifiers;\r\n            if (!binding.modifiers.lazy) {\r\n                el.addEventListener('compositionstart', onCompositionStart);\r\n                el.addEventListener('compositionend', onCompositionEnd);\r\n                // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n                // switching focus before confirming composition choice\r\n                // this also fixes the issue where some browsers e.g. iOS Chrome\r\n                // fires \"change\" instead of \"input\" on autocomplete.\r\n                el.addEventListener('change', onCompositionEnd);\r\n                /* istanbul ignore if */\r\n                if (isIE9) {\r\n                    el.vmodel = true;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    componentUpdated: function (el, binding, vnode) {\r\n        if (vnode.tag === 'select') {\r\n            setSelected(el, binding, vnode.context);\r\n            // in case the options rendered by v-for have changed,\r\n            // it's possible that the value is out-of-sync with the rendered options.\r\n            // detect such cases and filter out values that no longer has a matching\r\n            // option in the DOM.\r\n            var prevOptions_1 = el._vOptions;\r\n            var curOptions_1 = (el._vOptions = [].map.call(el.options, getValue));\r\n            if (curOptions_1.some(function (o, i) { return !looseEqual(o, prevOptions_1[i]); })) {\r\n                // trigger change event if\r\n                // no matching option found for at least one value\r\n                var needReset = el.multiple\r\n                    ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions_1); })\r\n                    : binding.value !== binding.oldValue &&\r\n                        hasNoMatchingOption(binding.value, curOptions_1);\r\n                if (needReset) {\r\n                    trigger(el, 'change');\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nfunction setSelected(el, binding, vm) {\r\n    actuallySetSelected(el, binding, vm);\r\n    /* istanbul ignore if */\r\n    if (isIE || isEdge) {\r\n        setTimeout(function () {\r\n            actuallySetSelected(el, binding, vm);\r\n        }, 0);\r\n    }\r\n}\r\nfunction actuallySetSelected(el, binding, vm) {\r\n    var value = binding.value;\r\n    var isMultiple = el.multiple;\r\n    if (isMultiple && !Array.isArray(value)) {\r\n         false &&\r\n            false;\r\n        return;\r\n    }\r\n    var selected, option;\r\n    for (var i = 0, l = el.options.length; i < l; i++) {\r\n        option = el.options[i];\r\n        if (isMultiple) {\r\n            selected = looseIndexOf(value, getValue(option)) > -1;\r\n            if (option.selected !== selected) {\r\n                option.selected = selected;\r\n            }\r\n        }\r\n        else {\r\n            if (looseEqual(getValue(option), value)) {\r\n                if (el.selectedIndex !== i) {\r\n                    el.selectedIndex = i;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (!isMultiple) {\r\n        el.selectedIndex = -1;\r\n    }\r\n}\r\nfunction hasNoMatchingOption(value, options) {\r\n    return options.every(function (o) { return !looseEqual(o, value); });\r\n}\r\nfunction getValue(option) {\r\n    return '_value' in option ? option._value : option.value;\r\n}\r\nfunction onCompositionStart(e) {\r\n    e.target.composing = true;\r\n}\r\nfunction onCompositionEnd(e) {\r\n    // prevent triggering an input event for no reason\r\n    if (!e.target.composing)\r\n        return;\r\n    e.target.composing = false;\r\n    trigger(e.target, 'input');\r\n}\r\nfunction trigger(el, type) {\r\n    var e = document.createEvent('HTMLEvents');\r\n    e.initEvent(type, true, true);\r\n    el.dispatchEvent(e);\r\n}\n\n// recursively search for possible transition defined inside the component root\r\nfunction locateNode(vnode) {\r\n    // @ts-expect-error\r\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\r\n        ? locateNode(vnode.componentInstance._vnode)\r\n        : vnode;\r\n}\r\nvar show = {\r\n    bind: function (el, _a, vnode) {\r\n        var value = _a.value;\r\n        vnode = locateNode(vnode);\r\n        var transition = vnode.data && vnode.data.transition;\r\n        var originalDisplay = (el.__vOriginalDisplay =\r\n            el.style.display === 'none' ? '' : el.style.display);\r\n        if (value && transition) {\r\n            vnode.data.show = true;\r\n            enter(vnode, function () {\r\n                el.style.display = originalDisplay;\r\n            });\r\n        }\r\n        else {\r\n            el.style.display = value ? originalDisplay : 'none';\r\n        }\r\n    },\r\n    update: function (el, _a, vnode) {\r\n        var value = _a.value, oldValue = _a.oldValue;\r\n        /* istanbul ignore if */\r\n        if (!value === !oldValue)\r\n            return;\r\n        vnode = locateNode(vnode);\r\n        var transition = vnode.data && vnode.data.transition;\r\n        if (transition) {\r\n            vnode.data.show = true;\r\n            if (value) {\r\n                enter(vnode, function () {\r\n                    el.style.display = el.__vOriginalDisplay;\r\n                });\r\n            }\r\n            else {\r\n                leave(vnode, function () {\r\n                    el.style.display = 'none';\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            el.style.display = value ? el.__vOriginalDisplay : 'none';\r\n        }\r\n    },\r\n    unbind: function (el, binding, vnode, oldVnode, isDestroy) {\r\n        if (!isDestroy) {\r\n            el.style.display = el.__vOriginalDisplay;\r\n        }\r\n    }\r\n};\n\nvar platformDirectives = {\r\n    model: directive,\r\n    show: show\r\n};\n\n// Provides transition support for a single element/component.\r\nvar transitionProps = {\r\n    name: String,\r\n    appear: Boolean,\r\n    css: Boolean,\r\n    mode: String,\r\n    type: String,\r\n    enterClass: String,\r\n    leaveClass: String,\r\n    enterToClass: String,\r\n    leaveToClass: String,\r\n    enterActiveClass: String,\r\n    leaveActiveClass: String,\r\n    appearClass: String,\r\n    appearActiveClass: String,\r\n    appearToClass: String,\r\n    duration: [Number, String, Object]\r\n};\r\n// in case the child is also an abstract component, e.g. <keep-alive>\r\n// we want to recursively retrieve the real component to be rendered\r\nfunction getRealChild(vnode) {\r\n    var compOptions = vnode && vnode.componentOptions;\r\n    if (compOptions && compOptions.Ctor.options.abstract) {\r\n        return getRealChild(getFirstComponentChild(compOptions.children));\r\n    }\r\n    else {\r\n        return vnode;\r\n    }\r\n}\r\nfunction extractTransitionData(comp) {\r\n    var data = {};\r\n    var options = comp.$options;\r\n    // props\r\n    for (var key in options.propsData) {\r\n        data[key] = comp[key];\r\n    }\r\n    // events.\r\n    // extract listeners and pass them directly to the transition methods\r\n    var listeners = options._parentListeners;\r\n    for (var key in listeners) {\r\n        data[camelize(key)] = listeners[key];\r\n    }\r\n    return data;\r\n}\r\nfunction placeholder(h, rawChild) {\r\n    // @ts-expect-error\r\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\r\n        return h('keep-alive', {\r\n            props: rawChild.componentOptions.propsData\r\n        });\r\n    }\r\n}\r\nfunction hasParentTransition(vnode) {\r\n    while ((vnode = vnode.parent)) {\r\n        if (vnode.data.transition) {\r\n            return true;\r\n        }\r\n    }\r\n}\r\nfunction isSameChild(child, oldChild) {\r\n    return oldChild.key === child.key && oldChild.tag === child.tag;\r\n}\r\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\r\nvar isVShowDirective = function (d) { return d.name === 'show'; };\r\nvar Transition = {\r\n    name: 'transition',\r\n    props: transitionProps,\r\n    abstract: true,\r\n    render: function (h) {\r\n        var _this = this;\r\n        var children = this.$slots.default;\r\n        if (!children) {\r\n            return;\r\n        }\r\n        // filter out text nodes (possible whitespaces)\r\n        children = children.filter(isNotTextNode);\r\n        /* istanbul ignore if */\r\n        if (!children.length) {\r\n            return;\r\n        }\r\n        // warn multiple elements\r\n        if (false) {}\r\n        var mode = this.mode;\r\n        // warn invalid mode\r\n        if (false) {}\r\n        var rawChild = children[0];\r\n        // if this is a component root node and the component's\r\n        // parent container node also has transition, skip.\r\n        if (hasParentTransition(this.$vnode)) {\r\n            return rawChild;\r\n        }\r\n        // apply transition data to child\r\n        // use getRealChild() to ignore abstract components e.g. keep-alive\r\n        var child = getRealChild(rawChild);\r\n        /* istanbul ignore if */\r\n        if (!child) {\r\n            return rawChild;\r\n        }\r\n        if (this._leaving) {\r\n            return placeholder(h, rawChild);\r\n        }\r\n        // ensure a key that is unique to the vnode type and to this transition\r\n        // component instance. This key will be used to remove pending leaving nodes\r\n        // during entering.\r\n        var id = \"__transition-\".concat(this._uid, \"-\");\r\n        child.key =\r\n            child.key == null\r\n                ? child.isComment\r\n                    ? id + 'comment'\r\n                    : id + child.tag\r\n                : isPrimitive(child.key)\r\n                    ? String(child.key).indexOf(id) === 0\r\n                        ? child.key\r\n                        : id + child.key\r\n                    : child.key;\r\n        var data = ((child.data || (child.data = {})).transition =\r\n            extractTransitionData(this));\r\n        var oldRawChild = this._vnode;\r\n        var oldChild = getRealChild(oldRawChild);\r\n        // mark v-show\r\n        // so that the transition module can hand over the control to the directive\r\n        if (child.data.directives && child.data.directives.some(isVShowDirective)) {\r\n            child.data.show = true;\r\n        }\r\n        if (oldChild &&\r\n            oldChild.data &&\r\n            !isSameChild(child, oldChild) &&\r\n            !isAsyncPlaceholder(oldChild) &&\r\n            // #6687 component root is a comment node\r\n            !(oldChild.componentInstance &&\r\n                oldChild.componentInstance._vnode.isComment)) {\r\n            // replace old child transition data with fresh one\r\n            // important for dynamic transitions!\r\n            var oldData = (oldChild.data.transition = extend({}, data));\r\n            // handle transition mode\r\n            if (mode === 'out-in') {\r\n                // return placeholder node and queue update when leave finishes\r\n                this._leaving = true;\r\n                mergeVNodeHook(oldData, 'afterLeave', function () {\r\n                    _this._leaving = false;\r\n                    _this.$forceUpdate();\r\n                });\r\n                return placeholder(h, rawChild);\r\n            }\r\n            else if (mode === 'in-out') {\r\n                if (isAsyncPlaceholder(child)) {\r\n                    return oldRawChild;\r\n                }\r\n                var delayedLeave_1;\r\n                var performLeave = function () {\r\n                    delayedLeave_1();\r\n                };\r\n                mergeVNodeHook(data, 'afterEnter', performLeave);\r\n                mergeVNodeHook(data, 'enterCancelled', performLeave);\r\n                mergeVNodeHook(oldData, 'delayLeave', function (leave) {\r\n                    delayedLeave_1 = leave;\r\n                });\r\n            }\r\n        }\r\n        return rawChild;\r\n    }\r\n};\n\n// Provides transition support for list items.\r\nvar props = extend({\r\n    tag: String,\r\n    moveClass: String\r\n}, transitionProps);\r\ndelete props.mode;\r\nvar TransitionGroup = {\r\n    props: props,\r\n    beforeMount: function () {\r\n        var _this = this;\r\n        var update = this._update;\r\n        this._update = function (vnode, hydrating) {\r\n            var restoreActiveInstance = setActiveInstance(_this);\r\n            // force removing pass\r\n            _this.__patch__(_this._vnode, _this.kept, false, // hydrating\r\n            true // removeOnly (!important, avoids unnecessary moves)\r\n            );\r\n            _this._vnode = _this.kept;\r\n            restoreActiveInstance();\r\n            update.call(_this, vnode, hydrating);\r\n        };\r\n    },\r\n    render: function (h) {\r\n        var tag = this.tag || this.$vnode.data.tag || 'span';\r\n        var map = Object.create(null);\r\n        var prevChildren = (this.prevChildren = this.children);\r\n        var rawChildren = this.$slots.default || [];\r\n        var children = (this.children = []);\r\n        var transitionData = extractTransitionData(this);\r\n        for (var i = 0; i < rawChildren.length; i++) {\r\n            var c = rawChildren[i];\r\n            if (c.tag) {\r\n                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\r\n                    children.push(c);\r\n                    map[c.key] = c;\r\n                    (c.data || (c.data = {})).transition = transitionData;\r\n                }\r\n                else if (false) { var name_1, opts; }\r\n            }\r\n        }\r\n        if (prevChildren) {\r\n            var kept = [];\r\n            var removed = [];\r\n            for (var i = 0; i < prevChildren.length; i++) {\r\n                var c = prevChildren[i];\r\n                c.data.transition = transitionData;\r\n                // @ts-expect-error .getBoundingClientRect is not typed in Node\r\n                c.data.pos = c.elm.getBoundingClientRect();\r\n                if (map[c.key]) {\r\n                    kept.push(c);\r\n                }\r\n                else {\r\n                    removed.push(c);\r\n                }\r\n            }\r\n            this.kept = h(tag, null, kept);\r\n            this.removed = removed;\r\n        }\r\n        return h(tag, null, children);\r\n    },\r\n    updated: function () {\r\n        var children = this.prevChildren;\r\n        var moveClass = this.moveClass || (this.name || 'v') + '-move';\r\n        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\r\n            return;\r\n        }\r\n        // we divide the work into three loops to avoid mixing DOM reads and writes\r\n        // in each iteration - which helps prevent layout thrashing.\r\n        children.forEach(callPendingCbs);\r\n        children.forEach(recordPosition);\r\n        children.forEach(applyTranslation);\r\n        // force reflow to put everything in position\r\n        // assign to this to avoid being removed in tree-shaking\r\n        // $flow-disable-line\r\n        this._reflow = document.body.offsetHeight;\r\n        children.forEach(function (c) {\r\n            if (c.data.moved) {\r\n                var el_1 = c.elm;\r\n                var s = el_1.style;\r\n                addTransitionClass(el_1, moveClass);\r\n                s.transform = s.WebkitTransform = s.transitionDuration = '';\r\n                el_1.addEventListener(transitionEndEvent, (el_1._moveCb = function cb(e) {\r\n                    if (e && e.target !== el_1) {\r\n                        return;\r\n                    }\r\n                    if (!e || /transform$/.test(e.propertyName)) {\r\n                        el_1.removeEventListener(transitionEndEvent, cb);\r\n                        el_1._moveCb = null;\r\n                        removeTransitionClass(el_1, moveClass);\r\n                    }\r\n                }));\r\n            }\r\n        });\r\n    },\r\n    methods: {\r\n        hasMove: function (el, moveClass) {\r\n            /* istanbul ignore if */\r\n            if (!hasTransition) {\r\n                return false;\r\n            }\r\n            /* istanbul ignore if */\r\n            if (this._hasMove) {\r\n                return this._hasMove;\r\n            }\r\n            // Detect whether an element with the move class applied has\r\n            // CSS transitions. Since the element may be inside an entering\r\n            // transition at this very moment, we make a clone of it and remove\r\n            // all other transition classes applied to ensure only the move class\r\n            // is applied.\r\n            var clone = el.cloneNode();\r\n            if (el._transitionClasses) {\r\n                el._transitionClasses.forEach(function (cls) {\r\n                    removeClass(clone, cls);\r\n                });\r\n            }\r\n            addClass(clone, moveClass);\r\n            clone.style.display = 'none';\r\n            this.$el.appendChild(clone);\r\n            var info = getTransitionInfo(clone);\r\n            this.$el.removeChild(clone);\r\n            return (this._hasMove = info.hasTransform);\r\n        }\r\n    }\r\n};\r\nfunction callPendingCbs(c) {\r\n    /* istanbul ignore if */\r\n    if (c.elm._moveCb) {\r\n        c.elm._moveCb();\r\n    }\r\n    /* istanbul ignore if */\r\n    if (c.elm._enterCb) {\r\n        c.elm._enterCb();\r\n    }\r\n}\r\nfunction recordPosition(c) {\r\n    c.data.newPos = c.elm.getBoundingClientRect();\r\n}\r\nfunction applyTranslation(c) {\r\n    var oldPos = c.data.pos;\r\n    var newPos = c.data.newPos;\r\n    var dx = oldPos.left - newPos.left;\r\n    var dy = oldPos.top - newPos.top;\r\n    if (dx || dy) {\r\n        c.data.moved = true;\r\n        var s = c.elm.style;\r\n        s.transform = s.WebkitTransform = \"translate(\".concat(dx, \"px,\").concat(dy, \"px)\");\r\n        s.transitionDuration = '0s';\r\n    }\r\n}\n\nvar platformComponents = {\r\n    Transition: Transition,\r\n    TransitionGroup: TransitionGroup\r\n};\n\n// install platform specific utils\r\nVue.config.mustUseProp = mustUseProp;\r\nVue.config.isReservedTag = isReservedTag;\r\nVue.config.isReservedAttr = isReservedAttr;\r\nVue.config.getTagNamespace = getTagNamespace;\r\nVue.config.isUnknownElement = isUnknownElement;\r\n// install platform runtime directives & components\r\nextend(Vue.options.directives, platformDirectives);\r\nextend(Vue.options.components, platformComponents);\r\n// install platform patch function\r\nVue.prototype.__patch__ = inBrowser ? patch : noop;\r\n// public mount method\r\nVue.prototype.$mount = function (el, hydrating) {\r\n    el = el && inBrowser ? query(el) : undefined;\r\n    return mountComponent(this, el, hydrating);\r\n};\r\n// devtools global hook\r\n/* istanbul ignore next */\r\nif (inBrowser) {\r\n    setTimeout(function () {\r\n        if (config.devtools) {\r\n            if (devtools) {\r\n                devtools.emit('init', Vue);\r\n            }\r\n            else if (false) {}\r\n        }\r\n        if (false) {}\r\n    }, 0);\r\n}\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"c8ba\")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLmpzPzJiMGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBLDhDQUE4QywrQkFBK0IsRUFBRSxtQkFBbUIsaUJBQWlCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxtQ0FBbUMsRUFBRTtBQUN6RixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQWlELEVBQUUsRUFFdEQ7QUFDTCxRQUFRLEtBQXFDLEVBQUUsRUFPMUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFxQyxFQUFFLEVBTTFDO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksS0FBcUMsRUFBRSxFQU0xQztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBNEQsRUFBRSxFQUVqRTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBbUUsRUFBRSxFQUc3RTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBcUMsRUFBRSxFQUcxQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFxQyxHQUFHLFNBQWtCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBcUM7QUFDckQsb0JBQW9CLEtBRW9EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLElBQUksS0FBcUMsRUFBRSxlQW9CMUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUMsRUFBRSx1QkFTMUM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFxQyxFQUFFLEVBWTFDO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQW1FLEVBQUUsRUFleEU7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDLEVBQUUsRUFHMUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDLEVBQUUsRUFFMUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFxQyxFQUFFLEVBRTFDO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHVGQUF1RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQTRELEVBQUUsRUFFakU7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDLEVBQUUsRUFFMUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXNELEVBQUUsRUFNM0Q7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFVBQVUsRUFBRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQyxFQUFFLEVBUTFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFtRSxFQUFFLEVBSXhFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBLFlBQVksS0FBcUMsRUFBRSxFQUUxQztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsWUFBWSxLQUFtRSxFQUFFLEVBSXhFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUErRCxFQUFFLEVBRXBFO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQTZDLEVBQUUsRUFFbEQ7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBNkQsRUFBRSxFQUVsRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQixFQUFFO0FBQzVFLFNBQVM7QUFDVDtBQUNBLCtDQUErQyw0QkFBNEIsRUFBRTtBQUM3RSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRCxRQUFRLEtBQXFDLEVBQUUsRUFJMUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBcUMsSUFBSSxLQUFrQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFxQyxFQUFFLEVBRS9DO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQscUNBQXFDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQTZDO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw0QkFBNEIsRUFBRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsK0JBQStCLEVBQUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBc0UsRUFBRSxFQUUzRTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFFLEVBQUUsRUFFMUU7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQseUNBQXlDLEVBQUU7QUFDOUY7QUFD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RUFJbEY7QUFDYjtBQUNBLFlBQVksS0FHOEIsRUFBRSxFQUtuQztBQUNULEtBQUs7QUFDTDs7QUFFNnNCIiwiZmlsZSI6IjJiMGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFZ1ZS5qcyB2Mi43LjlcbiAqIChjKSAyMDE0LTIwMjIgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XHJcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXHJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmcuXHJcbmZ1bmN0aW9uIGlzVW5kZWYodikge1xyXG4gICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGlzRGVmKHYpIHtcclxuICAgIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBpc1RydWUodikge1xyXG4gICAgcmV0dXJuIHYgPT09IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNGYWxzZSh2KSB7XHJcbiAgICByZXR1cm4gdiA9PT0gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxyXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKTtcclxufVxyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbi8qKlxyXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcclxuICogb2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxyXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcclxuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cclxuICovXHJcbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5mdW5jdGlvbiB0b1Jhd1R5cGUodmFsdWUpIHtcclxuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xyXG59XHJcbi8qKlxyXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXHJcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xyXG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVnRXhwKHYpIHtcclxuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXgodmFsKSB7XHJcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xyXG4gICAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbCk7XHJcbn1cclxuZnVuY3Rpb24gaXNQcm9taXNlKHZhbCkge1xyXG4gICAgcmV0dXJuIChpc0RlZih2YWwpICYmXHJcbiAgICAgICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9TdHJpbmcodmFsKSB7XHJcbiAgICByZXR1cm4gdmFsID09IG51bGxcclxuICAgICAgICA/ICcnXHJcbiAgICAgICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcclxuICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXHJcbiAgICAgICAgICAgIDogU3RyaW5nKHZhbCk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxyXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbCkge1xyXG4gICAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xyXG59XHJcbi8qKlxyXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcclxuICogaXMgaW4gdGhhdCBtYXAuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xyXG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfSA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cclxuICovXHJcbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xyXG4vKipcclxuICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxyXG4gKi9cclxudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xyXG4vKipcclxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZSQyKGFyciwgaXRlbSkge1xyXG4gICAgaWYgKGFyci5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxyXG4gKi9cclxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XHJcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGNhY2hlZChmbikge1xyXG4gICAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjYWNoZWRGbihzdHIpIHtcclxuICAgICAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxyXG4gKi9cclxudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XHJcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpOyB9KTtcclxufSk7XHJcbi8qKlxyXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxyXG4gKi9cclxudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcclxufSk7XHJcbi8qKlxyXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxyXG4gKi9cclxudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcclxudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpO1xyXG59KTtcclxuLyoqXHJcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcclxuICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXHJcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxyXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXHJcbiAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG4gKi9cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gcG9seWZpbGxCaW5kKGZuLCBjdHgpIHtcclxuICAgIGZ1bmN0aW9uIGJvdW5kRm4oYSkge1xyXG4gICAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gbFxyXG4gICAgICAgICAgICA/IGwgPiAxXHJcbiAgICAgICAgICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxyXG4gICAgICAgICAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcclxuICAgICAgICAgICAgOiBmbi5jYWxsKGN0eCk7XHJcbiAgICB9XHJcbiAgICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XHJcbiAgICByZXR1cm4gYm91bmRGbjtcclxufVxyXG5mdW5jdGlvbiBuYXRpdmVCaW5kKGZuLCBjdHgpIHtcclxuICAgIHJldHVybiBmbi5iaW5kKGN0eCk7XHJcbn1cclxuLy8gQHRzLWV4cGVjdC1lcnJvciBiaW5kIGNhbm5vdCBiZSBgdW5kZWZpbmVkYFxyXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID8gbmF0aXZlQmluZCA6IHBvbHlmaWxsQmluZDtcclxuLyoqXHJcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBzdGFydCkge1xyXG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xyXG4gICAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xyXG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbi8qKlxyXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRlbmQodG8sIF9mcm9tKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcclxuICAgICAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiB0bztcclxufVxyXG4vKipcclxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHRvT2JqZWN0KGFycikge1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYXJyW2ldKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vKipcclxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXHJcbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxyXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXHJcbiAqL1xyXG5mdW5jdGlvbiBub29wKGEsIGIsIGMpIHsgfVxyXG4vKipcclxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cclxuICovXHJcbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcclxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vKipcclxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxyXG4gKi9cclxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcclxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xyXG4gKi9cclxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcclxuICAgIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcclxuICAgIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcclxuICAgICAgICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgICAga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcclxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cclxuICovXHJcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpXHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gb25jZShmbikge1xyXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWNhbGxlZCkge1xyXG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzI3BvbHlmaWxsXHJcbmZ1bmN0aW9uIGhhc0NoYW5nZWQoeCwgeSkge1xyXG4gICAgaWYgKHggPT09IHkpIHtcclxuICAgICAgICByZXR1cm4geCA9PT0gMCAmJiAxIC8geCAhPT0gMSAvIHk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4geCA9PT0geCB8fCB5ID09PSB5O1xyXG4gICAgfVxyXG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XHJcbnZhciBBU1NFVF9UWVBFUyA9IFsnY29tcG9uZW50JywgJ2RpcmVjdGl2ZScsICdmaWx0ZXInXTtcclxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcclxuICAgICdiZWZvcmVDcmVhdGUnLFxyXG4gICAgJ2NyZWF0ZWQnLFxyXG4gICAgJ2JlZm9yZU1vdW50JyxcclxuICAgICdtb3VudGVkJyxcclxuICAgICdiZWZvcmVVcGRhdGUnLFxyXG4gICAgJ3VwZGF0ZWQnLFxyXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxyXG4gICAgJ2Rlc3Ryb3llZCcsXHJcbiAgICAnYWN0aXZhdGVkJyxcclxuICAgICdkZWFjdGl2YXRlZCcsXHJcbiAgICAnZXJyb3JDYXB0dXJlZCcsXHJcbiAgICAnc2VydmVyUHJlZmV0Y2gnLFxyXG4gICAgJ3JlbmRlclRyYWNrZWQnLFxyXG4gICAgJ3JlbmRlclRyaWdnZXJlZCdcclxuXTtcblxudmFyIGNvbmZpZyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXHJcbiAgICAgKi9cclxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxyXG4gICAgICovXHJcbiAgICBzaWxlbnQ6IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xyXG4gICAgICovXHJcbiAgICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xyXG4gICAgICovXHJcbiAgICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxyXG4gICAgICovXHJcbiAgICBwZXJmb3JtYW5jZTogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXHJcbiAgICAgKi9cclxuICAgIGVycm9ySGFuZGxlcjogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXHJcbiAgICAgKi9cclxuICAgIHdhcm5IYW5kbGVyOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcclxuICAgICAqL1xyXG4gICAgaWdub3JlZEVsZW1lbnRzOiBbXSxcclxuICAgIC8qKlxyXG4gICAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cclxuICAgICAqL1xyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXHJcbiAgICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIGlzUmVzZXJ2ZWRUYWc6IG5vLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxyXG4gICAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgaXNSZXNlcnZlZEF0dHI6IG5vLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXHJcbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXHJcbiAgICAgKi9cclxuICAgIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cclxuICAgICAqL1xyXG4gICAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxyXG4gICAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxyXG4gICAgICovXHJcbiAgICBtdXN0VXNlUHJvcDogbm8sXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xyXG4gICAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmM6IHRydWUsXHJcbiAgICAvKipcclxuICAgICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXHJcbiAgICAgKi9cclxuICAgIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXHJcbn07XG5cbi8qKlxyXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXHJcbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXHJcbiAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcclxuICovXHJcbnZhciB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xyXG4vKipcclxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Jlc2VydmVkKHN0cikge1xyXG4gICAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XHJcbiAgICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVmO1xyXG59XHJcbi8qKlxyXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cclxuICovXHJcbmZ1bmN0aW9uIGRlZihvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICB2YWx1ZTogdmFsLFxyXG4gICAgICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cclxuICovXHJcbnZhciBiYWlsUkUgPSBuZXcgUmVnRXhwKFwiW15cIi5jb25jYXQodW5pY29kZVJlZ0V4cC5zb3VyY2UsIFwiLiRfXFxcXGRdXCIpKTtcclxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcclxuICAgIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIW9iailcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbn1cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XHJcbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xyXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXHJcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcclxudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XHJcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XHJcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xyXG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XHJcblVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XHJcbnZhciBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XHJcblVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xyXG5VQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcclxudmFyIGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xyXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXHJcbi8vIEB0cy1leHBlY3QtZXJyb3IgZmlyZWJveCBzdXBwb3J0XHJcbnZhciBuYXRpdmVXYXRjaCA9IHt9LndhdGNoO1xyXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XHJcbmlmIChpbkJyb3dzZXIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB7fTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7IH1cclxufVxyXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcclxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcclxudmFyIF9pc1NlcnZlcjtcclxudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXHJcbiAgICAgICAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcclxuICAgICAgICAgICAgX2lzU2VydmVyID1cclxuICAgICAgICAgICAgICAgIGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBfaXNTZXJ2ZXI7XHJcbn07XHJcbi8vIGRldGVjdCBkZXZ0b29sc1xyXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGlzTmF0aXZlKEN0b3IpIHtcclxuICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKTtcclxufVxyXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgIGlzTmF0aXZlKFN5bWJvbCkgJiZcclxuICAgIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcclxudmFyIF9TZXQ7IC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcclxuICAgIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxyXG4gICAgX1NldCA9IFNldDtcclxufVxyXG5lbHNlIHtcclxuICAgIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cclxuICAgIF9TZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gU2V0KCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTZXQ7XHJcbiAgICB9KCkpO1xyXG59XG5cbnZhciBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xyXG4vKipcclxuICogVGhpcyBpcyBleHBvc2VkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdjMgKGUuZy4gc29tZSBmdW5jdGlvbnMgaW4gVnVlVXNlXHJcbiAqIHJlbGllcyBvbiBpdCkuIERvIG5vdCB1c2UgdGhpcyBpbnRlcm5hbGx5LCBqdXN0IHVzZSBgY3VycmVudEluc3RhbmNlYC5cclxuICpcclxuICogQGludGVybmFsIHRoaXMgZnVuY3Rpb24gbmVlZHMgbWFudWFsIHR5cGUgZGVjbGFyYXRpb24gYmVjYXVzZSBpdCByZWxpZXNcclxuICogb24gcHJldmlvdXNseSBtYW51YWxseSBhdXRob3JlZCB0eXBlcyBmcm9tIFZ1ZSAyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDdXJyZW50SW5zdGFuY2UoKSB7XHJcbiAgICByZXR1cm4gY3VycmVudEluc3RhbmNlICYmIHsgcHJveHk6IGN1cnJlbnRJbnN0YW5jZSB9O1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRJbnN0YW5jZSh2bSkge1xyXG4gICAgaWYgKHZtID09PSB2b2lkIDApIHsgdm0gPSBudWxsOyB9XHJcbiAgICBpZiAoIXZtKVxyXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2UuX3Njb3BlLm9mZigpO1xyXG4gICAgY3VycmVudEluc3RhbmNlID0gdm07XHJcbiAgICB2bSAmJiB2bS5fc2NvcGUub24oKTtcclxufVxuXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgVk5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWTm9kZSh0YWcsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCBlbG0sIGNvbnRleHQsIGNvbXBvbmVudE9wdGlvbnMsIGFzeW5jRmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy5lbG0gPSBlbG07XHJcbiAgICAgICAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yYXcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNPbmNlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWTm9kZS5wcm90b3R5cGUsIFwiY2hpbGRcIiwge1xyXG4gICAgICAgIC8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gVk5vZGU7XHJcbn0oKSk7XHJcbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICAgIGlmICh0ZXh0ID09PSB2b2lkIDApIHsgdGV4dCA9ICcnOyB9XHJcbiAgICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xyXG4gICAgbm9kZS50ZXh0ID0gdGV4dDtcclxuICAgIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcclxuICAgIHJldHVybiBub2RlO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodmFsKSB7XHJcbiAgICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKTtcclxufVxyXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxyXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXHJcbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxyXG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxyXG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlKSB7XHJcbiAgICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKHZub2RlLnRhZywgdm5vZGUuZGF0YSwgXHJcbiAgICAvLyAjNzk3NVxyXG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXHJcbiAgICAvLyBhIGNoaWxkLlxyXG4gICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSwgdm5vZGUudGV4dCwgdm5vZGUuZWxtLCB2bm9kZS5jb250ZXh0LCB2bm9kZS5jb21wb25lbnRPcHRpb25zLCB2bm9kZS5hc3luY0ZhY3RvcnkpO1xyXG4gICAgY2xvbmVkLm5zID0gdm5vZGUubnM7XHJcbiAgICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcclxuICAgIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XHJcbiAgICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xyXG4gICAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcclxuICAgIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XHJcbiAgICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xyXG4gICAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcclxuICAgIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcblxudmFyIHVpZCQyID0gMDtcclxuLyoqXHJcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxyXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBEZXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZXAoKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IHVpZCQyKys7XHJcbiAgICAgICAgdGhpcy5zdWJzID0gW107XHJcbiAgICB9XHJcbiAgICBEZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcclxuICAgICAgICB0aGlzLnN1YnMucHVzaChzdWIpO1xyXG4gICAgfTtcclxuICAgIERlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gKHN1Yikge1xyXG4gICAgICAgIHJlbW92ZSQyKHRoaXMuc3Vicywgc3ViKTtcclxuICAgIH07XHJcbiAgICBEZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICAgICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGluZm8gJiYgRGVwLnRhcmdldC5vblRyYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBEZXAudGFyZ2V0Lm9uVHJhY2soX19hc3NpZ24oeyBlZmZlY3Q6IERlcC50YXJnZXQgfSwgaW5mbykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxyXG4gICAgICAgIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmZpZy5hc3luYykge1xyXG4gICAgICAgICAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcclxuICAgICAgICAgICAgLy8gb3JkZXJcclxuICAgICAgICAgICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW5mbykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IHN1YnNbaV07XHJcbiAgICAgICAgICAgICAgICBzdWIub25UcmlnZ2VyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViLm9uVHJpZ2dlcihfX2Fzc2lnbih7IGVmZmVjdDogc3Vic1tpXSB9LCBpbmZvKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3Vic1tpXS51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERlcDtcclxufSgpKTtcclxuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxyXG4vLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXHJcbkRlcC50YXJnZXQgPSBudWxsO1xyXG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcHVzaFRhcmdldCh0YXJnZXQpIHtcclxuICAgIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcclxuICAgIERlcC50YXJnZXQgPSB0YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gcG9wVGFyZ2V0KCkge1xyXG4gICAgdGFyZ2V0U3RhY2sucG9wKCk7XHJcbiAgICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XHJcbn1cblxuLypcclxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXHJcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxyXG4gKi9cclxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XHJcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xyXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXHJcbiAgICAncHVzaCcsXHJcbiAgICAncG9wJyxcclxuICAgICdzaGlmdCcsXHJcbiAgICAndW5zaGlmdCcsXHJcbiAgICAnc3BsaWNlJyxcclxuICAgICdzb3J0JyxcclxuICAgICdyZXZlcnNlJ1xyXG5dO1xyXG4vKipcclxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXHJcbiAqL1xyXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxyXG4gICAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xyXG4gICAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgdmFyIG9iID0gdGhpcy5fX29iX187XHJcbiAgICAgICAgdmFyIGluc2VydGVkO1xyXG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3B1c2gnOlxyXG4gICAgICAgICAgICBjYXNlICd1bnNoaWZ0JzpcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gYXJncztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdzcGxpY2UnOlxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnNlcnRlZClcclxuICAgICAgICAgICAgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTtcclxuICAgICAgICAvLyBub3RpZnkgY2hhbmdlXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgb2IuZGVwLm5vdGlmeSh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5IG11dGF0aW9uXCIgLyogVHJpZ2dlck9wVHlwZXMuQVJSQVlfTVVUQVRJT04gKi8sXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBrZXk6IG1ldGhvZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9iLmRlcC5ub3RpZnkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0pO1xyXG59KTtcblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XHJcbnZhciBOT19JTklJVElBTF9WQUxVRSA9IHt9O1xyXG4vKipcclxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXHJcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cclxuICovXHJcbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcclxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nKHZhbHVlKSB7XHJcbiAgICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XHJcbn1cclxuLy8gc3NyIG1vY2sgZGVwXHJcbnZhciBtb2NrRGVwID0ge1xyXG4gICAgbm90aWZ5OiBub29wLFxyXG4gICAgZGVwZW5kOiBub29wLFxyXG4gICAgYWRkU3ViOiBub29wLFxyXG4gICAgcmVtb3ZlU3ViOiBub29wXHJcbn07XHJcbi8qKlxyXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcclxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxyXG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxyXG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cclxuICovXHJcbnZhciBPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9ic2VydmVyKHZhbHVlLCBzaGFsbG93LCBtb2NrKSB7XHJcbiAgICAgICAgaWYgKHNoYWxsb3cgPT09IHZvaWQgMCkgeyBzaGFsbG93ID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAobW9jayA9PT0gdm9pZCAwKSB7IG1vY2sgPSBmYWxzZTsgfVxyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnNoYWxsb3cgPSBzaGFsbG93O1xyXG4gICAgICAgIHRoaXMubW9jayA9IG1vY2s7XHJcbiAgICAgICAgLy8gdGhpcy52YWx1ZSA9IHZhbHVlXHJcbiAgICAgICAgdGhpcy5kZXAgPSBtb2NrID8gbW9ja0RlcCA6IG5ldyBEZXAoKTtcclxuICAgICAgICB0aGlzLnZtQ291bnQgPSAwO1xyXG4gICAgICAgIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xyXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAoIW1vY2spIHtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNQcm90bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLl9fcHJvdG9fXyA9IGFycmF5TWV0aG9kcztcclxuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5S2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGFycmF5S2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmKHZhbHVlLCBrZXksIGFycmF5TWV0aG9kc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFzaGFsbG93KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXHJcbiAgICAgICAgICAgICAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxyXG4gICAgICAgICAgICAgKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUodmFsdWUsIGtleSwgTk9fSU5JSVRJQUxfVkFMVUUsIHVuZGVmaW5lZCwgc2hhbGxvdywgbW9jayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxyXG4gICAgICovXHJcbiAgICBPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZSh2YWx1ZVtpXSwgZmFsc2UsIHRoaXMubW9jayk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBPYnNlcnZlcjtcclxufSgpKTtcclxuLy8gaGVscGVyc1xyXG4vKipcclxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXHJcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXHJcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxyXG4gKi9cclxuZnVuY3Rpb24gb2JzZXJ2ZSh2YWx1ZSwgc2hhbGxvdywgc3NyTW9ja1JlYWN0aXZpdHkpIHtcclxuICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzUmVmKHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIG9iO1xyXG4gICAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XHJcbiAgICAgICAgb2IgPSB2YWx1ZS5fX29iX187XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzaG91bGRPYnNlcnZlICYmXHJcbiAgICAgICAgKHNzck1vY2tSZWFjdGl2aXR5IHx8ICFpc1NlcnZlclJlbmRlcmluZygpKSAmJlxyXG4gICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcclxuICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxyXG4gICAgICAgICF2YWx1ZS5fX3Zfc2tpcCAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi8pIHtcclxuICAgICAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSwgc2hhbGxvdywgc3NyTW9ja1JlYWN0aXZpdHkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iO1xyXG59XHJcbi8qKlxyXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZShvYmosIGtleSwgdmFsLCBjdXN0b21TZXR0ZXIsIHNoYWxsb3csIG1vY2spIHtcclxuICAgIHZhciBkZXAgPSBuZXcgRGVwKCk7XHJcbiAgICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcclxuICAgIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXHJcbiAgICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xyXG4gICAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcclxuICAgIGlmICgoIWdldHRlciB8fCBzZXR0ZXIpICYmXHJcbiAgICAgICAgKHZhbCA9PT0gTk9fSU5JSVRJQUxfVkFMVUUgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikpIHtcclxuICAgICAgICB2YWwgPSBvYmpba2V5XTtcclxuICAgIH1cclxuICAgIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwsIGZhbHNlLCBtb2NrKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIoKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XHJcbiAgICAgICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcC5kZXBlbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG9iaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkT2IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWYodmFsdWUpICYmICFzaGFsbG93ID8gdmFsdWUudmFsdWUgOiB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIobmV3VmFsKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XHJcbiAgICAgICAgICAgIGlmICghaGFzQ2hhbmdlZCh2YWx1ZSwgbmV3VmFsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tU2V0dGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNldHRlcikge1xyXG4gICAgICAgICAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGdldHRlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXNoYWxsb3cgJiYgaXNSZWYodmFsdWUpICYmICFpc1JlZihuZXdWYWwpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS52YWx1ZSA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwsIGZhbHNlLCBtb2NrKTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGRlcC5ub3RpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogb2JqLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlcC5ub3RpZnkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlcDtcclxufVxyXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbCkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKSkge1xyXG4gICAgICAgIHdhcm4oXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIi5jb25jYXQodGFyZ2V0KSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFwiU2V0IG9wZXJhdGlvbiBvbiBrZXkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5cIikpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBvYiA9IHRhcmdldC5fX29iX187XHJcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcclxuICAgICAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcclxuICAgICAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcclxuICAgICAgICAvLyB3aGVuIG1vY2tpbmcgZm9yIFNTUiwgYXJyYXkgbWV0aG9kcyBhcmUgbm90IGhpamFja2VkXHJcbiAgICAgICAgaWYgKG9iICYmICFvYi5zaGFsbG93ICYmIG9iLm1vY2spIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZSh2YWwsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICAgIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XHJcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgd2FybignQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXHJcbiAgICAgICAgICAgICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJyk7XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICAgIGlmICghb2IpIHtcclxuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG4gICAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsLCB1bmRlZmluZWQsIG9iLnNoYWxsb3csIG9iLm1vY2spO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBvYi5kZXAubm90aWZ5KHtcclxuICAgICAgICAgICAgdHlwZTogXCJhZGRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5BREQgKi8sXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgbmV3VmFsdWU6IHZhbCxcclxuICAgICAgICAgICAgb2xkVmFsdWU6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb2IuZGVwLm5vdGlmeSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufVxyXG5mdW5jdGlvbiBkZWwodGFyZ2V0LCBrZXkpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSkpIHtcclxuICAgICAgICB3YXJuKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIuY29uY2F0KHRhcmdldCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XHJcbiAgICAgICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBvYiA9IHRhcmdldC5fX29iX187XHJcbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4oJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXHJcbiAgICAgICAgICAgICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLicpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4oXCJEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LlwiKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlIHRhcmdldFtrZXldO1xyXG4gICAgaWYgKCFvYikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgb2IuZGVwLm5vdGlmeSh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAga2V5OiBrZXlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG9iLmRlcC5ub3RpZnkoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcclxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXBlbmRBcnJheSh2YWx1ZSkge1xyXG4gICAgZm9yICh2YXIgZSA9IHZvaWQgMCwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBlID0gdmFsdWVbaV07XHJcbiAgICAgICAgaWYgKGUgJiYgZS5fX29iX18pIHtcclxuICAgICAgICAgICAgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheShlKSkge1xyXG4gICAgICAgICAgICBkZXBlbmRBcnJheShlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICBtYWtlUmVhY3RpdmUodGFyZ2V0LCBmYWxzZSk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBzaGFsbG93bHktcmVhY3RpdmUgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290XHJcbiAqIGxldmVsIHByb3BlcnRpZXMgYXJlIHJlYWN0aXZlLiBJdCBhbHNvIGRvZXMgbm90IGF1dG8tdW53cmFwIHJlZnMgKGV2ZW4gYXQgdGhlXHJcbiAqIHJvb3QgbGV2ZWwpLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xyXG4gICAgbWFrZVJlYWN0aXZlKHRhcmdldCwgdHJ1ZSk7XHJcbiAgICBkZWYodGFyZ2V0LCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHRydWUpO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBtYWtlUmVhY3RpdmUodGFyZ2V0LCBzaGFsbG93KSB7XHJcbiAgICAvLyBpZiB0cnlpbmcgdG8gb2JzZXJ2ZSBhIHJlYWRvbmx5IHByb3h5LCByZXR1cm4gdGhlIHJlYWRvbmx5IHZlcnNpb24uXHJcbiAgICBpZiAoIWlzUmVhZG9ubHkodGFyZ2V0KSkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJBdm9pZCB1c2luZyBBcnJheSBhcyByb290IHZhbHVlIGZvciBcIi5jb25jYXQoc2hhbGxvdyA/IFwic2hhbGxvd1JlYWN0aXZlKClcIiA6IFwicmVhY3RpdmUoKVwiLCBcIiBhcyBpdCBjYW5ub3QgYmUgdHJhY2tlZCBpbiB3YXRjaCgpIG9yIHdhdGNoRWZmZWN0KCkuIFVzZSBcIikuY29uY2F0KHNoYWxsb3cgPyBcInNoYWxsb3dSZWYoKVwiIDogXCJyZWYoKVwiLCBcIiBpbnN0ZWFkLiBUaGlzIGlzIGEgVnVlLTItb25seSBsaW1pdGF0aW9uLlwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nT2IgPSB0YXJnZXQgJiYgdGFyZ2V0Ll9fb2JfXztcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nT2IgJiYgZXhpc3RpbmdPYi5zaGFsbG93ICE9PSBzaGFsbG93KSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwiVGFyZ2V0IGlzIGFscmVhZHkgYSBcIi5jb25jYXQoZXhpc3RpbmdPYi5zaGFsbG93ID8gXCJcIiA6IFwibm9uLVwiLCBcInNoYWxsb3cgcmVhY3RpdmUgb2JqZWN0LCBhbmQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBcIikuY29uY2F0KHNoYWxsb3cgPyBcIlwiIDogXCJub24tXCIsIFwic2hhbGxvdy5cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYiA9IG9ic2VydmUodGFyZ2V0LCBzaGFsbG93LCBpc1NlcnZlclJlbmRlcmluZygpIC8qIHNzciBtb2NrIHJlYWN0aXZpdHkgKi8pO1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFvYikge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihcInZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiBcIi5jb25jYXQoU3RyaW5nKHRhcmdldCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uVHlwZSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwiVnVlIDIgZG9lcyBub3Qgc3VwcG9ydCByZWFjdGl2ZSBjb2xsZWN0aW9uIHR5cGVzIHN1Y2ggYXMgTWFwIG9yIFNldC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dKTtcclxuICAgIH1cclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX29iX18pO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fdl9pc1NoYWxsb3cpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX3ZfaXNSZWFkb25seSk7XHJcbn1cclxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XHJcbiAgICB2YXIgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xyXG4gICAgcmV0dXJuIHJhdyA/IHRvUmF3KHJhdykgOiBvYnNlcnZlZDtcclxufVxyXG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XHJcbiAgICBkZWYodmFsdWUsIFwiX192X3NraXBcIiAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi8sIHRydWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGlzQ29sbGVjdGlvblR5cGUodmFsdWUpIHtcclxuICAgIHZhciB0eXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICAgIHJldHVybiAodHlwZSA9PT0gJ01hcCcgfHwgdHlwZSA9PT0gJ1dlYWtNYXAnIHx8IHR5cGUgPT09ICdTZXQnIHx8IHR5cGUgPT09ICdXZWFrU2V0Jyk7XHJcbn1cblxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIFJlZkZsYWcgPSBcIl9fdl9pc1JlZlwiO1xyXG5mdW5jdGlvbiBpc1JlZihyKSB7XHJcbiAgICByZXR1cm4gISEociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmJDEodmFsdWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIGZhbHNlKTtcclxufVxyXG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcclxuICAgIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcmF3VmFsdWU7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVmID0ge307XHJcbiAgICBkZWYocmVmLCBSZWZGbGFnLCB0cnVlKTtcclxuICAgIGRlZihyZWYsIFwiX192X2lzU2hhbGxvd1wiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfU0hBTExPVyAqLywgc2hhbGxvdyk7XHJcbiAgICBkZWYocmVmLCAnZGVwJywgZGVmaW5lUmVhY3RpdmUocmVmLCAndmFsdWUnLCByYXdWYWx1ZSwgbnVsbCwgc2hhbGxvdywgaXNTZXJ2ZXJSZW5kZXJpbmcoKSkpO1xyXG4gICAgcmV0dXJuIHJlZjtcclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZikge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXJlZi5kZXApIHtcclxuICAgICAgICB3YXJuKFwicmVjZWl2ZWQgb2JqZWN0IGlzIG5vdCBhIHRyaWdnZXJhYmxlIHJlZi5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHJlZi5kZXAgJiZcclxuICAgICAgICAgICAgcmVmLmRlcC5ub3RpZnkoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcclxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlZi5kZXAgJiYgcmVmLmRlcC5ub3RpZnkoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB1bnJlZihyZWYpIHtcclxuICAgIHJldHVybiBpc1JlZihyZWYpID8gcmVmLnZhbHVlIDogcmVmO1xyXG59XHJcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xyXG4gICAgaWYgKGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdFdpdGhSZWZzO1xyXG4gICAgfVxyXG4gICAgdmFyIHByb3h5ID0ge307XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdFdpdGhSZWZzKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgb2JqZWN0V2l0aFJlZnMsIGtleXNbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XHJcbmZ1bmN0aW9uIHByb3h5V2l0aFJlZlVud3JhcCh0YXJnZXQsIHNvdXJjZSwga2V5KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYiA9IHZhbCAmJiB2YWwuX19vYl9fO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iKVxyXG4gICAgICAgICAgICAgICAgICAgIG9iLmRlcC5kZXBlbmQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2Vba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcclxuICAgIHZhciBkZXAgPSBuZXcgRGVwKCk7XHJcbiAgICB2YXIgX2EgPSBmYWN0b3J5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBkZXAuZGVwZW5kKHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxyXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBkZXAubm90aWZ5KHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXHJcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZXAubm90aWZ5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIGdldCA9IF9hLmdldCwgc2V0ID0gX2Euc2V0O1xyXG4gICAgdmFyIHJlZiA9IHtcclxuICAgICAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICAgICAgc2V0KG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xyXG4gICAgcmV0dXJuIHJlZjtcclxufVxyXG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNSZWFjdGl2ZShvYmplY3QpKSB7XHJcbiAgICAgICAgd2FybihcInRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLlwiKTtcclxuICAgIH1cclxuICAgIHZhciByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgICByZXRba2V5XSA9IHRvUmVmKG9iamVjdCwga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xyXG4gICAgaWYgKGlzUmVmKHZhbCkpIHtcclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlZiA9IHtcclxuICAgICAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBvYmplY3Rba2V5XTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogdmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IG5ld1ZhbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZGVmKHJlZiwgUmVmRmxhZywgdHJ1ZSk7XHJcbiAgICByZXR1cm4gcmVmO1xyXG59XG5cbnZhciByYXdUb1JlYWRvbmx5RmxhZyA9IFwiX192X3Jhd1RvUmVhZG9ubHlcIjtcclxudmFyIHJhd1RvU2hhbGxvd1JlYWRvbmx5RmxhZyA9IFwiX192X3Jhd1RvU2hhbGxvd1JlYWRvbmx5XCI7XHJcbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRvbmx5KHRhcmdldCwgZmFsc2UpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5KHRhcmdldCwgc2hhbGxvdykge1xyXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHRhcmdldCkpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwiVnVlIDIgZG9lcyBub3Qgc3VwcG9ydCByZWFkb25seSBhcnJheXMuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ29sbGVjdGlvblR5cGUodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihcIlZ1ZSAyIGRvZXMgbm90IHN1cHBvcnQgcmVhZG9ubHkgY29sbGVjdGlvbiB0eXBlcyBzdWNoIGFzIE1hcCBvciBTZXQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2FybihcInZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWRvbmx5OiBcIi5jb25jYXQodHlwZW9mIHRhcmdldCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyBhbHJlYWR5IGEgcmVhZG9ubHkgb2JqZWN0XHJcbiAgICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIGFscmVhZHkgaGFzIGEgcmVhZG9ubHkgcHJveHlcclxuICAgIHZhciBleGlzdGluZ0ZsYWcgPSBzaGFsbG93ID8gcmF3VG9TaGFsbG93UmVhZG9ubHlGbGFnIDogcmF3VG9SZWFkb25seUZsYWc7XHJcbiAgICB2YXIgZXhpc3RpbmdQcm94eSA9IHRhcmdldFtleGlzdGluZ0ZsYWddO1xyXG4gICAgaWYgKGV4aXN0aW5nUHJveHkpIHtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcclxuICAgIH1cclxuICAgIHZhciBwcm94eSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpO1xyXG4gICAgZGVmKHRhcmdldCwgZXhpc3RpbmdGbGFnLCBwcm94eSk7XHJcbiAgICBkZWYocHJveHksIFwiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovLCB0cnVlKTtcclxuICAgIGRlZihwcm94eSwgXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi8sIHRhcmdldCk7XHJcbiAgICBpZiAoaXNSZWYodGFyZ2V0KSkge1xyXG4gICAgICAgIGRlZihwcm94eSwgUmVmRmxhZywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhbGxvdyB8fCBpc1NoYWxsb3codGFyZ2V0KSkge1xyXG4gICAgICAgIGRlZihwcm94eSwgXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovLCB0cnVlKTtcclxuICAgIH1cclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGRlZmluZVJlYWRvbmx5UHJvcGVydHkocHJveHksIHRhcmdldCwga2V5c1tpXSwgc2hhbGxvdyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lUmVhZG9ubHlQcm9wZXJ0eShwcm94eSwgdGFyZ2V0LCBrZXksIHNoYWxsb3cpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwga2V5LCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3cgfHwgIWlzUGxhaW5PYmplY3QodmFsKSA/IHZhbCA6IHJlYWRvbmx5KHZhbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihcIlNldCBvcGVyYXRpb24gb24ga2V5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHJlYWN0aXZlLWNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdCBsZXZlbFxyXG4gKiBwcm9wZXJ0aWVzIGFyZSByZWFkb25seSwgYW5kIGRvZXMgTk9UIHVud3JhcCByZWZzIG5vciByZWN1cnNpdmVseSBjb252ZXJ0XHJcbiAqIHJldHVybmVkIHByb3BlcnRpZXMuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpbmcgdGhlIHByb3BzIHByb3h5IG9iamVjdCBmb3Igc3RhdGVmdWwgY29tcG9uZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFkb25seSh0YXJnZXQsIHRydWUpO1xyXG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSB7XHJcbiAgICB2YXIgZ2V0dGVyO1xyXG4gICAgdmFyIHNldHRlcjtcclxuICAgIHZhciBvbmx5R2V0dGVyID0gaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpO1xyXG4gICAgaWYgKG9ubHlHZXR0ZXIpIHtcclxuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XHJcbiAgICAgICAgc2V0dGVyID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ1dyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBub29wO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcclxuICAgICAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xyXG4gICAgfVxyXG4gICAgdmFyIHdhdGNoZXIgPSBpc1NlcnZlclJlbmRlcmluZygpXHJcbiAgICAgICAgPyBudWxsXHJcbiAgICAgICAgOiBuZXcgV2F0Y2hlcihjdXJyZW50SW5zdGFuY2UsIGdldHRlciwgbm9vcCwgeyBsYXp5OiB0cnVlIH0pO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2F0Y2hlciAmJiBkZWJ1Z09wdGlvbnMpIHtcclxuICAgICAgICB3YXRjaGVyLm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcclxuICAgICAgICB3YXRjaGVyLm9uVHJpZ2dlciA9IGRlYnVnT3B0aW9ucy5vblRyaWdnZXI7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVmID0ge1xyXG4gICAgICAgIC8vIHNvbWUgbGlicyByZWx5IG9uIHRoZSBwcmVzZW5jZSBlZmZlY3QgZm9yIGNoZWNraW5nIGNvbXB1dGVkIHJlZnNcclxuICAgICAgICAvLyBmcm9tIG5vcm1hbCByZWZzLCBidXQgdGhlIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgbWF0dGVyXHJcbiAgICAgICAgZWZmZWN0OiB3YXRjaGVyLFxyXG4gICAgICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICAgICAgaWYgKHdhdGNoZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBEZXAudGFyZ2V0Lm9uVHJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVwLnRhcmdldC5vblRyYWNrKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdDogRGVwLnRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICAgICAgc2V0dGVyKG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xyXG4gICAgZGVmKHJlZiwgXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8sIG9ubHlHZXR0ZXIpO1xyXG4gICAgcmV0dXJuIHJlZjtcclxufVxuXG52YXIgV0FUQ0hFUiA9IFwid2F0Y2hlclwiO1xyXG52YXIgV0FUQ0hFUl9DQiA9IFwiXCIuY29uY2F0KFdBVENIRVIsIFwiIGNhbGxiYWNrXCIpO1xyXG52YXIgV0FUQ0hFUl9HRVRURVIgPSBcIlwiLmNvbmNhdChXQVRDSEVSLCBcIiBnZXR0ZXJcIik7XHJcbnZhciBXQVRDSEVSX0NMRUFOVVAgPSBcIlwiLmNvbmNhdChXQVRDSEVSLCBcIiBjbGVhbnVwXCIpO1xyXG4vLyBTaW1wbGUgZWZmZWN0LlxyXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gd2F0Y2hQb3N0RWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xyXG4gICAgICAgID8gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZsdXNoOiAncG9zdCcgfSkgOiB7IGZsdXNoOiAncG9zdCcgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoU3luY0VmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcclxuICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmbHVzaDogJ3N5bmMnIH0pIDogeyBmbHVzaDogJ3N5bmMnIH0pKTtcclxufVxyXG4vLyBpbml0aWFsIHZhbHVlIGZvciB3YXRjaGVycyB0byB0cmlnZ2VyIG9uIHVuZGVmaW5lZCBpbml0aWFsIHZhbHVlc1xyXG52YXIgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHdhcm4oXCJgd2F0Y2goZm4sIG9wdGlvbnM/KWAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBcIiArXHJcbiAgICAgICAgICAgIFwiVXNlIGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pYCBpbnN0ZWFkLiBgd2F0Y2hgIG5vdyBvbmx5IFwiICtcclxuICAgICAgICAgICAgXCJzdXBwb3J0cyBgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIF9hKSB7XHJcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8gZW1wdHlPYmplY3QgOiBfYSwgaW1tZWRpYXRlID0gX2IuaW1tZWRpYXRlLCBkZWVwID0gX2IuZGVlcCwgX2MgPSBfYi5mbHVzaCwgZmx1c2ggPSBfYyA9PT0gdm9pZCAwID8gJ3ByZScgOiBfYywgb25UcmFjayA9IF9iLm9uVHJhY2ssIG9uVHJpZ2dlciA9IF9iLm9uVHJpZ2dlcjtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKFwid2F0Y2goKSBcXFwiaW1tZWRpYXRlXFxcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJ3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZXAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKFwid2F0Y2goKSBcXFwiZGVlcFxcXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIFwiICtcclxuICAgICAgICAgICAgICAgIFwid2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHdhcm5JbnZhbGlkU291cmNlID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICB3YXJuKFwiSW52YWxpZCB3YXRjaCBzb3VyY2U6IFwiLmNvbmNhdChzLCBcIi4gQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IFwiKSArXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuXCIpO1xyXG4gICAgfTtcclxuICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIHZhciBjYWxsID0gZnVuY3Rpb24gKGZuLCB0eXBlLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbiwgbnVsbCwgYXJncywgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXR0ZXI7XHJcbiAgICB2YXIgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XHJcbiAgICB2YXIgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xyXG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2UudmFsdWU7IH07XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93KHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5fX29iX18uZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGVlcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICBpc011bHRpU291cmNlID0gdHJ1ZTtcclxuICAgICAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZShmdW5jdGlvbiAocykgeyByZXR1cm4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3cocyk7IH0pO1xyXG4gICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5tYXAoZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1JlZihzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbChzLCBXQVRDSEVSX0dFVFRFUik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5JbnZhbGlkU291cmNlKHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXHJcbiAgICAgICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGwoc291cmNlLCBXQVRDSEVSX0dFVFRFUik7IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyBjYiAtPiBzaW1wbGUgZWZmZWN0XHJcbiAgICAgICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsKHNvdXJjZSwgV0FUQ0hFUiwgW29uQ2xlYW51cF0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IG5vb3A7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNiICYmIGRlZXApIHtcclxuICAgICAgICB2YXIgYmFzZUdldHRlcl8xID0gZ2V0dGVyO1xyXG4gICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYXZlcnNlKGJhc2VHZXR0ZXJfMSgpKTsgfTtcclxuICAgIH1cclxuICAgIHZhciBjbGVhbnVwO1xyXG4gICAgdmFyIG9uQ2xlYW51cCA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIGNsZWFudXAgPSB3YXRjaGVyLm9uU3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2FsbChmbiwgV0FUQ0hFUl9DTEVBTlVQKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIGluIFNTUiB0aGVyZSBpcyBubyBuZWVkIHRvIHNldHVwIGFuIGFjdHVhbCBlZmZlY3QsIGFuZCBpdCBzaG91bGQgYmUgbm9vcFxyXG4gICAgLy8gdW5sZXNzIGl0J3MgZWFnZXJcclxuICAgIGlmIChpc1NlcnZlclJlbmRlcmluZygpKSB7XHJcbiAgICAgICAgLy8gd2Ugd2lsbCBhbHNvIG5vdCBjYWxsIHRoZSBpbnZhbGlkYXRlIGNhbGxiYWNrICgrIHJ1bm5lciBpcyBub3Qgc2V0IHVwKVxyXG4gICAgICAgIG9uQ2xlYW51cCA9IG5vb3A7XHJcbiAgICAgICAgaWYgKCFjYikge1xyXG4gICAgICAgICAgICBnZXR0ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGNhbGwoY2IsIFdBVENIRVJfQ0IsIFtcclxuICAgICAgICAgICAgICAgIGdldHRlcigpLFxyXG4gICAgICAgICAgICAgICAgaXNNdWx0aVNvdXJjZSA/IFtdIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgb25DbGVhbnVwXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgIH1cclxuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIoY3VycmVudEluc3RhbmNlLCBnZXR0ZXIsIG5vb3AsIHtcclxuICAgICAgICBsYXp5OiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHdhdGNoZXIubm9SZWN1cnNlID0gIWNiO1xyXG4gICAgdmFyIG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IFtdIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xyXG4gICAgLy8gb3ZlcndyaXRlIGRlZmF1bHQgcnVuXHJcbiAgICB3YXRjaGVyLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXdhdGNoZXIuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoKHNvdXJjZSwgY2IpXHJcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHdhdGNoZXIuZ2V0KCk7XHJcbiAgICAgICAgICAgIGlmIChkZWVwIHx8XHJcbiAgICAgICAgICAgICAgICBmb3JjZVRyaWdnZXIgfHxcclxuICAgICAgICAgICAgICAgIChpc011bHRpU291cmNlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZS5zb21lKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xlYW51cCBiZWZvcmUgcnVubmluZyBjYiBhZ2FpblxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsKGNiLCBXQVRDSEVSX0NCLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdW5kZWZpbmVkIDogb2xkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGVhbnVwXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoRWZmZWN0XHJcbiAgICAgICAgICAgIHdhdGNoZXIuZ2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XHJcbiAgICAgICAgd2F0Y2hlci51cGRhdGUgPSB3YXRjaGVyLnJ1bjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcclxuICAgICAgICB3YXRjaGVyLnBvc3QgPSB0cnVlO1xyXG4gICAgICAgIHdhdGNoZXIudXBkYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcXVldWVXYXRjaGVyKHdhdGNoZXIpOyB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gcHJlXHJcbiAgICAgICAgd2F0Y2hlci51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZSA9PT0gY3VycmVudEluc3RhbmNlICYmICFpbnN0YW5jZS5faXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmUtd2F0Y2hlciB0cmlnZ2VyZWQgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gaW5zdGFuY2UuX3ByZVdhdGNoZXJzIHx8IChpbnN0YW5jZS5fcHJlV2F0Y2hlcnMgPSBbXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmluZGV4T2Yod2F0Y2hlcikgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHdhdGNoZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcXVldWVXYXRjaGVyKHdhdGNoZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2F0Y2hlci5vblRyYWNrID0gb25UcmFjaztcclxuICAgICAgICB3YXRjaGVyLm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcclxuICAgIH1cclxuICAgIC8vIGluaXRpYWwgcnVuXHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIHdhdGNoZXIucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IHdhdGNoZXIuZ2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0JyAmJiBpbnN0YW5jZSkge1xyXG4gICAgICAgIGluc3RhbmNlLiRvbmNlKCdob29rOm1vdW50ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB3YXRjaGVyLmdldCgpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdhdGNoZXIuZ2V0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcclxuICAgIH07XHJcbn1cblxudmFyIGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG52YXIgRWZmZWN0U2NvcGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFZmZlY3RTY29wZShkZXRhY2hlZCkge1xyXG4gICAgICAgIGlmIChkZXRhY2hlZCA9PT0gdm9pZCAwKSB7IGRldGFjaGVkID0gZmFsc2U7IH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGVhbnVwcyA9IFtdO1xyXG4gICAgICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9XHJcbiAgICAgICAgICAgICAgICAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2godGhpcykgLSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEVmZmVjdFNjb3BlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCJjYW5ub3QgcnVuIGFuIGluYWN0aXZlIGVmZmVjdCBzY29wZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIEVmZmVjdFNjb3BlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgRWZmZWN0U2NvcGUucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xyXG4gICAgfTtcclxuICAgIEVmZmVjdFNjb3BlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGZyb21QYXJlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB2b2lkIDAsIGwgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdHNbaV0udGVhcmRvd24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5lc3RlZCBzY29wZSwgZGVyZWZlcmVuY2UgZnJvbSBwYXJlbnQgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkIE8oMSkgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnBhcmVudC5zY29wZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdID0gbGFzdDtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRWZmZWN0U2NvcGU7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XHJcbiAgICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlKSB7XHJcbiAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlOyB9XHJcbiAgICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XHJcbiAgICAgICAgc2NvcGUuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xyXG4gICAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG59XHJcbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuKSB7XHJcbiAgICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuKFwib25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlXCIgK1xyXG4gICAgICAgICAgICBcIiB0byBiZSBhc3NvY2lhdGVkIHdpdGguXCIpO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB3YXJuKFwicHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcclxuICAgICAgICByZXNvbHZlUHJvdmlkZWQoY3VycmVudEluc3RhbmNlKVtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVByb3ZpZGVkKHZtKSB7XHJcbiAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcclxuICAgIC8vIGJ1dCB3aGVuIGl0IG5lZWRzIHRvIHByb3ZpZGUgdmFsdWVzIG9mIGl0cyBvd24sIGl0IGNyZWF0ZXMgaXRzXHJcbiAgICAvLyBvd24gcHJvdmlkZXMgb2JqZWN0IHVzaW5nIHBhcmVudCBwcm92aWRlcyBvYmplY3QgYXMgcHJvdG90eXBlLlxyXG4gICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcclxuICAgIC8vIHBhcmVudCBhbmQgbGV0IHRoZSBwcm90b3R5cGUgY2hhaW4gZG8gdGhlIHdvcmsuXHJcbiAgICB2YXIgZXhpc3RpbmcgPSB2bS5fcHJvdmlkZWQ7XHJcbiAgICB2YXIgcGFyZW50UHJvdmlkZXMgPSB2bS4kcGFyZW50ICYmIHZtLiRwYXJlbnQuX3Byb3ZpZGVkO1xyXG4gICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBleGlzdGluZykge1xyXG4gICAgICAgIHJldHVybiAodm0uX3Byb3ZpZGVkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5KSB7XHJcbiAgICBpZiAodHJlYXREZWZhdWx0QXNGYWN0b3J5ID09PSB2b2lkIDApIHsgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2U7IH1cclxuICAgIC8vIGZhbGxiYWNrIHRvIGBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VgIHNvIHRoYXQgdGhpcyBjYW4gYmUgY2FsbGVkIGluXHJcbiAgICAvLyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbiAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAvLyAjMjQwMFxyXG4gICAgICAgIC8vIHRvIHN1cHBvcnQgYGFwcC51c2VgIHBsdWdpbnMsXHJcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwQ29udGV4dCdzIGBwcm92aWRlc2AgaWYgdGhlIGluc3RhbmNlIGlzIGF0IHJvb3RcclxuICAgICAgICB2YXIgcHJvdmlkZXMgPSBpbnN0YW5jZS4kcGFyZW50ICYmIGluc3RhbmNlLiRwYXJlbnQuX3Byb3ZpZGVkO1xyXG4gICAgICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UpXHJcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB3YXJuKFwiaW5qZWN0aW9uIFxcXCJcIi5jb25jYXQoU3RyaW5nKGtleSksIFwiXFxcIiBub3QgZm91bmQuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FybihcImluamVjdCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLlwiKTtcclxuICAgIH1cclxufVxuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcclxuICAgIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XHJcbiAgICB2YXIgb25jZSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcclxuICAgIG5hbWUgPSBvbmNlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XHJcbiAgICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XHJcbiAgICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgIG9uY2U6IG9uY2UsXHJcbiAgICAgICAgY2FwdHVyZTogY2FwdHVyZSxcclxuICAgICAgICBwYXNzaXZlOiBwYXNzaXZlXHJcbiAgICB9O1xyXG59KTtcclxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyKGZucywgdm0pIHtcclxuICAgIGZ1bmN0aW9uIGludm9rZXIoKSB7XHJcbiAgICAgICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xyXG4gICAgICAgIGlmIChpc0FycmF5KGZucykpIHtcclxuICAgICAgICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcclxuICAgICAgICAgICAgcmV0dXJuIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGZucywgbnVsbCwgYXJndW1lbnRzLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW52b2tlci5mbnMgPSBmbnM7XHJcbiAgICByZXR1cm4gaW52b2tlcjtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQsIHJlbW92ZSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKSB7XHJcbiAgICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xyXG4gICAgZm9yIChuYW1lIGluIG9uKSB7XHJcbiAgICAgICAgY3VyID0gb25bbmFtZV07XHJcbiAgICAgICAgb2xkID0gb2xkT25bbmFtZV07XHJcbiAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcclxuICAgICAgICBpZiAoaXNVbmRlZihjdXIpKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIi5jb25jYXQoZXZlbnQubmFtZSwgXCJcXFwiOiBnb3QgXCIpICsgU3RyaW5nKGN1ciksIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNUcnVlKGV2ZW50Lm9uY2UpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcclxuICAgICAgICAgICAgb2xkLmZucyA9IGN1cjtcclxuICAgICAgICAgICAgb25bbmFtZV0gPSBvbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChuYW1lIGluIG9sZE9uKSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XHJcbiAgICAgICAgICAgIHJlbW92ZShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rKGRlZiwgaG9va0tleSwgaG9vaykge1xyXG4gICAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XHJcbiAgICAgICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcclxuICAgIH1cclxuICAgIHZhciBpbnZva2VyO1xyXG4gICAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XHJcbiAgICBmdW5jdGlvbiB3cmFwcGVkSG9vaygpIHtcclxuICAgICAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxyXG4gICAgICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXHJcbiAgICAgICAgcmVtb3ZlJDIoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcclxuICAgIH1cclxuICAgIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XHJcbiAgICAgICAgLy8gbm8gZXhpc3RpbmcgaG9va1xyXG4gICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXHJcbiAgICAgICAgICAgIGludm9rZXIgPSBvbGRIb29rO1xyXG4gICAgICAgICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcclxuICAgICAgICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XHJcbiAgICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xyXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKSB7XHJcbiAgICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cclxuICAgIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxyXG4gICAgLy8gY29tcG9uZW50IGl0c2VsZi5cclxuICAgIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcclxuICAgIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciByZXMgPSB7fTtcclxuICAgIHZhciBhdHRycyA9IGRhdGEuYXR0cnMsIHByb3BzID0gZGF0YS5wcm9wcztcclxuICAgIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiYgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aXAoXCJQcm9wIFxcXCJcIi5jb25jYXQoa2V5SW5Mb3dlckNhc2UsIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIuY29uY2F0KGZvcm1hdENvbXBvbmVudE5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGFnIGlzIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcgfHwgQ3RvciksIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIuIFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIuY29uY2F0KGFsdEtleSwgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiKS5jb25jYXQoa2V5LCBcIlxcXCIuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XHJcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrUHJvcChyZXMsIGhhc2gsIGtleSwgYWx0S2V5LCBwcmVzZXJ2ZSkge1xyXG4gICAgaWYgKGlzRGVmKGhhc2gpKSB7XHJcbiAgICAgICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xyXG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xyXG4gICAgICAgICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcclxuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XHJcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXHJcbi8vXHJcbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXHJcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcclxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxyXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcclxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXHJcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxyXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXHJcbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xyXG59XHJcbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXHJcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXHJcbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxyXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xyXG4gICAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxyXG4gICAgICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXHJcbiAgICAgICAgOiBpc0FycmF5KGNoaWxkcmVuKVxyXG4gICAgICAgICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xyXG4gICAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcclxuICAgIHZhciByZXMgPSBbXTtcclxuICAgIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xyXG4gICAgICAgIC8vICBuZXN0ZWRcclxuICAgICAgICBpZiAoaXNBcnJheShjKSkge1xyXG4gICAgICAgICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCBcIlwiLmNvbmNhdChuZXN0ZWRJbmRleCB8fCAnJywgXCJfXCIpLmNvbmNhdChpKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgY1swXS50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBjLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXHJcbiAgICAgICAgICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIi5jb25jYXQobmVzdGVkSW5kZXgsIFwiX1wiKS5jb25jYXQoaSwgXCJfX1wiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlckxpc3QodmFsLCByZW5kZXIpIHtcclxuICAgIHZhciByZXQgPSBudWxsLCBpLCBsLCBrZXlzLCBrZXk7XHJcbiAgICBpZiAoaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xyXG4gICAgICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcclxuICAgICAgICAgICAgcmV0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcclxuICAgICAgICAgICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XHJcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNEZWYocmV0KSkge1xyXG4gICAgICAgIHJldCA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0Ll9pc1ZMaXN0ID0gdHJ1ZTtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTbG90KG5hbWUsIGZhbGxiYWNrUmVuZGVyLCBwcm9wcywgYmluZE9iamVjdCkge1xyXG4gICAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xyXG4gICAgdmFyIG5vZGVzO1xyXG4gICAgaWYgKHNjb3BlZFNsb3RGbikge1xyXG4gICAgICAgIC8vIHNjb3BlZCBzbG90XHJcbiAgICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcclxuICAgICAgICBpZiAoYmluZE9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGVzID1cclxuICAgICAgICAgICAgc2NvcGVkU2xvdEZuKHByb3BzKSB8fFxyXG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZmFsbGJhY2tSZW5kZXIpID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5vZGVzID1cclxuICAgICAgICAgICAgdGhpcy4kc2xvdHNbbmFtZV0gfHxcclxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZhbGxiYWNrUmVuZGVyKSA/IGZhbGxiYWNrUmVuZGVyKCkgOiBmYWxsYmFja1JlbmRlcik7XHJcbiAgICB9XHJcbiAgICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2Rlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlcihpZCkge1xyXG4gICAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eTtcclxufVxuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoKGV4cGVjdCwgYWN0dWFsKSB7XHJcbiAgICBpZiAoaXNBcnJheShleHBlY3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXHJcbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xyXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMoZXZlbnRLZXlDb2RlLCBrZXksIGJ1aWx0SW5LZXlDb2RlLCBldmVudEtleU5hbWUsIGJ1aWx0SW5LZXlOYW1lKSB7XHJcbiAgICB2YXIgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xyXG4gICAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcclxuICAgICAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcclxuICAgICAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRLZXlDb2RlID09PSB1bmRlZmluZWQ7XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMoZGF0YSwgdGFnLCB2YWx1ZSwgYXNQcm9wLCBpc1N5bmMpIHtcclxuICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gdm9pZCAwO1xyXG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnIHx8IGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoY2FtZWxpemVkS2V5IGluIGhhc2gpICYmICEoaHlwaGVuYXRlZEtleSBpbiBoYXNoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbltcInVwZGF0ZTpcIi5jb25jYXQoa2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMoaW5kZXgsIGlzSW5Gb3IpIHtcclxuICAgIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XHJcbiAgICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XHJcbiAgICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcclxuICAgIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxyXG4gICAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcclxuICAgICAgICByZXR1cm4gdHJlZTtcclxuICAgIH1cclxuICAgIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cclxuICAgIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHksIHRoaXMuX2MsIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcclxuICAgICk7XHJcbiAgICBtYXJrU3RhdGljKHRyZWUsIFwiX19zdGF0aWNfX1wiLmNvbmNhdChpbmRleCksIGZhbHNlKTtcclxuICAgIHJldHVybiB0cmVlO1xyXG59XHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxyXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cclxuICovXHJcbmZ1bmN0aW9uIG1hcmtPbmNlKHRyZWUsIGluZGV4LCBrZXkpIHtcclxuICAgIG1hcmtTdGF0aWModHJlZSwgXCJfX29uY2VfX1wiLmNvbmNhdChpbmRleCkuY29uY2F0KGtleSA/IFwiX1wiLmNvbmNhdChrZXkpIDogXCJcIiksIHRydWUpO1xyXG4gICAgcmV0dXJuIHRyZWU7XHJcbn1cclxuZnVuY3Rpb24gbWFya1N0YXRpYyh0cmVlLCBrZXksIGlzT25jZSkge1xyXG4gICAgaWYgKGlzQXJyYXkodHJlZSkpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCBcIlwiLmNvbmNhdChrZXksIFwiX1wiKS5jb25jYXQoaSksIGlzT25jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUobm9kZSwga2V5LCBpc09uY2UpIHtcclxuICAgIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgbm9kZS5rZXkgPSBrZXk7XHJcbiAgICBub2RlLmlzT25jZSA9IGlzT25jZTtcclxufVxuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzKGRhdGEsIHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgb24gPSAoZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge30pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyhmbnMsIHJlcywgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxyXG5oYXNEeW5hbWljS2V5cywgY29udGVudEhhc2hLZXkpIHtcclxuICAgIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgc2xvdCA9IGZuc1tpXTtcclxuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xyXG4gICAgICAgICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgaWYgKHNsb3QucHJveHkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjb250ZW50SGFzaEtleSkge1xyXG4gICAgICAgIHJlcy4ka2V5ID0gY29udGVudEhhc2hLZXk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XG5cbi8vIGhlbHBlciB0byBwcm9jZXNzIGR5bmFtaWMga2V5cyBmb3IgZHluYW1pYyBhcmd1bWVudHMgaW4gdi1iaW5kIGFuZCB2LW9uLlxyXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMoYmFzZU9iaiwgdmFsdWVzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xyXG4gICAgICAgICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIG51bGwgaXMgYSBzcGVjaWFsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xyXG4gICAgICAgICAgICB3YXJuKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIuY29uY2F0KGtleSksIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBiYXNlT2JqO1xyXG59XHJcbi8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxyXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxyXG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXHJcbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllcih2YWx1ZSwgc3ltYm9sKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWU7XHJcbn1cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnModGFyZ2V0KSB7XHJcbiAgICB0YXJnZXQuX28gPSBtYXJrT25jZTtcclxuICAgIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xyXG4gICAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XHJcbiAgICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xyXG4gICAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcclxuICAgIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XHJcbiAgICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XHJcbiAgICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XHJcbiAgICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xyXG4gICAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcclxuICAgIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcclxuICAgIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcclxuICAgIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XHJcbiAgICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XHJcbiAgICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xyXG4gICAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xyXG4gICAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xyXG59XG5cbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICB2YXIgc2xvdHMgPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xyXG4gICAgICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcclxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xyXG4gICAgICAgICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcclxuICAgICAgICAvLyBzYW1lIGNvbnRleHQuXHJcbiAgICAgICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcclxuICAgICAgICAgICAgZGF0YSAmJlxyXG4gICAgICAgICAgICBkYXRhLnNsb3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gZGF0YS5zbG90O1xyXG4gICAgICAgICAgICB2YXIgc2xvdCA9IHNsb3RzW25hbWVfMV0gfHwgKHNsb3RzW25hbWVfMV0gPSBbXSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgICAgICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXHJcbiAgICBmb3IgKHZhciBuYW1lXzIgaW4gc2xvdHMpIHtcclxuICAgICAgICBpZiAoc2xvdHNbbmFtZV8yXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzbG90c1tuYW1lXzJdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzbG90cztcclxufVxyXG5mdW5jdGlvbiBpc1doaXRlc3BhY2Uobm9kZSkge1xyXG4gICAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnO1xyXG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlcihub2RlKSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG5vdCByZWFsbHkgYm9vbGVhbiB0eXBlXHJcbiAgICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnk7XHJcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMob3duZXJWbSwgc2NvcGVkU2xvdHMsIG5vcm1hbFNsb3RzLCBwcmV2U2NvcGVkU2xvdHMpIHtcclxuICAgIHZhciByZXM7XHJcbiAgICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcclxuICAgIHZhciBpc1N0YWJsZSA9IHNjb3BlZFNsb3RzID8gISFzY29wZWRTbG90cy4kc3RhYmxlIDogIWhhc05vcm1hbFNsb3RzO1xyXG4gICAgdmFyIGtleSA9IHNjb3BlZFNsb3RzICYmIHNjb3BlZFNsb3RzLiRrZXk7XHJcbiAgICBpZiAoIXNjb3BlZFNsb3RzKSB7XHJcbiAgICAgICAgcmVzID0ge307XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzY29wZWRTbG90cy5fbm9ybWFsaXplZCkge1xyXG4gICAgICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxyXG4gICAgICAgIHJldHVybiBzY29wZWRTbG90cy5fbm9ybWFsaXplZDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3RhYmxlICYmXHJcbiAgICAgICAgcHJldlNjb3BlZFNsb3RzICYmXHJcbiAgICAgICAgcHJldlNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxyXG4gICAgICAgIGtleSA9PT0gcHJldlNjb3BlZFNsb3RzLiRrZXkgJiZcclxuICAgICAgICAhaGFzTm9ybWFsU2xvdHMgJiZcclxuICAgICAgICAhcHJldlNjb3BlZFNsb3RzLiRoYXNOb3JtYWwpIHtcclxuICAgICAgICAvLyBmYXN0IHBhdGggMjogc3RhYmxlIHNjb3BlZCBzbG90cyB3LyBubyBub3JtYWwgc2xvdHMgdG8gcHJveHksXHJcbiAgICAgICAgLy8gb25seSBuZWVkIHRvIG5vcm1hbGl6ZSBvbmNlXHJcbiAgICAgICAgcmV0dXJuIHByZXZTY29wZWRTbG90cztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlcyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGtleV8xIGluIHNjb3BlZFNsb3RzKSB7XHJcbiAgICAgICAgICAgIGlmIChzY29wZWRTbG90c1trZXlfMV0gJiYga2V5XzFbMF0gIT09ICckJykge1xyXG4gICAgICAgICAgICAgICAgcmVzW2tleV8xXSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qob3duZXJWbSwgbm9ybWFsU2xvdHMsIGtleV8xLCBzY29wZWRTbG90c1trZXlfMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xyXG4gICAgZm9yICh2YXIga2V5XzIgaW4gbm9ybWFsU2xvdHMpIHtcclxuICAgICAgICBpZiAoIShrZXlfMiBpbiByZXMpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXlfMl0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleV8yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XHJcbiAgICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcclxuICAgIGlmIChzY29wZWRTbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNjb3BlZFNsb3RzKSkge1xyXG4gICAgICAgIHNjb3BlZFNsb3RzLl9ub3JtYWxpemVkID0gcmVzO1xyXG4gICAgfVxyXG4gICAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XHJcbiAgICBkZWYocmVzLCAnJGtleScsIGtleSk7XHJcbiAgICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdCh2bSwgbm9ybWFsU2xvdHMsIGtleSwgZm4pIHtcclxuICAgIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXIgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHZtKTtcclxuICAgICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XHJcbiAgICAgICAgcmVzID1cclxuICAgICAgICAgICAgcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFpc0FycmF5KHJlcylcclxuICAgICAgICAgICAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XHJcbiAgICAgICAgdmFyIHZub2RlID0gcmVzICYmIHJlc1swXTtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3VyKTtcclxuICAgICAgICByZXR1cm4gcmVzICYmXHJcbiAgICAgICAgICAgICghdm5vZGUgfHxcclxuICAgICAgICAgICAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHZub2RlLmlzQ29tbWVudCAmJiAhaXNBc3luY1BsYWNlaG9sZGVyKHZub2RlKSkpIC8vICM5NjU4LCAjMTAzOTFcclxuICAgICAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICAgICAgOiByZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXHJcbiAgICAvLyBjb21waWxlZCBhcyBhIHNjb3BlZCBzbG90LCByZW5kZXIgZm4gdXNlcnMgd291bGQgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnRcclxuICAgIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxyXG4gICAgaWYgKGZuLnByb3h5KSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcclxuICAgICAgICAgICAgZ2V0OiBub3JtYWxpemVkLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG59XHJcbmZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfTtcclxufVxuXG5mdW5jdGlvbiBpbml0U2V0dXAodm0pIHtcclxuICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XHJcbiAgICB2YXIgc2V0dXAgPSBvcHRpb25zLnNldHVwO1xyXG4gICAgaWYgKHNldHVwKSB7XHJcbiAgICAgICAgdmFyIGN0eCA9ICh2bS5fc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KHZtKSk7XHJcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHZtKTtcclxuICAgICAgICBwdXNoVGFyZ2V0KCk7XHJcbiAgICAgICAgdmFyIHNldHVwUmVzdWx0ID0gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIG51bGwsIFt2bS5fcHJvcHMgfHwgc2hhbGxvd1JlYWN0aXZlKHt9KSwgY3R4XSwgdm0sIFwic2V0dXBcIik7XHJcbiAgICAgICAgcG9wVGFyZ2V0KCk7XHJcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIG9wdGlvbnMucmVuZGVyID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICAvLyBiaW5kaW5nc1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzZXR1cFJlc3VsdCBpbnN0YW5jZW9mIFZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwic2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJyZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdm0uX3NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICAgICAgLy8gX19zZmMgaW5kaWNhdGVzIGNvbXBpbGVkIGJpbmRpbmdzIGZyb20gPHNjcmlwdCBzZXR1cD5cclxuICAgICAgICAgICAgaWYgKCFzZXR1cFJlc3VsdC5fX3NmYykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNldHVwUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlXaXRoUmVmVW53cmFwKHZtLCBzZXR1cFJlc3VsdCwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiQXZvaWQgdXNpbmcgdmFyaWFibGVzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQgaW4gc2V0dXAoKS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlZCBmb3IgY29tcGlsZWQgcmVuZGVyIGZuXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSAodm0uX3NldHVwUHJveHkgPSB7fSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2V0dXBSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnX19zZmMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgc2V0dXBSZXN1bHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2V0dXBSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKFwic2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6IFwiLmNvbmNhdChzZXR1cFJlc3VsdCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBzZXR1cFJlc3VsdCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQodm0pIHtcclxuICAgIHZhciBleHBvc2VDYWxsZWQgPSBmYWxzZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICBpZiAoIXZtLl9hdHRyc1Byb3h5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSAodm0uX2F0dHJzUHJveHkgPSB7fSk7XHJcbiAgICAgICAgICAgICAgICBkZWYocHJveHksICdfdl9hdHRyX3Byb3h5JywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBzeW5jU2V0dXBQcm94eShwcm94eSwgdm0uJGF0dHJzLCBlbXB0eU9iamVjdCwgdm0sICckYXR0cnMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdm0uX2F0dHJzUHJveHk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgbGlzdGVuZXJzKCkge1xyXG4gICAgICAgICAgICBpZiAoIXZtLl9saXN0ZW5lcnNQcm94eSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3h5ID0gKHZtLl9saXN0ZW5lcnNQcm94eSA9IHt9KTtcclxuICAgICAgICAgICAgICAgIHN5bmNTZXR1cFByb3h5KHByb3h5LCB2bS4kbGlzdGVuZXJzLCBlbXB0eU9iamVjdCwgdm0sICckbGlzdGVuZXJzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZtLl9saXN0ZW5lcnNQcm94eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzbG90cygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluaXRTbG90c1Byb3h5KHZtKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVtaXQ6IGJpbmQodm0uJGVtaXQsIHZtKSxcclxuICAgICAgICBleHBvc2U6IGZ1bmN0aW9uIChleHBvc2VkKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3NlQ2FsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihcImV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLlwiLCB2bSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBvc2VDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChleHBvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhleHBvc2VkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlXaXRoUmVmVW53cmFwKHZtLCBleHBvc2VkLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNTZXR1cFByb3h5KHRvLCBmcm9tLCBwcmV2LCBpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHRvKSkge1xyXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZGVmaW5lUHJveHlBdHRyKHRvLCBrZXksIGluc3RhbmNlLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZnJvbVtrZXldICE9PSBwcmV2W2tleV0pIHtcclxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIHRvKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBkZWxldGUgdG9ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhbmdlZDtcclxufVxyXG5mdW5jdGlvbiBkZWZpbmVQcm94eUF0dHIocHJveHksIGtleSwgaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwga2V5LCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVt0eXBlXVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTbG90c1Byb3h5KHZtKSB7XHJcbiAgICBpZiAoIXZtLl9zbG90c1Byb3h5KSB7XHJcbiAgICAgICAgc3luY1NldHVwU2xvdHMoKHZtLl9zbG90c1Byb3h5ID0ge30pLCB2bS4kc2NvcGVkU2xvdHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZtLl9zbG90c1Byb3h5O1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNTZXR1cFNsb3RzKHRvLCBmcm9tKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xyXG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdG8pIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRvW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgdXNlIG1hbnVhbCB0eXBlIGRlZiBiZWNhdXNlIHB1YmxpYyBzZXR1cCBjb250ZXh0IHR5cGUgcmVsaWVzIG9uXHJcbiAqIGxlZ2FjeSBWTm9kZSB0eXBlc1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgdXNlIG1hbnVhbCB0eXBlIGRlZiBiZWNhdXNlIHB1YmxpYyBzZXR1cCBjb250ZXh0IHR5cGUgcmVsaWVzIG9uXHJcbiAqIGxlZ2FjeSBWTm9kZSB0eXBlc1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xyXG59XHJcbi8qKlxyXG4gKiBWdWUgMiBvbmx5XHJcbiAqIEBpbnRlcm5hbCB1c2UgbWFudWFsIHR5cGUgZGVmIGJlY2F1c2UgcHVibGljIHNldHVwIGNvbnRleHQgdHlwZSByZWxpZXMgb25cclxuICogbGVnYWN5IFZOb2RlIHR5cGVzXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VMaXN0ZW5lcnMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmxpc3RlbmVycztcclxufVxyXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHdhcm4oXCJ1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLlwiKTtcclxuICAgIH1cclxuICAgIHZhciB2bSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIHJldHVybiB2bS5fc2V0dXBDb250ZXh0IHx8ICh2bS5fc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KHZtKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIGRlZmF1bHQgZGVjbGFyYXRpb25zLiBJbXBvcnRlZCBieSBjb21waWxlZCBjb2RlXHJcbiAqIG9ubHkuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhyYXcsIGRlZmF1bHRzKSB7XHJcbiAgICB2YXIgcHJvcHMgPSBpc0FycmF5KHJhdylcclxuICAgICAgICA/IHJhdy5yZWR1Y2UoZnVuY3Rpb24gKG5vcm1hbGl6ZWQsIHApIHsgcmV0dXJuICgobm9ybWFsaXplZFtwXSA9IHt9KSwgbm9ybWFsaXplZCk7IH0sIHt9KVxyXG4gICAgICAgIDogcmF3O1xyXG4gICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IHByb3BzW2tleV07XHJcbiAgICAgICAgaWYgKG9wdCkge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgdHlwZTogb3B0LCBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB7IGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB3YXJuKFwicHJvcHMgZGVmYXVsdCBrZXkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBoYXMgbm8gY29ycmVzcG9uZGluZyBkZWNsYXJhdGlvbi5cIikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxuXG5mdW5jdGlvbiBpbml0UmVuZGVyKHZtKSB7XHJcbiAgICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxyXG4gICAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xyXG4gICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuICAgIHZhciBwYXJlbnRWbm9kZSA9ICh2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZSk7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXHJcbiAgICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XHJcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xyXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gcGFyZW50Vm5vZGVcclxuICAgICAgICA/IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHZtLiRwYXJlbnQsIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsIHZtLiRzbG90cylcclxuICAgICAgICA6IGVtcHR5T2JqZWN0O1xyXG4gICAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXHJcbiAgICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxyXG4gICAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxyXG4gICAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQkMSh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xyXG4gICAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXHJcbiAgICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQkMSh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XHJcbiAgICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxyXG4gICAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxyXG4gICAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCAocGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzKSB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcclxuICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCAocGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzKSB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcclxuICAgIH1cclxufVxyXG52YXIgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcclxuZnVuY3Rpb24gcmVuZGVyTWl4aW4oVnVlKSB7XHJcbiAgICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xyXG4gICAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XHJcbiAgICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9hID0gdm0uJG9wdGlvbnMsIHJlbmRlciA9IF9hLnJlbmRlciwgX3BhcmVudFZub2RlID0gX2EuX3BhcmVudFZub2RlO1xyXG4gICAgICAgIGlmIChfcGFyZW50Vm5vZGUgJiYgdm0uX2lzTW91bnRlZCkge1xyXG4gICAgICAgICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyh2bS4kcGFyZW50LCBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cywgdm0uJHNsb3RzLCB2bS4kc2NvcGVkU2xvdHMpO1xyXG4gICAgICAgICAgICBpZiAodm0uX3Nsb3RzUHJveHkpIHtcclxuICAgICAgICAgICAgICAgIHN5bmNTZXR1cFNsb3RzKHZtLl9zbG90c1Byb3h5LCB2bS4kc2NvcGVkU2xvdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcclxuICAgICAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cclxuICAgICAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XHJcbiAgICAgICAgLy8gcmVuZGVyIHNlbGZcclxuICAgICAgICB2YXIgdm5vZGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIG1haW50YWluIGEgc3RhY2sgYmVjYXVzZSBhbGwgcmVuZGVyIGZucyBhcmUgY2FsbGVkXHJcbiAgICAgICAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSBvbmUgYW5vdGhlci4gTmVzdGVkIGNvbXBvbmVudCdzIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxyXG4gICAgICAgICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cclxuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHZtKTtcclxuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gdm07XHJcbiAgICAgICAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXHJcbiAgICAgICAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XHJcbiAgICAgICAgaWYgKGlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICB2bm9kZSA9IHZub2RlWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XHJcbiAgICAgICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNBcnJheSh2bm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcclxuICAgICAgICAgICAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJywgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgcGFyZW50XHJcbiAgICAgICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gZW5zdXJlQ3Rvcihjb21wLCBiYXNlKSB7XHJcbiAgICBpZiAoY29tcC5fX2VzTW9kdWxlIHx8IChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJykpIHtcclxuICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbXApID8gYmFzZS5leHRlbmQoY29tcCkgOiBjb21wO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoZmFjdG9yeSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZykge1xyXG4gICAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XHJcbiAgICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGZhY3RvcnksIGJhc2VDdG9yKSB7XHJcbiAgICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xyXG4gICAgICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcDtcclxuICAgIH1cclxuICAgIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xyXG4gICAgICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkO1xyXG4gICAgfVxyXG4gICAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgaWYgKG93bmVyICYmIGlzRGVmKGZhY3Rvcnkub3duZXJzKSAmJiBmYWN0b3J5Lm93bmVycy5pbmRleE9mKG93bmVyKSA9PT0gLTEpIHtcclxuICAgICAgICAvLyBhbHJlYWR5IHBlbmRpbmdcclxuICAgICAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcclxuICAgIH1cclxuICAgIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xyXG4gICAgICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wO1xyXG4gICAgfVxyXG4gICAgaWYgKG93bmVyICYmICFpc0RlZihmYWN0b3J5Lm93bmVycykpIHtcclxuICAgICAgICB2YXIgb3duZXJzXzEgPSAoZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdKTtcclxuICAgICAgICB2YXIgc3luY18xID0gdHJ1ZTtcclxuICAgICAgICB2YXIgdGltZXJMb2FkaW5nXzEgPSBudWxsO1xyXG4gICAgICAgIHZhciB0aW1lclRpbWVvdXRfMSA9IG51bGw7XHJcbiAgICAgICAgb3duZXIuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZSQyKG93bmVyc18xLCBvd25lcik7IH0pO1xyXG4gICAgICAgIHZhciBmb3JjZVJlbmRlcl8xID0gZnVuY3Rpb24gKHJlbmRlckNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG93bmVyc18xLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgb3duZXJzXzFbaV0uJGZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgb3duZXJzXzEubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lckxvYWRpbmdfMSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lckxvYWRpbmdfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXJMb2FkaW5nXzEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyVGltZW91dF8xICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyVGltZW91dF8xKTtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lclRpbWVvdXRfMSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXHJcbiAgICAgICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xyXG4gICAgICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXHJcbiAgICAgICAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxyXG4gICAgICAgICAgICBpZiAoIXN5bmNfMSkge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXJfMSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG93bmVyc18xLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmVqZWN0XzEgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIuY29uY2F0KFN0cmluZyhmYWN0b3J5KSkgK1xyXG4gICAgICAgICAgICAgICAgICAgIChyZWFzb24gPyBcIlxcblJlYXNvbjogXCIuY29uY2F0KHJlYXNvbikgOiAnJykpO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyXzEodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmVzXzEgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdF8xKTtcclxuICAgICAgICBpZiAoaXNPYmplY3QocmVzXzEpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UocmVzXzEpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAoKSA9PiBQcm9taXNlXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc18xLnRoZW4ocmVzb2x2ZSwgcmVqZWN0XzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJvbWlzZShyZXNfMS5jb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXNfMS5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3RfMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYocmVzXzEuZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlc18xLmVycm9yLCBiYXNlQ3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYocmVzXzEubG9hZGluZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXNfMS5sb2FkaW5nLCBiYXNlQ3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc18xLmRlbGF5ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5vZGVKUyB0aW1lb3V0IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJMb2FkaW5nXzEgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZ18xID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyXzEoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZXNfMS5kZWxheSB8fCAyMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZihyZXNfMS50aW1lb3V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTm9kZUpTIHRpbWVvdXQgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyVGltZW91dF8xID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyVGltZW91dF8xID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdF8xKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBcInRpbWVvdXQgKFwiLmNvbmNhdChyZXNfMS50aW1lb3V0LCBcIm1zKVwiKSA6IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVzXzEudGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3luY18xID0gZmFsc2U7XHJcbiAgICAgICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxyXG4gICAgICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmcgPyBmYWN0b3J5LmxvYWRpbmdDb21wIDogZmFjdG9yeS5yZXNvbHZlZDtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkKGNoaWxkcmVuKSB7XHJcbiAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XHJcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcclxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2VcclxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMShjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplKSB7XHJcbiAgICBpZiAoaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xyXG4gICAgICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XHJcbiAgICAgICAgY2hpbGRyZW4gPSBkYXRhO1xyXG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcclxuICAgICAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKSB7XHJcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5fX29iX18pKSB7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICB3YXJuKFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGRhdGEpLCBcIlxcblwiKSArICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcclxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xyXG4gICAgICAgIHRhZyA9IGRhdGEuaXM7XHJcbiAgICB9XHJcbiAgICBpZiAoIXRhZykge1xyXG4gICAgICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcclxuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KSkge1xyXG4gICAgICAgIHdhcm4oJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcclxuICAgICAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJywgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XHJcbiAgICBpZiAoaXNBcnJheShjaGlsZHJlbikgJiYgaXNGdW5jdGlvbihjaGlsZHJlblswXSkpIHtcclxuICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcclxuICAgICAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xyXG4gICAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICB2YXIgdm5vZGUsIG5zO1xyXG4gICAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdmFyIEN0b3IgPSB2b2lkIDA7XHJcbiAgICAgICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcclxuICAgICAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xyXG4gICAgICAgICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgaXNEZWYoZGF0YSkgJiZcclxuICAgICAgICAgICAgICAgIGlzRGVmKGRhdGEubmF0aXZlT24pICYmXHJcbiAgICAgICAgICAgICAgICBkYXRhLnRhZyAhPT0gJ2NvbXBvbmVudCcpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJUaGUgLm5hdGl2ZSBtb2RpZmllciBmb3Igdi1vbiBpcyBvbmx5IHZhbGlkIG9uIGNvbXBvbmVudHMgYnV0IGl0IHdhcyB1c2VkIG9uIDxcIi5jb25jYXQodGFnLCBcIj4uXCIpLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2bm9kZSA9IG5ldyBWTm9kZShjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiZcclxuICAgICAgICAgICAgaXNEZWYoKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkpIHtcclxuICAgICAgICAgICAgLy8gY29tcG9uZW50XHJcbiAgICAgICAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXHJcbiAgICAgICAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIHZub2RlID0gbmV3IFZOb2RlKHRhZywgZGF0YSwgY2hpbGRyZW4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkodm5vZGUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKG5zKSlcclxuICAgICAgICAgICAgYXBwbHlOUyh2bm9kZSwgbnMpO1xyXG4gICAgICAgIGlmIChpc0RlZihkYXRhKSlcclxuICAgICAgICAgICAgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhcHBseU5TKHZub2RlLCBucywgZm9yY2UpIHtcclxuICAgIHZub2RlLm5zID0gbnM7XHJcbiAgICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcclxuICAgICAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcclxuICAgICAgICBucyA9IHVuZGVmaW5lZDtcclxuICAgICAgICBmb3JjZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmXHJcbiAgICAgICAgICAgICAgICAoaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XHJcbiAgICAgICAgICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIHJlZiAjNTMxOFxyXG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxyXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xyXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKSB7XHJcbiAgICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcclxuICAgICAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcclxuICAgIH1cclxuICAgIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xyXG4gICAgICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWwgdGhpcyBmdW5jdGlvbiBuZWVkcyBtYW51YWwgcHVibGljIHR5cGUgZGVjbGFyYXRpb24gYmVjYXVzZSBpdCByZWxpZXNcclxuICogb24gcHJldmlvdXNseSBtYW51YWxseSBhdXRob3JlZCB0eXBlcyBmcm9tIFZ1ZSAyXHJcbiAqL1xyXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xyXG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4oXCJnbG9iYWxseSBpbXBvcnRlZCBoKCkgY2FuIG9ubHkgYmUgaW52b2tlZCB3aGVuIHRoZXJlIGlzIGFuIGFjdGl2ZSBcIiArXHJcbiAgICAgICAgICAgICAgICBcImNvbXBvbmVudCBpbnN0YW5jZSwgZS5nLiBzeW5jaHJvbm91c2x5IGluIGEgY29tcG9uZW50J3MgcmVuZGVyIG9yIHNldHVwIGZ1bmN0aW9uLlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50JDEoY3VycmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcywgY2hpbGRyZW4sIDIsIHRydWUpO1xyXG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pIHtcclxuICAgIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxyXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxyXG4gICAgcHVzaFRhcmdldCgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodm0pIHtcclxuICAgICAgICAgICAgdmFyIGN1ciA9IHZtO1xyXG4gICAgICAgICAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgcG9wVGFyZ2V0KCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlciwgY29udGV4dCwgYXJncywgdm0sIGluZm8pIHtcclxuICAgIHZhciByZXM7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykgJiYgIXJlcy5faGFuZGxlZCkge1xyXG4gICAgICAgICAgICByZXMuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgXCIgKFByb21pc2UvYXN5bmMpXCIpOyB9KTtcclxuICAgICAgICAgICAgcmVzLl9oYW5kbGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbykge1xyXG4gICAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcclxuICAgICAgICAgICAgaWYgKGUgIT09IGVycikge1xyXG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xyXG59XHJcbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FybihcIkVycm9yIGluIFwiLmNvbmNhdChpbmZvLCBcIjogXFxcIlwiKS5jb25jYXQoZXJyLnRvU3RyaW5nKCksIFwiXFxcIlwiKSwgdm0pO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG59XG5cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xyXG52YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xyXG52YXIgY2FsbGJhY2tzID0gW107XHJcbnZhciBwZW5kaW5nID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzKCkge1xyXG4gICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb3BpZXNbaV0oKTtcclxuICAgIH1cclxufVxyXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIG1pY3JvdGFza3MuXHJcbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXHJcbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XHJcbi8vIChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxyXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcclxuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXHJcbi8vIFNvIHdlIG5vdyB1c2UgbWljcm90YXNrcyBldmVyeXdoZXJlLCBhZ2Fpbi5cclxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXHJcbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxyXG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTAsIHdoaWNoIGhhdmUgd29ya2Fyb3VuZHMpXHJcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxyXG52YXIgdGltZXJGdW5jO1xyXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxyXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cclxuLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXHJcbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XHJcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcclxuLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXHJcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcclxuICAgIHZhciBwXzEgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwXzEudGhlbihmbHVzaENhbGxiYWNrcyk7XHJcbiAgICAgICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XHJcbiAgICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXHJcbiAgICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcclxuICAgICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cclxuICAgICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cclxuICAgICAgICBpZiAoaXNJT1MpXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQobm9vcCk7XHJcbiAgICB9O1xyXG4gICAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XHJcbn1cclxuZWxzZSBpZiAoIWlzSUUgJiZcclxuICAgIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgKGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XHJcbiAgICAgICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XHJcbiAgICAgICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJykpIHtcclxuICAgIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXHJcbiAgICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcclxuICAgIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcclxuICAgIHZhciBjb3VudGVyXzEgPSAxO1xyXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xyXG4gICAgdmFyIHRleHROb2RlXzEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcl8xKSk7XHJcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlXzEsIHtcclxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb3VudGVyXzEgPSAoY291bnRlcl8xICsgMSkgJSAyO1xyXG4gICAgICAgIHRleHROb2RlXzEuZGF0YSA9IFN0cmluZyhjb3VudGVyXzEpO1xyXG4gICAgfTtcclxuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xyXG59XHJcbmVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcclxuICAgIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cclxuICAgIC8vIFRlY2huaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxyXG4gICAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXHJcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcclxuICAgIH07XHJcbn1cclxuZWxzZSB7XHJcbiAgICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxyXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXh0VGljayhjYiwgY3R4KSB7XHJcbiAgICB2YXIgX3Jlc29sdmU7XHJcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoX3Jlc29sdmUpIHtcclxuICAgICAgICAgICAgX3Jlc29sdmUoY3R4KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmICghcGVuZGluZykge1xyXG4gICAgICAgIHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRpbWVyRnVuYygpO1xyXG4gICAgfVxyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUpIHtcclxuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9ICckc3R5bGUnOyB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAge1xyXG4gICAgICAgIGlmICghY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcInVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9kID0gY3VycmVudEluc3RhbmNlW25hbWVdO1xyXG4gICAgICAgIGlmICghbW9kKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIi5cIikpO1xyXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBTRkMncyBDU1MgdmFyaWFibGUgaW5qZWN0aW9uIGZlYXR1cmUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xyXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWZhbHNlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4oXCJ1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5cIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgd2F0Y2hQb3N0RWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWwgPSBpbnN0YW5jZS4kZWw7XHJcbiAgICAgICAgdmFyIHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UsIGluc3RhbmNlLl9zZXR1cFByb3h5KTtcclxuICAgICAgICBpZiAoZWwgJiYgZWwubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YXJzKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShcIi0tXCIuY29uY2F0KGtleSksIHZhcnNba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogdjMtY29tcGF0aWJsZSBhc3luYyBjb21wb25lbnQgQVBJLlxyXG4gKiBAaW50ZXJuYWwgdGhlIHR5cGUgaXMgbWFudWFsbHkgZGVjbGFyZWQgaW4gPHJvb3Q+L3R5cGVzL3YzLWRlZmluZS1hc3luYy1jb21wb25lbnQuZC50c1xyXG4gKiBiZWNhdXNlIGl0IHJlbGllcyBvbiBleGlzdGluZyBtYW51YWwgdHlwZXNcclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcclxuICAgIH1cclxuICAgIHZhciBsb2FkZXIgPSBzb3VyY2UubG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50ID0gc291cmNlLmxvYWRpbmdDb21wb25lbnQsIGVycm9yQ29tcG9uZW50ID0gc291cmNlLmVycm9yQ29tcG9uZW50LCBfYSA9IHNvdXJjZS5kZWxheSwgZGVsYXkgPSBfYSA9PT0gdm9pZCAwID8gMjAwIDogX2EsIHRpbWVvdXQgPSBzb3VyY2UudGltZW91dCwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XHJcbiAgICBfYiA9IHNvdXJjZS5zdXNwZW5zaWJsZSwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XHJcbiAgICBzdXNwZW5zaWJsZSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCAvLyBpbiBWdWUgMyBkZWZhdWx0IGlzIHRydWVcclxuICAgIHVzZXJPbkVycm9yID0gc291cmNlLm9uRXJyb3I7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdXNwZW5zaWJsZSkge1xyXG4gICAgICAgIHdhcm4oXCJUaGUgc3VzcGVuc2libGJlIG9wdGlvbiBmb3IgYXN5bmMgY29tcG9uZW50cyBpcyBub3Qgc3VwcG9ydGVkIGluIFZ1ZTIuIEl0IGlzIGlnbm9yZWQuXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgIHZhciByZXRyaWVzID0gMDtcclxuICAgIHZhciByZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXRyaWVzKys7XHJcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBsb2FkKCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoaXNSZXF1ZXN0O1xyXG4gICAgICAgIHJldHVybiAocGVuZGluZ1JlcXVlc3QgfHxcclxuICAgICAgICAgICAgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPVxyXG4gICAgICAgICAgICAgICAgbG9hZGVyKClcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXNlck9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyUmV0cnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKHJldHJ5KCkpOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJGYWlsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0KGVycik7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZHVsZSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogXCIuY29uY2F0KGNvbXApKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XHJcbiAgICAgICAgICAgICAgICB9KSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IGxvYWQoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcclxuICAgICAgICAgICAgZGVsYXk6IGRlbGF5LFxyXG4gICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxyXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JDb21wb25lbnQsXHJcbiAgICAgICAgICAgIGxvYWRpbmc6IGxvYWRpbmdDb21wb25lbnRcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaWZlQ3ljbGUoaG9va05hbWUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZm4sIHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2U7IH1cclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKFwiXCIuY29uY2F0KGZvcm1hdE5hbWUoaG9va05hbWUpLCBcIiBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhc3NvY2lhdGVkIHdpdGguIFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIkxpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluamVjdEhvb2sodGFyZ2V0LCBob29rTmFtZSwgZm4pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmb3JtYXROYW1lKG5hbWUpIHtcclxuICAgIGlmIChuYW1lID09PSAnYmVmb3JlRGVzdHJveScpIHtcclxuICAgICAgICBuYW1lID0gJ2JlZm9yZVVubW91bnQnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2Rlc3Ryb3llZCcpIHtcclxuICAgICAgICBuYW1lID0gJ3VubW91bnRlZCc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJvblwiLmNvbmNhdChuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKTtcclxufVxyXG5mdW5jdGlvbiBpbmplY3RIb29rKGluc3RhbmNlLCBob29rTmFtZSwgZm4pIHtcclxuICAgIHZhciBvcHRpb25zID0gaW5zdGFuY2UuJG9wdGlvbnM7XHJcbiAgICBvcHRpb25zW2hvb2tOYW1lXSA9IG1lcmdlTGlmZWN5Y2xlSG9vayhvcHRpb25zW2hvb2tOYW1lXSwgZm4pO1xyXG59XHJcbnZhciBvbkJlZm9yZU1vdW50ID0gY3JlYXRlTGlmZUN5Y2xlKCdiZWZvcmVNb3VudCcpO1xyXG52YXIgb25Nb3VudGVkID0gY3JlYXRlTGlmZUN5Y2xlKCdtb3VudGVkJyk7XHJcbnZhciBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUxpZmVDeWNsZSgnYmVmb3JlVXBkYXRlJyk7XHJcbnZhciBvblVwZGF0ZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ3VwZGF0ZWQnKTtcclxudmFyIG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUxpZmVDeWNsZSgnYmVmb3JlRGVzdHJveScpO1xyXG52YXIgb25Vbm1vdW50ZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2Rlc3Ryb3llZCcpO1xyXG52YXIgb25BY3RpdmF0ZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2FjdGl2YXRlZCcpO1xyXG52YXIgb25EZWFjdGl2YXRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnZGVhY3RpdmF0ZWQnKTtcclxudmFyIG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVMaWZlQ3ljbGUoJ3NlcnZlclByZWZldGNoJyk7XHJcbnZhciBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ3JlbmRlclRyYWNrZWQnKTtcclxudmFyIG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlTGlmZUN5Y2xlKCdyZW5kZXJUcmlnZ2VyZWQnKTtcclxudmFyIGluamVjdEVycm9yQ2FwdHVyZWRIb29rID0gY3JlYXRlTGlmZUN5Y2xlKCdlcnJvckNhcHR1cmVkJyk7XHJcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQpIHtcclxuICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2U7IH1cclxuICAgIGluamVjdEVycm9yQ2FwdHVyZWRIb29rKGhvb2ssIHRhcmdldCk7XHJcbn1cblxuLyoqXHJcbiAqIE5vdGU6IGFsc28gdXBkYXRlIGRpc3QvdnVlLnJ1bnRpbWUubWpzIHdoZW4gYWRkaW5nIG5ldyBleHBvcnRzIHRvIHRoaXMgZmlsZS5cclxuICovXHJcbnZhciB2ZXJzaW9uID0gJzIuNy45JztcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCB0eXBlIGlzIG1hbnVhbGx5IGRlY2xhcmVkIGluIDxyb290Pi90eXBlcy92My1kZWZpbmUtY29tcG9uZW50LmQudHNcclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxufVxuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xyXG4vKipcclxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcclxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcclxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbCkge1xyXG4gICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xyXG4gICAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuZnVuY3Rpb24gX3RyYXZlcnNlKHZhbCwgc2Vlbikge1xyXG4gICAgdmFyIGksIGtleXM7XHJcbiAgICB2YXIgaXNBID0gaXNBcnJheSh2YWwpO1xyXG4gICAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fFxyXG4gICAgICAgIE9iamVjdC5pc0Zyb3plbih2YWwpIHx8XHJcbiAgICAgICAgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodmFsLl9fb2JfXykge1xyXG4gICAgICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xyXG4gICAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWVuLmFkZChkZXBJZCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBKSB7XHJcbiAgICAgICAgaSA9IHZhbC5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlZih2YWwpKSB7XHJcbiAgICAgICAgX3RyYXZlcnNlKHZhbC52YWx1ZSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcclxuICAgICAgICBpID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7XHJcbiAgICB9XHJcbn1cblxudmFyIHVpZCQxID0gMDtcclxuLyoqXHJcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxyXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgV2F0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zLCBpc1JlbmRlcldhdGNoZXIpIHtcclxuICAgICAgICByZWNvcmRFZmZlY3RTY29wZSh0aGlzLCBcclxuICAgICAgICAvLyBpZiB0aGUgYWN0aXZlIGVmZmVjdCBzY29wZSBpcyBtYW51YWxseSBjcmVhdGVkIChub3QgYSBjb21wb25lbnQgc2NvcGUpLFxyXG4gICAgICAgIC8vIHByaW9yaXRpemUgaXRcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSAmJiAhYWN0aXZlRWZmZWN0U2NvcGUuX3ZtXHJcbiAgICAgICAgICAgID8gYWN0aXZlRWZmZWN0U2NvcGVcclxuICAgICAgICAgICAgOiB2bVxyXG4gICAgICAgICAgICAgICAgPyB2bS5fc2NvcGVcclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcclxuICAgICAgICBpZiAoKHRoaXMudm0gPSB2bSkgJiYgaXNSZW5kZXJXYXRjaGVyKSB7XHJcbiAgICAgICAgICAgIHZtLl93YXRjaGVyID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3B0aW9uc1xyXG4gICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xyXG4gICAgICAgICAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcclxuICAgICAgICAgICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XHJcbiAgICAgICAgICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xyXG4gICAgICAgICAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYWNrID0gb3B0aW9ucy5vblRyYWNrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblRyaWdnZXIgPSBvcHRpb25zLm9uVHJpZ2dlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2IgPSBjYjtcclxuICAgICAgICB0aGlzLmlkID0gKyt1aWQkMTsgLy8gdWlkIGZvciBiYXRjaGluZ1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnBvc3QgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xyXG4gICAgICAgIHRoaXMuZGVwcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmV3RGVwcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcclxuICAgICAgICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XHJcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGV4cE9yRm4udG9TdHJpbmcoKSA6ICcnO1xyXG4gICAgICAgIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGV4cE9yRm4pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldHRlciA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIuY29uY2F0KGV4cE9yRm4sIFwiXFxcIiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2V0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cclxuICAgICAqL1xyXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHB1c2hUYXJnZXQodGhpcyk7XHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXMudm07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXIpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIuY29uY2F0KHRoaXMuZXhwcmVzc2lvbiwgXCJcXFwiXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xyXG4gICAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVlcCkge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvcFRhcmdldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFudXBEZXBzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIChkZXApIHtcclxuICAgICAgICB2YXIgaWQgPSBkZXAuaWQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XHJcbiAgICAgICAgICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV07XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcclxuICAgICAgICAgICAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xyXG4gICAgICAgIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XHJcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XHJcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcclxuICAgICAgICB0bXAgPSB0aGlzLmRlcHM7XHJcbiAgICAgICAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xyXG4gICAgICAgIHRoaXMubmV3RGVwcyA9IHRtcDtcclxuICAgICAgICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxyXG4gICAgICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgaWYgKHRoaXMubGF6eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zeW5jKSB7XHJcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXHJcbiAgICAgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxyXG4gICAgICovXHJcbiAgICBXYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIG11dGF0ZWQuXHJcbiAgICAgICAgICAgICAgICBpc09iamVjdCh2YWx1ZSkgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVlcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiLmNvbmNhdCh0aGlzLmV4cHJlc3Npb24sIFwiXFxcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyh0aGlzLmNiLCB0aGlzLnZtLCBbdmFsdWUsIG9sZFZhbHVlXSwgdGhpcy52bSwgaW5mbyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cclxuICAgICAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cclxuICAgICAqL1xyXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZtICYmICF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZSQyKHRoaXMudm0uX3Njb3BlLmVmZmVjdHMsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU3RvcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gV2F0Y2hlcjtcclxufSgpKTtcblxudmFyIG1hcms7XHJcbnZhciBtZWFzdXJlO1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgdmFyIHBlcmZfMSA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChwZXJmXzEgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgcGVyZl8xLm1hcmsgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgcGVyZl8xLm1lYXN1cmUgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgcGVyZl8xLmNsZWFyTWFya3MgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgcGVyZl8xLmNsZWFyTWVhc3VyZXMpIHtcclxuICAgICAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZl8xLm1hcmsodGFnKTsgfTtcclxuICAgICAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcclxuICAgICAgICAgICAgcGVyZl8xLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgICAgIHBlcmZfMS5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcclxuICAgICAgICAgICAgcGVyZl8xLmNsZWFyTWFya3MoZW5kVGFnKTtcclxuICAgICAgICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBpbml0RXZlbnRzKHZtKSB7XHJcbiAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcclxuICAgIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xyXG4gICAgfVxyXG59XHJcbnZhciB0YXJnZXQkMTtcclxuZnVuY3Rpb24gYWRkJDEoZXZlbnQsIGZuKSB7XHJcbiAgICB0YXJnZXQkMS4kb24oZXZlbnQsIGZuKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmUkMShldmVudCwgZm4pIHtcclxuICAgIHRhcmdldCQxLiRvZmYoZXZlbnQsIGZuKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciQxKGV2ZW50LCBmbikge1xyXG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlcigpIHtcclxuICAgICAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycykge1xyXG4gICAgdGFyZ2V0JDEgPSB2bTtcclxuICAgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkJDEsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bSk7XHJcbiAgICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBldmVudHNNaXhpbihWdWUpIHtcclxuICAgIHZhciBob29rUkUgPSAvXmhvb2s6LztcclxuICAgIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XHJcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxyXG4gICAgICAgICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm07XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgICAgIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgICAgICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvbi5mbiA9IGZuO1xyXG4gICAgICAgIHZtLiRvbihldmVudCwgb24pO1xyXG4gICAgICAgIHJldHVybiB2bTtcclxuICAgIH07XHJcbiAgICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XHJcbiAgICAgICAgdmFyIHZtID0gdGhpcztcclxuICAgICAgICAvLyBhbGxcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXJyYXkgb2YgZXZlbnRzXHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGlfMSA8IGw7IGlfMSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2bS4kb2ZmKGV2ZW50W2lfMV0sIGZuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdm07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgICAgICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xyXG4gICAgICAgIGlmICghY2JzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmbikge1xyXG4gICAgICAgICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxyXG4gICAgICAgIHZhciBjYjtcclxuICAgICAgICB2YXIgaSA9IGNicy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBjYiA9IGNic1tpXTtcclxuICAgICAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgICAgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm07XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xyXG4gICAgICAgICAgICAgICAgdGlwKFwiRXZlbnQgXFxcIlwiLmNvbmNhdChsb3dlckNhc2VFdmVudCwgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJcIi5jb25jYXQoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSksIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIpLmNvbmNhdChldmVudCwgXCJcXFwiLiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIi5jb25jYXQoaHlwaGVuYXRlKGV2ZW50KSwgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiKS5jb25jYXQoZXZlbnQsIFwiXFxcIi5cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcclxuICAgICAgICBpZiAoY2JzKSB7XHJcbiAgICAgICAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIi5jb25jYXQoZXZlbnQsIFwiXFxcIlwiKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZtO1xyXG4gICAgfTtcclxufVxuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xyXG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XHJcbmZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XHJcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XHJcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSh2bSkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuICAgIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XHJcbiAgICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XHJcbiAgICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcclxuICAgIH1cclxuICAgIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xyXG4gICAgdm0uJGNoaWxkcmVuID0gW107XHJcbiAgICB2bS4kcmVmcyA9IHt9O1xyXG4gICAgdm0uX3Byb3ZpZGVkID0gcGFyZW50ID8gcGFyZW50Ll9wcm92aWRlZCA6IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB2bS5fd2F0Y2hlciA9IG51bGw7XHJcbiAgICB2bS5faW5hY3RpdmUgPSBudWxsO1xyXG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XHJcbiAgICB2bS5faXNNb3VudGVkID0gZmFsc2U7XHJcbiAgICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcclxuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4oVnVlKSB7XHJcbiAgICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcclxuICAgICAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xyXG4gICAgICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XHJcbiAgICAgICAgdm0uX3Zub2RlID0gdm5vZGU7XHJcbiAgICAgICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXHJcbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXHJcbiAgICAgICAgaWYgKCFwcmV2Vm5vZGUpIHtcclxuICAgICAgICAgICAgLy8gaW5pdGlhbCByZW5kZXJcclxuICAgICAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGVzXHJcbiAgICAgICAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XHJcbiAgICAgICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXHJcbiAgICAgICAgaWYgKHByZXZFbCkge1xyXG4gICAgICAgICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2bS4kZWwpIHtcclxuICAgICAgICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxyXG4gICAgICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XHJcbiAgICAgICAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXHJcbiAgICAgICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cclxuICAgIH07XHJcbiAgICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xyXG4gICAgICAgICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxIb29rJDEodm0sICdiZWZvcmVEZXN0cm95Jyk7XHJcbiAgICAgICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xyXG4gICAgICAgICAgICByZW1vdmUkMihwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRlYXJkb3duIHNjb3BlLiB0aGlzIGluY2x1ZGVzIGJvdGggdGhlIHJlbmRlciB3YXRjaGVyIGFuZCBvdGhlclxyXG4gICAgICAgIC8vIHdhdGNoZXJzIGNyZWF0ZWRcclxuICAgICAgICB2bS5fc2NvcGUuc3RvcCgpO1xyXG4gICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXHJcbiAgICAgICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXHJcbiAgICAgICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xyXG4gICAgICAgICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cclxuICAgICAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxyXG4gICAgICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xyXG4gICAgICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcclxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnZGVzdHJveWVkJyk7XHJcbiAgICAgICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cclxuICAgICAgICB2bS4kb2ZmKCk7XHJcbiAgICAgICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXHJcbiAgICAgICAgaWYgKHZtLiRlbCkge1xyXG4gICAgICAgICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcclxuICAgICAgICBpZiAodm0uJHZub2RlKSB7XHJcbiAgICAgICAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQodm0sIGVsLCBoeWRyYXRpbmcpIHtcclxuICAgIHZtLiRlbCA9IGVsO1xyXG4gICAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGludmFsaWQgdHlwZVxyXG4gICAgICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XHJcbiAgICAgICAgICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fFxyXG4gICAgICAgICAgICAgICAgZWwpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYWxsSG9vayQxKHZtLCAnYmVmb3JlTW91bnQnKTtcclxuICAgIHZhciB1cGRhdGVDb21wb25lbnQ7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XHJcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xyXG4gICAgICAgICAgICB2YXIgaWQgPSB2bS5fdWlkO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiLmNvbmNhdChpZCk7XHJcbiAgICAgICAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIi5jb25jYXQoaWQpO1xyXG4gICAgICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcclxuICAgICAgICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xyXG4gICAgICAgICAgICBtYXJrKGVuZFRhZyk7XHJcbiAgICAgICAgICAgIG1lYXN1cmUoXCJ2dWUgXCIuY29uY2F0KG5hbWUsIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgICAgIG1hcmsoc3RhcnRUYWcpO1xyXG4gICAgICAgICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xyXG4gICAgICAgICAgICBtYXJrKGVuZFRhZyk7XHJcbiAgICAgICAgICAgIG1lYXN1cmUoXCJ2dWUgXCIuY29uY2F0KG5hbWUsIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHdhdGNoZXJPcHRpb25zID0ge1xyXG4gICAgICAgIGJlZm9yZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsSG9vayQxKHZtLCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXRjaGVyT3B0aW9ucy5vblRyYWNrID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNhbGxIb29rJDEodm0sICdyZW5kZXJUcmFja2VkJywgW2VdKTsgfTtcclxuICAgICAgICB3YXRjaGVyT3B0aW9ucy5vblRyaWdnZXIgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gY2FsbEhvb2skMSh2bSwgJ3JlbmRlclRyaWdnZXJlZCcsIFtlXSk7IH07XHJcbiAgICB9XHJcbiAgICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxyXG4gICAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcclxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcclxuICAgIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHdhdGNoZXJPcHRpb25zLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XHJcbiAgICBoeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgIC8vIGZsdXNoIGJ1ZmZlciBmb3IgZmx1c2g6IFwicHJlXCIgd2F0Y2hlcnMgcXVldWVkIGluIHNldHVwKClcclxuICAgIHZhciBwcmVXYXRjaGVycyA9IHZtLl9wcmVXYXRjaGVycztcclxuICAgIGlmIChwcmVXYXRjaGVycykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlV2F0Y2hlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcHJlV2F0Y2hlcnNbaV0ucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcclxuICAgIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXHJcbiAgICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcclxuICAgICAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnbW91bnRlZCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZtO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50KHZtLCBwcm9wc0RhdGEsIGxpc3RlbmVycywgcGFyZW50Vm5vZGUsIHJlbmRlckNoaWxkcmVuKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cclxuICAgIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxyXG4gICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxyXG4gICAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcclxuICAgIC8vIFwiJHN0YWJsZVwiIG1hcmtlci5cclxuICAgIHZhciBuZXdTY29wZWRTbG90cyA9IHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XHJcbiAgICB2YXIgb2xkU2NvcGVkU2xvdHMgPSB2bS4kc2NvcGVkU2xvdHM7XHJcbiAgICB2YXIgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhISgobmV3U2NvcGVkU2xvdHMgJiYgIW5ld1Njb3BlZFNsb3RzLiRzdGFibGUpIHx8XHJcbiAgICAgICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcclxuICAgICAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpIHx8XHJcbiAgICAgICAgKCFuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSkpO1xyXG4gICAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xyXG4gICAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXHJcbiAgICAvLyB1cGRhdGUgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBjb3JyZWN0bmVzcy5cclxuICAgIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEocmVuZGVyQ2hpbGRyZW4gfHwgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcclxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcclxuICAgICAgICBoYXNEeW5hbWljU2NvcGVkU2xvdCk7XHJcbiAgICB2YXIgcHJldlZOb2RlID0gdm0uJHZub2RlO1xyXG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XHJcbiAgICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxyXG4gICAgaWYgKHZtLl92bm9kZSkge1xyXG4gICAgICAgIC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XHJcbiAgICAgICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xyXG4gICAgfVxyXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XHJcbiAgICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcclxuICAgIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxyXG4gICAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcclxuICAgIHZhciBhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XHJcbiAgICBpZiAodm0uX2F0dHJzUHJveHkpIHtcclxuICAgICAgICAvLyBmb3JjZSB1cGRhdGUgaWYgYXR0cnMgYXJlIGFjY2Vzc2VkIGFuZCBoYXMgY2hhbmdlZCBzaW5jZSBpdCBtYXkgYmVcclxuICAgICAgICAvLyBwYXNzZWQgdG8gYSBjaGlsZCBjb21wb25lbnQuXHJcbiAgICAgICAgaWYgKHN5bmNTZXR1cFByb3h5KHZtLl9hdHRyc1Byb3h5LCBhdHRycywgKHByZXZWTm9kZS5kYXRhICYmIHByZXZWTm9kZS5kYXRhLmF0dHJzKSB8fCBlbXB0eU9iamVjdCwgdm0sICckYXR0cnMnKSkge1xyXG4gICAgICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2bS4kYXR0cnMgPSBhdHRycztcclxuICAgIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcclxuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcclxuICAgIHZhciBwcmV2TGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcclxuICAgIGlmICh2bS5fbGlzdGVuZXJzUHJveHkpIHtcclxuICAgICAgICBzeW5jU2V0dXBQcm94eSh2bS5fbGlzdGVuZXJzUHJveHksIGxpc3RlbmVycywgcHJldkxpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgdm0sICckbGlzdGVuZXJzJyk7XHJcbiAgICB9XHJcbiAgICB2bS4kbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcclxuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBwcmV2TGlzdGVuZXJzKTtcclxuICAgIC8vIHVwZGF0ZSBwcm9wc1xyXG4gICAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xyXG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xyXG4gICAgICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcclxuICAgICAgICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xyXG4gICAgICAgICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XHJcbiAgICAgICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxyXG4gICAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcclxuICAgIH1cclxuICAgIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXHJcbiAgICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xyXG4gICAgICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XHJcbiAgICAgICAgdm0uJGZvcmNlVXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUodm0pIHtcclxuICAgIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xyXG4gICAgICAgIGlmICh2bS5faW5hY3RpdmUpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0sIGRpcmVjdCkge1xyXG4gICAgaWYgKGRpcmVjdCkge1xyXG4gICAgICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcclxuICAgICAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxIb29rJDEodm0sICdhY3RpdmF0ZWQnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0sIGRpcmVjdCkge1xyXG4gICAgaWYgKGRpcmVjdCkge1xyXG4gICAgICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xyXG4gICAgICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxIb29rJDEodm0sICdkZWFjdGl2YXRlZCcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbGxIb29rJDEodm0sIGhvb2ssIGFyZ3MsIHNldENvbnRleHQpIHtcclxuICAgIGlmIChzZXRDb250ZXh0ID09PSB2b2lkIDApIHsgc2V0Q29udGV4dCA9IHRydWU7IH1cclxuICAgIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcclxuICAgIHB1c2hUYXJnZXQoKTtcclxuICAgIHZhciBwcmV2ID0gY3VycmVudEluc3RhbmNlO1xyXG4gICAgc2V0Q29udGV4dCAmJiBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xyXG4gICAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XHJcbiAgICB2YXIgaW5mbyA9IFwiXCIuY29uY2F0KGhvb2ssIFwiIGhvb2tcIik7XHJcbiAgICBpZiAoaGFuZGxlcnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG4gICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIGFyZ3MgfHwgbnVsbCwgdm0sIGluZm8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XHJcbiAgICAgICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xyXG4gICAgfVxyXG4gICAgc2V0Q29udGV4dCAmJiBzZXRDdXJyZW50SW5zdGFuY2UocHJldik7XHJcbiAgICBwb3BUYXJnZXQoKTtcclxufVxuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcclxudmFyIHF1ZXVlID0gW107XHJcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xyXG52YXIgaGFzID0ge307XHJcbnZhciBjaXJjdWxhciA9IHt9O1xyXG52YXIgd2FpdGluZyA9IGZhbHNlO1xyXG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcclxudmFyIGluZGV4ID0gMDtcclxuLyoqXHJcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUoKSB7XHJcbiAgICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICBoYXMgPSB7fTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgY2lyY3VsYXIgPSB7fTtcclxuICAgIH1cclxuICAgIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xyXG59XHJcbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcclxuLy8gYXR0YWNoZWQuIEhvd2V2ZXIsIGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCkgaGFzIGEgcGVyZiBvdmVyaGVhZCBlc3BlY2lhbGx5XHJcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXHJcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xyXG4vLyBhdHRhY2hlZCBkdXJpbmcgdGhhdCBmbHVzaC5cclxudmFyIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XHJcbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXHJcbnZhciBnZXROb3cgPSBEYXRlLm5vdztcclxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcclxuLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcclxuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXHJcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cclxuLy8gQWxsIElFIHZlcnNpb25zIHVzZSBsb3ctcmVzIGV2ZW50IHRpbWVzdGFtcHMsIGFuZCBoYXZlIHByb2JsZW1hdGljIGNsb2NrXHJcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXHJcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUUpIHtcclxuICAgIHZhciBwZXJmb3JtYW5jZV8xID0gd2luZG93LnBlcmZvcm1hbmNlO1xyXG4gICAgaWYgKHBlcmZvcm1hbmNlXzEgJiZcclxuICAgICAgICB0eXBlb2YgcGVyZm9ybWFuY2VfMS5ub3cgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgICBnZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xyXG4gICAgICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gaXQsIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXHJcbiAgICAgICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xyXG4gICAgICAgIC8vIHdlbGwuXHJcbiAgICAgICAgZ2V0Tm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2VfMS5ub3coKTsgfTtcclxuICAgIH1cclxufVxyXG52YXIgc29ydENvbXBhcmVGbiA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYS5wb3N0KSB7XHJcbiAgICAgICAgaWYgKCFiLnBvc3QpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYi5wb3N0KSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xyXG59O1xyXG4vKipcclxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlKCkge1xyXG4gICAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XHJcbiAgICBmbHVzaGluZyA9IHRydWU7XHJcbiAgICB2YXIgd2F0Y2hlciwgaWQ7XHJcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xyXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxyXG4gICAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxyXG4gICAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxyXG4gICAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcclxuICAgIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cclxuICAgIHF1ZXVlLnNvcnQoc29ydENvbXBhcmVGbik7XHJcbiAgICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcclxuICAgIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xyXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcclxuICAgICAgICBpZiAod2F0Y2hlci5iZWZvcmUpIHtcclxuICAgICAgICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWQgPSB3YXRjaGVyLmlkO1xyXG4gICAgICAgIGhhc1tpZF0gPSBudWxsO1xyXG4gICAgICAgIHdhdGNoZXIucnVuKCk7XHJcbiAgICAgICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcclxuICAgICAgICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICtcclxuICAgICAgICAgICAgICAgICAgICAod2F0Y2hlci51c2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIuY29uY2F0KHdhdGNoZXIuZXhwcmVzc2lvbiwgXCJcXFwiXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCIpLCB3YXRjaGVyLnZtKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxyXG4gICAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcclxuICAgIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xyXG4gICAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xyXG4gICAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXHJcbiAgICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xyXG4gICAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xyXG4gICAgLy8gZGV2dG9vbCBob29rXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MocXVldWUpIHtcclxuICAgIHZhciBpID0gcXVldWUubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XHJcbiAgICAgICAgdmFyIHZtID0gd2F0Y2hlci52bTtcclxuICAgICAgICBpZiAodm0gJiYgdm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIGNhbGxIb29rJDEodm0sICd1cGRhdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXHJcbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KHZtKSB7XHJcbiAgICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXHJcbiAgICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxyXG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XHJcbiAgICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcclxufVxyXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MocXVldWUpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXHJcbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xyXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlcih3YXRjaGVyKSB7XHJcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xyXG4gICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh3YXRjaGVyID09PSBEZXAudGFyZ2V0ICYmIHdhdGNoZXIubm9SZWN1cnNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaGFzW2lkXSA9IHRydWU7XHJcbiAgICBpZiAoIWZsdXNoaW5nKSB7XHJcbiAgICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcclxuICAgICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxyXG4gICAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcclxuICAgICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xyXG4gICAgICAgICAgICBpLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XHJcbiAgICB9XHJcbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcclxuICAgIGlmICghd2FpdGluZykge1xyXG4gICAgICAgIHdhaXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcclxuICAgICAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlKHZtKSB7XHJcbiAgICB2YXIgcHJvdmlkZU9wdGlvbiA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XHJcbiAgICBpZiAocHJvdmlkZU9wdGlvbikge1xyXG4gICAgICAgIHZhciBwcm92aWRlZCA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbilcclxuICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9uLmNhbGwodm0pXHJcbiAgICAgICAgICAgIDogcHJvdmlkZU9wdGlvbjtcclxuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3ZpZGVkKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzb3VyY2UgPSByZXNvbHZlUHJvdmlkZWQodm0pO1xyXG4gICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgc28gd2UgaGF2ZSB0b1xyXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhlIGtleXMgb3Vyc2VsdmVzLlxyXG4gICAgICAgIHZhciBrZXlzID0gaGFzU3ltYm9sID8gUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVkKSA6IE9iamVjdC5rZXlzKHByb3ZpZGVkKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm92aWRlZCwga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zKHZtKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcclxuICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIlwiKSwgdm0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdChpbmplY3QsIHZtKSB7XHJcbiAgICBpZiAoaW5qZWN0KSB7XHJcbiAgICAgICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcclxuICAgICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB2YXIga2V5cyA9IGhhc1N5bWJvbCA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xyXG4gICAgICAgICAgICBpZiAocHJvdmlkZUtleSBpbiB2bS5fcHJvdmlkZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdm0uX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gaXNGdW5jdGlvbihwcm92aWRlRGVmYXVsdClcclxuICAgICAgICAgICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwiSW5qZWN0aW9uIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChkYXRhLCBwcm9wcywgY2hpbGRyZW4sIHBhcmVudCwgQ3Rvcikge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xyXG4gICAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xyXG4gICAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xyXG4gICAgdmFyIGNvbnRleHRWbTtcclxuICAgIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XHJcbiAgICAgICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xyXG4gICAgICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cclxuICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcclxuICAgICAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXHJcbiAgICAgICAgY29udGV4dFZtID0gcGFyZW50O1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xyXG4gICAgfVxyXG4gICAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xyXG4gICAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XHJcbiAgICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xyXG4gICAgdGhpcy5zbG90cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIV90aGlzLiRzbG90cykge1xyXG4gICAgICAgICAgICBub3JtYWxpemVTY29wZWRTbG90cyhwYXJlbnQsIGRhdGEuc2NvcGVkU2xvdHMsIChfdGhpcy4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzLiRzbG90cztcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhwYXJlbnQsIGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuc2xvdHMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXHJcbiAgICBpZiAoaXNDb21waWxlZCkge1xyXG4gICAgICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxyXG4gICAgICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcclxuICAgICAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcclxuICAgICAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcclxuICAgICAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudCQxKGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xyXG4gICAgICAgICAgICBpZiAodm5vZGUgJiYgIWlzQXJyYXkodm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50JDEoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xyXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dFZtLCBjaGlsZHJlbikge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XHJcbiAgICB2YXIgcHJvcHMgPSB7fTtcclxuICAgIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XHJcbiAgICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpXHJcbiAgICAgICAgICAgIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpO1xyXG4gICAgICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSlcclxuICAgICAgICAgICAgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChkYXRhLCBwcm9wcywgY2hpbGRyZW4sIGNvbnRleHRWbSwgQ3Rvcik7XHJcbiAgICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xyXG4gICAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgICAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheSh2bm9kZSkpIHtcclxuICAgICAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xyXG4gICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpIHtcclxuICAgIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXHJcbiAgICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcclxuICAgIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxyXG4gICAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XHJcbiAgICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID1cclxuICAgICAgICAgICAgcmVuZGVyQ29udGV4dDtcclxuICAgIH1cclxuICAgIGlmIChkYXRhLnNsb3QpIHtcclxuICAgICAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcclxuICAgIH1cclxuICAgIHJldHVybiBjbG9uZTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVByb3BzKHRvLCBmcm9tKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xyXG4gICAgICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9fbmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XHJcbn1cclxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcclxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XHJcbiAgICBpbml0OiBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xyXG4gICAgICAgIGlmICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxyXG4gICAgICAgICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXHJcbiAgICAgICAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XHJcbiAgICAgICAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxyXG4gICAgICAgICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xyXG4gICAgICAgICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKHZub2RlLCBhY3RpdmVJbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBwcmVwYXRjaDogZnVuY3Rpb24gKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICAgICAgICB2YXIgY2hpbGQgPSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoY2hpbGQsIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXHJcbiAgICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXHJcbiAgICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcclxuICAgICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAodm5vZGUpIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQsIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjYWxsSG9vayQxKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXHJcbiAgICAgICAgICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XHJcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcclxuICAgICAgICAgICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcclxuICAgICAgICAgICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cclxuICAgICAgICAgICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAodm5vZGUpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcclxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpIHtcclxuICAgIGlmIChpc1VuZGVmKEN0b3IpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcclxuICAgIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxyXG4gICAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XHJcbiAgICAgICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcclxuICAgIH1cclxuICAgIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcclxuICAgIC8vIHJlamVjdC5cclxuICAgIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIi5jb25jYXQoU3RyaW5nKEN0b3IpKSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGFzeW5jIGNvbXBvbmVudFxyXG4gICAgdmFyIGFzeW5jRmFjdG9yeTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xyXG4gICAgICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XHJcbiAgICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcclxuICAgICAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcclxuICAgICAgICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXHJcbiAgICAgICAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoYXN5bmNGYWN0b3J5LCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcclxuICAgIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcclxuICAgIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxyXG4gICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcclxuICAgIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcclxuICAgIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgLy8gZXh0cmFjdCBwcm9wc1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcclxuICAgIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcclxuICAgIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXHJcbiAgICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcclxuICAgIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXHJcbiAgICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cclxuICAgIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XHJcbiAgICAgICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xyXG4gICAgICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XHJcbiAgICAgICAgLy8gd29yayBhcm91bmQgZmxvd1xyXG4gICAgICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xyXG4gICAgICAgIGRhdGEgPSB7fTtcclxuICAgICAgICBpZiAoc2xvdCkge1xyXG4gICAgICAgICAgICBkYXRhLnNsb3QgPSBzbG90O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxyXG4gICAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xyXG4gICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDdG9yLm9wdGlvbnMpIHx8IHRhZztcclxuICAgIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIFwidnVlLWNvbXBvbmVudC1cIi5jb25jYXQoQ3Rvci5jaWQpLmNvbmNhdChuYW1lID8gXCItXCIuY29uY2F0KG5hbWUpIDogJycpLCBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LCBcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sIGFzeW5jRmFjdG9yeSk7XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcclxuLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XHJcbnZub2RlLCBcclxuLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXHJcbnBhcmVudCkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgX2lzQ29tcG9uZW50OiB0cnVlLFxyXG4gICAgICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXHJcbiAgICAgICAgcGFyZW50OiBwYXJlbnRcclxuICAgIH07XHJcbiAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xyXG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcclxuICAgIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcclxuICAgICAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcclxuICAgICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKSB7XHJcbiAgICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcclxuICAgICAgICB2YXIgZXhpc3RpbmcgPSBob29rc1trZXldO1xyXG4gICAgICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xyXG4gICAgICAgICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2sodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VIb29rKGYxLCBmMikge1xyXG4gICAgdmFyIG1lcmdlZCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxyXG4gICAgICAgIGYxKGEsIGIpO1xyXG4gICAgICAgIGYyKGEsIGIpO1xyXG4gICAgfTtcclxuICAgIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcclxuICAgIHJldHVybiBtZXJnZWQ7XHJcbn1cclxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xyXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cclxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwob3B0aW9ucywgZGF0YSkge1xyXG4gICAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XHJcbiAgICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnO1xyXG4gICAgKGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcclxuICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XHJcbiAgICB2YXIgZXhpc3RpbmcgPSBvbltldmVudF07XHJcbiAgICB2YXIgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xyXG4gICAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGV4aXN0aW5nKVxyXG4gICAgICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxyXG4gICAgICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb25bZXZlbnRdID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcbn1cblxudmFyIHdhcm4gPSBub29wO1xyXG52YXIgdGlwID0gbm9vcDtcclxudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2U7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcclxudmFyIGZvcm1hdENvbXBvbmVudE5hbWU7XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIgaGFzQ29uc29sZV8xID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xyXG4gICAgdmFyIGNsYXNzaWZ5UkVfMSA9IC8oPzpefFstX10pKFxcdykvZztcclxuICAgIHZhciBjbGFzc2lmeV8xID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShjbGFzc2lmeVJFXzEsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pLnJlcGxhY2UoL1stX10vZywgJycpO1xyXG4gICAgfTtcclxuICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xyXG4gICAgICAgIGlmICh2bSA9PT0gdm9pZCAwKSB7IHZtID0gY3VycmVudEluc3RhbmNlOyB9XHJcbiAgICAgICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xyXG4gICAgICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcclxuICAgICAgICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoYXNDb25zb2xlXzEgJiYgIWNvbmZpZy5zaWxlbnQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltWdWUgd2Fybl06IFwiLmNvbmNhdChtc2cpLmNvbmNhdCh0cmFjZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xyXG4gICAgICAgIGlmIChoYXNDb25zb2xlXzEgJiYgIWNvbmZpZy5zaWxlbnQpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIi5jb25jYXQobXNnKSArICh2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJycpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcclxuICAgICAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPFJvb3Q+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBpc0Z1bmN0aW9uKHZtKSAmJiB2bS5jaWQgIT0gbnVsbFxyXG4gICAgICAgICAgICA/IHZtLm9wdGlvbnNcclxuICAgICAgICAgICAgOiB2bS5faXNWdWVcclxuICAgICAgICAgICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgOiB2bTtcclxuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUob3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcclxuICAgICAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKChuYW1lID8gXCI8XCIuY29uY2F0KGNsYXNzaWZ5XzEobmFtZSksIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xyXG4gICAgICAgICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyBcIiBhdCBcIi5jb25jYXQoZmlsZSkgOiAnJykpO1xyXG4gICAgfTtcclxuICAgIHZhciByZXBlYXRfMSA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcclxuICAgICAgICB2YXIgcmVzID0gJyc7XHJcbiAgICAgICAgd2hpbGUgKG4pIHtcclxuICAgICAgICAgICAgaWYgKG4gJSAyID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmVzICs9IHN0cjtcclxuICAgICAgICAgICAgaWYgKG4gPiAxKVxyXG4gICAgICAgICAgICAgICAgc3RyICs9IHN0cjtcclxuICAgICAgICAgICAgbiA+Pj0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XHJcbiAgICAgICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciB0cmVlID0gW107XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodm0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJlZS5wdXNoKHZtKTtcclxuICAgICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKCdcXG5cXG5mb3VuZCBpblxcblxcbicgK1xyXG4gICAgICAgICAgICAgICAgdHJlZVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0XzEoJyAnLCA1ICsgaSAqIDIpKS5jb25jYXQoaXNBcnJheSh2bSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlwiLmNvbmNhdChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSwgXCIuLi4gKFwiKS5jb25jYXQodm1bMV0sIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcXG5cXG4oZm91bmQgaW4gXCIuY29uY2F0KGZvcm1hdENvbXBvbmVudE5hbWUodm0pLCBcIilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxyXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxyXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cclxuICovXHJcbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xyXG4vKipcclxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xyXG4gKi9cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xyXG4gICAgICAgIGlmICghdm0pIHtcclxuICAgICAgICAgICAgd2FybihcIm9wdGlvbiBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiKSArXHJcbiAgICAgICAgICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VEYXRhKHRvLCBmcm9tKSB7XHJcbiAgICBpZiAoIWZyb20pXHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XHJcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxyXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXHJcbiAgICAgICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cclxuICAgICAgICBpZiAoa2V5ID09PSAnX19vYl9fJylcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgdG9WYWwgPSB0b1trZXldO1xyXG4gICAgICAgIGZyb21WYWwgPSBmcm9tW2tleV07XHJcbiAgICAgICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcclxuICAgICAgICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0b1ZhbCAhPT0gZnJvbVZhbCAmJlxyXG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxyXG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XHJcbiAgICAgICAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvO1xyXG59XHJcbi8qKlxyXG4gKiBEYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XHJcbiAgICBpZiAoIXZtKSB7XHJcbiAgICAgICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcclxuICAgICAgICBpZiAoIWNoaWxkVmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcGFyZW50VmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxyXG4gICAgICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxyXG4gICAgICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXJnZURhdGEoaXNGdW5jdGlvbihjaGlsZFZhbCkgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsIGlzRnVuY3Rpb24ocGFyZW50VmFsKSA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuKCkge1xyXG4gICAgICAgICAgICAvLyBpbnN0YW5jZSBtZXJnZVxyXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VEYXRhID0gaXNGdW5jdGlvbihjaGlsZFZhbClcclxuICAgICAgICAgICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXHJcbiAgICAgICAgICAgICAgICA6IGNoaWxkVmFsO1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdERhdGEgPSBpc0Z1bmN0aW9uKHBhcmVudFZhbClcclxuICAgICAgICAgICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxyXG4gICAgICAgICAgICAgICAgOiBwYXJlbnRWYWw7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdERhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XHJcbiAgICBpZiAoIXZtKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdkZWZpbml0aW9ucy4nLCB2bSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xyXG59O1xyXG4vKipcclxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VMaWZlY3ljbGVIb29rKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcclxuICAgIHZhciByZXMgPSBjaGlsZFZhbFxyXG4gICAgICAgID8gcGFyZW50VmFsXHJcbiAgICAgICAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcclxuICAgICAgICAgICAgOiBpc0FycmF5KGNoaWxkVmFsKVxyXG4gICAgICAgICAgICAgICAgPyBjaGlsZFZhbFxyXG4gICAgICAgICAgICAgICAgOiBbY2hpbGRWYWxdXHJcbiAgICAgICAgOiBwYXJlbnRWYWw7XHJcbiAgICByZXR1cm4gcmVzID8gZGVkdXBlSG9va3MocmVzKSA6IHJlcztcclxufVxyXG5mdW5jdGlvbiBkZWR1cGVIb29rcyhob29rcykge1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XHJcbiAgICBzdHJhdHNbaG9va10gPSBtZXJnZUxpZmVjeWNsZUhvb2s7XHJcbn0pO1xyXG4vKipcclxuICogQXNzZXRzXHJcbiAqXHJcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cclxuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxyXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlQXNzZXRzKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcclxuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcclxuICAgIGlmIChjaGlsZFZhbCkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbn1cclxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XHJcbn0pO1xyXG4vKipcclxuICogV2F0Y2hlcnMuXHJcbiAqXHJcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcclxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXHJcbiAqL1xyXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0sIGtleSkge1xyXG4gICAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cclxuICAgIC8vQHRzLWV4cGVjdC1lcnJvciB3b3JrIGFyb3VuZFxyXG4gICAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpXHJcbiAgICAgICAgcGFyZW50VmFsID0gdW5kZWZpbmVkO1xyXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yIHdvcmsgYXJvdW5kXHJcbiAgICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKVxyXG4gICAgICAgIGNoaWxkVmFsID0gdW5kZWZpbmVkO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNoaWxkVmFsKVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcmVudFZhbClcclxuICAgICAgICByZXR1cm4gY2hpbGRWYWw7XHJcbiAgICB2YXIgcmV0ID0ge307XHJcbiAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gICAgZm9yICh2YXIga2V5XzEgaW4gY2hpbGRWYWwpIHtcclxuICAgICAgICB2YXIgcGFyZW50XzEgPSByZXRba2V5XzFdO1xyXG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV8xXTtcclxuICAgICAgICBpZiAocGFyZW50XzEgJiYgIWlzQXJyYXkocGFyZW50XzEpKSB7XHJcbiAgICAgICAgICAgIHBhcmVudF8xID0gW3BhcmVudF8xXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0W2tleV8xXSA9IHBhcmVudF8xID8gcGFyZW50XzEuY29uY2F0KGNoaWxkKSA6IGlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufTtcclxuLyoqXHJcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXHJcbiAqL1xyXG5zdHJhdHMucHJvcHMgPVxyXG4gICAgc3RyYXRzLm1ldGhvZHMgPVxyXG4gICAgICAgIHN0cmF0cy5pbmplY3QgPVxyXG4gICAgICAgICAgICBzdHJhdHMuY29tcHV0ZWQgPVxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWYWwgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFZhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XHJcbi8qKlxyXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxyXG4gKi9cclxudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XHJcbiAgICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZCA/IHBhcmVudFZhbCA6IGNoaWxkVmFsO1xyXG59O1xyXG4vKipcclxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMob3B0aW9ucykge1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xyXG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKSB7XHJcbiAgICBpZiAoIW5ldyBSZWdFeHAoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIi5jb25jYXQodW5pY29kZVJlZ0V4cC5zb3VyY2UsIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICtcclxuICAgICAgICAgICAgbmFtZSArXHJcbiAgICAgICAgICAgICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xyXG4gICAgICAgICAgICAnc2hvdWxkIGNvbmZvcm0gdG8gdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZSBpbiBodG1sNSBzcGVjaWZpY2F0aW9uLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xyXG4gICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXHJcbiAgICAgICAgICAgICdpZDogJyArXHJcbiAgICAgICAgICAgIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcclxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKG9wdGlvbnMsIHZtKSB7XHJcbiAgICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xyXG4gICAgaWYgKCFwcm9wcylcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICB2YXIgaSwgdmFsLCBuYW1lO1xyXG4gICAgaWYgKGlzQXJyYXkocHJvcHMpKSB7XHJcbiAgICAgICAgaSA9IHByb3BzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgdmFsID0gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKSA/IHZhbCA6IHsgdHlwZTogdmFsIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhcm4oXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXHJcbiAgICAgICAgICAgIFwiYnV0IGdvdCBcIi5jb25jYXQodG9SYXdUeXBlKHByb3BzKSwgXCIuXCIpLCB2bSk7XHJcbiAgICB9XHJcbiAgICBvcHRpb25zLnByb3BzID0gcmVzO1xyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3Qob3B0aW9ucywgdm0pIHtcclxuICAgIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcclxuICAgIGlmICghaW5qZWN0KVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciBub3JtYWxpemVkID0gKG9wdGlvbnMuaW5qZWN0ID0ge30pO1xyXG4gICAgaWYgKGlzQXJyYXkoaW5qZWN0KSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxyXG4gICAgICAgICAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxyXG4gICAgICAgICAgICAgICAgOiB7IGZyb206IHZhbCB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuKFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcclxuICAgICAgICAgICAgXCJidXQgZ290IFwiLmNvbmNhdCh0b1Jhd1R5cGUoaW5qZWN0KSwgXCIuXCIpLCB2bSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEob3B0aW9ucykge1xyXG4gICAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XHJcbiAgICBpZiAoZGlycykge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRlZikpIHtcclxuICAgICAgICAgICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUobmFtZSwgdmFsdWUsIHZtKSB7XHJcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgd2FybihcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIikgK1xyXG4gICAgICAgICAgICBcImJ1dCBnb3QgXCIuY29uY2F0KHRvUmF3VHlwZSh2YWx1ZSksIFwiLlwiKSwgdm0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXHJcbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZCwgdm0pIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcclxuICAgIH1cclxuICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkKSkge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xyXG4gICAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XHJcbiAgICBub3JtYWxpemVEaXJlY3RpdmVzJDEoY2hpbGQpO1xyXG4gICAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxyXG4gICAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxyXG4gICAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxyXG4gICAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxyXG4gICAgaWYgKCFjaGlsZC5fYmFzZSkge1xyXG4gICAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkLm1peGlucykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICAgIHZhciBrZXk7XHJcbiAgICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcclxuICAgICAgICBtZXJnZUZpZWxkKGtleSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGtleSBpbiBjaGlsZCkge1xyXG4gICAgICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xyXG4gICAgICAgICAgICBtZXJnZUZpZWxkKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWVyZ2VGaWVsZChrZXkpIHtcclxuICAgICAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XHJcbiAgICAgICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9wdGlvbnM7XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmUgYW4gYXNzZXQuXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xyXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQsIHdhcm5NaXNzaW5nKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XHJcbiAgICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxyXG4gICAgaWYgKGhhc093bihhc3NldHMsIGlkKSlcclxuICAgICAgICByZXR1cm4gYXNzZXRzW2lkXTtcclxuICAgIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcclxuICAgIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpXHJcbiAgICAgICAgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF07XHJcbiAgICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XHJcbiAgICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSlcclxuICAgICAgICByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF07XHJcbiAgICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cclxuICAgIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICAgICAgd2FybignRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pIHtcclxuICAgIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcclxuICAgIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcclxuICAgIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xyXG4gICAgLy8gYm9vbGVhbiBjYXN0aW5nXHJcbiAgICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XHJcbiAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcclxuICAgICAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxyXG4gICAgICAgICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcclxuICAgICAgICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XHJcbiAgICAgICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxyXG4gICAgICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XHJcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xyXG4gICAgICAgIG9ic2VydmUodmFsdWUpO1xyXG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpIHtcclxuICAgIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcclxuICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcclxuICAgIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcclxuICAgICAgICB3YXJuKCdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICtcclxuICAgICAgICAgICAga2V5ICtcclxuICAgICAgICAgICAgJ1wiOiAnICtcclxuICAgICAgICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsIHZtKTtcclxuICAgIH1cclxuICAgIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXHJcbiAgICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcclxuICAgIGlmICh2bSAmJlxyXG4gICAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxyXG4gICAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHZtLl9wcm9wc1trZXldO1xyXG4gICAgfVxyXG4gICAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcclxuICAgIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKGRlZikgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXHJcbiAgICAgICAgPyBkZWYuY2FsbCh2bSlcclxuICAgICAgICA6IGRlZjtcclxufVxyXG4vKipcclxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNzZXJ0UHJvcChwcm9wLCBuYW1lLCB2YWx1ZSwgdm0sIGFic2VudCkge1xyXG4gICAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XHJcbiAgICAgICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJywgdm0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XHJcbiAgICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xyXG4gICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcclxuICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKCFpc0FycmF5KHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBbdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0sIHZtKTtcclxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xyXG4gICAgICAgICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgaGF2ZUV4cGVjdGVkVHlwZXMgPSBleHBlY3RlZFR5cGVzLnNvbWUoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH0pO1xyXG4gICAgaWYgKCF2YWxpZCAmJiBoYXZlRXhwZWN0ZWRUeXBlcykge1xyXG4gICAgICAgIHdhcm4oZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSwgdm0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcclxuICAgIGlmICh2YWxpZGF0b3IpIHtcclxuICAgICAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgd2FybignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsIHZtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sfEJpZ0ludCkkLztcclxuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSwgdm0pIHtcclxuICAgIHZhciB2YWxpZDtcclxuICAgIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xyXG4gICAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XHJcbiAgICAgICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xyXG4gICAgICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xyXG4gICAgICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcclxuICAgICAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgcHJvcCB0eXBlOiBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgaXMgbm90IGEgY29uc3RydWN0b3InLCB2bSk7XHJcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWxpZDogdmFsaWQsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcclxuICAgIH07XHJcbn1cclxudmFyIGZ1bmN0aW9uVHlwZUNoZWNrUkUgPSAvXlxccypmdW5jdGlvbiAoXFx3KykvO1xyXG4vKipcclxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxyXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcclxuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHlwZShmbikge1xyXG4gICAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaChmdW5jdGlvblR5cGVDaGVja1JFKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gICAgaWYgKCFpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICAgIHZhciBtZXNzYWdlID0gXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiLlwiKSArXHJcbiAgICAgICAgXCIgRXhwZWN0ZWQgXCIuY29uY2F0KGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xyXG4gICAgdmFyIGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XHJcbiAgICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxyXG4gICAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcclxuICAgICAgICBpc0V4cGxpY2FibGUodHlwZW9mIHZhbHVlKSAmJlxyXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBcIiB3aXRoIHZhbHVlIFwiLmNvbmNhdChzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpKTtcclxuICAgIH1cclxuICAgIG1lc3NhZ2UgKz0gXCIsIGdvdCBcIi5jb25jYXQocmVjZWl2ZWRUeXBlLCBcIiBcIik7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcclxuICAgIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gXCJ3aXRoIHZhbHVlIFwiLmNvbmNhdChzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpLCBcIi5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVzc2FnZTtcclxufVxyXG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChOdW1iZXIodmFsdWUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxudmFyIEVYUExJQ0FCTEVfVFlQRVMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xyXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodmFsdWUpIHtcclxuICAgIHJldHVybiBFWFBMSUNBQkxFX1RZUEVTLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW07IH0pO1xyXG59XHJcbmZ1bmN0aW9uIGlzQm9vbGVhbigpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nOyB9KTtcclxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cclxudmFyIGluaXRQcm94eTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHZhciBhbGxvd2VkR2xvYmFsc18xID0gbWFrZU1hcCgnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcclxuICAgICAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXHJcbiAgICAgICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsJyArXHJcbiAgICAgICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcclxuICAgICk7XHJcbiAgICB2YXIgd2Fybk5vblByZXNlbnRfMSA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIHdhcm4oXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiKSArXHJcbiAgICAgICAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xyXG4gICAgICAgICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xyXG4gICAgICAgICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXHJcbiAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vdjIudnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLCB0YXJnZXQpO1xyXG4gICAgfTtcclxuICAgIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXhfMSA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIHdhcm4oXCJQcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFwiJGRhdGEuXCIpLmNvbmNhdChrZXksIFwiXFxcIiBiZWNhdXNlIFwiKSArXHJcbiAgICAgICAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXHJcbiAgICAgICAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMuICcgK1xyXG4gICAgICAgICAgICAnU2VlOiBodHRwczovL3YyLnZ1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLCB0YXJnZXQpO1xyXG4gICAgfTtcclxuICAgIHZhciBoYXNQcm94eV8xID0gdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XHJcbiAgICBpZiAoaGFzUHJveHlfMSkge1xyXG4gICAgICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllcl8xID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xyXG4gICAgICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXJfMShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiLmNvbmNhdChrZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaGFzSGFuZGxlcl8xID0ge1xyXG4gICAgICAgIGhhczogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHNfMShrZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICBrZXkuY2hhckF0KDApID09PSAnXycgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcclxuICAgICAgICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgd2FyblJlc2VydmVkUHJlZml4XzEodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Ob25QcmVzZW50XzEodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGdldEhhbmRsZXJfMSA9IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgd2FyblJlc2VydmVkUHJlZml4XzEodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Ob25QcmVzZW50XzEodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5KHZtKSB7XHJcbiAgICAgICAgaWYgKGhhc1Byb3h5XzEpIHtcclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWQgPyBnZXRIYW5kbGVyXzEgOiBoYXNIYW5kbGVyXzE7XHJcbiAgICAgICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogbm9vcCxcclxuICAgIHNldDogbm9vcFxyXG59O1xyXG5mdW5jdGlvbiBwcm94eSh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XHJcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldO1xyXG4gICAgfTtcclxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlcih2YWwpIHtcclxuICAgICAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFN0YXRlKHZtKSB7XHJcbiAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xyXG4gICAgaWYgKG9wdHMucHJvcHMpXHJcbiAgICAgICAgaW5pdFByb3BzJDEodm0sIG9wdHMucHJvcHMpO1xyXG4gICAgLy8gQ29tcG9zaXRpb24gQVBJXHJcbiAgICBpbml0U2V0dXAodm0pO1xyXG4gICAgaWYgKG9wdHMubWV0aG9kcylcclxuICAgICAgICBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTtcclxuICAgIGlmIChvcHRzLmRhdGEpIHtcclxuICAgICAgICBpbml0RGF0YSh2bSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgb2IgPSBvYnNlcnZlKCh2bS5fZGF0YSA9IHt9KSk7XHJcbiAgICAgICAgb2IgJiYgb2Iudm1Db3VudCsrO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdHMuY29tcHV0ZWQpXHJcbiAgICAgICAgaW5pdENvbXB1dGVkJDEodm0sIG9wdHMuY29tcHV0ZWQpO1xyXG4gICAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcclxuICAgICAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluaXRQcm9wcyQxKHZtLCBwcm9wc09wdGlvbnMpIHtcclxuICAgIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XHJcbiAgICB2YXIgcHJvcHMgPSAodm0uX3Byb3BzID0gc2hhbGxvd1JlYWN0aXZlKHt9KSk7XHJcbiAgICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxyXG4gICAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXHJcbiAgICB2YXIga2V5cyA9ICh2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXSk7XHJcbiAgICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XHJcbiAgICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcclxuICAgIGlmICghaXNSb290KSB7XHJcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcclxuICAgIH1cclxuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwiXFxcIlwiLmNvbmNhdChoeXBoZW5hdGVkS2V5LCBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIlwiKSwgdm0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxyXG4gICAgICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XHJcbiAgICAgICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxyXG4gICAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcclxuICAgICAgICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICBfbG9vcF8xKGtleSk7XHJcbiAgICB9XHJcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdERhdGEodm0pIHtcclxuICAgIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcclxuICAgIGRhdGEgPSB2bS5fZGF0YSA9IGlzRnVuY3Rpb24oZGF0YSkgPyBnZXREYXRhKGRhdGEsIHZtKSA6IGRhdGEgfHwge307XHJcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcclxuICAgICAgICBkYXRhID0ge307XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICB3YXJuKCdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcclxuICAgICAgICAgICAgICAgICdodHRwczovL3YyLnZ1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLCB2bSk7XHJcbiAgICB9XHJcbiAgICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xyXG4gICAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XHJcbiAgICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XHJcbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwiTWV0aG9kIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcclxuICAgICAgICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvYnNlcnZlIGRhdGFcclxuICAgIHZhciBvYiA9IG9ic2VydmUoZGF0YSk7XHJcbiAgICBvYiAmJiBvYi52bUNvdW50Kys7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGF0YShkYXRhLCB2bSkge1xyXG4gICAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xyXG4gICAgcHVzaFRhcmdldCgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICBwb3BUYXJnZXQoKTtcclxuICAgIH1cclxufVxyXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xyXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSh2bSwgY29tcHV0ZWQpIHtcclxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgdmFyIHdhdGNoZXJzID0gKHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XHJcbiAgICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxyXG4gICAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcclxuICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xyXG4gICAgICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcclxuICAgICAgICB2YXIgZ2V0dGVyID0gaXNGdW5jdGlvbih1c2VyRGVmKSA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB3YXJuKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIuXCIpLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNTU1IpIHtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIgfHwgbm9vcCwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcclxuICAgICAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxyXG4gICAgICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cclxuICAgICAgICBpZiAoIShrZXkgaW4gdm0pKSB7XHJcbiAgICAgICAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZtLiRvcHRpb25zLm1ldGhvZHMgJiYga2V5IGluIHZtLiRvcHRpb25zLm1ldGhvZHMpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBtZXRob2QuXCIpLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQodGFyZ2V0LCBrZXksIHVzZXJEZWYpIHtcclxuICAgIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24odXNlckRlZikpIHtcclxuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcclxuICAgICAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXHJcbiAgICAgICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmKTtcclxuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxyXG4gICAgICAgICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmLmdldClcclxuICAgICAgICAgICAgOiBub29wO1xyXG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xyXG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIoKSB7XHJcbiAgICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcclxuICAgICAgICBpZiAod2F0Y2hlcikge1xyXG4gICAgICAgICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBEZXAudGFyZ2V0Lm9uVHJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBEZXAudGFyZ2V0Lm9uVHJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3Q6IERlcC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlcigpIHtcclxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdE1ldGhvZHModm0sIG1ldGhvZHMpIHtcclxuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgd2FybihcIk1ldGhvZCBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGhhcyB0eXBlIFxcXCJcIikuY29uY2F0KHR5cGVvZiBtZXRob2RzW2tleV0sIFwiXFxcIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihcIk1ldGhvZCBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGtleSBpbiB2bSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJNZXRob2QgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdm1ba2V5XSA9IHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbml0V2F0Y2godm0sIHdhdGNoKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcclxuICAgICAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xyXG4gICAgICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xyXG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBzdGF0ZU1peGluKFZ1ZSkge1xyXG4gICAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XHJcbiAgICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcclxuICAgIC8vIHRoZSBvYmplY3QgaGVyZS5cclxuICAgIHZhciBkYXRhRGVmID0ge307XHJcbiAgICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcclxuICAgIH07XHJcbiAgICB2YXIgcHJvcHNEZWYgPSB7fTtcclxuICAgIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHM7XHJcbiAgICB9O1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgd2FybignQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xyXG4gICAgICAgICAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJywgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcclxuICAgIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcclxuICAgIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcclxuICAgIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHZtID0gdGhpcztcclxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcclxuICAgICAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmZvID0gXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiLmNvbmNhdCh3YXRjaGVyLmV4cHJlc3Npb24sIFwiXFxcIlwiKTtcclxuICAgICAgICAgICAgcHVzaFRhcmdldCgpO1xyXG4gICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYiwgdm0sIFt3YXRjaGVyLnZhbHVlXSwgdm0sIGluZm8pO1xyXG4gICAgICAgICAgICBwb3BUYXJnZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbigpIHtcclxuICAgICAgICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XG5cbnZhciB1aWQgPSAwO1xyXG5mdW5jdGlvbiBpbml0TWl4aW4kMShWdWUpIHtcclxuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgLy8gYSB1aWRcclxuICAgICAgICB2bS5fdWlkID0gdWlkKys7XHJcbiAgICAgICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiLmNvbmNhdCh2bS5fdWlkKTtcclxuICAgICAgICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIuY29uY2F0KHZtLl91aWQpO1xyXG4gICAgICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYSBmbGFnIHRvIG1hcmsgdGhpcyBhcyBhIFZ1ZSBpbnN0YW5jZSB3aXRob3V0IGhhdmluZyB0byBkbyBpbnN0YW5jZW9mXHJcbiAgICAgICAgLy8gY2hlY2tcclxuICAgICAgICB2bS5faXNWdWUgPSB0cnVlO1xyXG4gICAgICAgIC8vIGF2b2lkIGluc3RhbmNlcyBmcm9tIGJlaW5nIG9ic2VydmVkXHJcbiAgICAgICAgdm0uX192X3NraXAgPSB0cnVlO1xyXG4gICAgICAgIC8vIGVmZmVjdCBzY29wZVxyXG4gICAgICAgIHZtLl9zY29wZSA9IG5ldyBFZmZlY3RTY29wZSh0cnVlIC8qIGRldGFjaGVkICovKTtcclxuICAgICAgICB2bS5fc2NvcGUuX3ZtID0gdHJ1ZTtcclxuICAgICAgICAvLyBtZXJnZSBvcHRpb25zXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cclxuICAgICAgICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxyXG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cclxuICAgICAgICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLCBvcHRpb25zIHx8IHt9LCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgaW5pdFByb3h5KHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBleHBvc2UgcmVhbCBzZWxmXHJcbiAgICAgICAgdm0uX3NlbGYgPSB2bTtcclxuICAgICAgICBpbml0TGlmZWN5Y2xlKHZtKTtcclxuICAgICAgICBpbml0RXZlbnRzKHZtKTtcclxuICAgICAgICBpbml0UmVuZGVyKHZtKTtcclxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnYmVmb3JlQ3JlYXRlJywgdW5kZWZpbmVkLCBmYWxzZSAvKiBzZXRDb250ZXh0ICovKTtcclxuICAgICAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xyXG4gICAgICAgIGluaXRTdGF0ZSh2bSk7XHJcbiAgICAgICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xyXG4gICAgICAgIGNhbGxIb29rJDEodm0sICdjcmVhdGVkJyk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIG1hcmsoZW5kVGFnKTtcclxuICAgICAgICAgICAgbWVhc3VyZShcInZ1ZSBcIi5jb25jYXQodm0uX25hbWUsIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcclxuICAgICAgICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG9wdHMgPSAodm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpKTtcclxuICAgIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXHJcbiAgICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcclxuICAgIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XHJcbiAgICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xyXG4gICAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XHJcbiAgICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xyXG4gICAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XHJcbiAgICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xyXG4gICAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XHJcbiAgICAgICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcclxuICAgICAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcikge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XHJcbiAgICBpZiAoQ3Rvci5zdXBlcikge1xyXG4gICAgICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xyXG4gICAgICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcclxuICAgICAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cclxuICAgICAgICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcclxuICAgICAgICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvcHRpb25zO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcikge1xyXG4gICAgdmFyIG1vZGlmaWVkO1xyXG4gICAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcclxuICAgIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XHJcbiAgICAgICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xyXG4gICAgICAgICAgICBpZiAoIW1vZGlmaWVkKVxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB7fTtcclxuICAgICAgICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtb2RpZmllZDtcclxufVxuXG5mdW5jdGlvbiBWdWUob3B0aW9ucykge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgISh0aGlzIGluc3RhbmNlb2YgVnVlKSkge1xyXG4gICAgICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XHJcbn1cclxuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxyXG5pbml0TWl4aW4kMShWdWUpO1xyXG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXHJcbnN0YXRlTWl4aW4oVnVlKTtcclxuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxyXG5ldmVudHNNaXhpbihWdWUpO1xyXG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXHJcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XHJcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcclxucmVuZGVyTWl4aW4oVnVlKTtcblxuZnVuY3Rpb24gaW5pdFVzZShWdWUpIHtcclxuICAgIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XHJcbiAgICAgICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSB0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pO1xyXG4gICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcclxuICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XHJcbiAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocGx1Z2luKSkge1xyXG4gICAgICAgICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBpbml0TWl4aW4oVnVlKSB7XHJcbiAgICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQoVnVlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxyXG4gICAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxyXG4gICAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXHJcbiAgICAgKi9cclxuICAgIFZ1ZS5jaWQgPSAwO1xyXG4gICAgdmFyIGNpZCA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIENsYXNzIGluaGVyaXRhbmNlXHJcbiAgICAgKi9cclxuICAgIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xyXG4gICAgICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBTdXBlciA9IHRoaXM7XHJcbiAgICAgICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XHJcbiAgICAgICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcclxuICAgICAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoZXh0ZW5kT3B0aW9ucykgfHwgZ2V0Q29tcG9uZW50TmFtZShTdXBlci5vcHRpb25zKTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xyXG4gICAgICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XHJcbiAgICAgICAgU3ViLmNpZCA9IGNpZCsrO1xyXG4gICAgICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFN1cGVyLm9wdGlvbnMsIGV4dGVuZE9wdGlvbnMpO1xyXG4gICAgICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xyXG4gICAgICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXHJcbiAgICAgICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcclxuICAgICAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXHJcbiAgICAgICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XHJcbiAgICAgICAgICAgIGluaXRQcm9wcyhTdWIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgaW5pdENvbXB1dGVkKFN1Yik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxyXG4gICAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XHJcbiAgICAgICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XHJcbiAgICAgICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcclxuICAgICAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXHJcbiAgICAgICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxyXG4gICAgICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxyXG4gICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXHJcbiAgICAgICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcclxuICAgICAgICAvLyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XHJcbiAgICAgICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xyXG4gICAgICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XHJcbiAgICAgICAgLy8gY2FjaGUgY29uc3RydWN0b3JcclxuICAgICAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcclxuICAgICAgICByZXR1cm4gU3ViO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbml0UHJvcHMoQ29tcCkge1xyXG4gICAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5pdENvbXB1dGVkKENvbXApIHtcclxuICAgIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcclxuICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xyXG4gICAgICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxyXG4gICAgICovXHJcbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBub3QgZXhhY3Qgc2FtZSB0eXBlXHJcbiAgICAgICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKGlkLCBkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVmaW5pdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcclxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiBpc0Z1bmN0aW9uKGRlZmluaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIF9nZXRDb21wb25lbnROYW1lKG9wdHMpIHtcclxuICAgIHJldHVybiBvcHRzICYmIChnZXRDb21wb25lbnROYW1lKG9wdHMuQ3Rvci5vcHRpb25zKSB8fCBvcHRzLnRhZyk7XHJcbn1cclxuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XHJcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBwcnVuZUNhY2hlKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcclxuICAgIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlLCBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cywgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xyXG4gICAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcclxuICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IGVudHJ5Lm5hbWU7XHJcbiAgICAgICAgICAgIGlmIChuYW1lXzEgJiYgIWZpbHRlcihuYW1lXzEpKSB7XHJcbiAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgY3VycmVudCkge1xyXG4gICAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcclxuICAgIGlmIChlbnRyeSAmJiAoIWN1cnJlbnQgfHwgZW50cnkudGFnICE9PSBjdXJyZW50LnRhZykpIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbiBiZSB1bmRlZmluZWRcclxuICAgICAgICBlbnRyeS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgY2FjaGVba2V5XSA9IG51bGw7XHJcbiAgICByZW1vdmUkMihrZXlzLCBrZXkpO1xyXG59XHJcbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcclxuLy8gVE9ETyBkZWZpbmVDb21wb25lbnRcclxudmFyIEtlZXBBbGl2ZSA9IHtcclxuICAgIG5hbWU6ICdrZWVwLWFsaXZlJyxcclxuICAgIGFic3RyYWN0OiB0cnVlLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXHJcbiAgICAgICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxyXG4gICAgICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBjYWNoZVZOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGNhY2hlID0gX2EuY2FjaGUsIGtleXMgPSBfYS5rZXlzLCB2bm9kZVRvQ2FjaGUgPSBfYS52bm9kZVRvQ2FjaGUsIGtleVRvQ2FjaGUgPSBfYS5rZXlUb0NhY2hlO1xyXG4gICAgICAgICAgICBpZiAodm5vZGVUb0NhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gdm5vZGVUb0NhY2hlLnRhZywgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZVRvQ2FjaGUuY29tcG9uZW50SW5zdGFuY2UsIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZVRvQ2FjaGUuY29tcG9uZW50T3B0aW9ucztcclxuICAgICAgICAgICAgICAgIGNhY2hlW2tleVRvQ2FjaGVdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IF9nZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhZzogdGFnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlOiBjb21wb25lbnRJbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXlUb0NhY2hlKTtcclxuICAgICAgICAgICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZub2RlVG9DYWNoZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xyXG4gICAgfSxcclxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XHJcbiAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2FjaGVWTm9kZSgpO1xyXG4gICAgICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICBwcnVuZUNhY2hlKF90aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgcHJ1bmVDYWNoZShfdGhpcywgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhY2hlVk5vZGUoKTtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XHJcbiAgICAgICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcclxuICAgICAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgcGF0dGVyblxyXG4gICAgICAgICAgICB2YXIgbmFtZV8yID0gX2dldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGluY2x1ZGUgPSBfYS5pbmNsdWRlLCBleGNsdWRlID0gX2EuZXhjbHVkZTtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAvLyBub3QgaW5jbHVkZWRcclxuICAgICAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lXzIgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZV8yKSkpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBleGNsdWRlZFxyXG4gICAgICAgICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZV8yICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZV8yKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLCBjYWNoZSA9IF9iLmNhY2hlLCBrZXlzID0gX2Iua2V5cztcclxuICAgICAgICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXHJcbiAgICAgICAgICAgICAgICA/IC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcG9uZW50T3B0aW9ucy50YWcgPyBcIjo6XCIuY29uY2F0KGNvbXBvbmVudE9wdGlvbnMudGFnKSA6ICcnKVxyXG4gICAgICAgICAgICAgICAgOiB2bm9kZS5rZXk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XHJcbiAgICAgICAgICAgICAgICByZW1vdmUkMihrZXlzLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWxheSBzZXR0aW5nIHRoZSBjYWNoZSB1bnRpbCB1cGRhdGVcclxuICAgICAgICAgICAgICAgIHRoaXMudm5vZGVUb0NhY2hlID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleVRvQ2FjaGUgPSBrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjYW4gdm5vZGUuZGF0YSBjYW4gYmUgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pO1xyXG4gICAgfVxyXG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XHJcbiAgICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxyXG59O1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJKFZ1ZSkge1xyXG4gICAgLy8gY29uZmlnXHJcbiAgICB2YXIgY29uZmlnRGVmID0ge307XHJcbiAgICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB3YXJuKCdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLicpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcclxuICAgIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxyXG4gICAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXHJcbiAgICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxyXG4gICAgVnVlLnV0aWwgPSB7XHJcbiAgICAgICAgd2Fybjogd2FybixcclxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcclxuICAgICAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcclxuICAgICAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmVcclxuICAgIH07XHJcbiAgICBWdWUuc2V0ID0gc2V0O1xyXG4gICAgVnVlLmRlbGV0ZSA9IGRlbDtcclxuICAgIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xyXG4gICAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXHJcbiAgICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBvYnNlcnZlKG9iaik7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgfSk7XHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XHJcbiAgICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cclxuICAgIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xyXG4gICAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcclxuICAgIGluaXRVc2UoVnVlKTtcclxuICAgIGluaXRNaXhpbihWdWUpO1xyXG4gICAgaW5pdEV4dGVuZChWdWUpO1xyXG4gICAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XHJcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcclxuICAgIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0O1xyXG4gICAgfVxyXG59KTtcclxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcclxuICAgIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxyXG59KTtcclxuVnVlLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcclxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXHJcbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XHJcbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcclxudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xyXG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XHJcbiAgICByZXR1cm4gKChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykgJiYgdHlwZSAhPT0gJ2J1dHRvbicpIHx8XHJcbiAgICAgICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcclxuICAgICAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcclxuICAgICAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpKTtcclxufTtcclxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcclxudmFyIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcclxudmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXHJcbiAgICAgICAgPyAnZmFsc2UnXHJcbiAgICAgICAgOiAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcclxuICAgICAgICAgICAga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IHZhbHVlXHJcbiAgICAgICAgICAgICAgICA6ICd0cnVlJztcclxufTtcclxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKCdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xyXG4gICAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcclxuICAgICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xyXG4gICAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXHJcbiAgICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLCcgK1xyXG4gICAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnKTtcclxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluayc7XHJcbn07XHJcbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnO1xyXG59O1xyXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlO1xyXG59O1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlKHZub2RlKSB7XHJcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xyXG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xyXG4gICAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xyXG4gICAgICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcclxuICAgICAgICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHBhcmVudE5vZGUucGFyZW50IG5vdCBWTm9kZVdpdGhEYXRhXHJcbiAgICB3aGlsZSAoaXNEZWYoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YShjaGlsZCwgcGFyZW50KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXHJcbiAgICAgICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKSA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXSA6IHBhcmVudC5jbGFzc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJDbGFzcyhzdGF0aWNDbGFzcywgZHluYW1pY0NsYXNzKSB7XHJcbiAgICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcclxuICAgICAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gJyc7XHJcbn1cclxuZnVuY3Rpb24gY29uY2F0KGEsIGIpIHtcclxuICAgIHJldHVybiBhID8gKGIgPyBhICsgJyAnICsgYiA6IGEpIDogYiB8fCAnJztcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyh2YWx1ZSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHJldHVybiAnJztcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSh2YWx1ZSkge1xyXG4gICAgdmFyIHJlcyA9ICcnO1xyXG4gICAgdmFyIHN0cmluZ2lmaWVkO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoaXNEZWYoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXMpXHJcbiAgICAgICAgICAgICAgICByZXMgKz0gJyAnO1xyXG4gICAgICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QodmFsdWUpIHtcclxuICAgIHZhciByZXMgPSAnJztcclxuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZVtrZXldKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXMpXHJcbiAgICAgICAgICAgICAgICByZXMgKz0gJyAnO1xyXG4gICAgICAgICAgICByZXMgKz0ga2V5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcclxuICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcclxuICAgIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xyXG59O1xyXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcCgnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXHJcbiAgICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xyXG4gICAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xyXG4gICAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcclxuICAgICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcclxuICAgICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcclxuICAgICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcclxuICAgICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xyXG4gICAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXHJcbiAgICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xyXG4gICAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnKTtcclxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XHJcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXHJcbnZhciBpc1NWRyA9IG1ha2VNYXAoJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcclxuICAgICdmb3JlaWdub2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcclxuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JywgdHJ1ZSk7XHJcbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xyXG4gICAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZyk7XHJcbn07XHJcbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSh0YWcpIHtcclxuICAgIGlmIChpc1NWRyh0YWcpKSB7XHJcbiAgICAgICAgcmV0dXJuICdzdmcnO1xyXG4gICAgfVxyXG4gICAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXHJcbiAgICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXHJcbiAgICBpZiAodGFnID09PSAnbWF0aCcpIHtcclxuICAgICAgICByZXR1cm4gJ21hdGgnO1xyXG4gICAgfVxyXG59XHJcbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCh0YWcpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFpbkJyb3dzZXIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXTtcclxuICAgIH1cclxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcclxuICAgIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcclxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XHJcbiAgICAgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPVxyXG4gICAgICAgICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpO1xyXG4gICAgfVxyXG59XHJcbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKipcclxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeShlbCkge1xyXG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcclxuICAgICAgICBpZiAoIXNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCB2bm9kZSkge1xyXG4gICAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcbiAgICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICByZXR1cm4gZWxtO1xyXG4gICAgfVxyXG4gICAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcclxuICAgIGlmICh2bm9kZS5kYXRhICYmXHJcbiAgICAgICAgdm5vZGUuZGF0YS5hdHRycyAmJlxyXG4gICAgICAgIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxtO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZ05hbWUpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50KHRleHQpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpO1xyXG59XHJcbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XHJcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVDaGlsZChub2RlLCBjaGlsZCkge1xyXG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XHJcbn1cclxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQobm9kZSwgY2hpbGQpIHtcclxuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcmVudE5vZGUobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZTtcclxufVxyXG5mdW5jdGlvbiBuZXh0U2libGluZyhub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcclxufVxyXG5mdW5jdGlvbiB0YWdOYW1lKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnRhZ05hbWU7XHJcbn1cclxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQobm9kZSwgdGV4dCkge1xyXG4gICAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XHJcbn1cclxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZShub2RlLCBzY29wZUlkKSB7XHJcbiAgICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XHJcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbnZhciByZWYgPSB7XHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChfLCB2bm9kZSkge1xyXG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgICAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcclxuICAgICAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAodm5vZGUpIHtcclxuICAgICAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmKHZub2RlLCBpc1JlbW92YWwpIHtcclxuICAgIHZhciByZWYgPSB2bm9kZS5kYXRhLnJlZjtcclxuICAgIGlmICghaXNEZWYocmVmKSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xyXG4gICAgdmFyIHJlZlZhbHVlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xyXG4gICAgdmFyIHZhbHVlID0gaXNSZW1vdmFsID8gbnVsbCA6IHJlZlZhbHVlO1xyXG4gICAgdmFyICRyZWZzVmFsdWUgPSBpc1JlbW92YWwgPyB1bmRlZmluZWQgOiByZWZWYWx1ZTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcclxuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhyZWYsIHZtLCBbdmFsdWVdLCB2bSwgXCJ0ZW1wbGF0ZSByZWYgZnVuY3Rpb25cIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGlzRm9yID0gdm5vZGUuZGF0YS5yZWZJbkZvcjtcclxuICAgIHZhciBfaXNTdHJpbmcgPSB0eXBlb2YgcmVmID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcmVmID09PSAnbnVtYmVyJztcclxuICAgIHZhciBfaXNSZWYgPSBpc1JlZihyZWYpO1xyXG4gICAgdmFyIHJlZnMgPSB2bS4kcmVmcztcclxuICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XHJcbiAgICAgICAgaWYgKGlzRm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBleGlzdGluZyA9IF9pc1N0cmluZyA/IHJlZnNbcmVmXSA6IHJlZi52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKGlzUmVtb3ZhbCkge1xyXG4gICAgICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlJDIoZXhpc3RpbmcsIHJlZlZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFNldHVwUmVmKHZtLCByZWYsIHJlZnNbcmVmXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFleGlzdGluZy5pbmNsdWRlcyhyZWZWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKHJlZlZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChfaXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKGlzUmVtb3ZhbCAmJiByZWZzW3JlZl0gIT09IHJlZlZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVmc1tyZWZdID0gJHJlZnNWYWx1ZTtcclxuICAgICAgICAgICAgc2V0U2V0dXBSZWYodm0sIHJlZiwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChfaXNSZWYpIHtcclxuICAgICAgICAgICAgaWYgKGlzUmVtb3ZhbCAmJiByZWYudmFsdWUgIT09IHJlZlZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgd2FybihcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6IFwiLmNvbmNhdCh0eXBlb2YgcmVmKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldFNldHVwUmVmKF9hLCBrZXksIHZhbCkge1xyXG4gICAgdmFyIF9zZXR1cFN0YXRlID0gX2EuX3NldHVwU3RhdGU7XHJcbiAgICBpZiAoX3NldHVwU3RhdGUgJiYgaGFzT3duKF9zZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgaWYgKGlzUmVmKF9zZXR1cFN0YXRlW2tleV0pKSB7XHJcbiAgICAgICAgICAgIF9zZXR1cFN0YXRlW2tleV0udmFsdWUgPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfc2V0dXBTdGF0ZVtrZXldID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XHJcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxyXG4gKlxyXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcclxuICpcclxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxyXG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cclxuICovXHJcbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XHJcbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xyXG5mdW5jdGlvbiBzYW1lVm5vZGUoYSwgYikge1xyXG4gICAgcmV0dXJuIChhLmtleSA9PT0gYi5rZXkgJiZcclxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcclxuICAgICAgICAoKGEudGFnID09PSBiLnRhZyAmJlxyXG4gICAgICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcclxuICAgICAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxyXG4gICAgICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpKSB8fFxyXG4gICAgICAgICAgICAoaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJiBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKSkpKTtcclxufVxyXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlKGEsIGIpIHtcclxuICAgIGlmIChhLnRhZyAhPT0gJ2lucHV0JylcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIHR5cGVBID0gaXNEZWYoKGkgPSBhLmRhdGEpKSAmJiBpc0RlZigoaSA9IGkuYXR0cnMpKSAmJiBpLnR5cGU7XHJcbiAgICB2YXIgdHlwZUIgPSBpc0RlZigoaSA9IGIuZGF0YSkpICYmIGlzRGVmKChpID0gaS5hdHRycykpICYmIGkudHlwZTtcclxuICAgIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgKGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHgoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcclxuICAgIHZhciBpLCBrZXk7XHJcbiAgICB2YXIgbWFwID0ge307XHJcbiAgICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xyXG4gICAgICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcclxuICAgICAgICBpZiAoaXNEZWYoa2V5KSlcclxuICAgICAgICAgICAgbWFwW2tleV0gPSBpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hcDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uKGJhY2tlbmQpIHtcclxuICAgIHZhciBpLCBqO1xyXG4gICAgdmFyIGNicyA9IHt9O1xyXG4gICAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXMsIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjYnNbaG9va3NbaV1dID0gW107XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xyXG4gICAgICAgICAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0KGVsbSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSbUNiKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcclxuICAgICAgICBmdW5jdGlvbiByZW1vdmUoKSB7XHJcbiAgICAgICAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUoZWwpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcclxuICAgICAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcclxuICAgICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xyXG4gICAgICAgICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQodm5vZGUsIGluVlByZSkge1xyXG4gICAgICAgIHJldHVybiAoIWluVlByZSAmJlxyXG4gICAgICAgICAgICAhdm5vZGUubnMgJiZcclxuICAgICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZztcclxuICAgICAgICAgICAgICAgIH0pKSAmJlxyXG4gICAgICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpKTtcclxuICAgIH1cclxuICAgIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCwgb3duZXJBcnJheSwgaW5kZXgpIHtcclxuICAgICAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxyXG4gICAgICAgICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcclxuICAgICAgICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxyXG4gICAgICAgICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xyXG4gICAgICAgICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cclxuICAgICAgICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xyXG4gICAgICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XHJcbiAgICAgICAgaWYgKGlzRGVmKHRhZykpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50KHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc+IC0gZGlkIHlvdSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLCB2bm9kZS5jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xyXG4gICAgICAgICAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxyXG4gICAgICAgICAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XHJcbiAgICAgICAgICAgIHNldFNjb3BlKHZub2RlKTtcclxuICAgICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xyXG4gICAgICAgICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XHJcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XHJcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcclxuICAgICAgICB2YXIgaSA9IHZub2RlLmRhdGE7XHJcbiAgICAgICAgaWYgKGlzRGVmKGkpKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBpLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuaW5pdCkpKSB7XHJcbiAgICAgICAgICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XHJcbiAgICAgICAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cclxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cclxuICAgICAgICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcclxuICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xyXG4gICAgICAgICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XHJcbiAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xyXG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgc2V0U2NvcGUodm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXHJcbiAgICAgICAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcclxuICAgICAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xyXG4gICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cclxuICAgICAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXHJcbiAgICAgICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XHJcbiAgICAgICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cclxuICAgICAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XHJcbiAgICAgICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBpbm5lck5vZGUuZGF0YSkpICYmIGlzRGVmKChpID0gaS50cmFuc2l0aW9uKSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxyXG4gICAgICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXHJcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBhcmVudCwgZWxtLCByZWYpIHtcclxuICAgICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYocmVmKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYpID09PSBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2lfMSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2lfMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaV8xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xyXG4gICAgICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1BhdGNoYWJsZSh2bm9kZSkge1xyXG4gICAgICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaV8yID0gMDsgaV8yIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraV8yKSB7XHJcbiAgICAgICAgICAgIGNicy5jcmVhdGVbaV8yXShlbXB0eU5vZGUsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcclxuICAgICAgICBpZiAoaXNEZWYoaSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSlcclxuICAgICAgICAgICAgICAgIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKVxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXHJcbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxyXG4gICAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxyXG4gICAgZnVuY3Rpb24gc2V0U2NvcGUodm5vZGUpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoaXNEZWYoKGkgPSB2bm9kZS5mblNjb3BlSWQpKSkge1xyXG4gICAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xyXG4gICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGFuY2VzdG9yLmNvbnRleHQpKSAmJiBpc0RlZigoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxyXG4gICAgICAgIGlmIChpc0RlZigoaSA9IGFjdGl2ZUluc3RhbmNlKSkgJiZcclxuICAgICAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxyXG4gICAgICAgICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcclxuICAgICAgICAgICAgaXNEZWYoKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkpIHtcclxuICAgICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xyXG4gICAgICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcclxuICAgICAgICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayh2bm9kZSkge1xyXG4gICAgICAgIHZhciBpLCBqO1xyXG4gICAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLmRlc3Ryb3kpKSlcclxuICAgICAgICAgICAgICAgIGkodm5vZGUpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXSh2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZigoaSA9IHZub2RlLmNoaWxkcmVuKSkpIHtcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVWbm9kZXModm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XHJcbiAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xyXG4gICAgICAgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sodm5vZGUsIHJtKSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xyXG4gICAgICAgICAgICB2YXIgaV8zO1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYocm0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcclxuICAgICAgICAgICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xyXG4gICAgICAgICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGlfMyA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkgJiZcclxuICAgICAgICAgICAgICAgIGlzRGVmKChpXzMgPSBpXzMuX3Zub2RlKSkgJiZcclxuICAgICAgICAgICAgICAgIGlzRGVmKGlfMy5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpXzMsIHJtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGlfMyA9IDA7IGlfMyA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2lfMykge1xyXG4gICAgICAgICAgICAgICAgY2JzLnJlbW92ZVtpXzNdKHZub2RlLCBybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpXzMgPSB2bm9kZS5kYXRhLmhvb2spKSAmJiBpc0RlZigoaV8zID0gaV8zLnJlbW92ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpXzModm5vZGUsIHJtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJtKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XHJcbiAgICAgICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcclxuICAgICAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xyXG4gICAgICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XHJcbiAgICAgICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcclxuICAgICAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xyXG4gICAgICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XHJcbiAgICAgICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcclxuICAgICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cclxuICAgICAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXHJcbiAgICAgICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcclxuICAgICAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcclxuICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XHJcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcclxuICAgICAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFZub2RlIG1vdmVkIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xyXG4gICAgICAgICAgICAgICAgY2FuTW92ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XHJcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XHJcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCBsZWZ0XHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICBjYW5Nb3ZlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKVxyXG4gICAgICAgICAgICAgICAgICAgIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xyXG4gICAgICAgICAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcclxuICAgICAgICAgICAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxyXG4gICAgICAgICAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuTW92ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xyXG4gICAgICAgICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XHJcbiAgICAgICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgdmFyIHNlZW5LZXlzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaV80ID0gMDsgaV80IDwgY2hpbGRyZW4ubGVuZ3RoOyBpXzQrKykge1xyXG4gICAgICAgICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXzRdO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIi5jb25jYXQoa2V5LCBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksIHZub2RlLmNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICBmb3IgKHZhciBpXzUgPSBzdGFydDsgaV81IDwgZW5kOyBpXzUrKykge1xyXG4gICAgICAgICAgICB2YXIgYyA9IG9sZENoW2lfNV07XHJcbiAgICAgICAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaV81O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG93bmVyQXJyYXksIGluZGV4LCByZW1vdmVPbmx5KSB7XHJcbiAgICAgICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XHJcbiAgICAgICAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxyXG4gICAgICAgICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbG0gPSAodm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtKTtcclxuICAgICAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgICAgICAgICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXHJcbiAgICAgICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXHJcbiAgICAgICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXHJcbiAgICAgICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cclxuICAgICAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxyXG4gICAgICAgICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXHJcbiAgICAgICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXHJcbiAgICAgICAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKSkge1xyXG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGkgPSBkYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkucHJlcGF0Y2gpKSkge1xyXG4gICAgICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS51cGRhdGUpKSlcclxuICAgICAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRDaCAhPT0gY2gpXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYoY2gpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcclxuICAgICAgICAgICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XHJcbiAgICAgICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS5wb3N0cGF0Y2gpKSlcclxuICAgICAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xyXG4gICAgICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxyXG4gICAgICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXHJcbiAgICAgICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGlfNiA9IDA7IGlfNiA8IHF1ZXVlLmxlbmd0aDsgKytpXzYpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlW2lfNl0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXzZdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcclxuICAgIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XHJcbiAgICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXHJcbiAgICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cclxuICAgIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XHJcbiAgICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxyXG4gICAgZnVuY3Rpb24gaHlkcmF0ZShlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB0YWcgPSB2bm9kZS50YWcsIGRhdGEgPSB2bm9kZS5kYXRhLCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XHJcbiAgICAgICAgdm5vZGUuZWxtID0gZWxtO1xyXG4gICAgICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XHJcbiAgICAgICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLmluaXQpKSlcclxuICAgICAgICAgICAgICAgIGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXHJcbiAgICAgICAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGVmKHRhZykpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEZWYoKGkgPSBpLmRvbVByb3BzKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEZWYoKGkgPSBpLmlubmVySFRNTCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzcgPSAwOyBpXzcgPCBjaGlsZHJlbi5sZW5ndGg7IGlfNysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baV83XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcclxuICAgICAgICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAoIWlzVW5rbm93bkVsZW1lbnQodm5vZGUsIGluVlByZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiBwYXRjaChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xyXG4gICAgICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKVxyXG4gICAgICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcclxuICAgICAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcclxuICAgICAgICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxyXG4gICAgICAgICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxyXG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cclxuICAgICAgICAgICAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybignVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxyXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIFxyXG4gICAgICAgICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcclxuICAgICAgICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xyXG4gICAgICAgICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcclxuICAgICAgICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKSk7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfOCA9IDA7IGlfOCA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpXzgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNicy5kZXN0cm95W2lfOF0oYW5jZXN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV85ID0gMDsgaV85IDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraV85KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXzldKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzY1MTNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0XzEgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydF8xLm1lcmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMTAgPSAxOyBpXzEwIDwgaW5zZXJ0XzEuZm5zLmxlbmd0aDsgaV8xMCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydF8xLmZuc1tpXzEwXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlLmVsbTtcclxuICAgIH07XHJcbn1cblxudmFyIGRpcmVjdGl2ZXMgPSB7XHJcbiAgICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXHJcbiAgICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzKHZub2RlKSB7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBlbXB0eU5vZGUgaXMgbm90IFZOb2RlV2l0aERhdGFcclxuICAgICAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcclxuICAgICAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XHJcbiAgICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcclxuICAgIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyhvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xyXG4gICAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XHJcbiAgICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcclxuICAgIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xyXG4gICAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XHJcbiAgICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XHJcbiAgICAgICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xyXG4gICAgICAgIGRpciA9IG5ld0RpcnNba2V5XTtcclxuICAgICAgICBpZiAoIW9sZERpcikge1xyXG4gICAgICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXHJcbiAgICAgICAgICAgIGNhbGxIb29rKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXHJcbiAgICAgICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcclxuICAgICAgICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGlzQ3JlYXRlKSB7XHJcbiAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYWxsSW5zZXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xyXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQ3JlYXRlKSB7XHJcbiAgICAgICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xyXG4gICAgICAgICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxyXG4gICAgICAgICAgICAgICAgY2FsbEhvb2sob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMoZGlycywgdm0pIHtcclxuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgaWYgKCFkaXJzKSB7XHJcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHZhciBpLCBkaXI7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGRpciA9IGRpcnNbaV07XHJcbiAgICAgICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xyXG4gICAgICAgIGlmICh2bS5fc2V0dXBTdGF0ZSAmJiB2bS5fc2V0dXBTdGF0ZS5fX3NmYykge1xyXG4gICAgICAgICAgICB2YXIgc2V0dXBEZWYgPSBkaXIuZGVmIHx8IHJlc29sdmVBc3NldCh2bSwgJ19zZXR1cFN0YXRlJywgJ3YtJyArIGRpci5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR1cERlZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgZGlyLmRlZiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBiaW5kOiBzZXR1cERlZixcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHNldHVwRGVmLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRpci5kZWYgPSBzZXR1cERlZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkaXIuZGVmID0gZGlyLmRlZiB8fCByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUoZGlyKSB7XHJcbiAgICByZXR1cm4gKGRpci5yYXdOYW1lIHx8IFwiXCIuY29uY2F0KGRpci5uYW1lLCBcIi5cIikuY29uY2F0KE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGxIb29rKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcclxuICAgIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcclxuICAgIGlmIChmbikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIFwiZGlyZWN0aXZlIFwiLmNvbmNhdChkaXIubmFtZSwgXCIgXCIpLmNvbmNhdChob29rLCBcIiBob29rXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW3JlZiwgZGlyZWN0aXZlc107XG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gICAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGtleSwgY3VyLCBvbGQ7XHJcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtO1xyXG4gICAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcclxuICAgIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XHJcbiAgICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcclxuICAgIGlmIChpc0RlZihhdHRycy5fX29iX18pIHx8IGlzVHJ1ZShhdHRycy5fdl9hdHRyX3Byb3h5KSkge1xyXG4gICAgICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xyXG4gICAgfVxyXG4gICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICBjdXIgPSBhdHRyc1trZXldO1xyXG4gICAgICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XHJcbiAgICAgICAgaWYgKG9sZCAhPT0gY3VyKSB7XHJcbiAgICAgICAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1ciwgdm5vZGUuZGF0YS5wcmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXHJcbiAgICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xyXG4gICAgICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xyXG4gICAgICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzSW5QcmUpIHtcclxuICAgIGlmIChpc0luUHJlIHx8IGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcclxuICAgICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcclxuICAgICAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxyXG4gICAgICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XHJcbiAgICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxyXG4gICAgICAgICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJyA/ICd0cnVlJyA6IGtleTtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XHJcbiAgICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XHJcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxyXG4gICAgICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcclxuICAgICAgICAvLyBpbW1lZGlhdGVseS5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoaXNJRSAmJlxyXG4gICAgICAgICAgICAhaXNJRTkgJiZcclxuICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxyXG4gICAgICAgICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiZcclxuICAgICAgICAgICAgdmFsdWUgIT09ICcnICYmXHJcbiAgICAgICAgICAgICFlbC5fX2llcGgpIHtcclxuICAgICAgICAgICAgdmFyIGJsb2NrZXJfMSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyXzEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXJfMSk7XHJcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgICAgICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG52YXIgYXR0cnMgPSB7XHJcbiAgICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxyXG4gICAgdXBkYXRlOiB1cGRhdGVBdHRyc1xyXG59O1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyhvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcclxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcclxuICAgIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXHJcbiAgICAgICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJlxyXG4gICAgICAgIChpc1VuZGVmKG9sZERhdGEpIHx8XHJcbiAgICAgICAgICAgIChpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmIGlzVW5kZWYob2xkRGF0YS5jbGFzcykpKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcclxuICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcclxuICAgIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XHJcbiAgICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xyXG4gICAgICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xyXG4gICAgfVxyXG4gICAgLy8gc2V0IHRoZSBjbGFzc1xyXG4gICAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xyXG4gICAgICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XHJcbiAgICB9XHJcbn1cclxudmFyIGtsYXNzID0ge1xyXG4gICAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcclxuICAgIHVwZGF0ZTogdXBkYXRlQ2xhc3NcclxufTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxyXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxyXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcclxudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cclxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxyXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXHJcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyhvbikge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xyXG4gICAgICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcclxuICAgICAgICB2YXIgZXZlbnRfMSA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XHJcbiAgICAgICAgb25bZXZlbnRfMV0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF8xXSB8fCBbXSk7XHJcbiAgICAgICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XHJcbiAgICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XHJcbiAgICAgICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcclxuICAgICAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xyXG4gICAgfVxyXG59XHJcbnZhciB0YXJnZXQ7XHJcbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XHJcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldDsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcclxuICAgIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlcigpIHtcclxuICAgICAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVtb3ZlKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxyXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXHJcbi8vIHNhZmUgdG8gZXhjbHVkZS5cclxudmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XHJcbmZ1bmN0aW9uIGFkZChuYW1lLCBoYW5kbGVyLCBjYXB0dXJlLCBwYXNzaXZlKSB7XHJcbiAgICAvLyBhc3luYyBlZGdlIGNhc2UgIzY1NjY6IGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXHJcbiAgICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xyXG4gICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXHJcbiAgICAvLyB0aGUgc29sdXRpb24gaXMgc2ltcGxlOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXHJcbiAgICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXHJcbiAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXHJcbiAgICBpZiAodXNlTWljcm90YXNrRml4KSB7XHJcbiAgICAgICAgdmFyIGF0dGFjaGVkVGltZXN0YW1wXzEgPSBjdXJyZW50Rmx1c2hUaW1lc3RhbXA7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsXzEgPSBoYW5kbGVyO1xyXG4gICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICAgIGhhbmRsZXIgPSBvcmlnaW5hbF8xLl93cmFwcGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGp1c3QgYSBzYWZldHkgbmV0IGluIGNhc2UgZXZlbnQudGltZVN0YW1wIGlzIHVucmVsaWFibGUgaW5cclxuICAgICAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cclxuICAgICAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxyXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgaGFuZGxlciBhdHRhY2htZW50XHJcbiAgICAgICAgICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcF8xIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vICM5NDYyIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcclxuICAgICAgICAgICAgICAgIC8vICM5NjgxIFF0V2ViRW5naW5lIGV2ZW50LnRpbWVTdGFtcCBpcyBuZWdhdGl2ZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxyXG4gICAgICAgICAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxyXG4gICAgICAgICAgICAgICAgLy8gZWxlY3Ryb24vbncuanMgYXBwLCBzaW5jZSBldmVudC50aW1lU3RhbXAgd2lsbCBiZSB1c2luZyBhIGRpZmZlcmVudFxyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsXzEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCBzdXBwb3J0c1Bhc3NpdmUgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfSA6IGNhcHR1cmUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZShuYW1lLCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KSB7XHJcbiAgICAoX3RhcmdldCB8fCB0YXJnZXQpLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgXHJcbiAgICAvL0B0cy1leHBlY3QtZXJyb3JcclxuICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlciwgY2FwdHVyZSk7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XHJcbiAgICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xyXG4gICAgLy8gdm5vZGUgaXMgZW1wdHkgd2hlbiByZW1vdmluZyBhbGwgbGlzdGVuZXJzLFxyXG4gICAgLy8gYW5kIHVzZSBvbGQgdm5vZGUgZG9tIGVsZW1lbnRcclxuICAgIHRhcmdldCA9IHZub2RlLmVsbSB8fCBvbGRWbm9kZS5lbG07XHJcbiAgICBub3JtYWxpemVFdmVudHMob24pO1xyXG4gICAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkLCByZW1vdmUsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bm9kZS5jb250ZXh0KTtcclxuICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcclxufVxyXG52YXIgZXZlbnRzID0ge1xyXG4gICAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXHJcbiAgICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZW1wdHlOb2RlIGhhcyBhY3R1YWxseSBkYXRhXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAodm5vZGUpIHsgcmV0dXJuIHVwZGF0ZURPTUxpc3RlbmVycyh2bm9kZSwgZW1wdHlOb2RlKTsgfVxyXG59O1xuXG52YXIgc3ZnQ29udGFpbmVyO1xyXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyhvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIga2V5LCBjdXI7XHJcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtO1xyXG4gICAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcclxuICAgIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XHJcbiAgICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcclxuICAgIGlmIChpc0RlZihwcm9wcy5fX29iX18pIHx8IGlzVHJ1ZShwcm9wcy5fdl9hdHRyX3Byb3h5KSkge1xyXG4gICAgICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIGVsbVtrZXldID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICBjdXIgPSBwcm9wc1trZXldO1xyXG4gICAgICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxyXG4gICAgICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXHJcbiAgICAgICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcclxuICAgICAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcclxuICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKVxyXG4gICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXHJcbiAgICAgICAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XHJcbiAgICAgICAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xyXG4gICAgICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxyXG4gICAgICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXHJcbiAgICAgICAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XHJcbiAgICAgICAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxyXG4gICAgICAgICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xyXG4gICAgICAgICAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiZcclxuICAgICAgICAgICAgaXNTVkcoZWxtLnRhZ05hbWUpICYmXHJcbiAgICAgICAgICAgIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcclxuICAgICAgICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlubmVySFRNTCBmb3IgU1ZHIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIi5jb25jYXQoY3VyLCBcIjwvc3ZnPlwiKTtcclxuICAgICAgICAgICAgdmFyIHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIHNraXAgdGhlIHVwZGF0ZSBpZiBvbGQgYW5kIG5ldyBWRE9NIHN0YXRlIGlzIHRoZSBzYW1lLlxyXG4gICAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcclxuICAgICAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxyXG4gICAgICAgIC8vIFRoaXMgICM0NTIxIGJ5IHNraXBwaW5nIHRoZSB1bm5lY2Vzc2FyeSBgY2hlY2tlZGAgdXBkYXRlLlxyXG4gICAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XSkge1xyXG4gICAgICAgICAgICAvLyBzb21lIHByb3BlcnR5IHVwZGF0ZXMgY2FuIHRocm93XHJcbiAgICAgICAgICAgIC8vIGUuZy4gYHZhbHVlYCBvbiA8cHJvZ3Jlc3M+IHcvIG5vbi1maW5pdGUgdmFsdWVcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGVsbVtrZXldID0gY3VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBjaGVja1ZhbCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgIC8vQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgIWVsbS5jb21wb3NpbmcgJiZcclxuICAgICAgICAoZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XHJcbiAgICAgICAgICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XHJcbiAgICAgICAgICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkge1xyXG4gICAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xyXG4gICAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXHJcbiAgICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XHJcbiAgICAvLyAjNjE1N1xyXG4gICAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXHJcbiAgICB0cnkge1xyXG4gICAgICAgIG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsO1xyXG59XHJcbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgbmV3VmFsKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XHJcbiAgICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcclxuICAgIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XHJcbiAgICAgICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vZGlmaWVycy50cmltKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWw7XHJcbn1cclxudmFyIGRvbVByb3BzID0ge1xyXG4gICAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcclxuICAgIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcclxufTtcblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XHJcbiAgICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xyXG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xyXG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59KTtcclxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcclxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhKGRhdGEpIHtcclxuICAgIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcclxuICAgIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxyXG4gICAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcclxuICAgIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKSA6IHN0eWxlO1xyXG59XHJcbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcclxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGJpbmRpbmdTdHlsZSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xyXG4gICAgICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmluZGluZ1N0eWxlO1xyXG59XHJcbi8qKlxyXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXHJcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdHlsZSh2bm9kZSwgY2hlY2tDaGlsZCkge1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgdmFyIHN0eWxlRGF0YTtcclxuICAgIGlmIChjaGVja0NoaWxkKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xyXG4gICAgICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLmRhdGEgJiZcclxuICAgICAgICAgICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xyXG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBwYXJlbnROb2RlLnBhcmVudCBub3QgVk5vZGVXaXRoRGF0YVxyXG4gICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcclxudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XHJcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XHJcbiAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxyXG4gICAgICAgICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XHJcbiAgICAgICAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcclxudmFyIGVtcHR5U3R5bGU7XHJcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcclxuICAgIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xyXG4gICAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xyXG4gICAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIHByb3AgaW4gZW1wdHlTdHlsZSkge1xyXG4gICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgfVxyXG4gICAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgbmFtZV8xID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xyXG4gICAgICAgIGlmIChuYW1lXzEgaW4gZW1wdHlTdHlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZV8xO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xyXG4gICAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiZcclxuICAgICAgICBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXHJcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJlxyXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdHlsZSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY3VyLCBuYW1lO1xyXG4gICAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG4gICAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcclxuICAgIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xyXG4gICAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcclxuICAgIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcclxuICAgIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcclxuICAgIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcclxuICAgIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcclxuICAgIC8vIHRvIG11dGF0ZSBpdC5cclxuICAgIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKSA/IGV4dGVuZCh7fSwgc3R5bGUpIDogc3R5bGU7XHJcbiAgICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XHJcbiAgICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcclxuICAgICAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcclxuICAgICAgICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xyXG4gICAgICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xyXG4gICAgICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XHJcbiAgICAgICAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXHJcbiAgICAgICAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG52YXIgc3R5bGUgPSB7XHJcbiAgICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxyXG4gICAgdXBkYXRlOiB1cGRhdGVTdHlsZVxyXG59O1xuXG52YXIgd2hpdGVzcGFjZVJFID0gL1xccysvO1xyXG4vKipcclxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXHJcbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNscykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBjdXIgPSBcIiBcIi5jb25jYXQoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnLCBcIiBcIik7XHJcbiAgICAgICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXHJcbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNscykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBjdXIgPSBcIiBcIi5jb25jYXQoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnLCBcIiBcIik7XHJcbiAgICAgICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcclxuICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VyID0gY3VyLnRyaW0oKTtcclxuICAgICAgICBpZiAoY3VyKSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbihkZWYpIHtcclxuICAgIGlmICghZGVmKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHZhciByZXMgPSB7fTtcclxuICAgICAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4dGVuZChyZXMsIGRlZik7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZik7XHJcbiAgICB9XHJcbn1cclxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVudGVyQ2xhc3M6IFwiXCIuY29uY2F0KG5hbWUsIFwiLWVudGVyXCIpLFxyXG4gICAgICAgIGVudGVyVG9DbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItZW50ZXItdG9cIiksXHJcbiAgICAgICAgZW50ZXJBY3RpdmVDbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItZW50ZXItYWN0aXZlXCIpLFxyXG4gICAgICAgIGxlYXZlQ2xhc3M6IFwiXCIuY29uY2F0KG5hbWUsIFwiLWxlYXZlXCIpLFxyXG4gICAgICAgIGxlYXZlVG9DbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItbGVhdmUtdG9cIiksXHJcbiAgICAgICAgbGVhdmVBY3RpdmVDbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItbGVhdmUtYWN0aXZlXCIpXHJcbiAgICB9O1xyXG59KTtcclxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xyXG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcclxudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xyXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXHJcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcclxudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcclxudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcclxudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XHJcbmlmIChoYXNUcmFuc2l0aW9uKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcclxuICAgICAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XHJcbiAgICB9XHJcbiAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcclxuICAgICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xyXG4gICAgfVxyXG59XHJcbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxyXG52YXIgcmFmID0gaW5Ccm93c2VyXHJcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXHJcbiAgICAgICAgOiBzZXRUaW1lb3V0XHJcbiAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uICgvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmbikgeyByZXR1cm4gZm4oKTsgfTtcclxuZnVuY3Rpb24gbmV4dEZyYW1lKGZuKSB7XHJcbiAgICByYWYoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICByYWYoZm4pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xyXG4gICAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcclxuICAgICAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XHJcbiAgICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICByZW1vdmUkMihlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcclxufVxyXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgY2IpIHtcclxuICAgIHZhciBfYSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpLCB0eXBlID0gX2EudHlwZSwgdGltZW91dCA9IF9hLnRpbWVvdXQsIHByb3BDb3VudCA9IF9hLnByb3BDb3VudDtcclxuICAgIGlmICghdHlwZSlcclxuICAgICAgICByZXR1cm4gY2IoKTtcclxuICAgIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcclxuICAgIHZhciBlbmRlZCA9IDA7XHJcbiAgICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcclxuICAgICAgICBjYigpO1xyXG4gICAgfTtcclxuICAgIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xyXG4gICAgICAgICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aW1lb3V0ICsgMSk7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XHJcbn1cclxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xyXG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcclxuICAgIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XHJcbiAgICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xyXG4gICAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XHJcbiAgICB2YXIgdHlwZTtcclxuICAgIHZhciB0aW1lb3V0ID0gMDtcclxuICAgIHZhciBwcm9wQ291bnQgPSAwO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgICAgIHR5cGUgPVxyXG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAgICA/IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHByb3BDb3VudCA9IHR5cGVcclxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgOiAwO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiYgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgdGltZW91dDogdGltZW91dCxcclxuICAgICAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcclxuICAgICAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKTtcclxuICAgIH0pKTtcclxufVxyXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXHJcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cclxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3RpbmdcclxuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xyXG5mdW5jdGlvbiB0b01zKHMpIHtcclxuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcclxufVxuXG5mdW5jdGlvbiBlbnRlcih2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xyXG4gICAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG4gICAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcclxuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcclxuICAgICAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIGVsLl9sZWF2ZUNiKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XHJcbiAgICBpZiAoaXNVbmRlZihkYXRhKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBjc3MgPSBkYXRhLmNzcywgdHlwZSA9IGRhdGEudHlwZSwgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcywgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3MsIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcywgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcywgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzLCBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXIsIGVudGVyID0gZGF0YS5lbnRlciwgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlciwgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkLCBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhciwgYXBwZWFyID0gZGF0YS5hcHBlYXIsIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhciwgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQsIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcclxuICAgIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcclxuICAgIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxyXG4gICAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcclxuICAgIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxyXG4gICAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcclxuICAgIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcclxuICAgIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcclxuICAgICAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcclxuICAgICAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcclxuICAgIH1cclxuICAgIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcclxuICAgIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzID8gYXBwZWFyQ2xhc3MgOiBlbnRlckNsYXNzO1xyXG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3MgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3M7XHJcbiAgICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3MgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzO1xyXG4gICAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyID8gYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyIDogYmVmb3JlRW50ZXI7XHJcbiAgICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXIgPyAoaXNGdW5jdGlvbihhcHBlYXIpID8gYXBwZWFyIDogZW50ZXIpIDogZW50ZXI7XHJcbiAgICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhciA/IGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIgOiBhZnRlckVudGVyO1xyXG4gICAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXHJcbiAgICAgICAgPyBhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWRcclxuICAgICAgICA6IGVudGVyQ2FuY2VsbGVkO1xyXG4gICAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKGlzT2JqZWN0KGR1cmF0aW9uKSA/IGR1cmF0aW9uLmVudGVyIDogZHVyYXRpb24pO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcclxuICAgICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xyXG4gICAgfVxyXG4gICAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcclxuICAgIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xyXG4gICAgdmFyIGNiID0gKGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcclxuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5fZW50ZXJDYiA9IG51bGw7XHJcbiAgICB9KSk7XHJcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xyXG4gICAgICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZ05vZGUgJiZcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cclxuICAgIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xyXG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xyXG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xyXG4gICAgICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xyXG4gICAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcclxuICAgIH1cclxuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xyXG4gICAgICAgIGNiKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbGVhdmUodm5vZGUsIHJtKSB7XHJcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XHJcbiAgICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xyXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xyXG4gICAgICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgZWwuX2VudGVyQ2IoKTtcclxuICAgIH1cclxuICAgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcclxuICAgIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHJtKCk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY3NzID0gZGF0YS5jc3MsIHR5cGUgPSBkYXRhLnR5cGUsIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3MsIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzLCBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzLCBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmUsIGxlYXZlID0gZGF0YS5sZWF2ZSwgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZSwgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkLCBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlLCBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XHJcbiAgICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xyXG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcclxuICAgIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihpc09iamVjdChkdXJhdGlvbikgPyBkdXJhdGlvbi5sZWF2ZSA6IGR1cmF0aW9uKTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcclxuICAgICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNiID0gKGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xyXG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJtKCk7XHJcbiAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcclxuICAgIH0pKTtcclxuICAgIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICAgICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUoKSB7XHJcbiAgICAgICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxyXG4gICAgICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPVxyXG4gICAgICAgICAgICAgICAgdm5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcclxuICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XHJcbiAgICAgICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XHJcbiAgICAgICAgICAgIGNiKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxyXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uKHZhbCwgbmFtZSwgdm5vZGUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHdhcm4oXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIuY29uY2F0KG5hbWUsIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiKSArXHJcbiAgICAgICAgICAgIFwiZ290IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YWwpLCBcIi5cIiksIHZub2RlLmNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgIHdhcm4oXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIuY29uY2F0KG5hbWUsIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiKSArXHJcbiAgICAgICAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJywgdm5vZGUuY29udGV4dCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uKHZhbCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpO1xyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcclxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXHJcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxyXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGZuKSB7XHJcbiAgICBpZiAoaXNVbmRlZihmbikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcclxuICAgIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xyXG4gICAgICAgIC8vIGludm9rZXJcclxuICAgICAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChBcnJheS5pc0FycmF5KGludm9rZXJGbnMpID8gaW52b2tlckZuc1swXSA6IGludm9rZXJGbnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfZW50ZXIoXywgdm5vZGUpIHtcclxuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcclxuICAgICAgICBlbnRlcih2bm9kZSk7XHJcbiAgICB9XHJcbn1cclxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXJcclxuICAgID8ge1xyXG4gICAgICAgIGNyZWF0ZTogX2VudGVyLFxyXG4gICAgICAgIGFjdGl2YXRlOiBfZW50ZXIsXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAodm5vZGUsIHJtKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgICAgIGxlYXZlKHZub2RlLCBybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBybSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFthdHRycywga2xhc3MsIGV2ZW50cywgZG9tUHJvcHMsIHN0eWxlLCB0cmFuc2l0aW9uXTtcblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXHJcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXHJcbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XHJcbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcclxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXHJcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXHJcbiAqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuaWYgKGlzSUU5KSB7XHJcbiAgICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbnZhciBkaXJlY3RpdmUgPSB7XHJcbiAgICBpbnNlcnRlZDogZnVuY3Rpb24gKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcclxuICAgICAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAgICAgICAvLyAjNjkwM1xyXG4gICAgICAgICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XHJcbiAgICAgICAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XHJcbiAgICAgICAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xyXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxyXG4gICAgICAgICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSUU5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcclxuICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxyXG4gICAgICAgICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcclxuICAgICAgICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXHJcbiAgICAgICAgICAgIHZhciBwcmV2T3B0aW9uc18xID0gZWwuX3ZPcHRpb25zO1xyXG4gICAgICAgICAgICB2YXIgY3VyT3B0aW9uc18xID0gKGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKSk7XHJcbiAgICAgICAgICAgIGlmIChjdXJPcHRpb25zXzEuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNfMVtpXSk7IH0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxyXG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcclxuICAgICAgICAgICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnNfMSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9uc18xKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZWVkUmVzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSkge1xyXG4gICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xyXG4gICAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcclxuICAgIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgd2FybihcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIuY29uY2F0KGJpbmRpbmcuZXhwcmVzc2lvbiwgXCJcXFwiPiBcIikgK1xyXG4gICAgICAgICAgICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIi5jb25jYXQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSg4LCAtMSkpLCB2bSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHNlbGVjdGVkLCBvcHRpb247XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcclxuICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTXVsdGlwbGUpIHtcclxuICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbih2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VmFsdWUob3B0aW9uKSB7XHJcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uID8gb3B0aW9uLl92YWx1ZSA6IG9wdGlvbi52YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xyXG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcclxuICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXHJcbiAgICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcclxuICAgIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIoZWwsIHR5cGUpIHtcclxuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcclxuICAgIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xyXG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcclxufVxuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XHJcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUodm5vZGUpIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcclxuICAgICAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxyXG4gICAgICAgIDogdm5vZGU7XHJcbn1cclxudmFyIHNob3cgPSB7XHJcbiAgICBiaW5kOiBmdW5jdGlvbiAoZWwsIF9hLCB2bm9kZSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xyXG4gICAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcclxuICAgICAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gKGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheSk7XHJcbiAgICAgICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChlbCwgX2EsIHZub2RlKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWUsIG9sZFZhbHVlID0gX2Eub2xkVmFsdWU7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcclxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcclxuICAgICAgICBpZiAoIWlzRGVzdHJveSkge1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcclxuICAgIG1vZGVsOiBkaXJlY3RpdmUsXHJcbiAgICBzaG93OiBzaG93XHJcbn07XG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXHJcbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICBhcHBlYXI6IEJvb2xlYW4sXHJcbiAgICBjc3M6IEJvb2xlYW4sXHJcbiAgICBtb2RlOiBTdHJpbmcsXHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICBlbnRlckNsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlVG9DbGFzczogU3RyaW5nLFxyXG4gICAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXHJcbn07XHJcbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxyXG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxyXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQodm5vZGUpIHtcclxuICAgIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhKGNvbXApIHtcclxuICAgIHZhciBkYXRhID0ge307XHJcbiAgICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XHJcbiAgICAvLyBwcm9wc1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XHJcbiAgICAgICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xyXG4gICAgfVxyXG4gICAgLy8gZXZlbnRzLlxyXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXHJcbiAgICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xyXG4gICAgZm9yICh2YXIga2V5IGluIGxpc3RlbmVycykge1xyXG4gICAgICAgIGRhdGFbY2FtZWxpemUoa2V5KV0gPSBsaXN0ZW5lcnNba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG59XHJcbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XHJcbiAgICAgICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XHJcbiAgICAgICAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24odm5vZGUpIHtcclxuICAgIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSB7XHJcbiAgICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWc7XHJcbn1cclxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xyXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcclxudmFyIFRyYW5zaXRpb24gPSB7XHJcbiAgICBuYW1lOiAndHJhbnNpdGlvbicsXHJcbiAgICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxyXG4gICAgYWJzdHJhY3Q6IHRydWUsXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xyXG4gICAgICAgIGlmICghY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxyXG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGlzTm90VGV4dE5vZGUpO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgd2FybignPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xyXG4gICAgICAgICAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJywgdGhpcy4kcGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XHJcbiAgICAgICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XHJcbiAgICAgICAgICAgIHdhcm4oJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLCB0aGlzLiRwYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXHJcbiAgICAgICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXHJcbiAgICAgICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByYXdDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXHJcbiAgICAgICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxyXG4gICAgICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFjaGlsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmF3Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXHJcbiAgICAgICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xyXG4gICAgICAgIC8vIGR1cmluZyBlbnRlcmluZy5cclxuICAgICAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIi5jb25jYXQodGhpcy5fdWlkLCBcIi1cIik7XHJcbiAgICAgICAgY2hpbGQua2V5ID1cclxuICAgICAgICAgICAgY2hpbGQua2V5ID09IG51bGxcclxuICAgICAgICAgICAgICAgID8gY2hpbGQuaXNDb21tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgPyBpZCArICdjb21tZW50J1xyXG4gICAgICAgICAgICAgICAgICAgIDogaWQgKyBjaGlsZC50YWdcclxuICAgICAgICAgICAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxyXG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjaGlsZC5rZXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpZCArIGNoaWxkLmtleVxyXG4gICAgICAgICAgICAgICAgICAgIDogY2hpbGQua2V5O1xyXG4gICAgICAgIHZhciBkYXRhID0gKChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID1cclxuICAgICAgICAgICAgZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpKTtcclxuICAgICAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcclxuICAgICAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xyXG4gICAgICAgIC8vIG1hcmsgdi1zaG93XHJcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXHJcbiAgICAgICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xyXG4gICAgICAgICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2xkQ2hpbGQgJiZcclxuICAgICAgICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxyXG4gICAgICAgICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxyXG4gICAgICAgICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxyXG4gICAgICAgICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxyXG4gICAgICAgICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmXHJcbiAgICAgICAgICAgICAgICBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KSkge1xyXG4gICAgICAgICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcclxuICAgICAgICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxyXG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcclxuICAgICAgICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxyXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbGVhdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLiRmb3JjZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkZWxheWVkTGVhdmVfMTtcclxuICAgICAgICAgICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZExlYXZlXzEoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheWVkTGVhdmVfMSA9IGxlYXZlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhd0NoaWxkO1xyXG4gICAgfVxyXG59O1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXHJcbnZhciBwcm9wcyA9IGV4dGVuZCh7XHJcbiAgICB0YWc6IFN0cmluZyxcclxuICAgIG1vdmVDbGFzczogU3RyaW5nXHJcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XHJcbmRlbGV0ZSBwcm9wcy5tb2RlO1xyXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xyXG4gICAgcHJvcHM6IHByb3BzLFxyXG4gICAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKF90aGlzKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xyXG4gICAgICAgICAgICBfdGhpcy5fX3BhdGNoX18oX3RoaXMuX3Zub2RlLCBfdGhpcy5rZXB0LCBmYWxzZSwgLy8gaHlkcmF0aW5nXHJcbiAgICAgICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBfdGhpcy5fdm5vZGUgPSBfdGhpcy5rZXB0O1xyXG4gICAgICAgICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgdXBkYXRlLmNhbGwoX3RoaXMsIHZub2RlLCBoeWRyYXRpbmcpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoaCkge1xyXG4gICAgICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XHJcbiAgICAgICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9ICh0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gKHRoaXMuY2hpbGRyZW4gPSBbXSk7XHJcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKGMudGFnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwW2Mua2V5XSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgKGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG9wdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lKG9wdHMuQ3Rvci5vcHRpb25zKSB8fCBvcHRzLnRhZyB8fCAnJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGMudGFnO1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiLmNvbmNhdChuYW1lXzEsIFwiPlwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICB2YXIga2VwdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBwcmV2Q2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBjLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIG5vdCB0eXBlZCBpbiBOb2RlXHJcbiAgICAgICAgICAgICAgICBjLmRhdGEucG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwW2Mua2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtlcHQucHVzaChjKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChjKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcclxuICAgICAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJztcclxuICAgICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xyXG4gICAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxyXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xyXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xyXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XHJcbiAgICAgICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXHJcbiAgICAgICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcclxuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgICAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcclxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbF8xID0gYy5lbG07XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGVsXzEuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWxfMSwgbW92ZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xyXG4gICAgICAgICAgICAgICAgZWxfMS5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgKGVsXzEuX21vdmVDYiA9IGZ1bmN0aW9uIGNiKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWxfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxfMS5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbF8xLl9tb3ZlQ2IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWxfMSwgbW92ZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgaGFzTW92ZTogZnVuY3Rpb24gKGVsLCBtb3ZlQ2xhc3MpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXHJcbiAgICAgICAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xyXG4gICAgICAgICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXHJcbiAgICAgICAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xyXG4gICAgICAgICAgICAvLyBpcyBhcHBsaWVkLlxyXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcclxuICAgICAgICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcclxuICAgICAgICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XHJcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoYy5lbG0uX21vdmVDYikge1xyXG4gICAgICAgIGMuZWxtLl9tb3ZlQ2IoKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XHJcbiAgICAgICAgYy5lbG0uX2VudGVyQ2IoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XHJcbiAgICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XHJcbiAgICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcclxuICAgIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xyXG4gICAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcclxuICAgIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xyXG4gICAgaWYgKGR4IHx8IGR5KSB7XHJcbiAgICAgICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xyXG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQoZHgsIFwicHgsXCIpLmNvbmNhdChkeSwgXCJweClcIik7XHJcbiAgICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xyXG4gICAgfVxyXG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XHJcbiAgICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxyXG4gICAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcclxufTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xyXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XHJcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XHJcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcclxuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XHJcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XHJcbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xyXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcclxuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XHJcbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cclxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XHJcbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcclxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwsIGh5ZHJhdGluZykge1xyXG4gICAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZyk7XHJcbn07XHJcbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmIChpbkJyb3dzZXIpIHtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcclxuICAgICAgICAgICAgaWYgKGRldnRvb2xzKSB7XHJcbiAgICAgICAgICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKCdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcclxuICAgICAgICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcclxuICAgICAgICAgICAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcclxuICAgICAgICAgICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgMCk7XHJcbn1cblxuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIGNvbXB1dGVkLCBjdXN0b21SZWYsIFZ1ZSBhcyBkZWZhdWx0LCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWwsIGVmZmVjdFNjb3BlLCBnZXRDdXJyZW50SW5zdGFuY2UsIGdldEN1cnJlbnRTY29wZSwgaCwgaW5qZWN0LCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBtZXJnZURlZmF1bHRzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNjb3BlRGlzcG9zZSwgb25TZXJ2ZXJQcmVmZXRjaCwgb25Vbm1vdW50ZWQsIG9uVXBkYXRlZCwgcHJvdmlkZSwgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiQxIGFzIHJlZiwgc2V0LCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyaWdnZXJSZWYsIHVucmVmLCB1c2VBdHRycywgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB1c2VMaXN0ZW5lcnMsIHVzZVNsb3RzLCB2ZXJzaW9uLCB3YXRjaCwgd2F0Y2hFZmZlY3QsIHdhdGNoUG9zdEVmZmVjdCwgd2F0Y2hTeW5jRWZmZWN0IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2b0e\n")},"2b6d":function(module,exports){eval("L.LabelTextCollision = L.Canvas.extend({\n  options: {\n    /**\r\n     * Collision detection\r\n     */\n    collisionFlg: true\n  },\n  initialize: function initialize(options) {\n    options = L.Util.setOptions(this, options); //add\n\n    L.Util.stamp(this);\n    this._layers = this._layers || {};\n  },\n  _handleMouseHover: function _handleMouseHover(e, point) {\n    var id, layer;\n\n    for (id in this._drawnLayers) {\n      layer = this._drawnLayers[id];\n\n      if (layer.options.interactive && layer._containsPoint(point)) {\n        L.DomUtil.addClass(this._containerText, 'leaflet-interactive'); // change cursor\n\n        this._fireEvent([layer], e, 'mouseover');\n\n        this._hoveredLayer = layer;\n      }\n    }\n\n    if (this._hoveredLayer) {\n      this._fireEvent([this._hoveredLayer], e);\n    }\n  },\n  _handleMouseOut: function _handleMouseOut(e, point) {\n    var layer = this._hoveredLayer;\n\n    if (layer && (e.type === 'mouseout' || !layer._containsPoint(point))) {\n      // if we're leaving the layer, fire mouseout\n      L.DomUtil.removeClass(this._containerText, 'leaflet-interactive');\n\n      this._fireEvent([layer], e, 'mouseout');\n\n      this._hoveredLayer = null;\n    }\n  },\n  _updateTransform: function _updateTransform(center, zoom) {\n    L.Canvas.prototype._updateTransform.call(this, center, zoom);\n\n    var scale = this._map.getZoomScale(zoom, this._zoom),\n        position = L.DomUtil.getPosition(this._container),\n        viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n        currentCenterPoint = this._map.project(this._center, zoom),\n        destCenterPoint = this._map.project(center, zoom),\n        centerOffset = destCenterPoint.subtract(currentCenterPoint),\n        topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);\n\n    if (L.Browser.any3d) {\n      L.DomUtil.setTransform(this._containerText, topLeftOffset, scale);\n    } else {\n      L.DomUtil.setPosition(this._containerText, topLeftOffset);\n    }\n  },\n  _initContainer: function _initContainer(options) {\n    L.Canvas.prototype._initContainer.call(this);\n\n    this._containerText = document.createElement('canvas');\n    L.DomEvent.on(this._containerText, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this).on(this._containerText, 'click dblclick mousedown mouseup contextmenu', this._onClick, this).on(this._containerText, 'mouseout', this._handleMouseOut, this);\n    this._ctxLabel = this._containerText.getContext('2d');\n    L.DomUtil.addClass(this._containerText, 'leaflet-zoom-animated');\n    this.getPane().appendChild(this._containerText);\n  },\n  _update: function _update() {\n    // textList\n    this._textList = [];\n\n    L.Renderer.prototype._update.call(this);\n\n    var b = this._bounds,\n        container = this._containerText,\n        size = b.getSize(),\n        m = L.Browser.retina ? 2 : 1;\n    L.DomUtil.setPosition(container, b.min); // set canvas size (also clearing it); use double size on retina\n\n    container.width = m * size.x;\n    container.height = m * size.y;\n    container.style.width = size.x + 'px';\n    container.style.height = size.y + 'px'; // display text on the whole surface\n\n    container.style.zIndex = '4';\n    this._container.style.zIndex = '3';\n\n    if (L.Browser.retina) {\n      this._ctxLabel.scale(2, 2);\n    } // translate so we use the same path coordinates after canvas\n    // element moves\n\n\n    this._ctxLabel.translate(-b.min.x, -b.min.y);\n\n    L.Canvas.prototype._update.call(this);\n  },\n  _updatePoly: function _updatePoly(layer, closed) {\n    L.Canvas.prototype._updatePoly.call(this, layer, closed);\n\n    if (this._map.getBounds().contains(layer.getBounds())) {\n      this._text(this._ctxLabel, layer);\n    }\n  },\n  _updateCircle: function _updateCircle(layer) {\n    L.Canvas.prototype._updateCircle.call(this, layer);\n\n    if (this._map.getBounds().contains(layer.getLatLng())) {\n      this._text(this._ctxLabel, layer);\n    }\n  },\n  _text: function _text(ctx, layer) {\n    var text = layer.options.text;\n    if (text == null) return; //文字样式\n\n    var textStyle = layer.options.textStyle || {};\n    ctx.save();\n    ctx.globalAlpha = 1;\n    var p = layer._point;\n    var textPoint;\n\n    if (p == undefined) {\n      // polygon or polyline\n      if (layer._parts.length == 0 || layer._parts[0].length == 0) {\n        return;\n      }\n\n      p = this._getCenter(layer._parts[0]);\n    } // label bounds offset\n\n\n    var offsetX = textStyle.offsetX || 0;\n    var offsetY = textStyle.offsetY || 0;\n    /**\r\n     * TODO setting for custom font\r\n     */\n\n    ctx.lineWidth = 4.0;\n    ctx.font = textStyle.font || \"16px 'Microsoft Yahei'\"; // Collision detection\n\n    if (this.options.collisionFlg) {\n      var textWidth = ctx.measureText(text).width + p.x; // + offsetX;\n\n      var textHeight = p.y + offsetY + 20;\n      var bounds = L.bounds(L.point(p.x + offsetX, p.y + offsetY), L.point(textWidth, textHeight));\n\n      for (var index in this._textList) {\n        var pointBounds = this._textList[index];\n\n        if (pointBounds.intersects(bounds)) {\n          return;\n        }\n      }\n\n      this._textList.push(bounds);\n    }\n\n    if (textStyle.stroke) {\n      ctx.strokeStyle = textStyle.strokeColor || 'white';\n      ctx.strokeText(text, p.x + offsetX, p.y + offsetY);\n    }\n\n    ctx.fillStyle = textStyle.color || 'blue';\n\n    if (textStyle.rotate) {\n      //有旋转角度\n      ctx.translate(p.x, p.y);\n      ctx.rotate(textStyle.rotate * Math.PI / 180);\n      ctx.fillText(text, 0, 0);\n      ctx.restore();\n    } else {\n      ctx.fillText(text, p.x + offsetX, p.y + offsetY);\n    }\n  },\n  _getCenter: function _getCenter(points) {\n    var i,\n        halfDist,\n        segDist,\n        dist,\n        p1,\n        p2,\n        ratio,\n        len = points.length;\n\n    if (!len) {\n      return null;\n    } // polyline centroid algorithm; only uses the first ring if\n    // there are multiple\n\n\n    for (i = 0, halfDist = 0; i < len - 1; i++) {\n      halfDist += points[i].distanceTo(points[i + 1]) / 2;\n    } // The line is so small in the current view that all points are\n    // on the same pixel.\n\n\n    if (halfDist === 0) {\n      return points[0];\n    }\n\n    for (i = 0, dist = 0; i < len - 1; i++) {\n      p1 = points[i];\n      p2 = points[i + 1];\n      segDist = p1.distanceTo(p2);\n      dist += segDist;\n\n      if (dist > halfDist) {\n        ratio = (dist - halfDist) / segDist;\n        var resutl = [p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)];\n        return L.point(resutl[0], resutl[1]);\n      }\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvd2xlYWZsZXQvbGliL0wuTGFiZWxUZXh0Q29sbGlzaW9uLmpzPzJiNmQiXSwibmFtZXMiOlsiTCIsIkxhYmVsVGV4dENvbGxpc2lvbiIsIkNhbnZhcyIsImV4dGVuZCIsIm9wdGlvbnMiLCJjb2xsaXNpb25GbGciLCJpbml0aWFsaXplIiwiVXRpbCIsInNldE9wdGlvbnMiLCJzdGFtcCIsIl9sYXllcnMiLCJfaGFuZGxlTW91c2VIb3ZlciIsImUiLCJwb2ludCIsImlkIiwibGF5ZXIiLCJfZHJhd25MYXllcnMiLCJpbnRlcmFjdGl2ZSIsIl9jb250YWluc1BvaW50IiwiRG9tVXRpbCIsImFkZENsYXNzIiwiX2NvbnRhaW5lclRleHQiLCJfZmlyZUV2ZW50IiwiX2hvdmVyZWRMYXllciIsIl9oYW5kbGVNb3VzZU91dCIsInR5cGUiLCJyZW1vdmVDbGFzcyIsIl91cGRhdGVUcmFuc2Zvcm0iLCJjZW50ZXIiLCJ6b29tIiwicHJvdG90eXBlIiwiY2FsbCIsInNjYWxlIiwiX21hcCIsImdldFpvb21TY2FsZSIsIl96b29tIiwicG9zaXRpb24iLCJnZXRQb3NpdGlvbiIsIl9jb250YWluZXIiLCJ2aWV3SGFsZiIsImdldFNpemUiLCJtdWx0aXBseUJ5IiwicGFkZGluZyIsImN1cnJlbnRDZW50ZXJQb2ludCIsInByb2plY3QiLCJfY2VudGVyIiwiZGVzdENlbnRlclBvaW50IiwiY2VudGVyT2Zmc2V0Iiwic3VidHJhY3QiLCJ0b3BMZWZ0T2Zmc2V0IiwiYWRkIiwiQnJvd3NlciIsImFueTNkIiwic2V0VHJhbnNmb3JtIiwic2V0UG9zaXRpb24iLCJfaW5pdENvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIkRvbUV2ZW50Iiwib24iLCJ0aHJvdHRsZSIsIl9vbk1vdXNlTW92ZSIsIl9vbkNsaWNrIiwiX2N0eExhYmVsIiwiZ2V0Q29udGV4dCIsImdldFBhbmUiLCJhcHBlbmRDaGlsZCIsIl91cGRhdGUiLCJfdGV4dExpc3QiLCJSZW5kZXJlciIsImIiLCJfYm91bmRzIiwiY29udGFpbmVyIiwic2l6ZSIsIm0iLCJyZXRpbmEiLCJtaW4iLCJ3aWR0aCIsIngiLCJoZWlnaHQiLCJ5Iiwic3R5bGUiLCJ6SW5kZXgiLCJ0cmFuc2xhdGUiLCJfdXBkYXRlUG9seSIsImNsb3NlZCIsImdldEJvdW5kcyIsImNvbnRhaW5zIiwiX3RleHQiLCJfdXBkYXRlQ2lyY2xlIiwiZ2V0TGF0TG5nIiwiY3R4IiwidGV4dCIsInRleHRTdHlsZSIsInNhdmUiLCJnbG9iYWxBbHBoYSIsInAiLCJfcG9pbnQiLCJ0ZXh0UG9pbnQiLCJ1bmRlZmluZWQiLCJfcGFydHMiLCJsZW5ndGgiLCJfZ2V0Q2VudGVyIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJsaW5lV2lkdGgiLCJmb250IiwidGV4dFdpZHRoIiwibWVhc3VyZVRleHQiLCJ0ZXh0SGVpZ2h0IiwiYm91bmRzIiwiaW5kZXgiLCJwb2ludEJvdW5kcyIsImludGVyc2VjdHMiLCJwdXNoIiwic3Ryb2tlIiwic3Ryb2tlU3R5bGUiLCJzdHJva2VDb2xvciIsInN0cm9rZVRleHQiLCJmaWxsU3R5bGUiLCJjb2xvciIsInJvdGF0ZSIsIk1hdGgiLCJQSSIsImZpbGxUZXh0IiwicmVzdG9yZSIsInBvaW50cyIsImkiLCJoYWxmRGlzdCIsInNlZ0Rpc3QiLCJkaXN0IiwicDEiLCJwMiIsInJhdGlvIiwibGVuIiwiZGlzdGFuY2VUbyIsInJlc3V0bCJdLCJtYXBwaW5ncyI6IkFBQUFBLENBQUMsQ0FBQ0Msa0JBQUYsR0FBdUJELENBQUMsQ0FBQ0UsTUFBRixDQUFTQyxNQUFULENBQWdCO0VBQ3JDQyxPQUFPLEVBQUU7SUFDUDtBQUNKO0FBQ0E7SUFDSUMsWUFBWSxFQUFFO0VBSlAsQ0FENEI7RUFRckNDLFVBQVUsRUFBRSxvQkFBU0YsT0FBVCxFQUFrQjtJQUM1QkEsT0FBTyxHQUFHSixDQUFDLENBQUNPLElBQUYsQ0FBT0MsVUFBUCxDQUFrQixJQUFsQixFQUF3QkosT0FBeEIsQ0FBVixDQUQ0QixD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TUFDQUssRUFBRSxHQUFHTixNQUFNLENBQUNDLENBQUMsR0FBRyxDQUFMLENBQVg7TUFDQUUsT0FBTyxHQUFHRSxFQUFFLENBQUNJLFVBQUgsQ0FBY0gsRUFBZCxDQUFWO01BQ0FGLElBQUksSUFBSUQsT0FBUjs7TUFFQSxJQUFJQyxJQUFJLEdBQUdGLFFBQVgsRUFBcUI7UUFDbkJLLEtBQUssR0FBRyxDQUFDSCxJQUFJLEdBQUdGLFFBQVIsSUFBb0JDLE9BQTVCO1FBQ0EsSUFBSU8sTUFBTSxHQUFHLENBQUNKLEVBQUUsQ0FBQ3RELENBQUgsR0FBT3VELEtBQUssSUFBSUQsRUFBRSxDQUFDdEQsQ0FBSCxHQUFPcUQsRUFBRSxDQUFDckQsQ0FBZCxDQUFiLEVBQStCc0QsRUFBRSxDQUFDcEQsQ0FBSCxHQUFPcUQsS0FBSyxJQUFJRCxFQUFFLENBQUNwRCxDQUFILEdBQU9tRCxFQUFFLENBQUNuRCxDQUFkLENBQTNDLENBQWI7UUFFQSxPQUFPaEYsQ0FBQyxDQUFDYSxLQUFGLENBQVEySCxNQUFNLENBQUMsQ0FBRCxDQUFkLEVBQW1CQSxNQUFNLENBQUMsQ0FBRCxDQUF6QixDQUFQO01BQ0Q7SUFDRjtFQUNGO0FBbE9vQyxDQUFoQixDQUF2QiIsImZpbGUiOiIyYjZkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiTC5MYWJlbFRleHRDb2xsaXNpb24gPSBMLkNhbnZhcy5leHRlbmQoe1xyXG4gIG9wdGlvbnM6IHtcclxuICAgIC8qKlxyXG4gICAgICogQ29sbGlzaW9uIGRldGVjdGlvblxyXG4gICAgICovXHJcbiAgICBjb2xsaXNpb25GbGc6IHRydWVcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgICAvL2FkZFxyXG4gICAgTC5VdGlsLnN0YW1wKHRoaXMpO1xyXG4gICAgdGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xyXG4gIH0sXHJcblxyXG4gIF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbihlLCBwb2ludCkge1xyXG4gICAgdmFyIGlkLCBsYXllcjtcclxuXHJcbiAgICBmb3IgKGlkIGluIHRoaXMuX2RyYXduTGF5ZXJzKSB7XHJcbiAgICAgIGxheWVyID0gdGhpcy5fZHJhd25MYXllcnNbaWRdO1xyXG4gICAgICBpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcclxuICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyVGV4dCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxyXG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdmVyJyk7XHJcbiAgICAgICAgdGhpcy5faG92ZXJlZExheWVyID0gbGF5ZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5faG92ZXJlZExheWVyKSB7XHJcbiAgICAgIHRoaXMuX2ZpcmVFdmVudChbdGhpcy5faG92ZXJlZExheWVyXSwgZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX2hhbmRsZU1vdXNlT3V0OiBmdW5jdGlvbihlLCBwb2ludCkge1xyXG4gICAgdmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xyXG4gICAgaWYgKGxheWVyICYmIChlLnR5cGUgPT09ICdtb3VzZW91dCcgfHwgIWxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkpIHtcclxuICAgICAgLy8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcclxuICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lclRleHQsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcbiAgICAgIHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcclxuICAgICAgdGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfdXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbihjZW50ZXIsIHpvb20pIHtcclxuICAgIEwuQ2FudmFzLnByb3RvdHlwZS5fdXBkYXRlVHJhbnNmb3JtLmNhbGwodGhpcywgY2VudGVyLCB6b29tKTtcclxuXHJcbiAgICB2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxyXG4gICAgICBwb3NpdGlvbiA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpLFxyXG4gICAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXHJcbiAgICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXHJcbiAgICAgIGRlc3RDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcbiAgICAgIGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpLFxyXG4gICAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGZcclxuICAgICAgICAubXVsdGlwbHlCeSgtc2NhbGUpXHJcbiAgICAgICAgLmFkZChwb3NpdGlvbilcclxuICAgICAgICAuYWRkKHZpZXdIYWxmKVxyXG4gICAgICAgIC5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xyXG5cclxuICAgIGlmIChMLkJyb3dzZXIuYW55M2QpIHtcclxuICAgICAgTC5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXJUZXh0LCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyVGV4dCwgdG9wTGVmdE9mZnNldCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgTC5DYW52YXMucHJvdG90eXBlLl9pbml0Q29udGFpbmVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5fY29udGFpbmVyVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5cclxuICAgIEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyVGV4dCwgJ21vdXNlbW92ZScsIEwuVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdXNlTW92ZSwgMzIsIHRoaXMpLCB0aGlzKVxyXG4gICAgICAub24odGhpcy5fY29udGFpbmVyVGV4dCwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51JywgdGhpcy5fb25DbGljaywgdGhpcylcclxuICAgICAgLm9uKHRoaXMuX2NvbnRhaW5lclRleHQsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLl9jdHhMYWJlbCA9IHRoaXMuX2NvbnRhaW5lclRleHQuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyVGV4dCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG4gICAgdGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyVGV4dCk7XHJcbiAgfSxcclxuXHJcbiAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAvLyB0ZXh0TGlzdFxyXG4gICAgdGhpcy5fdGV4dExpc3QgPSBbXTtcclxuXHJcbiAgICBMLlJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICB2YXIgYiA9IHRoaXMuX2JvdW5kcyxcclxuICAgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyVGV4dCxcclxuICAgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxyXG4gICAgICBtID0gTC5Ccm93c2VyLnJldGluYSA/IDIgOiAxO1xyXG5cclxuICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcclxuXHJcbiAgICAvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXHJcbiAgICBjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xyXG4gICAgY29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XHJcbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xyXG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblxyXG4gICAgLy8gZGlzcGxheSB0ZXh0IG9uIHRoZSB3aG9sZSBzdXJmYWNlXHJcbiAgICBjb250YWluZXIuc3R5bGUuekluZGV4ID0gJzQnO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9ICczJztcclxuXHJcbiAgICBpZiAoTC5Ccm93c2VyLnJldGluYSkge1xyXG4gICAgICB0aGlzLl9jdHhMYWJlbC5zY2FsZSgyLCAyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0cmFuc2xhdGUgc28gd2UgdXNlIHRoZSBzYW1lIHBhdGggY29vcmRpbmF0ZXMgYWZ0ZXIgY2FudmFzXHJcbiAgICAvLyBlbGVtZW50IG1vdmVzXHJcbiAgICB0aGlzLl9jdHhMYWJlbC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcclxuICAgIEwuQ2FudmFzLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgfSxcclxuXHJcbiAgX3VwZGF0ZVBvbHk6IGZ1bmN0aW9uKGxheWVyLCBjbG9zZWQpIHtcclxuICAgIEwuQ2FudmFzLnByb3RvdHlwZS5fdXBkYXRlUG9seS5jYWxsKHRoaXMsIGxheWVyLCBjbG9zZWQpO1xyXG4gICAgaWYgKHRoaXMuX21hcC5nZXRCb3VuZHMoKS5jb250YWlucyhsYXllci5nZXRCb3VuZHMoKSkpIHtcclxuICAgICAgdGhpcy5fdGV4dCh0aGlzLl9jdHhMYWJlbCwgbGF5ZXIpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uKGxheWVyKSB7XHJcbiAgICBMLkNhbnZhcy5wcm90b3R5cGUuX3VwZGF0ZUNpcmNsZS5jYWxsKHRoaXMsIGxheWVyKTtcclxuICAgIGlmICh0aGlzLl9tYXAuZ2V0Qm91bmRzKCkuY29udGFpbnMobGF5ZXIuZ2V0TGF0TG5nKCkpKSB7XHJcbiAgICAgIHRoaXMuX3RleHQodGhpcy5fY3R4TGFiZWwsIGxheWVyKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfdGV4dDogZnVuY3Rpb24oY3R4LCBsYXllcikge1xyXG4gICAgdmFyIHRleHQgPSBsYXllci5vcHRpb25zLnRleHQ7XHJcbiAgICBpZiAodGV4dCA9PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgLy/mloflrZfmoLflvI9cclxuICAgIHZhciB0ZXh0U3R5bGUgPSBsYXllci5vcHRpb25zLnRleHRTdHlsZSB8fCB7fTtcclxuXHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcclxuXHJcbiAgICB2YXIgcCA9IGxheWVyLl9wb2ludDtcclxuICAgIHZhciB0ZXh0UG9pbnQ7XHJcblxyXG4gICAgaWYgKHAgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIHBvbHlnb24gb3IgcG9seWxpbmVcclxuICAgICAgaWYgKGxheWVyLl9wYXJ0cy5sZW5ndGggPT0gMCB8fCBsYXllci5fcGFydHNbMF0ubGVuZ3RoID09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgcCA9IHRoaXMuX2dldENlbnRlcihsYXllci5fcGFydHNbMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGxhYmVsIGJvdW5kcyBvZmZzZXRcclxuICAgIHZhciBvZmZzZXRYID0gdGV4dFN0eWxlLm9mZnNldFggfHwgMDtcclxuICAgIHZhciBvZmZzZXRZID0gdGV4dFN0eWxlLm9mZnNldFkgfHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRPRE8gc2V0dGluZyBmb3IgY3VzdG9tIGZvbnRcclxuICAgICAqL1xyXG4gICAgY3R4LmxpbmVXaWR0aCA9IDQuMDtcclxuICAgIGN0eC5mb250ID0gdGV4dFN0eWxlLmZvbnQgfHwgXCIxNnB4ICdNaWNyb3NvZnQgWWFoZWknXCI7XHJcblxyXG4gICAgLy8gQ29sbGlzaW9uIGRldGVjdGlvblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2xsaXNpb25GbGcpIHtcclxuICAgICAgdmFyIHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCArIHAueDsgLy8gKyBvZmZzZXRYO1xyXG4gICAgICB2YXIgdGV4dEhlaWdodCA9IHAueSArIG9mZnNldFkgKyAyMDtcclxuICAgICAgdmFyIGJvdW5kcyA9IEwuYm91bmRzKEwucG9pbnQocC54ICsgb2Zmc2V0WCwgcC55ICsgb2Zmc2V0WSksIEwucG9pbnQodGV4dFdpZHRoLCB0ZXh0SGVpZ2h0KSk7XHJcbiAgICAgIGZvciAodmFyIGluZGV4IGluIHRoaXMuX3RleHRMaXN0KSB7XHJcbiAgICAgICAgdmFyIHBvaW50Qm91bmRzID0gdGhpcy5fdGV4dExpc3RbaW5kZXhdO1xyXG4gICAgICAgIGlmIChwb2ludEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fdGV4dExpc3QucHVzaChib3VuZHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0ZXh0U3R5bGUuc3Ryb2tlKSB7XHJcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRleHRTdHlsZS5zdHJva2VDb2xvciB8fCAnd2hpdGUnO1xyXG4gICAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCBwLnggKyBvZmZzZXRYLCBwLnkgKyBvZmZzZXRZKTtcclxuICAgIH1cclxuICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0U3R5bGUuY29sb3IgfHwgJ2JsdWUnO1xyXG5cclxuICAgIGlmICh0ZXh0U3R5bGUucm90YXRlKSB7XHJcbiAgICAgIC8v5pyJ5peL6L2s6KeS5bqmXHJcbiAgICAgIGN0eC50cmFuc2xhdGUocC54LCBwLnkpO1xyXG4gICAgICBjdHgucm90YXRlKCh0ZXh0U3R5bGUucm90YXRlICogTWF0aC5QSSkgLyAxODApO1xyXG4gICAgICBjdHguZmlsbFRleHQodGV4dCwgMCwgMCk7XHJcbiAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdHguZmlsbFRleHQodGV4dCwgcC54ICsgb2Zmc2V0WCwgcC55ICsgb2Zmc2V0WSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX2dldENlbnRlcjogZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgaGFsZkRpc3QsXHJcbiAgICAgIHNlZ0Rpc3QsXHJcbiAgICAgIGRpc3QsXHJcbiAgICAgIHAxLFxyXG4gICAgICBwMixcclxuICAgICAgcmF0aW8sXHJcbiAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG4gICAgaWYgKCFsZW4pIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcG9seWxpbmUgY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWZcclxuICAgIC8vIHRoZXJlIGFyZSBtdWx0aXBsZVxyXG5cclxuICAgIGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xyXG4gICAgICBoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlXHJcbiAgICAvLyBvbiB0aGUgc2FtZSBwaXhlbC5cclxuICAgIGlmIChoYWxmRGlzdCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gcG9pbnRzWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDAsIGRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XHJcbiAgICAgIHAxID0gcG9pbnRzW2ldO1xyXG4gICAgICBwMiA9IHBvaW50c1tpICsgMV07XHJcbiAgICAgIHNlZ0Rpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcclxuICAgICAgZGlzdCArPSBzZWdEaXN0O1xyXG5cclxuICAgICAgaWYgKGRpc3QgPiBoYWxmRGlzdCkge1xyXG4gICAgICAgIHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xyXG4gICAgICAgIHZhciByZXN1dGwgPSBbcDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSwgcDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KV07XHJcblxyXG4gICAgICAgIHJldHVybiBMLnBvaW50KHJlc3V0bFswXSwgcmVzdXRsWzFdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2b6d\n")},"2e8a":function(module,exports){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAzCAYAAAADxoFxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAF+mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTA4LTI0VDAwOjA2OjEzKzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMi0wOC0yNFQwMDowODozMyswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wOC0yNFQwMDowODozMyswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpiZGM3NzBkZC05M2VhLTJkNDktOWE5MC0xMTQyYzgwNWUyZjIiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpjMzAxMzA1Ni01MGZkLTRiNGYtOTYwMS02NmY5Y2I5OWY2NzYiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoyMzc4YjQ2Mi02MDE4LWYwNGItOGYwYS1hMzQxOGMwZTk5ZWQiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjIzNzhiNDYyLTYwMTgtZjA0Yi04ZjBhLWEzNDE4YzBlOTllZCIgc3RFdnQ6d2hlbj0iMjAyMi0wOC0yNFQwMDowNjoxMyswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiZGM3NzBkZC05M2VhLTJkNDktOWE5MC0xMTQyYzgwNWUyZjIiIHN0RXZ0OndoZW49IjIwMjItMDgtMjRUMDA6MDg6MzMrMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5/aX48AAAJS0lEQVRogcWaeVRU1x3Hv28WZ1hmBhdkiSeBMaWERTAa9bhXY3Ni3UhUFBDURKy2okatGhuNHoNJ64JA5GhSak1ElEhcGqPSGLWiqcRS1HBQqkkUBEWF2ZjtLf3jvTfzZpgVJs33nHdmDnPfnc/9zu/e3+/eByHTUwiACKeLFw2A4a6ASdLD+3lIMXdJuT4JsMCk4ArYAHoCLeIuCQAZgCAAcu49D20WXBYAVgAU7PDdGoAD9BgxgVPhSo83KFo1hAC2F4BgAKEA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"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdlcy8xLTIucG5nPzVmOWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjJlOGEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDMEFBQUF6Q0FZQUFBQUR4b0Z4QUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUYrbWxVV0hSWVRVdzZZMjl0TG1Ga2IySmxMbmh0Y0FBQUFBQUFQRDk0Y0dGamEyVjBJR0psWjJsdVBTTHZ1NzhpSUdsa1BTSlhOVTB3VFhCRFpXaHBTSHB5WlZONlRsUmplbXRqT1dRaVB6NGdQSGc2ZUcxd2JXVjBZU0I0Yld4dWN6cDRQU0poWkc5aVpUcHVjenB0WlhSaEx5SWdlRHA0YlhCMGF6MGlRV1J2WW1VZ1dFMVFJRU52Y21VZ05TNDJMV014TkRVZ056a3VNVFl6TkRrNUxDQXlNREU0THpBNEx6RXpMVEUyT2pRd09qSXlJQ0FnSUNBZ0lDQWlQaUE4Y21SbU9sSkVSaUI0Yld4dWN6cHlaR1k5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZNREl2TWpJdGNtUm1MWE41Ym5SaGVDMXVjeU1pUGlBOGNtUm1Pa1JsYzJOeWFYQjBhVzl1SUhKa1pqcGhZbTkxZEQwaUlpQjRiV3h1Y3pwNGJYQTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzhpSUhodGJHNXpPbVJqUFNKb2RIUndPaTh2Y0hWeWJDNXZjbWN2WkdNdlpXeGxiV1Z1ZEhNdk1TNHhMeUlnZUcxc2JuTTZjR2h2ZEc5emFHOXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNCb2IzUnZjMmh2Y0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JGZG5ROUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlVWMlpXNTBJeUlnZUcxd09rTnlaV0YwYjNKVWIyOXNQU0pCWkc5aVpTQlFhRzkwYjNOb2IzQWdRME1nTWpBeE9TQW9WMmx1Wkc5M2N5a2lJSGh0Y0RwRGNtVmhkR1ZFWVhSbFBTSXlNREl5TFRBNExUSTBWREF3T2pBMk9qRXpLekE0T2pBd0lpQjRiWEE2VFc5a2FXWjVSR0YwWlQwaU1qQXlNaTB3T0MweU5GUXdNRG93T0Rvek15c3dPRG93TUNJZ2VHMXdPazFsZEdGa1lYUmhSR0YwWlQwaU1qQXlNaTB3T0MweU5GUXdNRG93T0Rvek15c3dPRG93TUNJZ1pHTTZabTl5YldGMFBTSnBiV0ZuWlM5d2JtY2lJSEJvYjNSdmMyaHZjRHBEYjJ4dmNrMXZaR1U5SWpNaUlIQm9iM1J2YzJodmNEcEpRME5RY205bWFXeGxQU0p6VWtkQ0lFbEZRell4T1RZMkxUSXVNU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBpWkdNM056QmtaQzA1TTJWaExUSmtORGt0T1dFNU1DMHhNVFF5WXpnd05XVXlaaklpSUhodGNFMU5Pa1J2WTNWdFpXNTBTVVE5SW1Ga2IySmxPbVJ2WTJsa09uQm9iM1J2YzJodmNEcGpNekF4TXpBMU5pMDFNR1prTFRSaU5HWXRPVFl3TVMwMk5tWTVZMkk1T1dZMk56WWlJSGh0Y0UxTk9rOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3lNemM0WWpRMk1pMDJNREU0TFdZd05HSXRPR1l3WVMxaE16UXhPR013WlRrNVpXUWlQaUE4ZUcxd1RVMDZTR2x6ZEc5eWVUNGdQSEprWmpwVFpYRStJRHh5WkdZNmJHa2djM1JGZG5RNllXTjBhVzl1UFNKamNtVmhkR1ZrSWlCemRFVjJkRHBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pJek56aGlORFl5TFRZd01UZ3RaakEwWWkwNFpqQmhMV0V6TkRFNFl6QmxPVGxsWkNJZ2MzUkZkblE2ZDJobGJqMGlNakF5TWkwd09DMHlORlF3TURvd05qb3hNeXN3T0Rvd01DSWdjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01Ua2dLRmRwYm1SdmQzTXBJaTgrSUR4eVpHWTZiR2tnYzNSRmRuUTZZV04wYVc5dVBTSnpZWFpsWkNJZ2MzUkZkblE2YVc1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwaVpHTTNOekJrWkMwNU0yVmhMVEprTkRrdE9XRTVNQzB4TVRReVl6Z3dOV1V5WmpJaUlITjBSWFowT25kb1pXNDlJakl3TWpJdE1EZ3RNalJVTURBNk1EZzZNek1yTURnNk1EQWlJSE4wUlhaME9uTnZablIzWVhKbFFXZGxiblE5SWtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEUXlBeU1ERTVJQ2hYYVc1a2IzZHpLU0lnYzNSRmRuUTZZMmhoYm1kbFpEMGlMeUl2UGlBOEwzSmtaanBUWlhFK0lEd3ZlRzF3VFUwNlNHbHpkRzl5ZVQ0Z1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0lEd3ZjbVJtT2xKRVJqNGdQQzk0T25odGNHMWxkR0UrSUR3L2VIQmhZMnRsZENCbGJtUTlJbklpUHo1L2FYNDhBQUFKUzBsRVFWUm9nY1dhZVZSVTF4M0h2MjhXWjFobUJoZGtpU2VCTWFXRVJUQWE5YmhYWTNOaTNVaFVGQkRVUkt5Mm9rYXRHaHVOSG9OSjY0SkE1R2hTYWsxRWxFaGNHcVBTR0xXaXFjUlMxSEJRcWtrVUJFV0YyWmp0TGYzanZUZnpacGdWSnMzM25IZG1EblBmbmMvOXp1L2UzKy9lQnlIVFV3aUFDS2VMRncyQTRhNkFTZExEKzNsSU1YZEp1VDRKc01DazRBcllBSG9DTGVJdUNRQVpnQ0FBY3U0OUQyMFdYQllBVmdBVTdQRGRHb0FEOUJneGdWUGhTbzgzS0ZvMWhBQzJGNEJnQUtFQUZFVnI4aFpuSC94a2NZY3FqSDU3ODNzbkQ4N08rQWhBS3dBRGdFNEFKbTRBVnJEdVV3QVlYYVRLSzd5aVZXTjdUd2hqMmhNMEIwc0lZSU1BaEFCUXpqeGVPYnB3VlY2QlFxK1RDdStoeEdJVUxzMzdvV2pKc3IrMTllbGJCVURMd1J1NUFWamdGRDd1QnVBWHRBQld6TUhLZU5qNC85NVc3ODlkOEZGaS9jMElOd2JaZEdIc2VPdkdkL09yNmhJU3l5amdGcnE2encrQUFrQTd3L3NFN1FRckFSdXZ3UUFVVXBMc3UrT2RQK1NuSHlrZkUyd3dDRmNMajZKRkl2eDd5RXRNV1ZaTzArR1o2UlVHc2VRMEJiUnhBeEM2YitIZ2JlSGpGVnJScW5HZVpIemNoaTA1VUxvby8rMDFiMHBJMG1kWWR3TW95MTVJRnE1Y2ZlVitaTlRuZWdaWEFPaGhEeDkrQXR2Y0J6ZDVDYWQxMnQwa1UwMzkrcXVYdDYvTzJ4TGQzQ1RyQ2F3clhSMDVCa1ZyMXJkVmp4eDFTcy9ncEJINEFhejd6cjhBS1lUbVlmbTR0VTB5OWFQV2hPS1Z5M2FPK2Vwc1ZLQmhuYVhwM1J0RmY5ek1WR1JtWHpNUW90TlBHT1lNQ1R3Q080SDE0SnduWkhxS0I1YUNqZHNRQUNvNUVQM0J0czNiRmhRVkRDVm8rcWZtZFJBakV1SFl2QVg0ZVBVNlEydEV4R2tEZzArYkdlWVNCMjRoWkhxS0R3YzVBSlVJQ0YvOHhmRzNOcTM0ZlVhSVR0dWp1QTJFYnFXa1doZnZMVDF6TFdaZ0xnQU5BQk9mWE1RQWd0NnFyTWo5VGVXUmxjUCtjVGJrNThPMHl4UVVSSmZNbWlPNnJWUWQ0djdFQUd4WThLK1M1K3BxWjc3dzdWWDU5YkhqZnc1R20yaXhtQ2xabUdzMlNhV2l1b1NrR2wyZmZqY2dTRUE4TkFNQXRYRy8vRlRSMFNFZWRQRTgyc1BEeWZyUm8vKy93VXdRK0hCcG5rWWJHa29zS2QwbnE1Z3lnLzR1S1dVMzJGV0VYN3ZCVDBRWkFHVndaMmYwbmVSZjFJUWE5TGFhcEMwcW1ueWlWaFB4MVpmRVB5VnYxWlRwSFlrMS93cUxmdGdLQU5Bb2xIaTU0dGpwaHRRaDY4RFdMeG9Pbk9hZEpnR1lPNE9EdFFjeXMzY0pPd3R2ZVNDSnI3NGtia3hJc2w1TmU4M01FSUdkbXkweE1lYkdXRFV6NmUvSGJjQUFzQzhyeDNvM0xyNEVnQTdzV2syQ2l3aCtuUmFCWFo5VkFDSWJVK09ySTF0YlhFN0d1M0h4OU9QRVJQTkx4eXFEQ0tiN3BmSDNLYW5HTm9sVU11eGFqZFQ1czViK0VaancyWW55cHJqNGJXQmQxb0p6bVljRk53S1NHNUZ1eC9KVmE5MTltZnAyZzJqWTUwZURiZ3dld2x4K2ZaYlJYK2ZiQnd3Z2o4MmFvNG01WGhma0NoZ0FpdWEvWVdpTmlmMllnK1ZkdHMwdllScm4zVllDaUxnMmRuaFYzTzBHcjlYYjViSGpZWW1PTW84N1hDN3o1THhab1dRcUZpNTZPTGU0SUZKTXVkL2lOY2FxTWFtOGNzK1Q1MkpMQUR5RTNXVmI1eUpCZTM1N1pBU2czYlJoMHpKdndBQXc4dUo1akM4L0pEdjc2aFNjeWN3aG5aMm5KUko4dG01REMwVmFpYXpkT3p3Q0E4Q3VoYmxQbmc1NDloQUVMb2MzMUR1NDRhcGc2Z1ZBQVNDaUttMXl4WWdyMVMvNEFzK3JjbllHQ0pXQ25yYS9WUFJOemtKZDBwSHlFSlZXSS9KK0oxQXpLQVhUOXgvYXFvdCtwZ3hzemFFRFlBMXZxR2ZhNGhOY1Erc2lWVkMwYXNSZ0M2WStxVGV1eDExNFpWeVZ5TS9hZ3lFSTNCeVVpdVM2V3IvdW1idXIrTjRYNlptelFSRE5BTm9CbUhTUktpcjJYRFVlSnlUWjJycHlnQVliUTRiL0pBOXEvbkxLdEhOK0VRTWdHQVlEN3QvejY1NnpvOGJnL0s4bTdnWkJkSUN0cWEwUVRENmh1a0J6Mnh3S2JBMnJXL0tuZ2cwbXVkd3ZxeG1DZ0xmWUZZb1VpMUd3NE0yYmhvaW9pMkFyT1JNQTB0MSswVjJzMmR4dUQrdmRmaWhyL2tGL29DbXhmeWNURmErOGltK0hqeXdBbS9WNGwyM0FERVU2dEhjSkxYRGJERUNYdC9XRDNSMTkrbGg4aFdBSVFHcjFyYmxSSmtmeHZQbVhUUDNDYTJGM21mSjByT0JwVmpOZ1I5d0pRTE43eFpyM2ZZVzJ5T1h3ZGZMdW41NUdOUXdlV2dpN3k3WjBiUU54NnNzdHRKUGIrdTI1UzQvOXFCNm85UVdFSVh4YTRkQ3VWS0lrTStkTFMxanYyN0J2cHp5NjdCR2EvMzZ3YmhzQmFQTFhiMXpqQzR3eEpCaFNxOVZydXoyek04ejNFNU5MNEppdXV3QXpsSTlPQXphMytUTTVmZG5VR2Q5Y0h6YWl5U3NOSVlMSXkrclIzRDhDZjUwOTV6QVpHbm9mOW5xNXl5R05LL255Ty9MRmxBbUFkdDNtOTFaNEs1S01vYUZlTzkyVk1VL1hGcCt3SDNhWHJicElsY3VKd05DT0JuaUZkbkxiOE0vQlEyOWRtRHkxenRNOXRNVHprbGNmcTBaNTJzeS8wTDFranlCdzJSdUx6OUFBd0RsZ0s2Ynl0bXhiUlVxbGJuOUdiMDd2eU14K3BIMCtyZ0pzYmVFeGtRQit4clNUYkFubisyY0d0SnpJeWpucnJpRWw3ZVcyazh2SktUZzVlVm94SXhhM294c3VBMzVBTzZWMzdhSXQ3NytyRCt2dGNyYVozVGpORUFTMloyYmZOYW9Ibm9IZFphOUxYTGVoT2RIZ0VvNUZLbTAvOEx2bHBhNGFrWExYeDMyblJvekV4UW1UQ3NBbUVwOWQ5aW1OdXhQbkNMK1M2TmN1VzdtdlJUM1E2TnpPRXRSMWUwbUtKZGlabVYxcmZ2YTV5MkJkOWltUnVKSy9UZ1AyaEdNQW9DbFkvMDQrSTNMc3hoSVMzT1dtc29tVG1OcFJZd3RnZnhyZ1VCUjUvRUpmMDdnN09hZjNQVlBUVHQxSmZmR3BjTzBtNVk3UW5USTVDdWRtZlcyTmlyNkJIcnJjTFdoT2ZKaDBBdEJzM2JobEhTV3hiNnd0Q3NlSnVHL0tOUExPc0JFZmdvMWxJL3h3R1FpQTAwQlh0NCtPR0hXMWZ0VG9lN1NZUFlTaWV0a240bU9WQ250bnBaOGcrL2E3QXpha3pQQXhYYnRUZDUwR0hNOUt0Q3Z5Lzd6Y0hCTENBSUFwVEdWclZEejlOZE9ESWNQM3drdFI1RkdCY0Jwd1NPOFdBUG9hOWZOMzZzWk51RWxKSkFDM2MvbXhmd1JLWjZaL1Fpc1V6YkNYbmoxeXVVZlFIRGkvYnBzQWFITjJGT1kxamgxdk1mVHZEd0RZK1hxNnBpUGx4UU1Rbk1lNUs0bzhpYUVkeDlnamFFNjI5UDVBcVdxOU1uSFNVYk5TaWU5aVlxbnlHV21GakV6R1AzSnp1N3YyVnoyR0ZpUWNJd0R0cWpkK205K1VtTlM0UFQzalhtZHlham5ZV1BaYUZIa1U0emhXaHhweTdWTmR0L3FFaGViRFJHOEY2S1pReFpaekUzOHRna2owRklJempNaURGZDNyMzBuT3gySTlFZitFVEFLN0dmeHo3NENGQnREei8vY1Fpay92RlBjS3NLRDhrOWFBS2REUWdQMlp0cXZQQXFML0FjcmhKM0IyQUtYaEFBQUFBRWxGVGtTdVFtQ0NcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2e8a\n')},"3c4e":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n    return Array.isArray(val) ? [] : {}\n}\n\nfunction cloneIfNecessary(value, optionsArgument) {\n    var clone = optionsArgument && optionsArgument.clone === true;\n    return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value\n}\n\nfunction defaultArrayMerge(target, source, optionsArgument) {\n    var destination = target.slice();\n    source.forEach(function(e, i) {\n        if (typeof destination[i] === 'undefined') {\n            destination[i] = cloneIfNecessary(e, optionsArgument);\n        } else if (isMergeableObject(e)) {\n            destination[i] = deepmerge(target[i], e, optionsArgument);\n        } else if (target.indexOf(e) === -1) {\n            destination.push(cloneIfNecessary(e, optionsArgument));\n        }\n    });\n    return destination\n}\n\nfunction mergeObject(target, source, optionsArgument) {\n    var destination = {};\n    if (isMergeableObject(target)) {\n        Object.keys(target).forEach(function(key) {\n            destination[key] = cloneIfNecessary(target[key], optionsArgument);\n        });\n    }\n    Object.keys(source).forEach(function(key) {\n        if (!isMergeableObject(source[key]) || !target[key]) {\n            destination[key] = cloneIfNecessary(source[key], optionsArgument);\n        } else {\n            destination[key] = deepmerge(target[key], source[key], optionsArgument);\n        }\n    });\n    return destination\n}\n\nfunction deepmerge(target, source, optionsArgument) {\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var options = optionsArgument || { arrayMerge: defaultArrayMerge };\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n    if (!sourceAndTargetTypesMatch) {\n        return cloneIfNecessary(source, optionsArgument)\n    } else if (sourceIsArray) {\n        var arrayMerge = options.arrayMerge || defaultArrayMerge;\n        return arrayMerge(target, source, optionsArgument)\n    } else {\n        return mergeObject(target, source, optionsArgument)\n    }\n}\n\ndeepmerge.all = function deepmergeAll(array, optionsArgument) {\n    if (!Array.isArray(array) || array.length < 2) {\n        throw new Error('first argument should be an array with at least two elements')\n    }\n\n    // we are sure there are at least 2 values, so it is safe to have no initial value\n    return array.reduce(function(prev, next) {\n        return deepmerge(prev, next, optionsArgument)\n    })\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvY2pzLmpzPzNjNGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBIiwiZmlsZSI6IjNjNGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lSWZOZWNlc3NhcnkodmFsdWUsIG9wdGlvbnNBcmd1bWVudCkge1xuICAgIHZhciBjbG9uZSA9IG9wdGlvbnNBcmd1bWVudCAmJiBvcHRpb25zQXJndW1lbnQuY2xvbmUgPT09IHRydWU7XG4gICAgcmV0dXJuIChjbG9uZSAmJiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpID8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnNBcmd1bWVudCkgOiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0gdGFyZ2V0LnNsaWNlKCk7XG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24oZSwgaSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGVzdGluYXRpb25baV0gPSBjbG9uZUlmTmVjZXNzYXJ5KGUsIG9wdGlvbnNBcmd1bWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNZXJnZWFibGVPYmplY3QoZSkpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW2ldID0gZGVlcG1lcmdlKHRhcmdldFtpXSwgZSwgb3B0aW9uc0FyZ3VtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQuaW5kZXhPZihlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY2xvbmVJZk5lY2Vzc2FyeShlLCBvcHRpb25zQXJndW1lbnQpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0ge307XG4gICAgaWYgKGlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IGNsb25lSWZOZWNlc3NhcnkodGFyZ2V0W2tleV0sIG9wdGlvbnNBcmd1bWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICghaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pIHx8ICF0YXJnZXRba2V5XSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IGNsb25lSWZOZWNlc3Nhcnkoc291cmNlW2tleV0sIG9wdGlvbnNBcmd1bWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltrZXldID0gZGVlcG1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9uc0FyZ3VtZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCkge1xuICAgIHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuICAgIHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuICAgIHZhciBvcHRpb25zID0gb3B0aW9uc0FyZ3VtZW50IHx8IHsgYXJyYXlNZXJnZTogZGVmYXVsdEFycmF5TWVyZ2UgfTtcbiAgICB2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cbiAgICBpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lSWZOZWNlc3Nhcnkoc291cmNlLCBvcHRpb25zQXJndW1lbnQpXG4gICAgfSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG4gICAgICAgIHZhciBhcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuICAgICAgICByZXR1cm4gYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KVxuICAgIH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9uc0FyZ3VtZW50KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSB8fCBhcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgdHdvIGVsZW1lbnRzJylcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgc3VyZSB0aGVyZSBhcmUgYXQgbGVhc3QgMiB2YWx1ZXMsIHNvIGl0IGlzIHNhZmUgdG8gaGF2ZSBubyBpbml0aWFsIHZhbHVlXG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG4gICAgICAgIHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9uc0FyZ3VtZW50KVxuICAgIH0pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcG1lcmdlXzE7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3c4e\n")},4138:function(module,exports){eval('/*!\n * \n *  leaflet.motion - v0.3.2 (https://github.com/Igor-Vladyka/leaflet.motion#readme) \n *  Animation plugin for Leaflet.js\n *  \n *  MIT (http://www.opensource.org/licenses/mit-license.php)\n *  (c) 2022  Igor Vladyka <igor.vladyka@gmail.com> (https://github.com/Igor-Vladyka/)\n * \n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== \'undefined\' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, \'__esModule\', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === \'object\' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, \'default\', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != \'string\') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ "./src/layer/leaflet.motion.group.js":\n/*!*******************************************!*\\\n  !*** ./src/layer/leaflet.motion.group.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval("/**\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Igor Vladyka <igor.vladyka@gmail.com> (https://github.com/Igor-Vladyka/leaflet.motion)\\n**/\\n\\nL.Motion.Group = L.FeatureGroup.extend ({\\n\\t_started: false,\\n\\t_completed: false,\\n\\n\\toptions: {\\n\\t\\tpane: L.Motion.Animate.options.pane,\\n\\t\\tattribution: L.Motion.Animate.options.attribution,\\n\\t},\\n\\n\\t/**\\n\\t\\tStarts all motions in current group;\\n\\t*/\\n\\tmotionStart: function () {\\n\\t\\tthis.invoke(\\"motionStart\\");\\n\\t\\tthis._started = true;\\n\\t\\tthis._completed = false;\\n\\t\\tthis.fire(L.Motion.Event.Started, {layer: this}, false);\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/**\\n\\t\\tStops all motions in current group;\\n\\t*/\\n\\tmotionStop: function () {\\n\\t\\tthis.invoke(\\"motionStop\\");\\n\\t\\tthis._completed = true;\\n\\t\\tthis.fire(L.Motion.Event.Ended, {layer: this}, false);\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/**\\n\\t\\tPauses all motions in current group;\\n\\t*/\\n\\tmotionPause: function () {\\n\\t\\tthis.invoke(\\"motionPause\\");\\n\\t\\tthis.fire(L.Motion.Event.Paused, {layer: this}, false);\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/**\\n\\t\\tReset all motions in current group;\\n\\t*/\\n\\tmotionResume: function () {\\n\\t\\tthis.invoke(\\"motionResume\\");\\n\\t\\tthis.fire(L.Motion.Event.Resumed, {layer: this}, false);\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/**\\n\\t\\tReset all motions in current group;\\n\\t*/\\n\\tmotionToggle: function () {\\n\\t\\tthis.invoke(\\"motionToggle\\");\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/**\\n\\t\\tReturns markers array from all inner layers without flattering.\\n\\t*/\\n\\tgetMarkers: function () {\\n\\t\\treturn this.getLayers().map(function(l) { return l.getMarkers(); });\\n\\t}\\n});\\n\\nL.motion.group = function(motions, options){\\n    return new L.Motion.Group(motions, options);\\n};\\n\\n\\n//# sourceURL=webpack:///./src/layer/leaflet.motion.group.js?");\n\n/***/ }),\n\n/***/ "./src/layer/leaflet.motion.polygon.js":\n/*!*********************************************!*\\\n  !*** ./src/layer/leaflet.motion.polygon.js ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval("/**\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Igor Vladyka <igor.vladyka@gmail.com> (https://github.com/Igor-Vladyka/leaflet.motion)\\n**/\\n\\nL.Motion.Polygon = L.Polygon.extend(L.Motion.Animate);\\n\\nL.motion.polygon = function(latlngs, options, motionOptions, markerOptions){\\n    return new L.Motion.Polygon(latlngs, options, motionOptions, markerOptions);\\n};\\n\\n\\n//# sourceURL=webpack:///./src/layer/leaflet.motion.polygon.js?");\n\n/***/ }),\n\n/***/ "./src/layer/leaflet.motion.polyline.js":\n/*!**********************************************!*\\\n  !*** ./src/layer/leaflet.motion.polyline.js ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval("/**\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Igor Vladyka <igor.vladyka@gmail.com> (https://github.com/Igor-Vladyka/leaflet.motion)\\n**/\\n\\nL.Motion.Polyline = L.Polyline.extend(L.Motion.Animate);\\n\\nL.motion.polyline = function(latlngs, options, motionOptions, markerOptions){\\n    return new L.Motion.Polyline(latlngs, options, motionOptions, markerOptions);\\n};\\n\\n\\n//# sourceURL=webpack:///./src/layer/leaflet.motion.polyline.js?");\n\n/***/ }),\n\n/***/ "./src/layer/leaflet.motion.seq.js":\n/*!*****************************************!*\\\n  !*** ./src/layer/leaflet.motion.seq.js ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval("/**\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Igor Vladyka <igor.vladyka@gmail.com> (https://github.com/Igor-Vladyka/leaflet.motion)\\n**/\\n\\nL.Motion.Seq = L.Motion.Group.extend ({\\n\\t_activeLayer: null,\\n\\t_started: false,\\n\\t_completed: false,\\n\\n\\taddLayer: function (l, autostart) {\\n\\t\\tif (autostart === undefined) {\\n\\t\\t\\tautostart = true;\\n\\t\\t}\\n\\t\\tthis.__prepareLayer(l);\\n\\t\\tL.Motion.Group.prototype.addLayer.call(this, l);\\n\\n\\t\\tif (!this._activeLayer && autostart && this._completed) {\\n\\t\\t\\tl.motionStart();\\n\\t\\t}\\n\\t},\\n\\n\\t/**\\n\\t\\tStart first motion in current group;\\n\\t*/\\n\\tmotionStart: function() {\\n\\t\\t// We will start animation only when its not running\\n\\t\\tif (!this._activeLayer) {\\n\\t\\t\\tvar layer = this.getFirstLayer();\\n\\t\\t\\tif (layer) {\\n\\t\\t\\t\\tlayer.motionStart();\\n\\t\\t\\t\\tthis._started = true;\\n\\t\\t\\t\\tthis._completed = false;\\n\\t\\t\\t\\tthis.fire(L.Motion.Event.Started, {layer: this}, false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/**\\n\\t\\tStops all motions in current group;\\n\\t*/\\n\\tmotionStop: function(softstop) {\\n\\t\\tif (!softstop) {\\n\\t\\t\\tthis.invoke(\\"motionStop\\");\\n\\t\\t}\\n\\t\\tthis._activeLayer = null;\\n\\t\\tthis._completed = true;\\n\\t\\tthis.fire(L.Motion.Event.Ended, {layer: this}, false);\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/**\\n\\t\\tPause current motion in current group;\\n\\t*/\\n\\tmotionPause: function() {\\n\\t\\tif (this._activeLayer) {\\n\\t\\t\\tthis._activeLayer.motionPause();\\n\\t\\t\\tthis.fire(L.Motion.Event.Paused, {layer: this}, false);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/**\\n\\t\\tResume last motion in current group;\\n\\t*/\\n\\tmotionResume: function() {\\n\\t\\tif (this._activeLayer) {\\n\\t\\t\\tthis._activeLayer.motionResume();\\n\\t\\t\\tthis.fire(L.Motion.Event.Resumed, {layer: this}, false);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/**\\n\\t\\tReset all motions in current group;\\n\\t*/\\n\\tmotionToggle: function () {\\n\\t\\tif (this._activeLayer) {\\n\\t\\t\\tthis.motionPause();\\n\\t\\t} else {\\n\\t\\t\\tthis.motionResume();\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tgetFirstLayer: function() {\\n\\t\\tvar allLayers = this.getLayers();\\n\\t\\treturn allLayers.length ? allLayers[0] : null;\\n\\t},\\n\\n\\t/**\\n\\t\\tInitialise a layer so it\'s ready to be part of this motion sequence\\n\\t*/\\n\\t__prepareLayer: function (l) {\\n\\t\\tif (l.setLatLngs) {\\n\\t\\t\\tl.setLatLngs([]);\\n\\t\\t}\\n\\n\\t\\t// When a layer finishes have it remove itself and call motionStart() on the next layer\\n\\t\\tl.off(L.Motion.Event.Ended, this.__clearActiveLayer__, this);\\n\\t\\tl.on(L.Motion.Event.Ended, this.__clearActiveLayer__, this);\\n\\n\\t\\t// When a layer is started (by the last one ending) set it as the active layer\\n\\t\\tl.off(L.Motion.Event.Started, this.__putActiveLayer__, this);\\n\\t\\tl.on(L.Motion.Event.Started, this.__putActiveLayer__, this);\\n\\t},\\n\\n\\t/**\\n\\t\\tCalled by a layer (e.g. one of the sequence events) when it finishes. Is responsible for\\n\\t\\tcleaning up after itself and starting the next layer.\\n\\t */\\n\\t__clearActiveLayer__: function (e) {\\n\\t\\tthis._activeLayer = null;\\n\\t\\tvar layers = this.getLayers();\\n\\t\\tvar currentId = e.layer._leaflet_id;\\n\\t\\tvar currentObject = layers.filter(function(f){ return f._leaflet_id == currentId })[0];\\n\\t\\tvar nextIndex = layers.indexOf(currentObject) + 1;\\n\\t\\tif (layers.length > nextIndex) {\\n\\t\\t\\tlayers[nextIndex].motionStart();\\n\\t\\t} else {\\n\\t\\t\\t//this.fire(L.Motion.Event.Ended, {layer: this}, false);\\n\\t\\t\\tthis.motionStop(true);\\n\\t\\t}\\n\\t},\\n\\n\\t/**\\n\\t\\tCalled by a layer when it\'s started, sets itself as the active layer on the sequence\\n\\t\\tgroup and trigger any other events which need triggering.\\n\\t */\\n\\t__putActiveLayer__: function (e) {\\n\\t\\tthis._activeLayer = e.layer;\\n\\t\\tthis.fire(L.Motion.Event.Section, {layer: this._activeLayer}, false);\\n\\t}\\n});\\n\\nL.motion.seq = function(motion, options){\\n    return new L.Motion.Seq(motion, options);\\n};\\n\\n\\n//# sourceURL=webpack:///./src/layer/leaflet.motion.seq.js?");\n\n/***/ }),\n\n/***/ "./src/leaflet.motion.easing.js":\n/*!**************************************!*\\\n  !*** ./src/leaflet.motion.easing.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval("/**\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Igor Vladyka <igor.vladyka@gmail.com> (https://github.com/Igor-Vladyka/leaflet.motion)\\n**/\\n\\nL.Motion.Ease = {\\n\\tlinear: function( x ) {\\n\\t\\treturn x;\\n\\t},\\n\\tswing: function( x ) {\\n\\t\\treturn 0.5 - Math.cos( x * Math.PI ) / 2;\\n\\t},\\n\\teaseInQuad: function (x, t, b, c, d) {\\n\\t\\treturn c*(t/=d)*t + b;\\n\\t},\\n\\teaseOutQuad: function (x, t, b, c, d) {\\n\\t\\treturn -c *(t/=d)*(t-2) + b;\\n\\t},\\n\\teaseInOutQuad: function (x, t, b, c, d) {\\n\\t\\tif ((t/=d/2) < 1) return c/2*t*t + b;\\n\\t\\treturn -c/2 * ((--t)*(t-2) - 1) + b;\\n\\t},\\n\\teaseInCubic: function (x, t, b, c, d) {\\n\\t\\treturn c*(t/=d)*t*t + b;\\n\\t},\\n\\teaseOutCubic: function (x, t, b, c, d) {\\n\\t\\treturn c*((t=t/d-1)*t*t + 1) + b;\\n\\t},\\n\\teaseInOutCubic: function (x, t, b, c, d) {\\n\\t\\tif ((t/=d/2) < 1) return c/2*t*t*t + b;\\n\\t\\treturn c/2*((t-=2)*t*t + 2) + b;\\n\\t},\\n\\teaseInQuart: function (x, t, b, c, d) {\\n\\t\\treturn c*(t/=d)*t*t*t + b;\\n\\t},\\n\\teaseOutQuart: function (x, t, b, c, d) {\\n\\t\\treturn -c * ((t=t/d-1)*t*t*t - 1) + b;\\n\\t},\\n\\teaseInOutQuart: function (x, t, b, c, d) {\\n\\t\\tif ((t/=d/2) < 1) return c/2*t*t*t*t + b;\\n\\t\\treturn -c/2 * ((t-=2)*t*t*t - 2) + b;\\n\\t},\\n\\teaseInQuint: function (x, t, b, c, d) {\\n\\t\\treturn c*(t/=d)*t*t*t*t + b;\\n\\t},\\n\\teaseOutQuint: function (x, t, b, c, d) {\\n\\t\\treturn c*((t=t/d-1)*t*t*t*t + 1) + b;\\n\\t},\\n\\teaseInOutQuint: function (x, t, b, c, d) {\\n\\t\\tif ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;\\n\\t\\treturn c/2*((t-=2)*t*t*t*t + 2) + b;\\n\\t},\\n\\teaseInSine: function (x, t, b, c, d) {\\n\\t\\treturn -c * Math.cos(t/d * (Math.PI/2)) + c + b;\\n\\t},\\n\\teaseOutSine: function (x, t, b, c, d) {\\n\\t\\treturn c * Math.sin(t/d * (Math.PI/2)) + b;\\n\\t},\\n\\teaseInOutSine: function (x, t, b, c, d) {\\n\\t\\treturn -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;\\n\\t},\\n\\teaseInExpo: function (x, t, b, c, d) {\\n\\t\\treturn (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;\\n\\t},\\n\\teaseOutExpo: function (x, t, b, c, d) {\\n\\t\\treturn (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;\\n\\t},\\n\\teaseInOutExpo: function (x, t, b, c, d) {\\n\\t\\tif (t==0) return b;\\n\\t\\tif (t==d) return b+c;\\n\\t\\tif ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;\\n\\t\\treturn c/2 * (-Math.pow(2, -10 * --t) + 2) + b;\\n\\t},\\n\\teaseInCirc: function (x, t, b, c, d) {\\n\\t\\treturn -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;\\n\\t},\\n\\teaseOutCirc: function (x, t, b, c, d) {\\n\\t\\treturn c * Math.sqrt(1 - (t=t/d-1)*t) + b;\\n\\t},\\n\\teaseInOutCirc: function (x, t, b, c, d) {\\n\\t\\tif ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;\\n\\t\\treturn c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;\\n\\t},\\n\\teaseInElastic: function (x, t, b, c, d) {\\n\\t\\tvar s=1.70158;var p=0;var a=c;\\n\\t\\tif (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;\\n\\t\\tif (a < Math.abs(c)) { a=c; var s=p/4; }\\n\\t\\telse var s = p/(2*Math.PI) * Math.asin (c/a);\\n\\t\\treturn -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;\\n\\t},\\n\\teaseOutElastic: function (x, t, b, c, d) {\\n\\t\\tvar s=1.70158;var p=0;var a=c;\\n\\t\\tif (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;\\n\\t\\tif (a < Math.abs(c)) { a=c; var s=p/4; }\\n\\t\\telse var s = p/(2*Math.PI) * Math.asin (c/a);\\n\\t\\treturn a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;\\n\\t},\\n\\teaseInOutElastic: function (x, t, b, c, d) {\\n\\t\\tvar s=1.70158;var p=0;var a=c;\\n\\t\\tif (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);\\n\\t\\tif (a < Math.abs(c)) { a=c; var s=p/4; }\\n\\t\\telse var s = p/(2*Math.PI) * Math.asin (c/a);\\n\\t\\tif (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;\\n\\t\\treturn a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;\\n\\t},\\n\\teaseInBack: function (x, t, b, c, d, s) {\\n\\t\\tif (s == undefined) s = 1.70158;\\n\\t\\treturn c*(t/=d)*t*((s+1)*t - s) + b;\\n\\t},\\n\\teaseOutBack: function (x, t, b, c, d, s) {\\n\\t\\tif (s == undefined) s = 1.70158;\\n\\t\\treturn c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;\\n\\t},\\n\\teaseInOutBack: function (x, t, b, c, d, s) {\\n\\t\\tif (s == undefined) s = 1.70158;\\n\\t\\tif ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;\\n\\t\\treturn c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;\\n\\t},\\n\\teaseInBounce: function (x, t, b, c, d) {\\n\\t\\treturn c - L.Motion.Ease.easeOutBounce (x, d-t, 0, c, d) + b;\\n\\t},\\n\\teaseOutBounce: function (x, t, b, c, d) {\\n\\t\\tif ((t/=d) < (1/2.75)) {\\n\\t\\t\\treturn c*(7.5625*t*t) + b;\\n\\t\\t} else if (t < (2/2.75)) {\\n\\t\\t\\treturn c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;\\n\\t\\t} else if (t < (2.5/2.75)) {\\n\\t\\t\\treturn c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;\\n\\t\\t} else {\\n\\t\\t\\treturn c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;\\n\\t\\t}\\n\\t},\\n\\teaseInOutBounce: function (x, t, b, c, d) {\\n\\t\\tif (t < d/2) return L.Motion.Ease.easeInBounce (x, t*2, 0, c, d) * .5 + b;\\n\\t\\treturn L.Motion.Ease.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;\\n\\t}\\n};\\n\\n\\n//# sourceURL=webpack:///./src/leaflet.motion.easing.js?");\n\n/***/ }),\n\n/***/ "./src/leaflet.motion.js":\n/*!*******************************!*\\\n  !*** ./src/leaflet.motion.js ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval("/**\\r\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\r\\n\\tAuthor Igor Vladyka <igor.vladyka@gmail.com> (https://github.com/Igor-Vladyka/leaflet.motion)\\r\\n**/\\r\\n\\r\\nL.Motion = L.Motion || {\\r\\n\\tEvent: {\\r\\n\\t\\t\\tStarted:\\"motion-started\\",\\r\\n\\t\\t\\tPaused: \\"motion-paused\\",\\r\\n\\t\\t\\tResumed: \\"motion-resumed\\",\\r\\n\\t\\t\\tSection: \\"motion-section\\",\\r\\n\\t\\t\\tEnded: \\"motion-ended\\"\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\nL.motion = L.motion || {};\\r\\nL.Motion.Animate = {\\r\\n\\toptions: {\\r\\n\\t\\tpane: \\"polymotionPane\\",\\r\\n\\t\\tattribution: \\"Leaflet.Motion © \\" + (new Date()).getFullYear() + \\" Igor Vladyka\\"\\r\\n\\t},\\r\\n\\r\\n\\tmotionOptions: {\\r\\n\\t\\tauto: false,\\r\\n\\t\\teasing: function(x){ return x; }, // linear\\r\\n\\t\\tspeed: 0, // KM/H\\r\\n\\t\\tduration: 0 // ms\\r\\n\\t},\\r\\n\\r\\n\\tmarkerOptions: undefined,\\r\\n\\r\\n\\tinitialize: function (latlngs, options, motionOptions, markerOptions) {\\r\\n\\t\\tL.Util.setOptions(this, options);\\r\\n\\t\\tif (motionOptions) {\\r\\n\\t\\t\\tthis.motionOptions = L.Util.extend({}, this.motionOptions, motionOptions);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (markerOptions) {\\r\\n\\t\\t\\tthis.markerOptions = L.Util.extend({}, markerOptions);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._bounds = L.latLngBounds();\\r\\n\\t\\tthis._linePoints = this._convertLatLngs(latlngs);\\r\\n\\t\\tif (!L.Motion.Utils.isFlat(this._linePoints)) {\\r\\n\\t\\t\\tthis._linePoints = this._linePoints[0];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._initializeMarker();\\r\\n\\t\\tthis._latlngs = [];\\r\\n\\t\\tL.Util.stamp(this); // Enforce proper animation order;\\r\\n\\t},\\r\\n\\r\\n\\taddLatLng: function(latLng, ring) {\\r\\n\\t\\tlatLng = L.Motion.Utils.toLatLng(latLng);\\r\\n\\t\\tthis._linePoints.push(latLng);\\r\\n\\t\\tif (this._latlngs.length) {\\r\\n\\t\\t\\tthis._latlngs.push(latLng);\\r\\n\\t\\t}\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n        @param {Map} map the Leaflet Map\\r\\n    */\\r\\n\\tbeforeAdd: function (map) {\\r\\n\\t\\tif (!map.getPane(this.options.pane)) {\\r\\n\\t\\t\\tmap.createPane(this.options.pane).style.zIndex = 599;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._renderer = map.getRenderer(this);\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n        @param {Map} map the Leaflet Map\\r\\n\\t\\t@return {MotionObject} this\\r\\n    */\\r\\n    onAdd: function (map) {\\r\\n\\t\\tthis._renderer._initPath(this);\\r\\n\\t\\tthis._reset();\\r\\n\\t\\tthis._renderer._addPath(this);\\r\\n\\t\\tif (this.__marker && this.markerOptions.showMarker) {\\r\\n\\t\\t\\tthis.__marker.addTo(map);\\r\\n\\r\\n\\t\\t\\tif(this.__marker._icon && this.__marker._icon.children.length){\\r\\n\\t\\t\\t\\tArray.from(this.__marker._icon.children).forEach(function(icon) {\\r\\n\\t\\t\\t\\t\\tvar baseRotationAngle = icon.getAttribute(\\"motion-base\\");\\r\\n\\t\\t\\t\\t\\tif (baseRotationAngle) {\\r\\n\\t\\t\\t\\t\\t\\ticon.style.transform = \\"rotate(\\" + baseRotationAngle + \\"deg)\\";\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (this.motionOptions.auto) {\\r\\n\\t\\t\\tthis.motionStart();\\r\\n\\t\\t}\\r\\n\\r\\n        return this;\\r\\n    },\\r\\n\\r\\n\\t/**\\r\\n        @param {Map} map the Leaflet Map\\r\\n    */\\r\\n\\tonRemove: function (map) {\\r\\n\\t\\tthis.motionStop();\\r\\n\\t\\tif (this.__marker) {\\r\\n\\t\\t\\tmap.removeLayer(this.__marker);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._renderer._removePath(this);\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n        @param {DateTime} startTime time from start animation\\r\\n    */\\r\\n    _motion: function (startTime) {\\r\\n\\t\\tvar ellapsedTime = (new Date()).getTime() - startTime;\\r\\n        var durationRatio = 1; // 0 - 1\\r\\n\\t\\tif (this.motionOptions.duration) {\\r\\n\\t\\t\\tdurationRatio = ellapsedTime / this.motionOptions.duration;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (durationRatio < 1) {\\r\\n\\t\\t\\tdurationRatio = this.motionOptions.easing(durationRatio, ellapsedTime, 0, 1, this.motionOptions.duration);\\r\\n\\t\\t\\tvar interpolatedLine = L.Motion.Utils.interpolateOnLine(this._map, this._linePoints, durationRatio);\\r\\n\\r\\n\\t\\t\\tthis.setLatLngs(interpolatedLine.traveledPath);\\r\\n\\t\\t\\tthis._drawMarker(interpolatedLine.latLng);\\r\\n\\r\\n\\t\\t\\tthis.__ellapsedTime = ellapsedTime;\\r\\n\\t\\t\\tthis.animation = L.Util.requestAnimFrame(function(){\\r\\n\\t\\t\\t\\tthis._motion(startTime);\\r\\n\\t\\t\\t}, this);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.motionStop(true);\\r\\n\\t\\t}\\r\\n    },\\r\\n\\r\\n\\t/**\\r\\n\\t\\tDraws marker according to line position\\r\\n        @param {LatLng} nextPoint next animation point\\r\\n    */\\r\\n\\t_drawMarker: function (nextPoint) {\\r\\n\\t\\tvar marker = this.getMarker();\\r\\n\\t\\tif (marker) {\\r\\n\\t\\t\\tvar prevPoint = marker.getLatLng();\\r\\n\\r\\n\\t\\t\\t// [0, 0] Means that marker is not added yet to the map\\r\\n\\t\\t\\tvar initialPoints = this._linePoints[0];\\r\\n\\t\\t\\tif (prevPoint.lat === initialPoints.lat && prevPoint.lng === initialPoints.lng) {\\r\\n\\t\\t\\t\\tmarker.addTo(this._map);\\r\\n\\t\\t\\t\\tmarker.addEventParent(this);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif (marker._icon && marker._icon.children.length) {\\r\\n\\t\\t\\t\\t\\tArray.from(marker._icon.children).forEach(function(icon) {\\r\\n\\t\\t\\t\\t\\t\\tvar needToRotateMarker = icon.getAttribute(\\"motion-base\\");\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif (needToRotateMarker) {\\r\\n\\t\\t\\t\\t\\t\\t\\tvar motionMarkerOnLine = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\tif (needToRotateMarker && !isNaN(+needToRotateMarker)) {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tmotionMarkerOnLine = +needToRotateMarker;\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ticon.style.transform = \\"rotate(-\\" + Math.round(L.Motion.Utils.getAngle(prevPoint, nextPoint) + motionMarkerOnLine) +\\"deg)\\";\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t});\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tmarker.setLatLng(nextPoint);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n        Removes marker from the map\\r\\n    */\\r\\n\\t_removeMarker: function (animEnded) {\\r\\n\\t\\tif (this.markerOptions && this.__marker) {\\r\\n\\t\\t\\tif (!animEnded || this.markerOptions.removeOnEnd) {\\r\\n\\t\\t\\t\\tthis._map.removeLayer(this.__marker);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n        Initialize marker from marker options and add it to the map if needed\\r\\n    */\\r\\n\\t_initializeMarker: function () {\\r\\n\\t\\tif (this.markerOptions) {\\r\\n\\t\\t\\tthis.__marker = L.marker(this._linePoints[0], this.markerOptions);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n        Starts animation of current object\\r\\n    */\\r\\n\\tmotionStart: function () {\\r\\n\\t\\tif (this._map && !this.animation) {\\r\\n\\t\\t\\tif (!this.motionOptions.duration) {\\r\\n\\t\\t\\t\\tif (this.motionOptions.speed) {\\r\\n\\t\\t\\t\\t\\tthis.motionOptions.duration = L.Motion.Utils.getDuration(this._map, this._linePoints, this.motionOptions.speed);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis.motionOptions.duration = 0;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.setLatLngs([]);\\r\\n\\t        this._motion((new Date).getTime());\\r\\n\\t\\t\\tthis.fire(L.Motion.Event.Started, {layer: this}, false);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n    },\\r\\n\\r\\n\\t/**\\r\\n        Stops animation of current object\\r\\n        @param {LatLng[]} points full object points collection or empty collection for cleanup\\r\\n    */\\r\\n    motionStop: function (animEnded) {\\r\\n\\t\\tthis.motionPause();\\r\\n\\t\\tthis.setLatLngs(this._linePoints);\\r\\n\\t\\tthis.__ellapsedTime = null;\\r\\n\\t\\tthis._removeMarker(animEnded);\\r\\n\\t\\tthis.fire(L.Motion.Event.Ended, {layer: this}, false);\\r\\n\\r\\n\\t\\treturn this;\\r\\n    },\\r\\n\\r\\n\\t/**\\r\\n        Pauses animation of current object\\r\\n    */\\r\\n\\tmotionPause: function () {\\r\\n\\t\\tif (this.animation) {\\r\\n\\t\\t\\tL.Util.cancelAnimFrame(this.animation);\\r\\n\\t\\t\\tthis.animation = null;\\r\\n\\t\\t\\tthis.fire(L.Motion.Event.Paused, {layer: this}, false);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n        Resume animation of current object\\r\\n    */\\r\\n\\tmotionResume: function () {\\r\\n\\t\\tif (!this.animation && this.__ellapsedTime) {\\r\\n\\t\\t\\tif (!this.motionOptions.duration) {\\r\\n\\t\\t\\t\\tif (this.motionOptions.speed) {\\r\\n\\t\\t\\t\\t\\tthis.motionOptions.duration = L.Motion.Utils.getDuration(this._map, this._linePoints, this.motionOptions.speed);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis.motionOptions.duration = 0;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis._motion((new Date).getTime() - (this.__ellapsedTime));\\r\\n\\t\\t\\tthis.fire(L.Motion.Event.Resumed, {layer: this}, false);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n        Toggles animation of current object; Start/Pause/Resume;\\r\\n    */\\r\\n\\tmotionToggle: function () {\\r\\n\\t\\tif (this.animation) {\\r\\n\\t\\t\\tif (this.__ellapsedTime) {\\r\\n\\t\\t\\t\\tthis.motionPause();\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (this.__ellapsedTime) {\\r\\n\\t\\t\\t\\tthis.motionResume();\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.motionStart();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t\\tSetup motion duration at any time\\r\\n\\t*/\\r\\n\\tmotionDuration: function (duration) {\\r\\n\\t\\tvar prevDuration = this.motionSpeed.duration;\\r\\n\\t\\tthis.motionOptions.duration = duration || 0;\\r\\n\\r\\n\\t\\tif (this.animation && prevDuration) {\\r\\n\\t\\t\\tthis.motionPause();\\r\\n\\t\\t    this.__ellapsedTime = this.__ellapsedTime * (prevDuration / duration);\\r\\n\\t\\t    this.motionOptions.duration = duration;\\r\\n\\t\\t\\tthis.motionResume();\\r\\n\\t\\t}\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t\\tSetup motion speed at any time\\r\\n\\t*/\\r\\n\\tmotionSpeed: function (speed) {\\r\\n\\t\\tvar prevSpeed = this.motionOptions.speed;\\r\\n\\t\\tthis.motionOptions.speed = speed || 0;\\r\\n\\r\\n\\t\\tif (this.animation && prevSpeed) {\\r\\n\\t\\t\\tthis.motionPause();\\r\\n\\t\\t    this.__ellapsedTime = this.__ellapsedTime * (prevSpeed / speed);\\r\\n\\t\\t    this.motionOptions.duration = L.Motion.Utils.getDuration(this._map, this._linePoints, this.motionOptions.speed);\\r\\n\\t\\t\\tthis.motionResume();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturns current constructed marker\\r\\n\\t*/\\r\\n\\tgetMarker: function () {\\r\\n\\t\\treturn this.__marker;\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturns markers array from all inner layers without flattering.\\r\\n\\t*/\\r\\n\\tgetMarkers: function () {\\r\\n\\t\\treturn [this.getMarker()];\\r\\n\\t}\\r\\n}\\r\\n\\n\\n//# sourceURL=webpack:///./src/leaflet.motion.js?");\n\n/***/ }),\n\n/***/ "./src/leaflet.motion.utils.js":\n/*!*************************************!*\\\n  !*** ./src/leaflet.motion.utils.js ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval("/**\\r\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\r\\n\\tAuthor Igor Vladyka <igor.vladyka@gmail.com> (https://github.com/Igor-Vladyka/leaflet.motion)\\r\\n**/\\r\\n\\r\\nL.Motion.Utils = {\\r\\n\\t/**\\r\\n\\t\\tAttaches distances precalculated to current set of LatLng\\r\\n\\t\\t@param {L.Map} map Leaflet map to be calculate distances\\r\\n\\t\\t@param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\\r\\n\\t\\t@returns {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points with attached distances\\r\\n\\t*/\\r\\n\\tattachDistances: function(map, latLngs) {\\r\\n\\t\\tif (latLngs.length > 1) {\\r\\n\\t\\t\\tfor (var i = 1; i < latLngs.length; i++) {\\r\\n\\t\\t\\t\\tlatLngs[i - 1].distanceToNextPoint = map.distance(latLngs[i - 1], latLngs[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn latLngs;\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturns the coordinate of the point located on a line at the specified ratio of the line length.\\r\\n\\t\\t@param {L.Map} map Leaflet map to be used for this method\\r\\n\\t\\t@param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\\r\\n\\t\\t@param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\\r\\n\\t\\t@returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\\r\\n\\t\\t(-1 if the interpolated point is the first vertex)\\r\\n\\t*/\\r\\n\\tinterpolateOnLine: function (map, latLngs, ratio) {\\r\\n\\t\\tlatLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;\\r\\n\\t\\tif (latLngs.length < 2) {\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar allDistancesCalculated = true;\\r\\n\\t\\tfor (var d = 0; d < latLngs.length - 1; d++) {\\r\\n\\t\\t\\tif (!latLngs[d].distanceToNextPoint) {\\r\\n\\t\\t\\t\\tallDistancesCalculated = false;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!allDistancesCalculated) {\\r\\n\\t\\t\\tthis.attachDistances(map, latLngs);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// ensure the ratio is between 0 and 1;\\r\\n\\t\\tratio = Math.max(Math.min(ratio, 1), 0);\\r\\n\\r\\n\\t\\tif (ratio === 0) {\\r\\n\\t\\t\\tvar singlePoint = latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]);\\r\\n\\t\\t\\treturn {\\r\\n\\t\\t\\t\\ttraveledPath: [singlePoint],\\r\\n\\t\\t\\t\\tlatLng: singlePoint\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (ratio == 1) {\\r\\n\\t\\t\\treturn {\\r\\n\\t\\t\\t\\ttraveledPath: latLngs,\\r\\n\\t\\t\\t\\tlatLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1])\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// get full line length between points\\r\\n\\t\\tvar fullLength = 0;\\r\\n\\t\\tfor (var dIndex = 0; dIndex < latLngs.length - 1; dIndex++) {\\r\\n\\t\\t\\tfullLength += latLngs[dIndex].distanceToNextPoint;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Calculate expected ratio\\r\\n\\t\\tvar ratioDist = fullLength * ratio;\\r\\n\\r\\n\\t\\t// follow the line segments [ab], adding lengths,\\r\\n\\t\\t// until we find the segment where the points should lie on\\r\\n\\t\\tvar cumulativeDistanceToA = 0, cumulativeDistanceToB = 0;\\r\\n\\t\\tfor (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\\r\\n\\t\\t\\tvar pointA = latLngs[i], pointB = latLngs[i+1];\\r\\n\\r\\n\\t\\t\\tcumulativeDistanceToA = cumulativeDistanceToB;\\r\\n\\t\\t\\tcumulativeDistanceToB += pointA.distanceToNextPoint;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (pointA == undefined && pointB == undefined) { // Happens when line has no length\\r\\n\\t\\t\\tvar pointA = latLngs[0], pointB = latLngs[1], i = 1;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// compute the ratio relative to the segment [ab]\\r\\n\\t\\tvar segmentRatio = ((cumulativeDistanceToB - cumulativeDistanceToA) !== 0) ? ((ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA)) : 0;\\r\\n\\t\\tvar interpolatedPoint = this.interpolateOnLatLngSegment(pointA, pointB, segmentRatio);\\r\\n\\t\\tvar traveledPath = latLngs.slice(0, i);\\r\\n\\t\\ttraveledPath.push(interpolatedPoint);\\r\\n\\t\\treturn {\\r\\n\\t\\t\\ttraveledPath: traveledPath,\\r\\n\\t\\t\\tlatLng: interpolatedPoint\\r\\n\\t\\t};\\r\\n\\t},\\r\\n\\r\\n    /**\\r\\n        Returns the Point located on a segment at the specified ratio of the segment length.\\r\\n        @param {L.Point} pA coordinates of point A\\r\\n        @param {L.Point} pB coordinates of point B\\r\\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\\r\\n        @returns {L.Point} the interpolated point.\\r\\n    */\\r\\n    interpolateOnPointSegment: function (pA, pB, ratio) {\\r\\n        return L.point(\\r\\n            (pA.x * (1 - ratio)) + (ratio * pB.x),\\r\\n            (pA.y * (1 - ratio)) + (ratio * pB.y)\\r\\n        );\\r\\n    },\\r\\n\\r\\n    /**\\r\\n        Returns the LatLng located on a segment at the specified ratio of the segment length.\\r\\n        @param {L.LatLng} pA coordinates of LatLng A\\r\\n        @param {L.LatLng} pB coordinates of LatLng B\\r\\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\\r\\n        @returns {L.LatLng} the interpolated LatLng.\\r\\n    */\\r\\n    interpolateOnLatLngSegment: function (pA, pB, ratio) {\\r\\n        return L.latLng(\\r\\n            (pA.lat * (1 - ratio)) + (ratio * pB.lat),\\r\\n            (pA.lng * (1 - ratio)) + (ratio * pB.lng)\\r\\n        );\\r\\n    },\\r\\n\\r\\n\\t/**\\r\\n\\t\\t@param {L.Map} map Leaflet map to be calculate distances\\r\\n        @param {LatLng[]} linePoints of coordinates\\r\\n        @return {Number} distance in meter\\r\\n    */\\r\\n\\tdistance: function(map, linePoints){\\r\\n\\t\\tvar distanceInMeter = 0;\\r\\n        for (var i = 1; i < linePoints.length; i++) {\\r\\n            distanceInMeter +=  map.distance(linePoints[i], linePoints[i - 1]);\\r\\n        }\\r\\n\\r\\n        return distanceInMeter;\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t\\t@param {L.Map} map Leaflet map to be calculate distances\\r\\n        @param {LatLng[]} collection of coordinates\\r\\n        @param {Number} speed in KM/H\\r\\n        @return {Number} duration in ms\\r\\n    */\\r\\n\\tgetDuration: function (map, collection, speed) {\\r\\n\\t\\tvar distance = L.Motion.Utils.distance(map, collection.map(function(m){ return L.Motion.Utils.toLatLng(m); })); // in meters;\\r\\n\\t\\treturn distance/(speed/3600); // m / (km/h * 1000 => m/h / (60 * 60)) => m / k/s (m/s * 1000) => 1000 * m / m/s => ms;\\r\\n\\t},\\r\\n\\r\\n\\ttoLatLng: function(a, b, c) {\\r\\n\\t\\tif (a instanceof L.LatLng) {\\r\\n\\t\\t\\treturn a;\\r\\n\\t\\t}\\r\\n\\t\\tif (L.Util.isArray(a) && typeof a[0] !== \'object\') {\\r\\n\\t\\t\\tif (a.length === 3) {\\r\\n\\t\\t\\t\\treturn L.latLng(a[0], a[1], a[2]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (a.length === 2) {\\r\\n\\t\\t\\t\\treturn L.latLng(a[0], a[1]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\t\\tif (a === undefined || a === null) {\\r\\n\\t\\t\\treturn a;\\r\\n\\t\\t}\\r\\n\\t\\tif (typeof a === \'object\' && \'lat\' in a) {\\r\\n\\t\\t\\treturn L.latLng(a.lat, \'lng\' in a ? a.lng : a.lon, a.alt);\\r\\n\\t\\t}\\r\\n\\t\\tif (b === undefined) {\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\t\\treturn L.latLng(a, b, c);\\r\\n\\t},\\r\\n\\r\\n\\tgetAngle: function(prevPoint, nextPoint) {\\r\\n\\t\\tvar angle = Math.atan2(nextPoint.lat - prevPoint.lat, nextPoint.lng - prevPoint.lng) * 180 / Math.PI;\\r\\n\\t\\tif (angle < 0) {\\r\\n\\t\\t\\tangle += 360;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn angle;\\r\\n\\t},\\r\\n\\r\\n\\t// Leaflet -> geometries -> LineUtil\\r\\n\\tisFlat: function (latlngs) {\\r\\n\\t\\treturn !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== \'object\' && typeof latlngs[0][0] !== \'undefined\');\\r\\n\\t}\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./src/leaflet.motion.utils.js?");\n\n/***/ }),\n\n/***/ 0:\n/*!*****************************************************************************************************************************************************************************************************************************************************!*\\\n  !*** multi ./src/leaflet.motion.js ./src/leaflet.motion.utils.js ./src/leaflet.motion.easing.js ./src/layer/leaflet.motion.polyline.js ./src/layer/leaflet.motion.polygon.js ./src/layer/leaflet.motion.group.js ./src/layer/leaflet.motion.seq.js ***!\n  \\*****************************************************************************************************************************************************************************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval("__webpack_require__(/*! ./src/leaflet.motion.js */\\"./src/leaflet.motion.js\\");\\n__webpack_require__(/*! ./src/leaflet.motion.utils.js */\\"./src/leaflet.motion.utils.js\\");\\n__webpack_require__(/*! ./src/leaflet.motion.easing.js */\\"./src/leaflet.motion.easing.js\\");\\n__webpack_require__(/*! ./src/layer/leaflet.motion.polyline.js */\\"./src/layer/leaflet.motion.polyline.js\\");\\n__webpack_require__(/*! ./src/layer/leaflet.motion.polygon.js */\\"./src/layer/leaflet.motion.polygon.js\\");\\n__webpack_require__(/*! ./src/layer/leaflet.motion.group.js */\\"./src/layer/leaflet.motion.group.js\\");\\nmodule.exports = __webpack_require__(/*! ./src/layer/leaflet.motion.seq.js */\\"./src/layer/leaflet.motion.seq.js\\");\\n\\n\\n//# sourceURL=webpack:///multi_./src/leaflet.motion.js_./src/leaflet.motion.utils.js_./src/leaflet.motion.easing.js_./src/layer/leaflet.motion.polyline.js_./src/layer/leaflet.motion.polygon.js_./src/layer/leaflet.motion.group.js_./src/layer/leaflet.motion.seq.js?");\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tb3Rpb24vZGlzdC9sZWFmbGV0Lm1vdGlvbi5qcz80MTM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhOQUE4TiwwREFBMEQsdUdBQXVHLG9EQUFvRCxvQ0FBb0MsbUNBQW1DLDJCQUEyQiw4QkFBOEIseUNBQXlDLFlBQVksU0FBUyxrQkFBa0IsS0FBSyxtREFBbUQsbUNBQW1DLGtDQUFrQyw2QkFBNkIsdUNBQXVDLFlBQVks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OERBQThELFNBQVMsK0NBQStDLE9BQU8sc0VBQXNFLGdDQUFnQywyQkFBMkIsdUJBQXVCLE9BQU8sbUZBQW1GLGFBQWEsdUNBQXVDLE9BQU8sOEJBQThCLE1BQU0sOERBQThELFNBQVMsOENBQThDLE9BQU8sbUNBQW1DLE9BQU8sK0VBQStFLCtFQUErRSxtQ0FBbUMsRUFBRSxHQUFHLGNBQWMscUNBQXFDLHlGQUF5RixPQUFPLHdDQUF3QyxvQ0FBb0MsbUJBQW1CLFNBQVMsNERBQTRELCtCQUErQiw4Q0FBOEMsV0FBVywrQkFBK0Isd0NBQXdDLFdBQVcsc0JBQXNCLFNBQVMsNENBQTRDLG1CQUFtQixTQUFTLGtEQUFrRCxvRUFBb0UsU0FBUyw4QkFBOEIsc0JBQXNCLFNBQVMsaUNBQWlDLE9BQU8scURBQXFELDZHQUE2Ryx3QkFBd0IsdUJBQXVCLFNBQVMseUJBQXlCLE9BQU8saUZBQWlGLDBIQUEwSCxPQUFPLE1BQU07O0FBRWhtTyxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRkFBcUYsNkZBQTZGLCtGQUErRiwrR0FBK0csNkdBQTZHLHlHQUF5RyxzSEFBc0g7O0FBRTVzQixPQUFPOztBQUVQLFVBQVUiLCJmaWxlIjoiNDEzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogXG4gKiAgbGVhZmxldC5tb3Rpb24gLSB2MC4zLjIgKGh0dHBzOi8vZ2l0aHViLmNvbS9JZ29yLVZsYWR5a2EvbGVhZmxldC5tb3Rpb24jcmVhZG1lKSBcbiAqICBBbmltYXRpb24gcGx1Z2luIGZvciBMZWFmbGV0LmpzXG4gKiAgXG4gKiAgTUlUIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbiAqICAoYykgMjAyMiAgSWdvciBWbGFkeWthIDxpZ29yLnZsYWR5a2FAZ21haWwuY29tPiAoaHR0cHM6Ly9naXRodWIuY29tL0lnb3ItVmxhZHlrYS8pXG4gKiBcbiAqL1xuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5ncm91cC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5ncm91cC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiLyoqXFxuXFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXG5cXHRBdXRob3IgSWdvciBWbGFkeWthIDxpZ29yLnZsYWR5a2FAZ21haWwuY29tPiAoaHR0cHM6Ly9naXRodWIuY29tL0lnb3ItVmxhZHlrYS9sZWFmbGV0Lm1vdGlvbilcXG4qKi9cXG5cXG5MLk1vdGlvbi5Hcm91cCA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCAoe1xcblxcdF9zdGFydGVkOiBmYWxzZSxcXG5cXHRfY29tcGxldGVkOiBmYWxzZSxcXG5cXG5cXHRvcHRpb25zOiB7XFxuXFx0XFx0cGFuZTogTC5Nb3Rpb24uQW5pbWF0ZS5vcHRpb25zLnBhbmUsXFxuXFx0XFx0YXR0cmlidXRpb246IEwuTW90aW9uLkFuaW1hdGUub3B0aW9ucy5hdHRyaWJ1dGlvbixcXG5cXHR9LFxcblxcblxcdC8qKlxcblxcdFxcdFN0YXJ0cyBhbGwgbW90aW9ucyBpbiBjdXJyZW50IGdyb3VwO1xcblxcdCovXFxuXFx0bW90aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR0aGlzLmludm9rZShcXFwibW90aW9uU3RhcnRcXFwiKTtcXG5cXHRcXHR0aGlzLl9zdGFydGVkID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLl9jb21wbGV0ZWQgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmZpcmUoTC5Nb3Rpb24uRXZlbnQuU3RhcnRlZCwge2xheWVyOiB0aGlzfSwgZmFsc2UpO1xcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH0sXFxuXFxuXFx0LyoqXFxuXFx0XFx0U3RvcHMgYWxsIG1vdGlvbnMgaW4gY3VycmVudCBncm91cDtcXG5cXHQqL1xcblxcdG1vdGlvblN0b3A6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR0aGlzLmludm9rZShcXFwibW90aW9uU3RvcFxcXCIpO1xcblxcdFxcdHRoaXMuX2NvbXBsZXRlZCA9IHRydWU7XFxuXFx0XFx0dGhpcy5maXJlKEwuTW90aW9uLkV2ZW50LkVuZGVkLCB7bGF5ZXI6IHRoaXN9LCBmYWxzZSk7XFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHQvKipcXG5cXHRcXHRQYXVzZXMgYWxsIG1vdGlvbnMgaW4gY3VycmVudCBncm91cDtcXG5cXHQqL1xcblxcdG1vdGlvblBhdXNlOiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dGhpcy5pbnZva2UoXFxcIm1vdGlvblBhdXNlXFxcIik7XFxuXFx0XFx0dGhpcy5maXJlKEwuTW90aW9uLkV2ZW50LlBhdXNlZCwge2xheWVyOiB0aGlzfSwgZmFsc2UpO1xcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH0sXFxuXFxuXFx0LyoqXFxuXFx0XFx0UmVzZXQgYWxsIG1vdGlvbnMgaW4gY3VycmVudCBncm91cDtcXG5cXHQqL1xcblxcdG1vdGlvblJlc3VtZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdHRoaXMuaW52b2tlKFxcXCJtb3Rpb25SZXN1bWVcXFwiKTtcXG5cXHRcXHR0aGlzLmZpcmUoTC5Nb3Rpb24uRXZlbnQuUmVzdW1lZCwge2xheWVyOiB0aGlzfSwgZmFsc2UpO1xcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH0sXFxuXFxuXFx0LyoqXFxuXFx0XFx0UmVzZXQgYWxsIG1vdGlvbnMgaW4gY3VycmVudCBncm91cDtcXG5cXHQqL1xcblxcdG1vdGlvblRvZ2dsZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdHRoaXMuaW52b2tlKFxcXCJtb3Rpb25Ub2dnbGVcXFwiKTtcXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9LFxcblxcblxcdC8qKlxcblxcdFxcdFJldHVybnMgbWFya2VycyBhcnJheSBmcm9tIGFsbCBpbm5lciBsYXllcnMgd2l0aG91dCBmbGF0dGVyaW5nLlxcblxcdCovXFxuXFx0Z2V0TWFya2VyczogZnVuY3Rpb24gKCkge1xcblxcdFxcdHJldHVybiB0aGlzLmdldExheWVycygpLm1hcChmdW5jdGlvbihsKSB7IHJldHVybiBsLmdldE1hcmtlcnMoKTsgfSk7XFxuXFx0fVxcbn0pO1xcblxcbkwubW90aW9uLmdyb3VwID0gZnVuY3Rpb24obW90aW9ucywgb3B0aW9ucyl7XFxuICAgIHJldHVybiBuZXcgTC5Nb3Rpb24uR3JvdXAobW90aW9ucywgb3B0aW9ucyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGVhZmxldC5tb3Rpb24uZ3JvdXAuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5wb2x5Z29uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbGF5ZXIvbGVhZmxldC5tb3Rpb24ucG9seWdvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCIvKipcXG5cXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxcblxcdEF1dGhvciBJZ29yIFZsYWR5a2EgPGlnb3IudmxhZHlrYUBnbWFpbC5jb20+IChodHRwczovL2dpdGh1Yi5jb20vSWdvci1WbGFkeWthL2xlYWZsZXQubW90aW9uKVxcbioqL1xcblxcbkwuTW90aW9uLlBvbHlnb24gPSBMLlBvbHlnb24uZXh0ZW5kKEwuTW90aW9uLkFuaW1hdGUpO1xcblxcbkwubW90aW9uLnBvbHlnb24gPSBmdW5jdGlvbihsYXRsbmdzLCBvcHRpb25zLCBtb3Rpb25PcHRpb25zLCBtYXJrZXJPcHRpb25zKXtcXG4gICAgcmV0dXJuIG5ldyBMLk1vdGlvbi5Qb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMsIG1vdGlvbk9wdGlvbnMsIG1hcmtlck9wdGlvbnMpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2xheWVyL2xlYWZsZXQubW90aW9uLnBvbHlnb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5wb2x5bGluZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5wb2x5bGluZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiLyoqXFxuXFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXG5cXHRBdXRob3IgSWdvciBWbGFkeWthIDxpZ29yLnZsYWR5a2FAZ21haWwuY29tPiAoaHR0cHM6Ly9naXRodWIuY29tL0lnb3ItVmxhZHlrYS9sZWFmbGV0Lm1vdGlvbilcXG4qKi9cXG5cXG5MLk1vdGlvbi5Qb2x5bGluZSA9IEwuUG9seWxpbmUuZXh0ZW5kKEwuTW90aW9uLkFuaW1hdGUpO1xcblxcbkwubW90aW9uLnBvbHlsaW5lID0gZnVuY3Rpb24obGF0bG5ncywgb3B0aW9ucywgbW90aW9uT3B0aW9ucywgbWFya2VyT3B0aW9ucyl7XFxuICAgIHJldHVybiBuZXcgTC5Nb3Rpb24uUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucywgbW90aW9uT3B0aW9ucywgbWFya2VyT3B0aW9ucyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGVhZmxldC5tb3Rpb24ucG9seWxpbmUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5zZXEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xheWVyL2xlYWZsZXQubW90aW9uLnNlcS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIi8qKlxcblxcdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuXFx0QXV0aG9yIElnb3IgVmxhZHlrYSA8aWdvci52bGFkeWthQGdtYWlsLmNvbT4gKGh0dHBzOi8vZ2l0aHViLmNvbS9JZ29yLVZsYWR5a2EvbGVhZmxldC5tb3Rpb24pXFxuKiovXFxuXFxuTC5Nb3Rpb24uU2VxID0gTC5Nb3Rpb24uR3JvdXAuZXh0ZW5kICh7XFxuXFx0X2FjdGl2ZUxheWVyOiBudWxsLFxcblxcdF9zdGFydGVkOiBmYWxzZSxcXG5cXHRfY29tcGxldGVkOiBmYWxzZSxcXG5cXG5cXHRhZGRMYXllcjogZnVuY3Rpb24gKGwsIGF1dG9zdGFydCkge1xcblxcdFxcdGlmIChhdXRvc3RhcnQgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdGF1dG9zdGFydCA9IHRydWU7XFxuXFx0XFx0fVxcblxcdFxcdHRoaXMuX19wcmVwYXJlTGF5ZXIobCk7XFxuXFx0XFx0TC5Nb3Rpb24uR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbCk7XFxuXFxuXFx0XFx0aWYgKCF0aGlzLl9hY3RpdmVMYXllciAmJiBhdXRvc3RhcnQgJiYgdGhpcy5fY29tcGxldGVkKSB7XFxuXFx0XFx0XFx0bC5tb3Rpb25TdGFydCgpO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdC8qKlxcblxcdFxcdFN0YXJ0IGZpcnN0IG1vdGlvbiBpbiBjdXJyZW50IGdyb3VwO1xcblxcdCovXFxuXFx0bW90aW9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdC8vIFdlIHdpbGwgc3RhcnQgYW5pbWF0aW9uIG9ubHkgd2hlbiBpdHMgbm90IHJ1bm5pbmdcXG5cXHRcXHRpZiAoIXRoaXMuX2FjdGl2ZUxheWVyKSB7XFxuXFx0XFx0XFx0dmFyIGxheWVyID0gdGhpcy5nZXRGaXJzdExheWVyKCk7XFxuXFx0XFx0XFx0aWYgKGxheWVyKSB7XFxuXFx0XFx0XFx0XFx0bGF5ZXIubW90aW9uU3RhcnQoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zdGFydGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jb21wbGV0ZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR0aGlzLmZpcmUoTC5Nb3Rpb24uRXZlbnQuU3RhcnRlZCwge2xheWVyOiB0aGlzfSwgZmFsc2UpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHQvKipcXG5cXHRcXHRTdG9wcyBhbGwgbW90aW9ucyBpbiBjdXJyZW50IGdyb3VwO1xcblxcdCovXFxuXFx0bW90aW9uU3RvcDogZnVuY3Rpb24oc29mdHN0b3ApIHtcXG5cXHRcXHRpZiAoIXNvZnRzdG9wKSB7XFxuXFx0XFx0XFx0dGhpcy5pbnZva2UoXFxcIm1vdGlvblN0b3BcXFwiKTtcXG5cXHRcXHR9XFxuXFx0XFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBudWxsO1xcblxcdFxcdHRoaXMuX2NvbXBsZXRlZCA9IHRydWU7XFxuXFx0XFx0dGhpcy5maXJlKEwuTW90aW9uLkV2ZW50LkVuZGVkLCB7bGF5ZXI6IHRoaXN9LCBmYWxzZSk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHQvKipcXG5cXHRcXHRQYXVzZSBjdXJyZW50IG1vdGlvbiBpbiBjdXJyZW50IGdyb3VwO1xcblxcdCovXFxuXFx0bW90aW9uUGF1c2U6IGZ1bmN0aW9uKCkge1xcblxcdFxcdGlmICh0aGlzLl9hY3RpdmVMYXllcikge1xcblxcdFxcdFxcdHRoaXMuX2FjdGl2ZUxheWVyLm1vdGlvblBhdXNlKCk7XFxuXFx0XFx0XFx0dGhpcy5maXJlKEwuTW90aW9uLkV2ZW50LlBhdXNlZCwge2xheWVyOiB0aGlzfSwgZmFsc2UpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9LFxcblxcblxcdC8qKlxcblxcdFxcdFJlc3VtZSBsYXN0IG1vdGlvbiBpbiBjdXJyZW50IGdyb3VwO1xcblxcdCovXFxuXFx0bW90aW9uUmVzdW1lOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAodGhpcy5fYWN0aXZlTGF5ZXIpIHtcXG5cXHRcXHRcXHR0aGlzLl9hY3RpdmVMYXllci5tb3Rpb25SZXN1bWUoKTtcXG5cXHRcXHRcXHR0aGlzLmZpcmUoTC5Nb3Rpb24uRXZlbnQuUmVzdW1lZCwge2xheWVyOiB0aGlzfSwgZmFsc2UpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9LFxcblxcblxcdC8qKlxcblxcdFxcdFJlc2V0IGFsbCBtb3Rpb25zIGluIGN1cnJlbnQgZ3JvdXA7XFxuXFx0Ki9cXG5cXHRtb3Rpb25Ub2dnbGU6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRpZiAodGhpcy5fYWN0aXZlTGF5ZXIpIHtcXG5cXHRcXHRcXHR0aGlzLm1vdGlvblBhdXNlKCk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aGlzLm1vdGlvblJlc3VtZSgpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9LFxcblxcblxcdGdldEZpcnN0TGF5ZXI6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBhbGxMYXllcnMgPSB0aGlzLmdldExheWVycygpO1xcblxcdFxcdHJldHVybiBhbGxMYXllcnMubGVuZ3RoID8gYWxsTGF5ZXJzWzBdIDogbnVsbDtcXG5cXHR9LFxcblxcblxcdC8qKlxcblxcdFxcdEluaXRpYWxpc2UgYSBsYXllciBzbyBpdCdzIHJlYWR5IHRvIGJlIHBhcnQgb2YgdGhpcyBtb3Rpb24gc2VxdWVuY2VcXG5cXHQqL1xcblxcdF9fcHJlcGFyZUxheWVyOiBmdW5jdGlvbiAobCkge1xcblxcdFxcdGlmIChsLnNldExhdExuZ3MpIHtcXG5cXHRcXHRcXHRsLnNldExhdExuZ3MoW10pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBXaGVuIGEgbGF5ZXIgZmluaXNoZXMgaGF2ZSBpdCByZW1vdmUgaXRzZWxmIGFuZCBjYWxsIG1vdGlvblN0YXJ0KCkgb24gdGhlIG5leHQgbGF5ZXJcXG5cXHRcXHRsLm9mZihMLk1vdGlvbi5FdmVudC5FbmRlZCwgdGhpcy5fX2NsZWFyQWN0aXZlTGF5ZXJfXywgdGhpcyk7XFxuXFx0XFx0bC5vbihMLk1vdGlvbi5FdmVudC5FbmRlZCwgdGhpcy5fX2NsZWFyQWN0aXZlTGF5ZXJfXywgdGhpcyk7XFxuXFxuXFx0XFx0Ly8gV2hlbiBhIGxheWVyIGlzIHN0YXJ0ZWQgKGJ5IHRoZSBsYXN0IG9uZSBlbmRpbmcpIHNldCBpdCBhcyB0aGUgYWN0aXZlIGxheWVyXFxuXFx0XFx0bC5vZmYoTC5Nb3Rpb24uRXZlbnQuU3RhcnRlZCwgdGhpcy5fX3B1dEFjdGl2ZUxheWVyX18sIHRoaXMpO1xcblxcdFxcdGwub24oTC5Nb3Rpb24uRXZlbnQuU3RhcnRlZCwgdGhpcy5fX3B1dEFjdGl2ZUxheWVyX18sIHRoaXMpO1xcblxcdH0sXFxuXFxuXFx0LyoqXFxuXFx0XFx0Q2FsbGVkIGJ5IGEgbGF5ZXIgKGUuZy4gb25lIG9mIHRoZSBzZXF1ZW5jZSBldmVudHMpIHdoZW4gaXQgZmluaXNoZXMuIElzIHJlc3BvbnNpYmxlIGZvclxcblxcdFxcdGNsZWFuaW5nIHVwIGFmdGVyIGl0c2VsZiBhbmQgc3RhcnRpbmcgdGhlIG5leHQgbGF5ZXIuXFxuXFx0ICovXFxuXFx0X19jbGVhckFjdGl2ZUxheWVyX186IGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBudWxsO1xcblxcdFxcdHZhciBsYXllcnMgPSB0aGlzLmdldExheWVycygpO1xcblxcdFxcdHZhciBjdXJyZW50SWQgPSBlLmxheWVyLl9sZWFmbGV0X2lkO1xcblxcdFxcdHZhciBjdXJyZW50T2JqZWN0ID0gbGF5ZXJzLmZpbHRlcihmdW5jdGlvbihmKXsgcmV0dXJuIGYuX2xlYWZsZXRfaWQgPT0gY3VycmVudElkIH0pWzBdO1xcblxcdFxcdHZhciBuZXh0SW5kZXggPSBsYXllcnMuaW5kZXhPZihjdXJyZW50T2JqZWN0KSArIDE7XFxuXFx0XFx0aWYgKGxheWVycy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcXG5cXHRcXHRcXHRsYXllcnNbbmV4dEluZGV4XS5tb3Rpb25TdGFydCgpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly90aGlzLmZpcmUoTC5Nb3Rpb24uRXZlbnQuRW5kZWQsIHtsYXllcjogdGhpc30sIGZhbHNlKTtcXG5cXHRcXHRcXHR0aGlzLm1vdGlvblN0b3AodHJ1ZSk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0LyoqXFxuXFx0XFx0Q2FsbGVkIGJ5IGEgbGF5ZXIgd2hlbiBpdCdzIHN0YXJ0ZWQsIHNldHMgaXRzZWxmIGFzIHRoZSBhY3RpdmUgbGF5ZXIgb24gdGhlIHNlcXVlbmNlXFxuXFx0XFx0Z3JvdXAgYW5kIHRyaWdnZXIgYW55IG90aGVyIGV2ZW50cyB3aGljaCBuZWVkIHRyaWdnZXJpbmcuXFxuXFx0ICovXFxuXFx0X19wdXRBY3RpdmVMYXllcl9fOiBmdW5jdGlvbiAoZSkge1xcblxcdFxcdHRoaXMuX2FjdGl2ZUxheWVyID0gZS5sYXllcjtcXG5cXHRcXHR0aGlzLmZpcmUoTC5Nb3Rpb24uRXZlbnQuU2VjdGlvbiwge2xheWVyOiB0aGlzLl9hY3RpdmVMYXllcn0sIGZhbHNlKTtcXG5cXHR9XFxufSk7XFxuXFxuTC5tb3Rpb24uc2VxID0gZnVuY3Rpb24obW90aW9uLCBvcHRpb25zKXtcXG4gICAgcmV0dXJuIG5ldyBMLk1vdGlvbi5TZXEobW90aW9uLCBvcHRpb25zKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5zZXEuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sZWFmbGV0Lm1vdGlvbi5lYXNpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xlYWZsZXQubW90aW9uLmVhc2luZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIi8qKlxcblxcdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuXFx0QXV0aG9yIElnb3IgVmxhZHlrYSA8aWdvci52bGFkeWthQGdtYWlsLmNvbT4gKGh0dHBzOi8vZ2l0aHViLmNvbS9JZ29yLVZsYWR5a2EvbGVhZmxldC5tb3Rpb24pXFxuKiovXFxuXFxuTC5Nb3Rpb24uRWFzZSA9IHtcXG5cXHRsaW5lYXI6IGZ1bmN0aW9uKCB4ICkge1xcblxcdFxcdHJldHVybiB4O1xcblxcdH0sXFxuXFx0c3dpbmc6IGZ1bmN0aW9uKCB4ICkge1xcblxcdFxcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggeCAqIE1hdGguUEkgKSAvIDI7XFxuXFx0fSxcXG5cXHRlYXNlSW5RdWFkOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xcblxcdFxcdHJldHVybiBjKih0Lz1kKSp0ICsgYjtcXG5cXHR9LFxcblxcdGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xcblxcdFxcdHJldHVybiAtYyAqKHQvPWQpKih0LTIpICsgYjtcXG5cXHR9LFxcblxcdGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0aWYgKCh0Lz1kLzIpIDwgMSkgcmV0dXJuIGMvMip0KnQgKyBiO1xcblxcdFxcdHJldHVybiAtYy8yICogKCgtLXQpKih0LTIpIC0gMSkgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0cmV0dXJuIGMqKHQvPWQpKnQqdCArIGI7XFxuXFx0fSxcXG5cXHRlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0cmV0dXJuIGMqKCh0PXQvZC0xKSp0KnQgKyAxKSArIGI7XFxuXFx0fSxcXG5cXHRlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcXG5cXHRcXHRpZiAoKHQvPWQvMikgPCAxKSByZXR1cm4gYy8yKnQqdCp0ICsgYjtcXG5cXHRcXHRyZXR1cm4gYy8yKigodC09MikqdCp0ICsgMikgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0cmV0dXJuIGMqKHQvPWQpKnQqdCp0ICsgYjtcXG5cXHR9LFxcblxcdGVhc2VPdXRRdWFydDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcXG5cXHRcXHRyZXR1cm4gLWMgKiAoKHQ9dC9kLTEpKnQqdCp0IC0gMSkgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0aWYgKCh0Lz1kLzIpIDwgMSkgcmV0dXJuIGMvMip0KnQqdCp0ICsgYjtcXG5cXHRcXHRyZXR1cm4gLWMvMiAqICgodC09MikqdCp0KnQgLSAyKSArIGI7XFxuXFx0fSxcXG5cXHRlYXNlSW5RdWludDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcXG5cXHRcXHRyZXR1cm4gYyoodC89ZCkqdCp0KnQqdCArIGI7XFxuXFx0fSxcXG5cXHRlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0cmV0dXJuIGMqKCh0PXQvZC0xKSp0KnQqdCp0ICsgMSkgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0aWYgKCh0Lz1kLzIpIDwgMSkgcmV0dXJuIGMvMip0KnQqdCp0KnQgKyBiO1xcblxcdFxcdHJldHVybiBjLzIqKCh0LT0yKSp0KnQqdCp0ICsgMikgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZUluU2luZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcXG5cXHRcXHRyZXR1cm4gLWMgKiBNYXRoLmNvcyh0L2QgKiAoTWF0aC5QSS8yKSkgKyBjICsgYjtcXG5cXHR9LFxcblxcdGVhc2VPdXRTaW5lOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xcblxcdFxcdHJldHVybiBjICogTWF0aC5zaW4odC9kICogKE1hdGguUEkvMikpICsgYjtcXG5cXHR9LFxcblxcdGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0cmV0dXJuIC1jLzIgKiAoTWF0aC5jb3MoTWF0aC5QSSp0L2QpIC0gMSkgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZUluRXhwbzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcXG5cXHRcXHRyZXR1cm4gKHQ9PTApID8gYiA6IGMgKiBNYXRoLnBvdygyLCAxMCAqICh0L2QgLSAxKSkgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZU91dEV4cG86IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0cmV0dXJuICh0PT1kKSA/IGIrYyA6IGMgKiAoLU1hdGgucG93KDIsIC0xMCAqIHQvZCkgKyAxKSArIGI7XFxuXFx0fSxcXG5cXHRlYXNlSW5PdXRFeHBvOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xcblxcdFxcdGlmICh0PT0wKSByZXR1cm4gYjtcXG5cXHRcXHRpZiAodD09ZCkgcmV0dXJuIGIrYztcXG5cXHRcXHRpZiAoKHQvPWQvMikgPCAxKSByZXR1cm4gYy8yICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSArIGI7XFxuXFx0XFx0cmV0dXJuIGMvMiAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpICsgYjtcXG5cXHR9LFxcblxcdGVhc2VJbkNpcmM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0cmV0dXJuIC1jICogKE1hdGguc3FydCgxIC0gKHQvPWQpKnQpIC0gMSkgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZU91dENpcmM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0cmV0dXJuIGMgKiBNYXRoLnNxcnQoMSAtICh0PXQvZC0xKSp0KSArIGI7XFxuXFx0fSxcXG5cXHRlYXNlSW5PdXRDaXJjOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xcblxcdFxcdGlmICgodC89ZC8yKSA8IDEpIHJldHVybiAtYy8yICogKE1hdGguc3FydCgxIC0gdCp0KSAtIDEpICsgYjtcXG5cXHRcXHRyZXR1cm4gYy8yICogKE1hdGguc3FydCgxIC0gKHQtPTIpKnQpICsgMSkgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZUluRWxhc3RpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcXG5cXHRcXHR2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9YztcXG5cXHRcXHRpZiAodD09MCkgcmV0dXJuIGI7ICBpZiAoKHQvPWQpPT0xKSByZXR1cm4gYitjOyAgaWYgKCFwKSBwPWQqLjM7XFxuXFx0XFx0aWYgKGEgPCBNYXRoLmFicyhjKSkgeyBhPWM7IHZhciBzPXAvNDsgfVxcblxcdFxcdGVsc2UgdmFyIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luIChjL2EpO1xcblxcdFxcdHJldHVybiAtKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oICh0KmQtcykqKDIqTWF0aC5QSSkvcCApKSArIGI7XFxuXFx0fSxcXG5cXHRlYXNlT3V0RWxhc3RpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcXG5cXHRcXHR2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9YztcXG5cXHRcXHRpZiAodD09MCkgcmV0dXJuIGI7ICBpZiAoKHQvPWQpPT0xKSByZXR1cm4gYitjOyAgaWYgKCFwKSBwPWQqLjM7XFxuXFx0XFx0aWYgKGEgPCBNYXRoLmFicyhjKSkgeyBhPWM7IHZhciBzPXAvNDsgfVxcblxcdFxcdGVsc2UgdmFyIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luIChjL2EpO1xcblxcdFxcdHJldHVybiBhKk1hdGgucG93KDIsLTEwKnQpICogTWF0aC5zaW4oICh0KmQtcykqKDIqTWF0aC5QSSkvcCApICsgYyArIGI7XFxuXFx0fSxcXG5cXHRlYXNlSW5PdXRFbGFzdGljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xcblxcdFxcdHZhciBzPTEuNzAxNTg7dmFyIHA9MDt2YXIgYT1jO1xcblxcdFxcdGlmICh0PT0wKSByZXR1cm4gYjsgIGlmICgodC89ZC8yKT09MikgcmV0dXJuIGIrYzsgIGlmICghcCkgcD1kKiguMyoxLjUpO1xcblxcdFxcdGlmIChhIDwgTWF0aC5hYnMoYykpIHsgYT1jOyB2YXIgcz1wLzQ7IH1cXG5cXHRcXHRlbHNlIHZhciBzID0gcC8oMipNYXRoLlBJKSAqIE1hdGguYXNpbiAoYy9hKTtcXG5cXHRcXHRpZiAodCA8IDEpIHJldHVybiAtLjUqKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oICh0KmQtcykqKDIqTWF0aC5QSSkvcCApKSArIGI7XFxuXFx0XFx0cmV0dXJuIGEqTWF0aC5wb3coMiwtMTAqKHQtPTEpKSAqIE1hdGguc2luKCAodCpkLXMpKigyKk1hdGguUEkpL3AgKSouNSArIGMgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZUluQmFjazogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQsIHMpIHtcXG5cXHRcXHRpZiAocyA9PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xcblxcdFxcdHJldHVybiBjKih0Lz1kKSp0KigocysxKSp0IC0gcykgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZU91dEJhY2s6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkLCBzKSB7XFxuXFx0XFx0aWYgKHMgPT0gdW5kZWZpbmVkKSBzID0gMS43MDE1ODtcXG5cXHRcXHRyZXR1cm4gYyooKHQ9dC9kLTEpKnQqKChzKzEpKnQgKyBzKSArIDEpICsgYjtcXG5cXHR9LFxcblxcdGVhc2VJbk91dEJhY2s6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkLCBzKSB7XFxuXFx0XFx0aWYgKHMgPT0gdW5kZWZpbmVkKSBzID0gMS43MDE1ODtcXG5cXHRcXHRpZiAoKHQvPWQvMikgPCAxKSByZXR1cm4gYy8yKih0KnQqKCgocyo9KDEuNTI1KSkrMSkqdCAtIHMpKSArIGI7XFxuXFx0XFx0cmV0dXJuIGMvMiooKHQtPTIpKnQqKCgocyo9KDEuNTI1KSkrMSkqdCArIHMpICsgMikgKyBiO1xcblxcdH0sXFxuXFx0ZWFzZUluQm91bmNlOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xcblxcdFxcdHJldHVybiBjIC0gTC5Nb3Rpb24uRWFzZS5lYXNlT3V0Qm91bmNlICh4LCBkLXQsIDAsIGMsIGQpICsgYjtcXG5cXHR9LFxcblxcdGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XFxuXFx0XFx0aWYgKCh0Lz1kKSA8ICgxLzIuNzUpKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGMqKDcuNTYyNSp0KnQpICsgYjtcXG5cXHRcXHR9IGVsc2UgaWYgKHQgPCAoMi8yLjc1KSkge1xcblxcdFxcdFxcdHJldHVybiBjKig3LjU2MjUqKHQtPSgxLjUvMi43NSkpKnQgKyAuNzUpICsgYjtcXG5cXHRcXHR9IGVsc2UgaWYgKHQgPCAoMi41LzIuNzUpKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGMqKDcuNTYyNSoodC09KDIuMjUvMi43NSkpKnQgKyAuOTM3NSkgKyBiO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cmV0dXJuIGMqKDcuNTYyNSoodC09KDIuNjI1LzIuNzUpKSp0ICsgLjk4NDM3NSkgKyBiO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcdGVhc2VJbk91dEJvdW5jZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcXG5cXHRcXHRpZiAodCA8IGQvMikgcmV0dXJuIEwuTW90aW9uLkVhc2UuZWFzZUluQm91bmNlICh4LCB0KjIsIDAsIGMsIGQpICogLjUgKyBiO1xcblxcdFxcdHJldHVybiBMLk1vdGlvbi5FYXNlLmVhc2VPdXRCb3VuY2UgKHgsIHQqMi1kLCAwLCBjLCBkKSAqIC41ICsgYyouNSArIGI7XFxuXFx0fVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2xlYWZsZXQubW90aW9uLmVhc2luZy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xlYWZsZXQubW90aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xlYWZsZXQubW90aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCIvKipcXHJcXG5cXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxcclxcblxcdEF1dGhvciBJZ29yIFZsYWR5a2EgPGlnb3IudmxhZHlrYUBnbWFpbC5jb20+IChodHRwczovL2dpdGh1Yi5jb20vSWdvci1WbGFkeWthL2xlYWZsZXQubW90aW9uKVxcclxcbioqL1xcclxcblxcclxcbkwuTW90aW9uID0gTC5Nb3Rpb24gfHwge1xcclxcblxcdEV2ZW50OiB7XFxyXFxuXFx0XFx0XFx0U3RhcnRlZDpcXFwibW90aW9uLXN0YXJ0ZWRcXFwiLFxcclxcblxcdFxcdFxcdFBhdXNlZDogXFxcIm1vdGlvbi1wYXVzZWRcXFwiLFxcclxcblxcdFxcdFxcdFJlc3VtZWQ6IFxcXCJtb3Rpb24tcmVzdW1lZFxcXCIsXFxyXFxuXFx0XFx0XFx0U2VjdGlvbjogXFxcIm1vdGlvbi1zZWN0aW9uXFxcIixcXHJcXG5cXHRcXHRcXHRFbmRlZDogXFxcIm1vdGlvbi1lbmRlZFxcXCJcXHJcXG5cXHRcXHR9XFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5MLm1vdGlvbiA9IEwubW90aW9uIHx8IHt9O1xcclxcbkwuTW90aW9uLkFuaW1hdGUgPSB7XFxyXFxuXFx0b3B0aW9uczoge1xcclxcblxcdFxcdHBhbmU6IFxcXCJwb2x5bW90aW9uUGFuZVxcXCIsXFxyXFxuXFx0XFx0YXR0cmlidXRpb246IFxcXCJMZWFmbGV0Lk1vdGlvbiDCqSBcXFwiICsgKG5ldyBEYXRlKCkpLmdldEZ1bGxZZWFyKCkgKyBcXFwiIElnb3IgVmxhZHlrYVxcXCJcXHJcXG5cXHR9LFxcclxcblxcclxcblxcdG1vdGlvbk9wdGlvbnM6IHtcXHJcXG5cXHRcXHRhdXRvOiBmYWxzZSxcXHJcXG5cXHRcXHRlYXNpbmc6IGZ1bmN0aW9uKHgpeyByZXR1cm4geDsgfSwgLy8gbGluZWFyXFxyXFxuXFx0XFx0c3BlZWQ6IDAsIC8vIEtNL0hcXHJcXG5cXHRcXHRkdXJhdGlvbjogMCAvLyBtc1xcclxcblxcdH0sXFxyXFxuXFxyXFxuXFx0bWFya2VyT3B0aW9uczogdW5kZWZpbmVkLFxcclxcblxcclxcblxcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zLCBtb3Rpb25PcHRpb25zLCBtYXJrZXJPcHRpb25zKSB7XFxyXFxuXFx0XFx0TC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XFxyXFxuXFx0XFx0aWYgKG1vdGlvbk9wdGlvbnMpIHtcXHJcXG5cXHRcXHRcXHR0aGlzLm1vdGlvbk9wdGlvbnMgPSBMLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLm1vdGlvbk9wdGlvbnMsIG1vdGlvbk9wdGlvbnMpO1xcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAobWFya2VyT3B0aW9ucykge1xcclxcblxcdFxcdFxcdHRoaXMubWFya2VyT3B0aW9ucyA9IEwuVXRpbC5leHRlbmQoe30sIG1hcmtlck9wdGlvbnMpO1xcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR0aGlzLl9ib3VuZHMgPSBMLmxhdExuZ0JvdW5kcygpO1xcclxcblxcdFxcdHRoaXMuX2xpbmVQb2ludHMgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcXHJcXG5cXHRcXHRpZiAoIUwuTW90aW9uLlV0aWxzLmlzRmxhdCh0aGlzLl9saW5lUG9pbnRzKSkge1xcclxcblxcdFxcdFxcdHRoaXMuX2xpbmVQb2ludHMgPSB0aGlzLl9saW5lUG9pbnRzWzBdO1xcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR0aGlzLl9pbml0aWFsaXplTWFya2VyKCk7XFxyXFxuXFx0XFx0dGhpcy5fbGF0bG5ncyA9IFtdO1xcclxcblxcdFxcdEwuVXRpbC5zdGFtcCh0aGlzKTsgLy8gRW5mb3JjZSBwcm9wZXIgYW5pbWF0aW9uIG9yZGVyO1xcclxcblxcdH0sXFxyXFxuXFxyXFxuXFx0YWRkTGF0TG5nOiBmdW5jdGlvbihsYXRMbmcsIHJpbmcpIHtcXHJcXG5cXHRcXHRsYXRMbmcgPSBMLk1vdGlvbi5VdGlscy50b0xhdExuZyhsYXRMbmcpO1xcclxcblxcdFxcdHRoaXMuX2xpbmVQb2ludHMucHVzaChsYXRMbmcpO1xcclxcblxcdFxcdGlmICh0aGlzLl9sYXRsbmdzLmxlbmd0aCkge1xcclxcblxcdFxcdFxcdHRoaXMuX2xhdGxuZ3MucHVzaChsYXRMbmcpO1xcclxcblxcdFxcdH1cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHR9LFxcclxcblxcclxcblxcdC8qKlxcclxcbiAgICAgICAgQHBhcmFtIHtNYXB9IG1hcCB0aGUgTGVhZmxldCBNYXBcXHJcXG4gICAgKi9cXHJcXG5cXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcXHJcXG5cXHRcXHRpZiAoIW1hcC5nZXRQYW5lKHRoaXMub3B0aW9ucy5wYW5lKSkge1xcclxcblxcdFxcdFxcdG1hcC5jcmVhdGVQYW5lKHRoaXMub3B0aW9ucy5wYW5lKS5zdHlsZS56SW5kZXggPSA1OTk7XFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xcclxcblxcdH0sXFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuICAgICAgICBAcGFyYW0ge01hcH0gbWFwIHRoZSBMZWFmbGV0IE1hcFxcclxcblxcdFxcdEByZXR1cm4ge01vdGlvbk9iamVjdH0gdGhpc1xcclxcbiAgICAqL1xcclxcbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xcclxcblxcdFxcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcXHJcXG5cXHRcXHR0aGlzLl9yZXNldCgpO1xcclxcblxcdFxcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xcclxcblxcdFxcdGlmICh0aGlzLl9fbWFya2VyICYmIHRoaXMubWFya2VyT3B0aW9ucy5zaG93TWFya2VyKSB7XFxyXFxuXFx0XFx0XFx0dGhpcy5fX21hcmtlci5hZGRUbyhtYXApO1xcclxcblxcclxcblxcdFxcdFxcdGlmKHRoaXMuX19tYXJrZXIuX2ljb24gJiYgdGhpcy5fX21hcmtlci5faWNvbi5jaGlsZHJlbi5sZW5ndGgpe1xcclxcblxcdFxcdFxcdFxcdEFycmF5LmZyb20odGhpcy5fX21hcmtlci5faWNvbi5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihpY29uKSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJhc2VSb3RhdGlvbkFuZ2xlID0gaWNvbi5nZXRBdHRyaWJ1dGUoXFxcIm1vdGlvbi1iYXNlXFxcIik7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGJhc2VSb3RhdGlvbkFuZ2xlKSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWNvbi5zdHlsZS50cmFuc2Zvcm0gPSBcXFwicm90YXRlKFxcXCIgKyBiYXNlUm90YXRpb25BbmdsZSArIFxcXCJkZWcpXFxcIjtcXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0XFx0fSk7XFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAodGhpcy5tb3Rpb25PcHRpb25zLmF1dG8pIHtcXHJcXG5cXHRcXHRcXHR0aGlzLm1vdGlvblN0YXJ0KCk7XFxyXFxuXFx0XFx0fVxcclxcblxcclxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuICAgICAgICBAcGFyYW0ge01hcH0gbWFwIHRoZSBMZWFmbGV0IE1hcFxcclxcbiAgICAqL1xcclxcblxcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XFxyXFxuXFx0XFx0dGhpcy5tb3Rpb25TdG9wKCk7XFxyXFxuXFx0XFx0aWYgKHRoaXMuX19tYXJrZXIpIHtcXHJcXG5cXHRcXHRcXHRtYXAucmVtb3ZlTGF5ZXIodGhpcy5fX21hcmtlcik7XFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMuX3JlbmRlcmVyLl9yZW1vdmVQYXRoKHRoaXMpO1xcclxcblxcdH0sXFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuICAgICAgICBAcGFyYW0ge0RhdGVUaW1lfSBzdGFydFRpbWUgdGltZSBmcm9tIHN0YXJ0IGFuaW1hdGlvblxcclxcbiAgICAqL1xcclxcbiAgICBfbW90aW9uOiBmdW5jdGlvbiAoc3RhcnRUaW1lKSB7XFxyXFxuXFx0XFx0dmFyIGVsbGFwc2VkVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydFRpbWU7XFxyXFxuICAgICAgICB2YXIgZHVyYXRpb25SYXRpbyA9IDE7IC8vIDAgLSAxXFxyXFxuXFx0XFx0aWYgKHRoaXMubW90aW9uT3B0aW9ucy5kdXJhdGlvbikge1xcclxcblxcdFxcdFxcdGR1cmF0aW9uUmF0aW8gPSBlbGxhcHNlZFRpbWUgLyB0aGlzLm1vdGlvbk9wdGlvbnMuZHVyYXRpb247XFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGlmIChkdXJhdGlvblJhdGlvIDwgMSkge1xcclxcblxcdFxcdFxcdGR1cmF0aW9uUmF0aW8gPSB0aGlzLm1vdGlvbk9wdGlvbnMuZWFzaW5nKGR1cmF0aW9uUmF0aW8sIGVsbGFwc2VkVGltZSwgMCwgMSwgdGhpcy5tb3Rpb25PcHRpb25zLmR1cmF0aW9uKTtcXHJcXG5cXHRcXHRcXHR2YXIgaW50ZXJwb2xhdGVkTGluZSA9IEwuTW90aW9uLlV0aWxzLmludGVycG9sYXRlT25MaW5lKHRoaXMuX21hcCwgdGhpcy5fbGluZVBvaW50cywgZHVyYXRpb25SYXRpbyk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zZXRMYXRMbmdzKGludGVycG9sYXRlZExpbmUudHJhdmVsZWRQYXRoKTtcXHJcXG5cXHRcXHRcXHR0aGlzLl9kcmF3TWFya2VyKGludGVycG9sYXRlZExpbmUubGF0TG5nKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLl9fZWxsYXBzZWRUaW1lID0gZWxsYXBzZWRUaW1lO1xcclxcblxcdFxcdFxcdHRoaXMuYW5pbWF0aW9uID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24oKXtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl9tb3Rpb24oc3RhcnRUaW1lKTtcXHJcXG5cXHRcXHRcXHR9LCB0aGlzKTtcXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcdFxcdFxcdHRoaXMubW90aW9uU3RvcCh0cnVlKTtcXHJcXG5cXHRcXHR9XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0XFx0RHJhd3MgbWFya2VyIGFjY29yZGluZyB0byBsaW5lIHBvc2l0aW9uXFxyXFxuICAgICAgICBAcGFyYW0ge0xhdExuZ30gbmV4dFBvaW50IG5leHQgYW5pbWF0aW9uIHBvaW50XFxyXFxuICAgICovXFxyXFxuXFx0X2RyYXdNYXJrZXI6IGZ1bmN0aW9uIChuZXh0UG9pbnQpIHtcXHJcXG5cXHRcXHR2YXIgbWFya2VyID0gdGhpcy5nZXRNYXJrZXIoKTtcXHJcXG5cXHRcXHRpZiAobWFya2VyKSB7XFxyXFxuXFx0XFx0XFx0dmFyIHByZXZQb2ludCA9IG1hcmtlci5nZXRMYXRMbmcoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBbMCwgMF0gTWVhbnMgdGhhdCBtYXJrZXIgaXMgbm90IGFkZGVkIHlldCB0byB0aGUgbWFwXFxyXFxuXFx0XFx0XFx0dmFyIGluaXRpYWxQb2ludHMgPSB0aGlzLl9saW5lUG9pbnRzWzBdO1xcclxcblxcdFxcdFxcdGlmIChwcmV2UG9pbnQubGF0ID09PSBpbml0aWFsUG9pbnRzLmxhdCAmJiBwcmV2UG9pbnQubG5nID09PSBpbml0aWFsUG9pbnRzLmxuZykge1xcclxcblxcdFxcdFxcdFxcdG1hcmtlci5hZGRUbyh0aGlzLl9tYXApO1xcclxcblxcdFxcdFxcdFxcdG1hcmtlci5hZGRFdmVudFBhcmVudCh0aGlzKTtcXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcdFxcdFxcdFxcdGlmIChtYXJrZXIuX2ljb24gJiYgbWFya2VyLl9pY29uLmNoaWxkcmVuLmxlbmd0aCkge1xcclxcblxcdFxcdFxcdFxcdFxcdEFycmF5LmZyb20obWFya2VyLl9pY29uLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKGljb24pIHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbmVlZFRvUm90YXRlTWFya2VyID0gaWNvbi5nZXRBdHRyaWJ1dGUoXFxcIm1vdGlvbi1iYXNlXFxcIik7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG5lZWRUb1JvdGF0ZU1hcmtlcikge1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBtb3Rpb25NYXJrZXJPbkxpbmUgPSAwO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChuZWVkVG9Sb3RhdGVNYXJrZXIgJiYgIWlzTmFOKCtuZWVkVG9Sb3RhdGVNYXJrZXIpKSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bW90aW9uTWFya2VyT25MaW5lID0gK25lZWRUb1JvdGF0ZU1hcmtlcjtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWNvbi5zdHlsZS50cmFuc2Zvcm0gPSBcXFwicm90YXRlKC1cXFwiICsgTWF0aC5yb3VuZChMLk1vdGlvbi5VdGlscy5nZXRBbmdsZShwcmV2UG9pbnQsIG5leHRQb2ludCkgKyBtb3Rpb25NYXJrZXJPbkxpbmUpICtcXFwiZGVnKVxcXCI7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdFxcdH0pO1xcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0bWFya2VyLnNldExhdExuZyhuZXh0UG9pbnQpO1xcclxcblxcdFxcdH1cXHJcXG5cXHR9LFxcclxcblxcclxcblxcdC8qKlxcclxcbiAgICAgICAgUmVtb3ZlcyBtYXJrZXIgZnJvbSB0aGUgbWFwXFxyXFxuICAgICovXFxyXFxuXFx0X3JlbW92ZU1hcmtlcjogZnVuY3Rpb24gKGFuaW1FbmRlZCkge1xcclxcblxcdFxcdGlmICh0aGlzLm1hcmtlck9wdGlvbnMgJiYgdGhpcy5fX21hcmtlcikge1xcclxcblxcdFxcdFxcdGlmICghYW5pbUVuZGVkIHx8IHRoaXMubWFya2VyT3B0aW9ucy5yZW1vdmVPbkVuZCkge1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9fbWFya2VyKTtcXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fVxcclxcblxcdH0sXFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuICAgICAgICBJbml0aWFsaXplIG1hcmtlciBmcm9tIG1hcmtlciBvcHRpb25zIGFuZCBhZGQgaXQgdG8gdGhlIG1hcCBpZiBuZWVkZWRcXHJcXG4gICAgKi9cXHJcXG5cXHRfaW5pdGlhbGl6ZU1hcmtlcjogZnVuY3Rpb24gKCkge1xcclxcblxcdFxcdGlmICh0aGlzLm1hcmtlck9wdGlvbnMpIHtcXHJcXG5cXHRcXHRcXHR0aGlzLl9fbWFya2VyID0gTC5tYXJrZXIodGhpcy5fbGluZVBvaW50c1swXSwgdGhpcy5tYXJrZXJPcHRpb25zKTtcXHJcXG5cXHRcXHR9XFxyXFxuXFx0fSxcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG4gICAgICAgIFN0YXJ0cyBhbmltYXRpb24gb2YgY3VycmVudCBvYmplY3RcXHJcXG4gICAgKi9cXHJcXG5cXHRtb3Rpb25TdGFydDogZnVuY3Rpb24gKCkge1xcclxcblxcdFxcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuYW5pbWF0aW9uKSB7XFxyXFxuXFx0XFx0XFx0aWYgKCF0aGlzLm1vdGlvbk9wdGlvbnMuZHVyYXRpb24pIHtcXHJcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5tb3Rpb25PcHRpb25zLnNwZWVkKSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tb3Rpb25PcHRpb25zLmR1cmF0aW9uID0gTC5Nb3Rpb24uVXRpbHMuZ2V0RHVyYXRpb24odGhpcy5fbWFwLCB0aGlzLl9saW5lUG9pbnRzLCB0aGlzLm1vdGlvbk9wdGlvbnMuc3BlZWQpO1xcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tb3Rpb25PcHRpb25zLmR1cmF0aW9uID0gMDtcXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdHRoaXMuc2V0TGF0TG5ncyhbXSk7XFxyXFxuXFx0ICAgICAgICB0aGlzLl9tb3Rpb24oKG5ldyBEYXRlKS5nZXRUaW1lKCkpO1xcclxcblxcdFxcdFxcdHRoaXMuZmlyZShMLk1vdGlvbi5FdmVudC5TdGFydGVkLCB7bGF5ZXI6IHRoaXN9LCBmYWxzZSk7XFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcbiAgICB9LFxcclxcblxcclxcblxcdC8qKlxcclxcbiAgICAgICAgU3RvcHMgYW5pbWF0aW9uIG9mIGN1cnJlbnQgb2JqZWN0XFxyXFxuICAgICAgICBAcGFyYW0ge0xhdExuZ1tdfSBwb2ludHMgZnVsbCBvYmplY3QgcG9pbnRzIGNvbGxlY3Rpb24gb3IgZW1wdHkgY29sbGVjdGlvbiBmb3IgY2xlYW51cFxcclxcbiAgICAqL1xcclxcbiAgICBtb3Rpb25TdG9wOiBmdW5jdGlvbiAoYW5pbUVuZGVkKSB7XFxyXFxuXFx0XFx0dGhpcy5tb3Rpb25QYXVzZSgpO1xcclxcblxcdFxcdHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9saW5lUG9pbnRzKTtcXHJcXG5cXHRcXHR0aGlzLl9fZWxsYXBzZWRUaW1lID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLl9yZW1vdmVNYXJrZXIoYW5pbUVuZGVkKTtcXHJcXG5cXHRcXHR0aGlzLmZpcmUoTC5Nb3Rpb24uRXZlbnQuRW5kZWQsIHtsYXllcjogdGhpc30sIGZhbHNlKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG4gICAgICAgIFBhdXNlcyBhbmltYXRpb24gb2YgY3VycmVudCBvYmplY3RcXHJcXG4gICAgKi9cXHJcXG5cXHRtb3Rpb25QYXVzZTogZnVuY3Rpb24gKCkge1xcclxcblxcdFxcdGlmICh0aGlzLmFuaW1hdGlvbikge1xcclxcblxcdFxcdFxcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5hbmltYXRpb24pO1xcclxcblxcdFxcdFxcdHRoaXMuYW5pbWF0aW9uID0gbnVsbDtcXHJcXG5cXHRcXHRcXHR0aGlzLmZpcmUoTC5Nb3Rpb24uRXZlbnQuUGF1c2VkLCB7bGF5ZXI6IHRoaXN9LCBmYWxzZSk7XFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcdH0sXFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuICAgICAgICBSZXN1bWUgYW5pbWF0aW9uIG9mIGN1cnJlbnQgb2JqZWN0XFxyXFxuICAgICovXFxyXFxuXFx0bW90aW9uUmVzdW1lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFx0XFx0aWYgKCF0aGlzLmFuaW1hdGlvbiAmJiB0aGlzLl9fZWxsYXBzZWRUaW1lKSB7XFxyXFxuXFx0XFx0XFx0aWYgKCF0aGlzLm1vdGlvbk9wdGlvbnMuZHVyYXRpb24pIHtcXHJcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5tb3Rpb25PcHRpb25zLnNwZWVkKSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tb3Rpb25PcHRpb25zLmR1cmF0aW9uID0gTC5Nb3Rpb24uVXRpbHMuZ2V0RHVyYXRpb24odGhpcy5fbWFwLCB0aGlzLl9saW5lUG9pbnRzLCB0aGlzLm1vdGlvbk9wdGlvbnMuc3BlZWQpO1xcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tb3Rpb25PcHRpb25zLmR1cmF0aW9uID0gMDtcXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdHRoaXMuX21vdGlvbigobmV3IERhdGUpLmdldFRpbWUoKSAtICh0aGlzLl9fZWxsYXBzZWRUaW1lKSk7XFxyXFxuXFx0XFx0XFx0dGhpcy5maXJlKEwuTW90aW9uLkV2ZW50LlJlc3VtZWQsIHtsYXllcjogdGhpc30sIGZhbHNlKTtcXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFx0fSxcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG4gICAgICAgIFRvZ2dsZXMgYW5pbWF0aW9uIG9mIGN1cnJlbnQgb2JqZWN0OyBTdGFydC9QYXVzZS9SZXN1bWU7XFxyXFxuICAgICovXFxyXFxuXFx0bW90aW9uVG9nZ2xlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFx0XFx0aWYgKHRoaXMuYW5pbWF0aW9uKSB7XFxyXFxuXFx0XFx0XFx0aWYgKHRoaXMuX19lbGxhcHNlZFRpbWUpIHtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm1vdGlvblBhdXNlKCk7XFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH0gZWxzZSB7XFxyXFxuXFx0XFx0XFx0aWYgKHRoaXMuX19lbGxhcHNlZFRpbWUpIHtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm1vdGlvblJlc3VtZSgpO1xcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5tb3Rpb25TdGFydCgpO1xcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFx0fSxcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHRcXHRTZXR1cCBtb3Rpb24gZHVyYXRpb24gYXQgYW55IHRpbWVcXHJcXG5cXHQqL1xcclxcblxcdG1vdGlvbkR1cmF0aW9uOiBmdW5jdGlvbiAoZHVyYXRpb24pIHtcXHJcXG5cXHRcXHR2YXIgcHJldkR1cmF0aW9uID0gdGhpcy5tb3Rpb25TcGVlZC5kdXJhdGlvbjtcXHJcXG5cXHRcXHR0aGlzLm1vdGlvbk9wdGlvbnMuZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwO1xcclxcblxcclxcblxcdFxcdGlmICh0aGlzLmFuaW1hdGlvbiAmJiBwcmV2RHVyYXRpb24pIHtcXHJcXG5cXHRcXHRcXHR0aGlzLm1vdGlvblBhdXNlKCk7XFxyXFxuXFx0XFx0ICAgIHRoaXMuX19lbGxhcHNlZFRpbWUgPSB0aGlzLl9fZWxsYXBzZWRUaW1lICogKHByZXZEdXJhdGlvbiAvIGR1cmF0aW9uKTtcXHJcXG5cXHRcXHQgICAgdGhpcy5tb3Rpb25PcHRpb25zLmR1cmF0aW9uID0gZHVyYXRpb247XFxyXFxuXFx0XFx0XFx0dGhpcy5tb3Rpb25SZXN1bWUoKTtcXHJcXG5cXHRcXHR9XFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFx0fSxcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHRcXHRTZXR1cCBtb3Rpb24gc3BlZWQgYXQgYW55IHRpbWVcXHJcXG5cXHQqL1xcclxcblxcdG1vdGlvblNwZWVkOiBmdW5jdGlvbiAoc3BlZWQpIHtcXHJcXG5cXHRcXHR2YXIgcHJldlNwZWVkID0gdGhpcy5tb3Rpb25PcHRpb25zLnNwZWVkO1xcclxcblxcdFxcdHRoaXMubW90aW9uT3B0aW9ucy5zcGVlZCA9IHNwZWVkIHx8IDA7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKHRoaXMuYW5pbWF0aW9uICYmIHByZXZTcGVlZCkge1xcclxcblxcdFxcdFxcdHRoaXMubW90aW9uUGF1c2UoKTtcXHJcXG5cXHRcXHQgICAgdGhpcy5fX2VsbGFwc2VkVGltZSA9IHRoaXMuX19lbGxhcHNlZFRpbWUgKiAocHJldlNwZWVkIC8gc3BlZWQpO1xcclxcblxcdFxcdCAgICB0aGlzLm1vdGlvbk9wdGlvbnMuZHVyYXRpb24gPSBMLk1vdGlvbi5VdGlscy5nZXREdXJhdGlvbih0aGlzLl9tYXAsIHRoaXMuX2xpbmVQb2ludHMsIHRoaXMubW90aW9uT3B0aW9ucy5zcGVlZCk7XFxyXFxuXFx0XFx0XFx0dGhpcy5tb3Rpb25SZXN1bWUoKTtcXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFx0fSxcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHRcXHRSZXR1cm5zIGN1cnJlbnQgY29uc3RydWN0ZWQgbWFya2VyXFxyXFxuXFx0Ki9cXHJcXG5cXHRnZXRNYXJrZXI6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHRcXHRyZXR1cm4gdGhpcy5fX21hcmtlcjtcXHJcXG5cXHR9LFxcclxcblxcclxcblxcdC8qKlxcclxcblxcdFxcdFJldHVybnMgbWFya2VycyBhcnJheSBmcm9tIGFsbCBpbm5lciBsYXllcnMgd2l0aG91dCBmbGF0dGVyaW5nLlxcclxcblxcdCovXFxyXFxuXFx0Z2V0TWFya2VyczogZnVuY3Rpb24gKCkge1xcclxcblxcdFxcdHJldHVybiBbdGhpcy5nZXRNYXJrZXIoKV07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvbGVhZmxldC5tb3Rpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sZWFmbGV0Lm1vdGlvbi51dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sZWFmbGV0Lm1vdGlvbi51dGlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiLyoqXFxyXFxuXFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXHJcXG5cXHRBdXRob3IgSWdvciBWbGFkeWthIDxpZ29yLnZsYWR5a2FAZ21haWwuY29tPiAoaHR0cHM6Ly9naXRodWIuY29tL0lnb3ItVmxhZHlrYS9sZWFmbGV0Lm1vdGlvbilcXHJcXG4qKi9cXHJcXG5cXHJcXG5MLk1vdGlvbi5VdGlscyA9IHtcXHJcXG5cXHQvKipcXHJcXG5cXHRcXHRBdHRhY2hlcyBkaXN0YW5jZXMgcHJlY2FsY3VsYXRlZCB0byBjdXJyZW50IHNldCBvZiBMYXRMbmdcXHJcXG5cXHRcXHRAcGFyYW0ge0wuTWFwfSBtYXAgTGVhZmxldCBtYXAgdG8gYmUgY2FsY3VsYXRlIGRpc3RhbmNlc1xcclxcblxcdFxcdEBwYXJhbSB7QXJyYXk8TC5MYXRMbmc+fEwuUG9seUxpbmV9IGxhdGxuZ3MgU2V0IG9mIGdlb2dyYXBoaWNhbCBwb2ludHNcXHJcXG5cXHRcXHRAcmV0dXJucyB7QXJyYXk8TC5MYXRMbmc+fEwuUG9seUxpbmV9IGxhdGxuZ3MgU2V0IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgd2l0aCBhdHRhY2hlZCBkaXN0YW5jZXNcXHJcXG5cXHQqL1xcclxcblxcdGF0dGFjaERpc3RhbmNlczogZnVuY3Rpb24obWFwLCBsYXRMbmdzKSB7XFxyXFxuXFx0XFx0aWYgKGxhdExuZ3MubGVuZ3RoID4gMSkge1xcclxcblxcdFxcdFxcdGZvciAodmFyIGkgPSAxOyBpIDwgbGF0TG5ncy5sZW5ndGg7IGkrKykge1xcclxcblxcdFxcdFxcdFxcdGxhdExuZ3NbaSAtIDFdLmRpc3RhbmNlVG9OZXh0UG9pbnQgPSBtYXAuZGlzdGFuY2UobGF0TG5nc1tpIC0gMV0sIGxhdExuZ3NbaV0pO1xcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGxhdExuZ3M7XFxyXFxuXFx0fSxcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHRcXHRSZXR1cm5zIHRoZSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBsb2NhdGVkIG9uIGEgbGluZSBhdCB0aGUgc3BlY2lmaWVkIHJhdGlvIG9mIHRoZSBsaW5lIGxlbmd0aC5cXHJcXG5cXHRcXHRAcGFyYW0ge0wuTWFwfSBtYXAgTGVhZmxldCBtYXAgdG8gYmUgdXNlZCBmb3IgdGhpcyBtZXRob2RcXHJcXG5cXHRcXHRAcGFyYW0ge0FycmF5PEwuTGF0TG5nPnxMLlBvbHlMaW5lfSBsYXRsbmdzIFNldCBvZiBnZW9ncmFwaGljYWwgcG9pbnRzXFxyXFxuXFx0XFx0QHBhcmFtIHtOdW1iZXJ9IHJhdGlvIHRoZSBsZW5ndGggcmF0aW8sIGV4cHJlc3NlZCBhcyBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxLCBpbmNsdXNpdmVcXHJcXG5cXHRcXHRAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBsYXRMbmcgKHtMYXRMbmd9KSBhbmQgcHJlZGVjZXNzb3IgKHtOdW1iZXJ9KSwgdGhlIGluZGV4IG9mIHRoZSBwcmVjZWRpbmcgdmVydGV4IGluIHRoZSBQb2x5bGluZVxcclxcblxcdFxcdCgtMSBpZiB0aGUgaW50ZXJwb2xhdGVkIHBvaW50IGlzIHRoZSBmaXJzdCB2ZXJ0ZXgpXFxyXFxuXFx0Ki9cXHJcXG5cXHRpbnRlcnBvbGF0ZU9uTGluZTogZnVuY3Rpb24gKG1hcCwgbGF0TG5ncywgcmF0aW8pIHtcXHJcXG5cXHRcXHRsYXRMbmdzID0gKGxhdExuZ3MgaW5zdGFuY2VvZiBMLlBvbHlsaW5lKSA/IGxhdExuZ3MuZ2V0TGF0TG5ncygpIDogbGF0TG5ncztcXHJcXG5cXHRcXHRpZiAobGF0TG5ncy5sZW5ndGggPCAyKSB7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHZhciBhbGxEaXN0YW5jZXNDYWxjdWxhdGVkID0gdHJ1ZTtcXHJcXG5cXHRcXHRmb3IgKHZhciBkID0gMDsgZCA8IGxhdExuZ3MubGVuZ3RoIC0gMTsgZCsrKSB7XFxyXFxuXFx0XFx0XFx0aWYgKCFsYXRMbmdzW2RdLmRpc3RhbmNlVG9OZXh0UG9pbnQpIHtcXHJcXG5cXHRcXHRcXHRcXHRhbGxEaXN0YW5jZXNDYWxjdWxhdGVkID0gZmFsc2U7XFxyXFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAoIWFsbERpc3RhbmNlc0NhbGN1bGF0ZWQpIHtcXHJcXG5cXHRcXHRcXHR0aGlzLmF0dGFjaERpc3RhbmNlcyhtYXAsIGxhdExuZ3MpO1xcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBlbnN1cmUgdGhlIHJhdGlvIGlzIGJldHdlZW4gMCBhbmQgMTtcXHJcXG5cXHRcXHRyYXRpbyA9IE1hdGgubWF4KE1hdGgubWluKHJhdGlvLCAxKSwgMCk7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKHJhdGlvID09PSAwKSB7XFxyXFxuXFx0XFx0XFx0dmFyIHNpbmdsZVBvaW50ID0gbGF0TG5nc1swXSBpbnN0YW5jZW9mIEwuTGF0TG5nID8gbGF0TG5nc1swXSA6IEwubGF0TG5nKGxhdExuZ3NbMF0pO1xcclxcblxcdFxcdFxcdHJldHVybiB7XFxyXFxuXFx0XFx0XFx0XFx0dHJhdmVsZWRQYXRoOiBbc2luZ2xlUG9pbnRdLFxcclxcblxcdFxcdFxcdFxcdGxhdExuZzogc2luZ2xlUG9pbnRcXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAocmF0aW8gPT0gMSkge1xcclxcblxcdFxcdFxcdHJldHVybiB7XFxyXFxuXFx0XFx0XFx0XFx0dHJhdmVsZWRQYXRoOiBsYXRMbmdzLFxcclxcblxcdFxcdFxcdFxcdGxhdExuZzogbGF0TG5nc1tsYXRMbmdzLmxlbmd0aCAtMV0gaW5zdGFuY2VvZiBMLkxhdExuZyA/IGxhdExuZ3NbbGF0TG5ncy5sZW5ndGggLTFdIDogTC5sYXRMbmcobGF0TG5nc1tsYXRMbmdzLmxlbmd0aCAtMV0pXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZ2V0IGZ1bGwgbGluZSBsZW5ndGggYmV0d2VlbiBwb2ludHNcXHJcXG5cXHRcXHR2YXIgZnVsbExlbmd0aCA9IDA7XFxyXFxuXFx0XFx0Zm9yICh2YXIgZEluZGV4ID0gMDsgZEluZGV4IDwgbGF0TG5ncy5sZW5ndGggLSAxOyBkSW5kZXgrKykge1xcclxcblxcdFxcdFxcdGZ1bGxMZW5ndGggKz0gbGF0TG5nc1tkSW5kZXhdLmRpc3RhbmNlVG9OZXh0UG9pbnQ7XFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIENhbGN1bGF0ZSBleHBlY3RlZCByYXRpb1xcclxcblxcdFxcdHZhciByYXRpb0Rpc3QgPSBmdWxsTGVuZ3RoICogcmF0aW87XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZm9sbG93IHRoZSBsaW5lIHNlZ21lbnRzIFthYl0sIGFkZGluZyBsZW5ndGhzLFxcclxcblxcdFxcdC8vIHVudGlsIHdlIGZpbmQgdGhlIHNlZ21lbnQgd2hlcmUgdGhlIHBvaW50cyBzaG91bGQgbGllIG9uXFxyXFxuXFx0XFx0dmFyIGN1bXVsYXRpdmVEaXN0YW5jZVRvQSA9IDAsIGN1bXVsYXRpdmVEaXN0YW5jZVRvQiA9IDA7XFxyXFxuXFx0XFx0Zm9yICh2YXIgaSA9IDA7IGN1bXVsYXRpdmVEaXN0YW5jZVRvQiA8IHJhdGlvRGlzdDsgaSsrKSB7XFxyXFxuXFx0XFx0XFx0dmFyIHBvaW50QSA9IGxhdExuZ3NbaV0sIHBvaW50QiA9IGxhdExuZ3NbaSsxXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjdW11bGF0aXZlRGlzdGFuY2VUb0EgPSBjdW11bGF0aXZlRGlzdGFuY2VUb0I7XFxyXFxuXFx0XFx0XFx0Y3VtdWxhdGl2ZURpc3RhbmNlVG9CICs9IHBvaW50QS5kaXN0YW5jZVRvTmV4dFBvaW50O1xcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAocG9pbnRBID09IHVuZGVmaW5lZCAmJiBwb2ludEIgPT0gdW5kZWZpbmVkKSB7IC8vIEhhcHBlbnMgd2hlbiBsaW5lIGhhcyBubyBsZW5ndGhcXHJcXG5cXHRcXHRcXHR2YXIgcG9pbnRBID0gbGF0TG5nc1swXSwgcG9pbnRCID0gbGF0TG5nc1sxXSwgaSA9IDE7XFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIGNvbXB1dGUgdGhlIHJhdGlvIHJlbGF0aXZlIHRvIHRoZSBzZWdtZW50IFthYl1cXHJcXG5cXHRcXHR2YXIgc2VnbWVudFJhdGlvID0gKChjdW11bGF0aXZlRGlzdGFuY2VUb0IgLSBjdW11bGF0aXZlRGlzdGFuY2VUb0EpICE9PSAwKSA/ICgocmF0aW9EaXN0IC0gY3VtdWxhdGl2ZURpc3RhbmNlVG9BKSAvIChjdW11bGF0aXZlRGlzdGFuY2VUb0IgLSBjdW11bGF0aXZlRGlzdGFuY2VUb0EpKSA6IDA7XFxyXFxuXFx0XFx0dmFyIGludGVycG9sYXRlZFBvaW50ID0gdGhpcy5pbnRlcnBvbGF0ZU9uTGF0TG5nU2VnbWVudChwb2ludEEsIHBvaW50Qiwgc2VnbWVudFJhdGlvKTtcXHJcXG5cXHRcXHR2YXIgdHJhdmVsZWRQYXRoID0gbGF0TG5ncy5zbGljZSgwLCBpKTtcXHJcXG5cXHRcXHR0cmF2ZWxlZFBhdGgucHVzaChpbnRlcnBvbGF0ZWRQb2ludCk7XFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHRcXHRcXHR0cmF2ZWxlZFBhdGg6IHRyYXZlbGVkUGF0aCxcXHJcXG5cXHRcXHRcXHRsYXRMbmc6IGludGVycG9sYXRlZFBvaW50XFxyXFxuXFx0XFx0fTtcXHJcXG5cXHR9LFxcclxcblxcclxcbiAgICAvKipcXHJcXG4gICAgICAgIFJldHVybnMgdGhlIFBvaW50IGxvY2F0ZWQgb24gYSBzZWdtZW50IGF0IHRoZSBzcGVjaWZpZWQgcmF0aW8gb2YgdGhlIHNlZ21lbnQgbGVuZ3RoLlxcclxcbiAgICAgICAgQHBhcmFtIHtMLlBvaW50fSBwQSBjb29yZGluYXRlcyBvZiBwb2ludCBBXFxyXFxuICAgICAgICBAcGFyYW0ge0wuUG9pbnR9IHBCIGNvb3JkaW5hdGVzIG9mIHBvaW50IEJcXHJcXG4gICAgICAgIEBwYXJhbSB7TnVtYmVyfSB0aGUgbGVuZ3RoIHJhdGlvLCBleHByZXNzZWQgYXMgYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSwgaW5jbHVzaXZlLlxcclxcbiAgICAgICAgQHJldHVybnMge0wuUG9pbnR9IHRoZSBpbnRlcnBvbGF0ZWQgcG9pbnQuXFxyXFxuICAgICovXFxyXFxuICAgIGludGVycG9sYXRlT25Qb2ludFNlZ21lbnQ6IGZ1bmN0aW9uIChwQSwgcEIsIHJhdGlvKSB7XFxyXFxuICAgICAgICByZXR1cm4gTC5wb2ludChcXHJcXG4gICAgICAgICAgICAocEEueCAqICgxIC0gcmF0aW8pKSArIChyYXRpbyAqIHBCLngpLFxcclxcbiAgICAgICAgICAgIChwQS55ICogKDEgLSByYXRpbykpICsgKHJhdGlvICogcEIueSlcXHJcXG4gICAgICAgICk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIC8qKlxcclxcbiAgICAgICAgUmV0dXJucyB0aGUgTGF0TG5nIGxvY2F0ZWQgb24gYSBzZWdtZW50IGF0IHRoZSBzcGVjaWZpZWQgcmF0aW8gb2YgdGhlIHNlZ21lbnQgbGVuZ3RoLlxcclxcbiAgICAgICAgQHBhcmFtIHtMLkxhdExuZ30gcEEgY29vcmRpbmF0ZXMgb2YgTGF0TG5nIEFcXHJcXG4gICAgICAgIEBwYXJhbSB7TC5MYXRMbmd9IHBCIGNvb3JkaW5hdGVzIG9mIExhdExuZyBCXFxyXFxuICAgICAgICBAcGFyYW0ge051bWJlcn0gdGhlIGxlbmd0aCByYXRpbywgZXhwcmVzc2VkIGFzIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDEsIGluY2x1c2l2ZS5cXHJcXG4gICAgICAgIEByZXR1cm5zIHtMLkxhdExuZ30gdGhlIGludGVycG9sYXRlZCBMYXRMbmcuXFxyXFxuICAgICovXFxyXFxuICAgIGludGVycG9sYXRlT25MYXRMbmdTZWdtZW50OiBmdW5jdGlvbiAocEEsIHBCLCByYXRpbykge1xcclxcbiAgICAgICAgcmV0dXJuIEwubGF0TG5nKFxcclxcbiAgICAgICAgICAgIChwQS5sYXQgKiAoMSAtIHJhdGlvKSkgKyAocmF0aW8gKiBwQi5sYXQpLFxcclxcbiAgICAgICAgICAgIChwQS5sbmcgKiAoMSAtIHJhdGlvKSkgKyAocmF0aW8gKiBwQi5sbmcpXFxyXFxuICAgICAgICApO1xcclxcbiAgICB9LFxcclxcblxcclxcblxcdC8qKlxcclxcblxcdFxcdEBwYXJhbSB7TC5NYXB9IG1hcCBMZWFmbGV0IG1hcCB0byBiZSBjYWxjdWxhdGUgZGlzdGFuY2VzXFxyXFxuICAgICAgICBAcGFyYW0ge0xhdExuZ1tdfSBsaW5lUG9pbnRzIG9mIGNvb3JkaW5hdGVzXFxyXFxuICAgICAgICBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlIGluIG1ldGVyXFxyXFxuICAgICovXFxyXFxuXFx0ZGlzdGFuY2U6IGZ1bmN0aW9uKG1hcCwgbGluZVBvaW50cyl7XFxyXFxuXFx0XFx0dmFyIGRpc3RhbmNlSW5NZXRlciA9IDA7XFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpbmVQb2ludHMubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgICAgICBkaXN0YW5jZUluTWV0ZXIgKz0gIG1hcC5kaXN0YW5jZShsaW5lUG9pbnRzW2ldLCBsaW5lUG9pbnRzW2kgLSAxXSk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICByZXR1cm4gZGlzdGFuY2VJbk1ldGVyO1xcclxcblxcdH0sXFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0XFx0QHBhcmFtIHtMLk1hcH0gbWFwIExlYWZsZXQgbWFwIHRvIGJlIGNhbGN1bGF0ZSBkaXN0YW5jZXNcXHJcXG4gICAgICAgIEBwYXJhbSB7TGF0TG5nW119IGNvbGxlY3Rpb24gb2YgY29vcmRpbmF0ZXNcXHJcXG4gICAgICAgIEBwYXJhbSB7TnVtYmVyfSBzcGVlZCBpbiBLTS9IXFxyXFxuICAgICAgICBAcmV0dXJuIHtOdW1iZXJ9IGR1cmF0aW9uIGluIG1zXFxyXFxuICAgICovXFxyXFxuXFx0Z2V0RHVyYXRpb246IGZ1bmN0aW9uIChtYXAsIGNvbGxlY3Rpb24sIHNwZWVkKSB7XFxyXFxuXFx0XFx0dmFyIGRpc3RhbmNlID0gTC5Nb3Rpb24uVXRpbHMuZGlzdGFuY2UobWFwLCBjb2xsZWN0aW9uLm1hcChmdW5jdGlvbihtKXsgcmV0dXJuIEwuTW90aW9uLlV0aWxzLnRvTGF0TG5nKG0pOyB9KSk7IC8vIGluIG1ldGVycztcXHJcXG5cXHRcXHRyZXR1cm4gZGlzdGFuY2UvKHNwZWVkLzM2MDApOyAvLyBtIC8gKGttL2ggKiAxMDAwID0+IG0vaCAvICg2MCAqIDYwKSkgPT4gbSAvIGsvcyAobS9zICogMTAwMCkgPT4gMTAwMCAqIG0gLyBtL3MgPT4gbXM7XFxyXFxuXFx0fSxcXHJcXG5cXHJcXG5cXHR0b0xhdExuZzogZnVuY3Rpb24oYSwgYiwgYykge1xcclxcblxcdFxcdGlmIChhIGluc3RhbmNlb2YgTC5MYXRMbmcpIHtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gYTtcXHJcXG5cXHRcXHR9XFxyXFxuXFx0XFx0aWYgKEwuVXRpbC5pc0FycmF5KGEpICYmIHR5cGVvZiBhWzBdICE9PSAnb2JqZWN0Jykge1xcclxcblxcdFxcdFxcdGlmIChhLmxlbmd0aCA9PT0gMykge1xcclxcblxcdFxcdFxcdFxcdHJldHVybiBMLmxhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIEwubGF0TG5nKGFbMF0sIGFbMV0pO1xcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbnVsbDtcXHJcXG5cXHRcXHR9XFxyXFxuXFx0XFx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIGE7XFxyXFxuXFx0XFx0fVxcclxcblxcdFxcdGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ2xhdCcgaW4gYSkge1xcclxcblxcdFxcdFxcdHJldHVybiBMLmxhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcXHJcXG5cXHRcXHR9XFxyXFxuXFx0XFx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xcclxcblxcdFxcdFxcdHJldHVybiBudWxsO1xcclxcblxcdFxcdH1cXHJcXG5cXHRcXHRyZXR1cm4gTC5sYXRMbmcoYSwgYiwgYyk7XFxyXFxuXFx0fSxcXHJcXG5cXHJcXG5cXHRnZXRBbmdsZTogZnVuY3Rpb24ocHJldlBvaW50LCBuZXh0UG9pbnQpIHtcXHJcXG5cXHRcXHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5leHRQb2ludC5sYXQgLSBwcmV2UG9pbnQubGF0LCBuZXh0UG9pbnQubG5nIC0gcHJldlBvaW50LmxuZykgKiAxODAgLyBNYXRoLlBJO1xcclxcblxcdFxcdGlmIChhbmdsZSA8IDApIHtcXHJcXG5cXHRcXHRcXHRhbmdsZSArPSAzNjA7XFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiBhbmdsZTtcXHJcXG5cXHR9LFxcclxcblxcclxcblxcdC8vIExlYWZsZXQgLT4gZ2VvbWV0cmllcyAtPiBMaW5lVXRpbFxcclxcblxcdGlzRmxhdDogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcXHJcXG5cXHRcXHRyZXR1cm4gIUwuVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pIHx8ICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICd1bmRlZmluZWQnKTtcXHJcXG5cXHR9XFxyXFxufTtcXHJcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvbGVhZmxldC5tb3Rpb24udXRpbHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMDpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIG11bHRpIC4vc3JjL2xlYWZsZXQubW90aW9uLmpzIC4vc3JjL2xlYWZsZXQubW90aW9uLnV0aWxzLmpzIC4vc3JjL2xlYWZsZXQubW90aW9uLmVhc2luZy5qcyAuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5wb2x5bGluZS5qcyAuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5wb2x5Z29uLmpzIC4vc3JjL2xheWVyL2xlYWZsZXQubW90aW9uLmdyb3VwLmpzIC4vc3JjL2xheWVyL2xlYWZsZXQubW90aW9uLnNlcS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2xlYWZsZXQubW90aW9uLmpzICovXFxcIi4vc3JjL2xlYWZsZXQubW90aW9uLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvbGVhZmxldC5tb3Rpb24udXRpbHMuanMgKi9cXFwiLi9zcmMvbGVhZmxldC5tb3Rpb24udXRpbHMuanNcXFwiKTtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9sZWFmbGV0Lm1vdGlvbi5lYXNpbmcuanMgKi9cXFwiLi9zcmMvbGVhZmxldC5tb3Rpb24uZWFzaW5nLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvbGF5ZXIvbGVhZmxldC5tb3Rpb24ucG9seWxpbmUuanMgKi9cXFwiLi9zcmMvbGF5ZXIvbGVhZmxldC5tb3Rpb24ucG9seWxpbmUuanNcXFwiKTtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5wb2x5Z29uLmpzICovXFxcIi4vc3JjL2xheWVyL2xlYWZsZXQubW90aW9uLnBvbHlnb24uanNcXFwiKTtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5ncm91cC5qcyAqL1xcXCIuL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5ncm91cC5qc1xcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvbGF5ZXIvbGVhZmxldC5tb3Rpb24uc2VxLmpzICovXFxcIi4vc3JjL2xheWVyL2xlYWZsZXQubW90aW9uLnNlcS5qc1xcXCIpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy9tdWx0aV8uL3NyYy9sZWFmbGV0Lm1vdGlvbi5qc18uL3NyYy9sZWFmbGV0Lm1vdGlvbi51dGlscy5qc18uL3NyYy9sZWFmbGV0Lm1vdGlvbi5lYXNpbmcuanNfLi9zcmMvbGF5ZXIvbGVhZmxldC5tb3Rpb24ucG9seWxpbmUuanNfLi9zcmMvbGF5ZXIvbGVhZmxldC5tb3Rpb24ucG9seWdvbi5qc18uL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5ncm91cC5qc18uL3NyYy9sYXllci9sZWFmbGV0Lm1vdGlvbi5zZXEuanM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4138\n')},4362:function(module,exports,__webpack_require__){eval("exports.nextTick = function nextTick(fn) {\n    var args = Array.prototype.slice.call(arguments);\n    args.shift();\n    setTimeout(function () {\n        fn.apply(null, args);\n    }, 0);\n};\n\nexports.platform = exports.arch = \nexports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n\tthrow new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    exports.cwd = function () { return cwd };\n    exports.chdir = function (dir) {\n        if (!path) path = __webpack_require__(\"df7c\");\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\nexports.exit = exports.kill = \nexports.umask = exports.dlopen = \nexports.uptime = exports.memoryUsage = \nexports.uvCounters = function() {};\nexports.features = {};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbW9jay9wcm9jZXNzLmpzPzQzNjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLE1BQU07QUFDeEM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0MzYyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5uZXh0VGljayA9IGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGFyZ3Muc2hpZnQoKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgMCk7XG59O1xuXG5leHBvcnRzLnBsYXRmb3JtID0gZXhwb3J0cy5hcmNoID0gXG5leHBvcnRzLmV4ZWNQYXRoID0gZXhwb3J0cy50aXRsZSA9ICdicm93c2VyJztcbmV4cG9ydHMucGlkID0gMTtcbmV4cG9ydHMuYnJvd3NlciA9IHRydWU7XG5leHBvcnRzLmVudiA9IHt9O1xuZXhwb3J0cy5hcmd2ID0gW107XG5cbmV4cG9ydHMuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBtb2R1bGUuIChQb3NzaWJseSBub3QgeWV0IGxvYWRlZCknKVxufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3dkID0gJy8nO1xuICAgIHZhciBwYXRoO1xuICAgIGV4cG9ydHMuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY3dkIH07XG4gICAgZXhwb3J0cy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgaWYgKCFwYXRoKSBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuICAgICAgICBjd2QgPSBwYXRoLnJlc29sdmUoZGlyLCBjd2QpO1xuICAgIH07XG59KSgpO1xuXG5leHBvcnRzLmV4aXQgPSBleHBvcnRzLmtpbGwgPSBcbmV4cG9ydHMudW1hc2sgPSBleHBvcnRzLmRsb3BlbiA9IFxuZXhwb3J0cy51cHRpbWUgPSBleHBvcnRzLm1lbW9yeVVzYWdlID0gXG5leHBvcnRzLnV2Q291bnRlcnMgPSBmdW5jdGlvbigpIHt9O1xuZXhwb3J0cy5mZWF0dXJlcyA9IHt9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4362\n")},"56d7":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.runtime.esm.js\nvar vue_runtime_esm = __webpack_require__("2b0e");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5f48ba14-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=template&id=f8a82e40&scoped=true&\nvar Appvue_type_template_id_f8a82e40_scoped_true_render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\'div\', {\n    attrs: {\n      "id": "app"\n    }\n  }, [_c(\'Home\')], 1);\n};\n\nvar staticRenderFns = [];\n\n// CONCATENATED MODULE: ./src/App.vue?vue&type=template&id=f8a82e40&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5f48ba14-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/index.vue?vue&type=template&id=23ec8df8&scoped=true&\nvar viewsvue_type_template_id_23ec8df8_scoped_true_render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\'div\', {\n    staticClass: "home-container"\n  }, [_c(\'WMap\', {\n    on: {\n      "mapComplete": _vm.mapComplete\n    }\n  }, [_c(\'WDrawTool\', {\n    attrs: {\n      "map": _vm.map\n    }\n  })], 1), _c(\'WTable\', {\n    attrs: {\n      "tableList": _vm.tableList,\n      "loading": _vm.loading,\n      "params": _vm.params\n    },\n    on: {\n      "currentChange": _vm.currentChange,\n      "rowClick": _vm.rowClick\n    }\n  }), _c(\'WVector\'), _c(\'WHuge\'), _c(\'WAvoid\')], 1);\n};\n\nvar viewsvue_type_template_id_23ec8df8_scoped_true_staticRenderFns = [];\n\n// CONCATENATED MODULE: ./src/views/index.vue?vue&type=template&id=23ec8df8&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5f48ba14-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/wleaflet/ui/Map/index.vue?vue&type=template&id=fad4bd8e&scoped=true&\nvar Mapvue_type_template_id_fad4bd8e_scoped_true_render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\'div\', {\n    "class": [\'wcx-map-container\', _vm.customClass],\n    attrs: {\n      "id": _vm.el\n    }\n  }, [_vm.map ? [_vm._t("default", null, {\n    "map": _vm.map\n  })] : _vm._e()], 2);\n};\n\nvar Mapvue_type_template_id_fad4bd8e_scoped_true_staticRenderFns = [];\n\n// CONCATENATED MODULE: ./src/wleaflet/ui/Map/index.vue?vue&type=template&id=fad4bd8e&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n// EXTERNAL MODULE: ./node_modules/leaflet/dist/leaflet-src.js\nvar leaflet_src = __webpack_require__("e11e");\nvar leaflet_src_default = /*#__PURE__*/__webpack_require__.n(leaflet_src);\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/global.js\n/* harmony default export */ var global = (function(defs) {\n  defs(\'EPSG:4326\', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");\n  defs(\'EPSG:4269\', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");\n  defs(\'EPSG:3857\', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");\n\n  defs.WGS84 = defs[\'EPSG:4326\'];\n  defs[\'EPSG:3785\'] = defs[\'EPSG:3857\']; // maintain backward compat, official code is 3857\n  defs.GOOGLE = defs[\'EPSG:3857\'];\n  defs[\'EPSG:900913\'] = defs[\'EPSG:3857\'];\n  defs[\'EPSG:102113\'] = defs[\'EPSG:3857\'];\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/values.js\nvar PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar PJD_GRIDSHIFT = 3;\nvar PJD_WGS84 = 4; // WGS84 or equivalent\nvar PJD_NODATUM = 5; // WGS84 or equivalent\nvar SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms\nvar SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms\nvar SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms\nvar SEC_TO_RAD = 4.84813681109535993589914102357e-6;\nvar HALF_PI = Math.PI/2;\n// ellipoid pj_set_ell.c\nvar SIXTH = 0.1666666666666666667;\n/* 1/6 */\nvar RA4 = 0.04722222222222222222;\n/* 17/360 */\nvar RA6 = 0.02215608465608465608;\nvar EPSLN = 1.0e-10;\n// you\'d think you could use Number.EPSILON above but that makes\n// Mollweide get into an infinate loop.\n\nvar D2R = 0.01745329251994329577;\nvar R2D = 57.29577951308232088;\nvar FORTPI = Math.PI/4;\nvar TWO_PI = Math.PI * 2;\n// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don\'t get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\nvar SPI = 3.14159265359;\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/PrimeMeridian.js\nvar PrimeMeridian_exports = {};\n\n\nPrimeMeridian_exports.greenwich = 0.0; //"0dE",\nPrimeMeridian_exports.lisbon = -9.131906111111; //"9d07\'54.862\\"W",\nPrimeMeridian_exports.paris = 2.337229166667; //"2d20\'14.025\\"E",\nPrimeMeridian_exports.bogota = -74.080916666667; //"74d04\'51.3\\"W",\nPrimeMeridian_exports.madrid = -3.687938888889; //"3d41\'16.58\\"W",\nPrimeMeridian_exports.rome = 12.452333333333; //"12d27\'8.4\\"E",\nPrimeMeridian_exports.bern = 7.439583333333; //"7d26\'22.5\\"E",\nPrimeMeridian_exports.jakarta = 106.807719444444; //"106d48\'27.79\\"E",\nPrimeMeridian_exports.ferro = -17.666666666667; //"17d40\'W",\nPrimeMeridian_exports.brussels = 4.367975; //"4d22\'4.71\\"E",\nPrimeMeridian_exports.stockholm = 18.058277777778; //"18d3\'29.8\\"E",\nPrimeMeridian_exports.athens = 23.7163375; //"23d42\'58.815\\"E",\nPrimeMeridian_exports.oslo = 10.722916666667; //"10d43\'22.5\\"E"\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/units.js\n/* harmony default export */ var units = ({\n  ft: {to_meter: 0.3048},\n  \'us-ft\': {to_meter: 1200 / 3937}\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/match.js\nvar ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nfunction match(obj, key) {\n  if (obj[key]) {\n    return obj[key];\n  }\n  var keys = Object.keys(obj);\n  var lkey = key.toLowerCase().replace(ignoredChar, \'\');\n  var i = -1;\n  var testkey, processedKey;\n  while (++i < keys.length) {\n    testkey = keys[i];\n    processedKey = testkey.toLowerCase().replace(ignoredChar, \'\');\n    if (processedKey === lkey) {\n      return obj[testkey];\n    }\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projString.js\n\n\n\n\n\n/* harmony default export */ var projString = (function(defData) {\n  var self = {};\n  var paramObj = defData.split(\'+\').map(function(v) {\n    return v.trim();\n  }).filter(function(a) {\n    return a;\n  }).reduce(function(p, a) {\n    var split = a.split(\'=\');\n    split.push(true);\n    p[split[0].toLowerCase()] = split[1];\n    return p;\n  }, {});\n  var paramName, paramVal, paramOutname;\n  var params = {\n    proj: \'projName\',\n    datum: \'datumCode\',\n    rf: function(v) {\n      self.rf = parseFloat(v);\n    },\n    lat_0: function(v) {\n      self.lat0 = v * D2R;\n    },\n    lat_1: function(v) {\n      self.lat1 = v * D2R;\n    },\n    lat_2: function(v) {\n      self.lat2 = v * D2R;\n    },\n    lat_ts: function(v) {\n      self.lat_ts = v * D2R;\n    },\n    lon_0: function(v) {\n      self.long0 = v * D2R;\n    },\n    lon_1: function(v) {\n      self.long1 = v * D2R;\n    },\n    lon_2: function(v) {\n      self.long2 = v * D2R;\n    },\n    alpha: function(v) {\n      self.alpha = parseFloat(v) * D2R;\n    },\n    gamma: function(v) {\n      self.rectified_grid_angle = parseFloat(v);\n    },\n    lonc: function(v) {\n      self.longc = v * D2R;\n    },\n    x_0: function(v) {\n      self.x0 = parseFloat(v);\n    },\n    y_0: function(v) {\n      self.y0 = parseFloat(v);\n    },\n    k_0: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    k: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    a: function(v) {\n      self.a = parseFloat(v);\n    },\n    b: function(v) {\n      self.b = parseFloat(v);\n    },\n    r_a: function() {\n      self.R_A = true;\n    },\n    zone: function(v) {\n      self.zone = parseInt(v, 10);\n    },\n    south: function() {\n      self.utmSouth = true;\n    },\n    towgs84: function(v) {\n      self.datum_params = v.split(",").map(function(a) {\n        return parseFloat(a);\n      });\n    },\n    to_meter: function(v) {\n      self.to_meter = parseFloat(v);\n    },\n    units: function(v) {\n      self.units = v;\n      var unit = match(units, v);\n      if (unit) {\n        self.to_meter = unit.to_meter;\n      }\n    },\n    from_greenwich: function(v) {\n      self.from_greenwich = v * D2R;\n    },\n    pm: function(v) {\n      var pm = match(PrimeMeridian_exports, v);\n      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;\n    },\n    nadgrids: function(v) {\n      if (v === \'@null\') {\n        self.datumCode = \'none\';\n      }\n      else {\n        self.nadgrids = v;\n      }\n    },\n    axis: function(v) {\n      var legalAxis = "ewnsud";\n      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n        self.axis = v;\n      }\n    },\n    approx: function() {\n      self.approx = true;\n    }\n  };\n  for (paramName in paramObj) {\n    paramVal = paramObj[paramName];\n    if (paramName in params) {\n      paramOutname = params[paramName];\n      if (typeof paramOutname === \'function\') {\n        paramOutname(paramVal);\n      }\n      else {\n        self[paramOutname] = paramVal;\n      }\n    }\n    else {\n      self[paramName] = paramVal;\n    }\n  }\n  if(typeof self.datumCode === \'string\' && self.datumCode !== "WGS84"){\n    self.datumCode = self.datumCode.toLowerCase();\n  }\n  return self;\n});\n\n// CONCATENATED MODULE: ./node_modules/wkt-parser/parser.js\n/* harmony default export */ var parser = (parseString);\n\nvar NEUTRAL = 1;\nvar KEYWORD = 2;\nvar NUMBER = 3;\nvar QUOTED = 4;\nvar AFTERQUOTE = 5;\nvar ENDED = -1;\nvar whitespace = /\\s/;\nvar latin = /[A-Za-z]/;\nvar keyword = /[A-Za-z84_]/;\nvar endThings = /[,\\]]/;\nvar digets = /[\\d\\.E\\-\\+]/;\n// const ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nfunction Parser(text) {\n  if (typeof text !== \'string\') {\n    throw new Error(\'not a string\');\n  }\n  this.text = text.trim();\n  this.level = 0;\n  this.place = 0;\n  this.root = null;\n  this.stack = [];\n  this.currentObject = null;\n  this.state = NEUTRAL;\n}\nParser.prototype.readCharicter = function() {\n  var char = this.text[this.place++];\n  if (this.state !== QUOTED) {\n    while (whitespace.test(char)) {\n      if (this.place >= this.text.length) {\n        return;\n      }\n      char = this.text[this.place++];\n    }\n  }\n  switch (this.state) {\n    case NEUTRAL:\n      return this.neutral(char);\n    case KEYWORD:\n      return this.keyword(char)\n    case QUOTED:\n      return this.quoted(char);\n    case AFTERQUOTE:\n      return this.afterquote(char);\n    case NUMBER:\n      return this.number(char);\n    case ENDED:\n      return;\n  }\n};\nParser.prototype.afterquote = function(char) {\n  if (char === \'"\') {\n    this.word += \'"\';\n    this.state = QUOTED;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = this.word.trim();\n    this.afterItem(char);\n    return;\n  }\n  throw new Error(\'havn\\\'t handled "\' +char + \'" in afterquote yet, index \' + this.place);\n};\nParser.prototype.afterItem = function(char) {\n  if (char === \',\') {\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n    }\n    this.word = null;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (char === \']\') {\n    this.level--;\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n      this.word = null;\n    }\n    this.state = NEUTRAL;\n    this.currentObject = this.stack.pop();\n    if (!this.currentObject) {\n      this.state = ENDED;\n    }\n\n    return;\n  }\n};\nParser.prototype.number = function(char) {\n  if (digets.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = parseFloat(this.word);\n    this.afterItem(char);\n    return;\n  }\n  throw new Error(\'havn\\\'t handled "\' +char + \'" in number yet, index \' + this.place);\n};\nParser.prototype.quoted = function(char) {\n  if (char === \'"\') {\n    this.state = AFTERQUOTE;\n    return;\n  }\n  this.word += char;\n  return;\n};\nParser.prototype.keyword = function(char) {\n  if (keyword.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (char === \'[\') {\n    var newObjects = [];\n    newObjects.push(this.word);\n    this.level++;\n    if (this.root === null) {\n      this.root = newObjects;\n    } else {\n      this.currentObject.push(newObjects);\n    }\n    this.stack.push(this.currentObject);\n    this.currentObject = newObjects;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error(\'havn\\\'t handled "\' +char + \'" in keyword yet, index \' + this.place);\n};\nParser.prototype.neutral = function(char) {\n  if (latin.test(char)) {\n    this.word = char;\n    this.state = KEYWORD;\n    return;\n  }\n  if (char === \'"\') {\n    this.word = \'\';\n    this.state = QUOTED;\n    return;\n  }\n  if (digets.test(char)) {\n    this.word = char;\n    this.state = NUMBER;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error(\'havn\\\'t handled "\' +char + \'" in neutral yet, index \' + this.place);\n};\nParser.prototype.output = function() {\n  while (this.place < this.text.length) {\n    this.readCharicter();\n  }\n  if (this.state === ENDED) {\n    return this.root;\n  }\n  throw new Error(\'unable to parse string "\' +this.text + \'". State is \' + this.state);\n};\n\nfunction parseString(txt) {\n  var parser = new Parser(txt);\n  return parser.output();\n}\n\n// CONCATENATED MODULE: ./node_modules/wkt-parser/process.js\n\n\nfunction mapit(obj, key, value) {\n  if (Array.isArray(key)) {\n    value.unshift(key);\n    key = null;\n  }\n  var thing = key ? {} : obj;\n\n  var out = value.reduce(function(newObj, item) {\n    sExpr(item, newObj);\n    return newObj\n  }, thing);\n  if (key) {\n    obj[key] = out;\n  }\n}\n\nfunction sExpr(v, obj) {\n  if (!Array.isArray(v)) {\n    obj[v] = true;\n    return;\n  }\n  var key = v.shift();\n  if (key === \'PARAMETER\') {\n    key = v.shift();\n  }\n  if (v.length === 1) {\n    if (Array.isArray(v[0])) {\n      obj[key] = {};\n      sExpr(v[0], obj[key]);\n      return;\n    }\n    obj[key] = v[0];\n    return;\n  }\n  if (!v.length) {\n    obj[key] = true;\n    return;\n  }\n  if (key === \'TOWGS84\') {\n    obj[key] = v;\n    return;\n  }\n  if (key === \'AXIS\') {\n    if (!(key in obj)) {\n      obj[key] = [];\n    }\n    obj[key].push(v);\n    return;\n  }\n  if (!Array.isArray(key)) {\n    obj[key] = {};\n  }\n\n  var i;\n  switch (key) {\n    case \'UNIT\':\n    case \'PRIMEM\':\n    case \'VERT_DATUM\':\n      obj[key] = {\n        name: v[0].toLowerCase(),\n        convert: v[1]\n      };\n      if (v.length === 3) {\n        sExpr(v[2], obj[key]);\n      }\n      return;\n    case \'SPHEROID\':\n    case \'ELLIPSOID\':\n      obj[key] = {\n        name: v[0],\n        a: v[1],\n        rf: v[2]\n      };\n      if (v.length === 4) {\n        sExpr(v[3], obj[key]);\n      }\n      return;\n    case \'PROJECTEDCRS\':\n    case \'PROJCRS\':\n    case \'GEOGCS\':\n    case \'GEOCCS\':\n    case \'PROJCS\':\n    case \'LOCAL_CS\':\n    case \'GEODCRS\':\n    case \'GEODETICCRS\':\n    case \'GEODETICDATUM\':\n    case \'EDATUM\':\n    case \'ENGINEERINGDATUM\':\n    case \'VERT_CS\':\n    case \'VERTCRS\':\n    case \'VERTICALCRS\':\n    case \'COMPD_CS\':\n    case \'COMPOUNDCRS\':\n    case \'ENGINEERINGCRS\':\n    case \'ENGCRS\':\n    case \'FITTED_CS\':\n    case \'LOCAL_DATUM\':\n    case \'DATUM\':\n      v[0] = [\'name\', v[0]];\n      mapit(obj, key, v);\n      return;\n    default:\n      i = -1;\n      while (++i < v.length) {\n        if (!Array.isArray(v[i])) {\n          return sExpr(v, obj[key]);\n        }\n      }\n      return mapit(obj, key, v);\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/wkt-parser/index.js\nvar wkt_parser_D2R = 0.01745329251994329577;\n\n\n\n\n\nfunction rename(obj, params) {\n  var outName = params[0];\n  var inName = params[1];\n  if (!(outName in obj) && (inName in obj)) {\n    obj[outName] = obj[inName];\n    if (params.length === 3) {\n      obj[outName] = params[2](obj[outName]);\n    }\n  }\n}\n\nfunction d2r(input) {\n  return input * wkt_parser_D2R;\n}\n\nfunction cleanWKT(wkt) {\n  if (wkt.type === \'GEOGCS\') {\n    wkt.projName = \'longlat\';\n  } else if (wkt.type === \'LOCAL_CS\') {\n    wkt.projName = \'identity\';\n    wkt.local = true;\n  } else {\n    if (typeof wkt.PROJECTION === \'object\') {\n      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n    } else {\n      wkt.projName = wkt.PROJECTION;\n    }\n  }\n  if (wkt.AXIS) {\n    var axisOrder = \'\';\n    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {\n      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];\n      if (axis[0].indexOf(\'north\') !== -1 || ((axis[0] === \'y\' || axis[0] === \'lat\') && axis[1] === \'north\')) {\n        axisOrder += \'n\';\n      } else if (axis[0].indexOf(\'south\') !== -1 || ((axis[0] === \'y\' || axis[0] === \'lat\') && axis[1] === \'south\')) {\n        axisOrder += \'s\';\n      } else if (axis[0].indexOf(\'east\') !== -1 || ((axis[0] === \'x\' || axis[0] === \'lon\') && axis[1] === \'east\')) {\n        axisOrder += \'e\';\n      } else if (axis[0].indexOf(\'west\') !== -1 || ((axis[0] === \'x\' || axis[0] === \'lon\') && axis[1] === \'west\')) {\n        axisOrder += \'w\';\n      }\n    }\n    if (axisOrder.length === 2) {\n      axisOrder += \'u\';\n    }\n    if (axisOrder.length === 3) {\n      wkt.axis = axisOrder;\n    }\n  }\n  if (wkt.UNIT) {\n    wkt.units = wkt.UNIT.name.toLowerCase();\n    if (wkt.units === \'metre\') {\n      wkt.units = \'meter\';\n    }\n    if (wkt.UNIT.convert) {\n      if (wkt.type === \'GEOGCS\') {\n        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt.to_meter = wkt.UNIT.convert;\n      }\n    }\n  }\n  var geogcs = wkt.GEOGCS;\n  if (wkt.type === \'GEOGCS\') {\n    geogcs = wkt;\n  }\n  if (geogcs) {\n    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n    //}\n    if (geogcs.DATUM) {\n      wkt.datumCode = geogcs.DATUM.name.toLowerCase();\n    } else {\n      wkt.datumCode = geogcs.name.toLowerCase();\n    }\n    if (wkt.datumCode.slice(0, 2) === \'d_\') {\n      wkt.datumCode = wkt.datumCode.slice(2);\n    }\n    if (wkt.datumCode === \'new_zealand_geodetic_datum_1949\' || wkt.datumCode === \'new_zealand_1949\') {\n      wkt.datumCode = \'nzgd49\';\n    }\n    if (wkt.datumCode === \'wgs_1984\' || wkt.datumCode === \'world_geodetic_system_1984\') {\n      if (wkt.PROJECTION === \'Mercator_Auxiliary_Sphere\') {\n        wkt.sphere = true;\n      }\n      wkt.datumCode = \'wgs84\';\n    }\n    if (wkt.datumCode.slice(-6) === \'_ferro\') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n    }\n    if (wkt.datumCode.slice(-8) === \'_jakarta\') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n    }\n    if (~wkt.datumCode.indexOf(\'belge\')) {\n      wkt.datumCode = \'rnb72\';\n    }\n    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {\n      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace(\'_19\', \'\').replace(/[Cc]larke\\_18/, \'clrk\');\n      if (wkt.ellps.toLowerCase().slice(0, 13) === \'international\') {\n        wkt.ellps = \'intl\';\n      }\n\n      wkt.a = geogcs.DATUM.SPHEROID.a;\n      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);\n    }\n\n    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {\n      wkt.datum_params = geogcs.DATUM.TOWGS84;\n    }\n    if (~wkt.datumCode.indexOf(\'osgb_1936\')) {\n      wkt.datumCode = \'osgb36\';\n    }\n    if (~wkt.datumCode.indexOf(\'osni_1952\')) {\n      wkt.datumCode = \'osni52\';\n    }\n    if (~wkt.datumCode.indexOf(\'tm65\')\n      || ~wkt.datumCode.indexOf(\'geodetic_datum_of_1965\')) {\n      wkt.datumCode = \'ire65\';\n    }\n    if (wkt.datumCode === \'ch1903+\') {\n      wkt.datumCode = \'ch1903\';\n    }\n    if (~wkt.datumCode.indexOf(\'israel\')) {\n      wkt.datumCode = \'isr93\';\n    }\n  }\n  if (wkt.b && !isFinite(wkt.b)) {\n    wkt.b = wkt.a;\n  }\n\n  function toMeter(input) {\n    var ratio = wkt.to_meter || 1;\n    return input * ratio;\n  }\n  var renamer = function(a) {\n    return rename(wkt, a);\n  };\n  var list = [\n    [\'standard_parallel_1\', \'Standard_Parallel_1\'],\n    [\'standard_parallel_1\', \'Latitude of 1st standard parallel\'],\n    [\'standard_parallel_2\', \'Standard_Parallel_2\'],\n    [\'standard_parallel_2\', \'Latitude of 2nd standard parallel\'],\n    [\'false_easting\', \'False_Easting\'],\n    [\'false_easting\', \'False easting\'],\n    [\'false-easting\', \'Easting at false origin\'],\n    [\'false_northing\', \'False_Northing\'],\n    [\'false_northing\', \'False northing\'],\n    [\'false_northing\', \'Northing at false origin\'],\n    [\'central_meridian\', \'Central_Meridian\'],\n    [\'central_meridian\', \'Longitude of natural origin\'],\n    [\'central_meridian\', \'Longitude of false origin\'],\n    [\'latitude_of_origin\', \'Latitude_Of_Origin\'],\n    [\'latitude_of_origin\', \'Central_Parallel\'],\n    [\'latitude_of_origin\', \'Latitude of natural origin\'],\n    [\'latitude_of_origin\', \'Latitude of false origin\'],\n    [\'scale_factor\', \'Scale_Factor\'],\n    [\'k0\', \'scale_factor\'],\n    [\'latitude_of_center\', \'Latitude_Of_Center\'],\n    [\'latitude_of_center\', \'Latitude_of_center\'],\n    [\'lat0\', \'latitude_of_center\', d2r],\n    [\'longitude_of_center\', \'Longitude_Of_Center\'],\n    [\'longitude_of_center\', \'Longitude_of_center\'],\n    [\'longc\', \'longitude_of_center\', d2r],\n    [\'x0\', \'false_easting\', toMeter],\n    [\'y0\', \'false_northing\', toMeter],\n    [\'long0\', \'central_meridian\', d2r],\n    [\'lat0\', \'latitude_of_origin\', d2r],\n    [\'lat0\', \'standard_parallel_1\', d2r],\n    [\'lat1\', \'standard_parallel_1\', d2r],\n    [\'lat2\', \'standard_parallel_2\', d2r],\n    [\'azimuth\', \'Azimuth\'],\n    [\'alpha\', \'azimuth\', d2r],\n    [\'srsCode\', \'name\']\n  ];\n  list.forEach(renamer);\n  if (!wkt.long0 && wkt.longc && (wkt.projName === \'Albers_Conic_Equal_Area\' || wkt.projName === \'Lambert_Azimuthal_Equal_Area\')) {\n    wkt.long0 = wkt.longc;\n  }\n  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === \'Stereographic_South_Pole\' || wkt.projName === \'Polar Stereographic (variant B)\')) {\n    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n    wkt.lat_ts = wkt.lat1;\n  }\n}\n/* harmony default export */ var wkt_parser = (function(wkt) {\n  var lisp = parser(wkt);\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift([\'name\', name]);\n  lisp.unshift([\'type\', type]);\n  var obj = {};\n  sExpr(lisp, obj);\n  cleanWKT(obj);\n  return obj;\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/defs.js\n\n\n\n\nfunction defs(name) {\n  /*global console*/\n  var that = this;\n  if (arguments.length === 2) {\n    var def = arguments[1];\n    if (typeof def === \'string\') {\n      if (def.charAt(0) === \'+\') {\n        defs[name] = projString(arguments[1]);\n      }\n      else {\n        defs[name] = wkt_parser(arguments[1]);\n      }\n    } else {\n      defs[name] = def;\n    }\n  }\n  else if (arguments.length === 1) {\n    if (Array.isArray(name)) {\n      return name.map(function(v) {\n        if (Array.isArray(v)) {\n          defs.apply(that, v);\n        }\n        else {\n          defs(v);\n        }\n      });\n    }\n    else if (typeof name === \'string\') {\n      if (name in defs) {\n        return defs[name];\n      }\n    }\n    else if (\'EPSG\' in name) {\n      defs[\'EPSG:\' + name.EPSG] = name;\n    }\n    else if (\'ESRI\' in name) {\n      defs[\'ESRI:\' + name.ESRI] = name;\n    }\n    else if (\'IAU2000\' in name) {\n      defs[\'IAU2000:\' + name.IAU2000] = name;\n    }\n    else {\n      console.log(name);\n    }\n    return;\n  }\n\n\n}\nglobal(defs);\n/* harmony default export */ var lib_defs = (defs);\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/parseCode.js\n\n\n\n\nfunction testObj(code){\n  return typeof code === \'string\';\n}\nfunction testDef(code){\n  return code in lib_defs;\n}\nvar codeWords = [\'PROJECTEDCRS\', \'PROJCRS\', \'GEOGCS\',\'GEOCCS\',\'PROJCS\',\'LOCAL_CS\', \'GEODCRS\', \'GEODETICCRS\', \'GEODETICDATUM\', \'ENGCRS\', \'ENGINEERINGCRS\'];\nfunction testWKT(code){\n  return codeWords.some(function (word) {\n    return code.indexOf(word) > -1;\n  });\n}\nvar codes = [\'3857\', \'900913\', \'3785\', \'102113\'];\nfunction checkMercator(item) {\n  var auth = match(item, \'authority\');\n  if (!auth) {\n    return;\n  }\n  var code = match(auth, \'epsg\');\n  return code && codes.indexOf(code) > -1;\n}\nfunction checkProjStr(item) {\n  var ext = match(item, \'extension\');\n  if (!ext) {\n    return;\n  }\n  return match(ext, \'proj4\');\n}\nfunction testProj(code){\n  return code[0] === \'+\';\n}\nfunction parse(code){\n  if (testObj(code)) {\n    //check to see if this is a WKT string\n    if (testDef(code)) {\n      return lib_defs[code];\n    }\n    if (testWKT(code)) {\n      var out = wkt_parser(code);\n      // test of spetial case, due to this being a very common and often malformed\n      if (checkMercator(out)) {\n        return lib_defs[\'EPSG:3857\'];\n      }\n      var maybeProjStr = checkProjStr(out);\n      if (maybeProjStr) {\n        return projString(maybeProjStr);\n      }\n      return out;\n    }\n    if (testProj(code)) {\n      return projString(code);\n    }\n  }else{\n    return code;\n  }\n}\n\n/* harmony default export */ var parseCode = (parse);\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/extend.js\n/* harmony default export */ var extend = (function(destination, source) {\n  destination = destination || {};\n  var value, property;\n  if (!source) {\n    return destination;\n  }\n  for (property in source) {\n    value = source[property];\n    if (value !== undefined) {\n      destination[property] = value;\n    }\n  }\n  return destination;\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/msfnz.js\n/* harmony default export */ var msfnz = (function(eccent, sinphi, cosphi) {\n  var con = eccent * sinphi;\n  return cosphi / (Math.sqrt(1 - con * con));\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sign.js\n/* harmony default export */ var sign = (function(x) {\n  return x<0 ? -1 : 1;\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lon.js\n\n\n\n\n/* harmony default export */ var adjust_lon = (function(x) {\n  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/tsfnz.js\n\n\n/* harmony default export */ var tsfnz = (function(eccent, phi, sinphi) {\n  var con = eccent * sinphi;\n  var com = 0.5 * eccent;\n  con = Math.pow(((1 - con) / (1 + con)), com);\n  return (Math.tan(0.5 * (HALF_PI - phi)) / con);\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/phi2z.js\n\n\n/* harmony default export */ var phi2z = (function(eccent, ts) {\n  var eccnth = 0.5 * eccent;\n  var con, dphi;\n  var phi = HALF_PI - 2 * Math.atan(ts);\n  for (var i = 0; i <= 15; i++) {\n    con = eccent * Math.sin(phi);\n    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n  //console.log("phi2z has NoConvergence");\n  return -9999;\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/merc.js\n\n\n\n\n\n\nfunction init() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n  if(!(\'x0\' in this)){\n    this.x0 = 0;\n  }\n  if(!(\'y0\' in this)){\n    this.y0 = 0;\n  }\n  this.e = Math.sqrt(this.es);\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    }\n    else {\n      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  }\n  else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      }\n      else {\n        this.k0 = 1;\n      }\n    }\n  }\n}\n\n/* Mercator forward equations--mapping lat,long to x,y\n  --------------------------------------------------*/\n\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  // convert to radians\n  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n    return null;\n  }\n\n  var x, y;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    return null;\n  }\n  else {\n    if (this.sphere) {\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n    }\n    else {\n      var sinphi = Math.sin(lat);\n      var ts = tsfnz(this.e, lat, sinphi);\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n    p.x = x;\n    p.y = y;\n    return p;\n  }\n}\n\n/* Mercator inverse equations--mapping x,y to lat/long\n  --------------------------------------------------*/\nfunction merc_inverse(p) {\n\n  var x = p.x - this.x0;\n  var y = p.y - this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n  }\n  else {\n    var ts = Math.exp(-y / (this.a * this.k0));\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];\n/* harmony default export */ var merc = ({\n  init: init,\n  forward: forward,\n  inverse: merc_inverse,\n  names: names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/longlat.js\nfunction longlat_init() {\n  //no-op for longlat\n}\n\nfunction identity(pt) {\n  return pt;\n}\n\n\nvar longlat_names = ["longlat", "identity"];\n/* harmony default export */ var longlat = ({\n  init: longlat_init,\n  forward: identity,\n  inverse: identity,\n  names: longlat_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections.js\n\n\nvar projs = [merc, longlat];\nvar projections_names = {};\nvar projStore = [];\n\nfunction add(proj, i) {\n  var len = projStore.length;\n  if (!proj.names) {\n    console.log(i);\n    return true;\n  }\n  projStore[len] = proj;\n  proj.names.forEach(function(n) {\n    projections_names[n.toLowerCase()] = len;\n  });\n  return this;\n}\n\n\n\nfunction get(name) {\n  if (!name) {\n    return false;\n  }\n  var n = name.toLowerCase();\n  if (typeof projections_names[n] !== \'undefined\' && projStore[projections_names[n]]) {\n    return projStore[projections_names[n]];\n  }\n}\n\nfunction projections_start() {\n  projs.forEach(add);\n}\n/* harmony default export */ var projections = ({\n  start: projections_start,\n  add: add,\n  get: get\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Ellipsoid.js\nvar Ellipsoid_exports = {};\n\nEllipsoid_exports.MERIT = {\n  a: 6378137.0,\n  rf: 298.257,\n  ellipseName: "MERIT 1983"\n};\n\nEllipsoid_exports.SGS85 = {\n  a: 6378136.0,\n  rf: 298.257,\n  ellipseName: "Soviet Geodetic System 85"\n};\n\nEllipsoid_exports.GRS80 = {\n  a: 6378137.0,\n  rf: 298.257222101,\n  ellipseName: "GRS 1980(IUGG, 1980)"\n};\n\nEllipsoid_exports.IAU76 = {\n  a: 6378140.0,\n  rf: 298.257,\n  ellipseName: "IAU 1976"\n};\n\nEllipsoid_exports.airy = {\n  a: 6377563.396,\n  b: 6356256.910,\n  ellipseName: "Airy 1830"\n};\n\nEllipsoid_exports.APL4 = {\n  a: 6378137,\n  rf: 298.25,\n  ellipseName: "Appl. Physics. 1965"\n};\n\nEllipsoid_exports.NWL9D = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: "Naval Weapons Lab., 1965"\n};\n\nEllipsoid_exports.mod_airy = {\n  a: 6377340.189,\n  b: 6356034.446,\n  ellipseName: "Modified Airy"\n};\n\nEllipsoid_exports.andrae = {\n  a: 6377104.43,\n  rf: 300.0,\n  ellipseName: "Andrae 1876 (Den., Iclnd.)"\n};\n\nEllipsoid_exports.aust_SA = {\n  a: 6378160.0,\n  rf: 298.25,\n  ellipseName: "Australian Natl & S. Amer. 1969"\n};\n\nEllipsoid_exports.GRS67 = {\n  a: 6378160.0,\n  rf: 298.2471674270,\n  ellipseName: "GRS 67(IUGG 1967)"\n};\n\nEllipsoid_exports.bessel = {\n  a: 6377397.155,\n  rf: 299.1528128,\n  ellipseName: "Bessel 1841"\n};\n\nEllipsoid_exports.bess_nam = {\n  a: 6377483.865,\n  rf: 299.1528128,\n  ellipseName: "Bessel 1841 (Namibia)"\n};\n\nEllipsoid_exports.clrk66 = {\n  a: 6378206.4,\n  b: 6356583.8,\n  ellipseName: "Clarke 1866"\n};\n\nEllipsoid_exports.clrk80 = {\n  a: 6378249.145,\n  rf: 293.4663,\n  ellipseName: "Clarke 1880 mod."\n};\n\nEllipsoid_exports.clrk58 = {\n  a: 6378293.645208759,\n  rf: 294.2606763692654,\n  ellipseName: "Clarke 1858"\n};\n\nEllipsoid_exports.CPM = {\n  a: 6375738.7,\n  rf: 334.29,\n  ellipseName: "Comm. des Poids et Mesures 1799"\n};\n\nEllipsoid_exports.delmbr = {\n  a: 6376428.0,\n  rf: 311.5,\n  ellipseName: "Delambre 1810 (Belgium)"\n};\n\nEllipsoid_exports.engelis = {\n  a: 6378136.05,\n  rf: 298.2566,\n  ellipseName: "Engelis 1985"\n};\n\nEllipsoid_exports.evrst30 = {\n  a: 6377276.345,\n  rf: 300.8017,\n  ellipseName: "Everest 1830"\n};\n\nEllipsoid_exports.evrst48 = {\n  a: 6377304.063,\n  rf: 300.8017,\n  ellipseName: "Everest 1948"\n};\n\nEllipsoid_exports.evrst56 = {\n  a: 6377301.243,\n  rf: 300.8017,\n  ellipseName: "Everest 1956"\n};\n\nEllipsoid_exports.evrst69 = {\n  a: 6377295.664,\n  rf: 300.8017,\n  ellipseName: "Everest 1969"\n};\n\nEllipsoid_exports.evrstSS = {\n  a: 6377298.556,\n  rf: 300.8017,\n  ellipseName: "Everest (Sabah & Sarawak)"\n};\n\nEllipsoid_exports.fschr60 = {\n  a: 6378166.0,\n  rf: 298.3,\n  ellipseName: "Fischer (Mercury Datum) 1960"\n};\n\nEllipsoid_exports.fschr60m = {\n  a: 6378155.0,\n  rf: 298.3,\n  ellipseName: "Fischer 1960"\n};\n\nEllipsoid_exports.fschr68 = {\n  a: 6378150.0,\n  rf: 298.3,\n  ellipseName: "Fischer 1968"\n};\n\nEllipsoid_exports.helmert = {\n  a: 6378200.0,\n  rf: 298.3,\n  ellipseName: "Helmert 1906"\n};\n\nEllipsoid_exports.hough = {\n  a: 6378270.0,\n  rf: 297.0,\n  ellipseName: "Hough"\n};\n\nEllipsoid_exports.intl = {\n  a: 6378388.0,\n  rf: 297.0,\n  ellipseName: "International 1909 (Hayford)"\n};\n\nEllipsoid_exports.kaula = {\n  a: 6378163.0,\n  rf: 298.24,\n  ellipseName: "Kaula 1961"\n};\n\nEllipsoid_exports.lerch = {\n  a: 6378139.0,\n  rf: 298.257,\n  ellipseName: "Lerch 1979"\n};\n\nEllipsoid_exports.mprts = {\n  a: 6397300.0,\n  rf: 191.0,\n  ellipseName: "Maupertius 1738"\n};\n\nEllipsoid_exports.new_intl = {\n  a: 6378157.5,\n  b: 6356772.2,\n  ellipseName: "New International 1967"\n};\n\nEllipsoid_exports.plessis = {\n  a: 6376523.0,\n  rf: 6355863.0,\n  ellipseName: "Plessis 1817 (France)"\n};\n\nEllipsoid_exports.krass = {\n  a: 6378245.0,\n  rf: 298.3,\n  ellipseName: "Krassovsky, 1942"\n};\n\nEllipsoid_exports.SEasia = {\n  a: 6378155.0,\n  b: 6356773.3205,\n  ellipseName: "Southeast Asia"\n};\n\nEllipsoid_exports.walbeck = {\n  a: 6376896.0,\n  b: 6355834.8467,\n  ellipseName: "Walbeck"\n};\n\nEllipsoid_exports.WGS60 = {\n  a: 6378165.0,\n  rf: 298.3,\n  ellipseName: "WGS 60"\n};\n\nEllipsoid_exports.WGS66 = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: "WGS 66"\n};\n\nEllipsoid_exports.WGS7 = {\n  a: 6378135.0,\n  rf: 298.26,\n  ellipseName: "WGS 72"\n};\n\nvar WGS84 = Ellipsoid_exports.WGS84 = {\n  a: 6378137.0,\n  rf: 298.257223563,\n  ellipseName: "WGS 84"\n};\n\nEllipsoid_exports.sphere = {\n  a: 6370997.0,\n  b: 6370997.0,\n  ellipseName: "Normal Sphere (r=6370997)"\n};\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/deriveConstants.js\n\n\n\n\nfunction eccentricity(a, b, rf, R_A) {\n  var a2 = a * a; // used in geocentric\n  var b2 = b * b; // used in geocentric\n  var es = (a2 - b2) / a2; // e ^ 2\n  var e = 0;\n  if (R_A) {\n    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));\n    a2 = a * a;\n    es = 0;\n  } else {\n    e = Math.sqrt(es); // eccentricity\n  }\n  var ep2 = (a2 - b2) / b2; // used in geocentric\n  return {\n    es: es,\n    e: e,\n    ep2: ep2\n  };\n}\nfunction deriveConstants_sphere(a, b, rf, ellps, sphere) {\n  if (!a) { // do we have an ellipsoid?\n    var ellipse = match(Ellipsoid_exports, ellps);\n    if (!ellipse) {\n      ellipse = WGS84;\n    }\n    a = ellipse.a;\n    b = ellipse.b;\n    rf = ellipse.rf;\n  }\n\n  if (rf && !b) {\n    b = (1.0 - 1.0 / rf) * a;\n  }\n  if (rf === 0 || Math.abs(a - b) < EPSLN) {\n    sphere = true;\n    b = a;\n  }\n  return {\n    a: a,\n    b: b,\n    rf: rf,\n    sphere: sphere\n  };\n}\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Datum.js\nvar Datum_exports = {};\n\nDatum_exports.wgs84 = {\n  towgs84: "0,0,0",\n  ellipse: "WGS84",\n  datumName: "WGS84"\n};\n\nDatum_exports.ch1903 = {\n  towgs84: "674.374,15.056,405.346",\n  ellipse: "bessel",\n  datumName: "swiss"\n};\n\nDatum_exports.ggrs87 = {\n  towgs84: "-199.87,74.79,246.62",\n  ellipse: "GRS80",\n  datumName: "Greek_Geodetic_Reference_System_1987"\n};\n\nDatum_exports.nad83 = {\n  towgs84: "0,0,0",\n  ellipse: "GRS80",\n  datumName: "North_American_Datum_1983"\n};\n\nDatum_exports.nad27 = {\n  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",\n  ellipse: "clrk66",\n  datumName: "North_American_Datum_1927"\n};\n\nDatum_exports.potsdam = {\n  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",\n  ellipse: "bessel",\n  datumName: "Potsdam Rauenberg 1950 DHDN"\n};\n\nDatum_exports.carthage = {\n  towgs84: "-263.0,6.0,431.0",\n  ellipse: "clark80",\n  datumName: "Carthage 1934 Tunisia"\n};\n\nDatum_exports.hermannskogel = {\n  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",\n  ellipse: "bessel",\n  datumName: "Hermannskogel"\n};\n\nDatum_exports.osni52 = {\n  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",\n  ellipse: "airy",\n  datumName: "Irish National"\n};\n\nDatum_exports.ire65 = {\n  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",\n  ellipse: "mod_airy",\n  datumName: "Ireland 1965"\n};\n\nDatum_exports.rassadiran = {\n  towgs84: "-133.63,-157.5,-158.62",\n  ellipse: "intl",\n  datumName: "Rassadiran"\n};\n\nDatum_exports.nzgd49 = {\n  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",\n  ellipse: "intl",\n  datumName: "New Zealand Geodetic Datum 1949"\n};\n\nDatum_exports.osgb36 = {\n  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",\n  ellipse: "airy",\n  datumName: "Airy 1830"\n};\n\nDatum_exports.s_jtsk = {\n  towgs84: "589,76,480",\n  ellipse: \'bessel\',\n  datumName: \'S-JTSK (Ferro)\'\n};\n\nDatum_exports.beduaram = {\n  towgs84: \'-106,-87,188\',\n  ellipse: \'clrk80\',\n  datumName: \'Beduaram\'\n};\n\nDatum_exports.gunung_segara = {\n  towgs84: \'-403,684,41\',\n  ellipse: \'bessel\',\n  datumName: \'Gunung Segara Jakarta\'\n};\n\nDatum_exports.rnb72 = {\n  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",\n  ellipse: "intl",\n  datumName: "Reseau National Belge 1972"\n};\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/datum.js\n\n\nfunction datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {\n  var out = {};\n\n  if (datumCode === undefined || datumCode === \'none\') {\n    out.datum_type = PJD_NODATUM;\n  } else {\n    out.datum_type = PJD_WGS84;\n  }\n\n  if (datum_params) {\n    out.datum_params = datum_params.map(parseFloat);\n    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n      out.datum_type = PJD_3PARAM;\n    }\n    if (out.datum_params.length > 3) {\n      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n        out.datum_type = PJD_7PARAM;\n        out.datum_params[3] *= SEC_TO_RAD;\n        out.datum_params[4] *= SEC_TO_RAD;\n        out.datum_params[5] *= SEC_TO_RAD;\n        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\n      }\n    }\n  }\n\n  if (nadgrids) {\n    out.datum_type = PJD_GRIDSHIFT;\n    out.grids = nadgrids;\n  }\n  out.a = a; //datum object also uses these values\n  out.b = b;\n  out.es = es;\n  out.ep2 = ep2;\n  return out;\n}\n\n/* harmony default export */ var lib_datum = (datum);\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/nadgrid.js\n/**\n * Resources for details of NTv2 file formats:\n * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf\n * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm\n */\n\nvar loadedNadgrids = {};\n\n/**\n * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file\n * as an ArrayBuffer.\n */\nfunction nadgrid(key, data) {\n  var view = new DataView(data);\n  var isLittleEndian = detectLittleEndian(view);\n  var header = readHeader(view, isLittleEndian);\n  if (header.nSubgrids > 1) {\n    console.log(\'Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored\');\n  }\n  var subgrids = readSubgrids(view, header, isLittleEndian);\n  var nadgrid = {header: header, subgrids: subgrids};\n  loadedNadgrids[key] = nadgrid;\n  return nadgrid;\n}\n\n/**\n * Given a proj4 value for nadgrids, return an array of loaded grids\n */\nfunction getNadgrids(nadgrids) {\n  // Format details: http://proj.maptools.org/gen_parms.html\n  if (nadgrids === undefined) { return null; }\n  var grids = nadgrids.split(\',\');\n  return grids.map(parseNadgridString);\n}\n\nfunction parseNadgridString(value) {\n  if (value.length === 0) {\n    return null;\n  }\n  var optional = value[0] === \'@\';\n  if (optional) {\n    value = value.slice(1);\n  }\n  if (value === \'null\') {\n    return {name: \'null\', mandatory: !optional, grid: null, isNull: true};\n  }\n  return {\n    name: value,\n    mandatory: !optional,\n    grid: loadedNadgrids[value] || null,\n    isNull: false\n  };\n}\n\nfunction secondsToRadians(seconds) {\n  return (seconds / 3600) * Math.PI / 180;\n}\n\nfunction detectLittleEndian(view) {\n  var nFields = view.getInt32(8, false);\n  if (nFields === 11) {\n    return false;\n  }\n  nFields = view.getInt32(8, true);\n  if (nFields !== 11) {\n    console.warn(\'Failed to detect nadgrid endian-ness, defaulting to little-endian\');\n  }\n  return true;\n}\n\nfunction readHeader(view, isLittleEndian) {\n  return {\n    nFields: view.getInt32(8, isLittleEndian),\n    nSubgridFields: view.getInt32(24, isLittleEndian),\n    nSubgrids: view.getInt32(40, isLittleEndian),\n    shiftType: decodeString(view, 56, 56 + 8).trim(),\n    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),\n    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),\n    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),\n    toSemiMinorAxis: view.getFloat64(168, isLittleEndian),\n  };\n}\n\nfunction decodeString(view, start, end) {\n  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));\n}\n\nfunction readSubgrids(view, header, isLittleEndian) {\n  var gridOffset = 176;\n  var grids = [];\n  for (var i = 0; i < header.nSubgrids; i++) {\n    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);\n    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);\n    var lngColumnCount = Math.round(\n      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);\n    var latColumnCount = Math.round(\n      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);\n    // Proj4 operates on radians whereas the coordinates are in seconds in the grid\n    grids.push({\n      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],\n      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],\n      lim: [lngColumnCount, latColumnCount],\n      count: subHeader.gridNodeCount,\n      cvs: mapNodes(nodes)\n    });\n  }\n  return grids;\n}\n\nfunction mapNodes(nodes) {\n  return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});\n}\n\nfunction readGridHeader(view, offset, isLittleEndian) {\n  return {\n    name: decodeString(view, offset + 8, offset + 16).trim(),\n    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),\n    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),\n    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),\n    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),\n    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),\n    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),\n    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),\n    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)\n  };\n}\n\nfunction readGridNodes(view, offset, gridHeader, isLittleEndian) {\n  var nodesOffset = offset + 176;\n  var gridRecordLength = 16;\n  var gridShiftRecords = [];\n  for (var i = 0; i < gridHeader.gridNodeCount; i++) {\n    var record = {\n      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),\n      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),\n      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),\n      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),\n    };\n    gridShiftRecords.push(record);\n  }\n  return gridShiftRecords;\n}\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/Proj.js\n\n\n\n\n\n\n\n\n\nfunction Projection(srsCode,callback) {\n  if (!(this instanceof Projection)) {\n    return new Projection(srsCode);\n  }\n  callback = callback || function(error){\n    if(error){\n      throw error;\n    }\n  };\n  var json = parseCode(srsCode);\n  if(typeof json !== \'object\'){\n    callback(srsCode);\n    return;\n  }\n  var ourProj = Projection.projections.get(json.projName);\n  if(!ourProj){\n    callback(srsCode);\n    return;\n  }\n  if (json.datumCode && json.datumCode !== \'none\') {\n    var datumDef = match(Datum_exports, json.datumCode);\n    if (datumDef) {\n      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(\',\') : null);\n      json.ellps = datumDef.ellipse;\n      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n    }\n  }\n  json.k0 = json.k0 || 1.0;\n  json.axis = json.axis || \'enu\';\n  json.ellps = json.ellps || \'wgs84\';\n  json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this\n\n  var sphere_ = deriveConstants_sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\n  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);\n  var nadgrids = getNadgrids(json.nadgrids);\n  var datumObj = json.datum || lib_datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,\n    nadgrids);\n\n  extend(this, json); // transfer everything over from the projection because we don\'t know what we\'ll need\n  extend(this, ourProj); // transfer all the methods from the projection\n\n  // copy the 4 things over we calculated in deriveConstants.sphere\n  this.a = sphere_.a;\n  this.b = sphere_.b;\n  this.rf = sphere_.rf;\n  this.sphere = sphere_.sphere;\n\n  // copy the 3 things we calculated in deriveConstants.eccentricity\n  this.es = ecc.es;\n  this.e = ecc.e;\n  this.ep2 = ecc.ep2;\n\n  // add in the datum object\n  this.datum = datumObj;\n\n  // init the projection\n  this.init();\n\n  // legecy callback from back in the day when it went to spatialreference.org\n  callback(null, this);\n\n}\nProjection.projections = projections;\nProjection.projections.start();\n/* harmony default export */ var Proj = (Projection);\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/datumUtils.js\n\n\nfunction compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n    // the tolerance for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n  } else if (source.datum_type === PJD_7PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n  } else {\n    return true; // datums are equal\n  }\n} // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nfunction geodeticToGeocentric(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don\'t blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if (Latitude < -HALF_PI) {\n    /* Latitude out of range */\n    //..reportError(\'geocent:lat out of range:\' + Latitude);\n    return { x: -Infinity, y: -Infinity, z: p.z };\n  } else if (Latitude > HALF_PI) {\n    /* Latitude out of range */\n    return { x: Infinity, y: Infinity, z: p.z };\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= (2 * Math.PI);\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n  };\n} // cs_geodetic_to_geocentric()\n\nfunction geocentricToGeodetic(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = (genau * genau);\n  var maxiter = 30;\n\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * "Institut for Erdmessung", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  }\n  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n} // cs_geocentric_to_geodetic()\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nfunction geocentricToWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2],\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n} // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nfunction geocentricFromWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2],\n    };\n\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n}\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/datum_transform.js\n\n\n\n\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\n\n/* harmony default export */ var datum_transform = (function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting \'datum=none\' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n  var source_a = source.a;\n  var source_es = source.es;\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  }\n\n  // Do we need to go through geocentric coordinates?\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source_es, source_a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n\n  return point;\n});\n\nfunction applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log(\'Grid shift grids not found\');\n    return -1;\n  }\n  var input = {x: -point.x, y: point.y};\n  var output = {x: Number.NaN, y: Number.NaN};\n  var onlyMandatoryGrids = false;\n  var attemptedGrids = [];\n  for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n    onlyMandatoryGrids = grid.mandatory;\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log("Unable to find mandatory grid \'" + grid.name + "\'");\n        return -1;\n      }\n      continue;\n    }\n    var subgrid = grid.grid.subgrids[0];\n    // skip tables that don\'t match our point at all\n    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n    var minX = subgrid.ll[0] - epsilon;\n    var minY = subgrid.ll[1] - epsilon;\n    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {\n      continue;\n    }\n    output = applySubgridShift(input, inverse, subgrid);\n    if (!isNaN(output.x)) {\n      break;\n    }\n  }\n  if (isNaN(output.x)) {\n    console.log("Failed to find a grid shift table for location \'"+\n      -input.x * R2D + " " + input.y * R2D + " tried: \'" + attemptedGrids + "\'");\n    return -1;\n  }\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\n\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = {x: Number.NaN, y: Number.NaN};\n  if (isNaN(pin.x)) { return val; }\n  var tb = {x: pin.x, y: pin.y};\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9, tol = 1e-12;\n    var dif, del;\n    do {\n      del = nadInterpolate(t, ct);\n      if (isNaN(del.x)) {\n        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");\n        break;\n      }\n      dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n    if (i < 0) {\n      console.log("Inverse grid shift iterator failed to converge.");\n      return val;\n    }\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n  return val;\n}\n\nfunction nadInterpolate(pin, ct) {\n  var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};\n  var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};\n  var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};\n  var val= {x: Number.NaN, y: Number.NaN};\n  var inx;\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n  inx = (indx.y * ct.lim[0]) + indx.x;\n  var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx++;\n  var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx += ct.lim[0];\n  var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx--;\n  var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),\n    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;\n  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);\n  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);\n  return val;\n}\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/adjust_axis.js\n/* harmony default export */ var adjust_axis = (function(crs, denorm, point) {\n  var xin = point.x,\n    yin = point.y,\n    zin = point.z || 0.0;\n  var v, t, i;\n  var out = {};\n  for (i = 0; i < 3; i++) {\n    if (denorm && i === 2 && point.z === undefined) {\n      continue;\n    }\n    if (i === 0) {\n      v = xin;\n      if ("ew".indexOf(crs.axis[i]) !== -1) {\n        t = \'x\';\n      } else {\n        t = \'y\';\n      }\n\n    }\n    else if (i === 1) {\n      v = yin;\n      if ("ns".indexOf(crs.axis[i]) !== -1) {\n        t = \'y\';\n      } else {\n        t = \'x\';\n      }\n    }\n    else {\n      v = zin;\n      t = \'z\';\n    }\n    switch (crs.axis[i]) {\n    case \'e\':\n      out[t] = v;\n      break;\n    case \'w\':\n      out[t] = -v;\n      break;\n    case \'n\':\n      out[t] = v;\n      break;\n    case \'s\':\n      out[t] = -v;\n      break;\n    case \'u\':\n      if (point[t] !== undefined) {\n        out.z = v;\n      }\n      break;\n    case \'d\':\n      if (point[t] !== undefined) {\n        out.z = -v;\n      }\n      break;\n    default:\n      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);\n      return null;\n    }\n  }\n  return out;\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/toPoint.js\n/* harmony default export */ var toPoint = (function (array){\n  var out = {\n    x: array[0],\n    y: array[1]\n  };\n  if (array.length>2) {\n    out.z = array[2];\n  }\n  if (array.length>3) {\n    out.m = array[3];\n  }\n  return out;\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/checkSanity.js\n/* harmony default export */ var checkSanity = (function (point) {\n  checkCoord(point.x);\n  checkCoord(point.y);\n});\nfunction checkCoord(num) {\n  if (typeof Number.isFinite === \'function\') {\n    if (Number.isFinite(num)) {\n      return;\n    }\n    throw new TypeError(\'coordinates must be finite numbers\');\n  }\n  if (typeof num !== \'number\' || num !== num || !isFinite(num)) {\n    throw new TypeError(\'coordinates must be finite numbers\');\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/transform.js\n\n\n\n\n\n\n\nfunction checkNotWGS(source, dest) {\n  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== \'WGS84\') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== \'WGS84\');\n}\n\nfunction transform(source, dest, point, enforceAxis) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n  checkSanity(point);\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new Proj(\'WGS84\');\n    point = transform(source, wgs84, point, enforceAxis);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (enforceAxis && source.axis !== \'enu\') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren\'t already.\n  if (source.projName === \'longlat\') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n    point = source.inverse(point); // Convert Cartesian to longlat\n    if (!point) {\n      return;\n    }\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n  if (!point) {\n    return;\n  }\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n\n  if (dest.projName === \'longlat\') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else { // else project\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (enforceAxis && dest.axis !== \'enu\') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n}\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/core.js\n\n\nvar core_wgs84 = Proj(\'WGS84\');\n\nfunction transformer(from, to, coords, enforceAxis) {\n  var transformedArray, out, keys;\n  if (Array.isArray(coords)) {\n    transformedArray = transform(from, to, coords, enforceAxis) || {x: NaN, y: NaN};\n    if (coords.length > 2) {\n      if ((typeof from.name !== \'undefined\' && from.name === \'geocent\') || (typeof to.name !== \'undefined\' && to.name === \'geocent\')) {\n        if (typeof transformedArray.z === \'number\') {\n          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));\n        } else {\n          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));\n        }\n      } else {\n        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));\n      }\n    } else {\n      return [transformedArray.x, transformedArray.y];\n    }\n  } else {\n    out = transform(from, to, coords, enforceAxis);\n    keys = Object.keys(coords);\n    if (keys.length === 2) {\n      return out;\n    }\n    keys.forEach(function (key) {\n      if ((typeof from.name !== \'undefined\' && from.name === \'geocent\') || (typeof to.name !== \'undefined\' && to.name === \'geocent\')) {\n        if (key === \'x\' || key === \'y\' || key === \'z\') {\n          return;\n        }\n      } else {\n        if (key === \'x\' || key === \'y\') {\n          return;\n        }\n      }\n      out[key] = coords[key];\n    });\n    return out;\n  }\n}\n\nfunction checkProj(item) {\n  if (item instanceof Proj) {\n    return item;\n  }\n  if (item.oProj) {\n    return item.oProj;\n  }\n  return Proj(item);\n}\n\nfunction core_proj4(fromProj, toProj, coord) {\n  fromProj = checkProj(fromProj);\n  var single = false;\n  var obj;\n  if (typeof toProj === \'undefined\') {\n    toProj = fromProj;\n    fromProj = core_wgs84;\n    single = true;\n  } else if (typeof toProj.x !== \'undefined\' || Array.isArray(toProj)) {\n    coord = toProj;\n    toProj = fromProj;\n    fromProj = core_wgs84;\n    single = true;\n  }\n  toProj = checkProj(toProj);\n  if (coord) {\n    return transformer(fromProj, toProj, coord);\n  } else {\n    obj = {\n      forward: function (coords, enforceAxis) {\n        return transformer(fromProj, toProj, coords, enforceAxis);\n      },\n      inverse: function (coords, enforceAxis) {\n        return transformer(toProj, fromProj, coords, enforceAxis);\n      }\n    };\n    if (single) {\n      obj.oProj = toProj;\n    }\n    return obj;\n  }\n}\n/* harmony default export */ var core = (core_proj4);\n// CONCATENATED MODULE: ./node_modules/mgrs/mgrs.js\n\n\n\n/**\n * UTM zones are grouped, and assigned to one of a group of 6\n * sets.\n *\n * {int} @private\n */\nvar NUM_100K_SETS = 6;\n\n/**\n * The column letters (for easting) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_COLUMN_LETTERS = \'AJSAJS\';\n\n/**\n * The row letters (for northing) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_ROW_LETTERS = \'AFAFAF\';\n\nvar mgrs_A = 65; // A\nvar I = 73; // I\nvar O = 79; // O\nvar mgrs_V = 86; // V\nvar mgrs_Z = 90; // Z\n/* harmony default export */ var mgrs = ({\n  forward: mgrs_forward,\n  inverse: mgrs_inverse,\n  toPoint: mgrs_toPoint\n});\n/**\n * Conversion of lat/lon to MGRS.\n *\n * @param {object} ll Object literal with lat and lon properties on a\n *     WGS84 ellipsoid.\n * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n * @return {string} the MGRS string for the given location and accuracy.\n */\nfunction mgrs_forward(ll, accuracy) {\n  accuracy = accuracy || 5; // default accuracy 1m\n  return encode(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n};\n\n/**\n * Conversion of MGRS to lat/lon.\n *\n * @param {string} mgrs MGRS string.\n * @return {array} An array with left (longitude), bottom (latitude), right\n *     (longitude) and top (latitude) values in WGS84, representing the\n *     bounding box for the provided MGRS reference.\n */\nfunction mgrs_inverse(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n  }\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n};\n\nfunction mgrs_toPoint(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat];\n  }\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n};\n/**\n * Conversion from degrees to radians.\n *\n * @private\n * @param {number} deg the angle in degrees.\n * @return {number} the angle in radians.\n */\nfunction degToRad(deg) {\n  return (deg * (Math.PI / 180.0));\n}\n\n/**\n * Conversion from radians to degrees.\n *\n * @private\n * @param {number} rad the angle in radians.\n * @return {number} the angle in degrees.\n */\nfunction radToDeg(rad) {\n  return (180.0 * (rad / Math.PI));\n}\n\n/**\n * Converts a set of Longitude and Latitude co-ordinates to UTM\n * using the WGS84 ellipsoid.\n *\n * @private\n * @param {object} ll Object literal with lat and lon properties\n *     representing the WGS84 coordinate to be converted.\n * @return {object} Object literal containing the UTM value with easting,\n *     northing, zoneNumber and zoneLetter properties, and an optional\n *     accuracy property in digits. Returns null if the conversion failed.\n */\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N, T, C, A, M;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  // (int)\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n  //Make sure the longitude 180.00 is in Zone 60\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n\n  // Special zone for Norway\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n    ZoneNumber = 32;\n  }\n\n  // Special zones for Svalbard\n  if (Lat >= 72.0 && Lat < 84.0) {\n    if (Long >= 0.0 && Long < 9.0) {\n      ZoneNumber = 31;\n    }\n    else if (Long >= 9.0 && Long < 21.0) {\n      ZoneNumber = 33;\n    }\n    else if (Long >= 21.0 && Long < 33.0) {\n      ZoneNumber = 35;\n    }\n    else if (Long >= 33.0 && Long < 42.0) {\n      ZoneNumber = 37;\n    }\n  }\n\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n  // in middle of\n  // zone\n  LongOriginRad = degToRad(LongOrigin);\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T = Math.tan(LatRad) * Math.tan(LatRad);\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n  if (Lat < 0.0) {\n    UTMNorthing += 10000000.0; //10000000 meter offset for\n    // southern hemisphere\n  }\n\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\n\n/**\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n * class where the Zone can be specified as a single string eg."60N" which\n * is then broken down into the ZoneNumber and ZoneLetter.\n *\n * @private\n * @param {object} utm An object literal with northing, easting, zoneNumber\n *     and zoneLetter properties. If an optional accuracy property is\n *     provided (in meters), a bounding box will be returned instead of\n *     latitude and longitude.\n * @return {object} An object literal containing either lat and lon values\n *     (if no accuracy was provided), or top, right, bottom and left values\n *     for the bounding box calculated according to the provided accuracy.\n *     Returns null if the conversion failed.\n */\nfunction UTMtoLL(utm) {\n\n  var UTMNorthing = utm.northing;\n  var UTMEasting = utm.easting;\n  var zoneLetter = utm.zoneLetter;\n  var zoneNumber = utm.zoneNumber;\n  // check the ZoneNummber is valid\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n\n  var k0 = 0.9996;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C1, R1, D, M;\n  var LongOrigin;\n  var mu, phi1Rad;\n\n  // remove 500,000 meter offset for longitude\n  var x = UTMEasting - 500000.0;\n  var y = UTMNorthing;\n\n  // We must know somehow if we are in the Northern or Southern\n  // hemisphere, this is the only time we use the letter So even\n  // if the Zone letter isn\'t exactly correct it should indicate\n  // the hemisphere correctly\n  if (zoneLetter < \'N\') {\n    y -= 10000000.0; // remove 10,000,000 meter offset used\n    // for southern hemisphere\n  }\n\n  // There are 60 zones with zone 1 being at West -180 to -174\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n  // in middle of\n  // zone\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  M = y / k0;\n  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D = x / (N1 * k0);\n\n  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n  lat = radToDeg(lat);\n\n  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n\n  var result;\n  if (utm.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm.northing + utm.accuracy,\n      easting: utm.easting + utm.accuracy,\n      zoneLetter: utm.zoneLetter,\n      zoneNumber: utm.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  }\n  else {\n    result = {\n      lat: lat,\n      lon: lon\n    };\n  }\n  return result;\n}\n\n/**\n * Calculates the MGRS letter designator for the given latitude.\n *\n * @private\n * @param {number} lat The latitude in WGS84 to get the letter designator\n *     for.\n * @return {char} The letter designator.\n */\nfunction getLetterDesignator(lat) {\n  //This is here as an error flag to show that the Latitude is\n  //outside MGRS limits\n  var LetterDesignator = \'Z\';\n\n  if ((84 >= lat) && (lat >= 72)) {\n    LetterDesignator = \'X\';\n  }\n  else if ((72 > lat) && (lat >= 64)) {\n    LetterDesignator = \'W\';\n  }\n  else if ((64 > lat) && (lat >= 56)) {\n    LetterDesignator = \'V\';\n  }\n  else if ((56 > lat) && (lat >= 48)) {\n    LetterDesignator = \'U\';\n  }\n  else if ((48 > lat) && (lat >= 40)) {\n    LetterDesignator = \'T\';\n  }\n  else if ((40 > lat) && (lat >= 32)) {\n    LetterDesignator = \'S\';\n  }\n  else if ((32 > lat) && (lat >= 24)) {\n    LetterDesignator = \'R\';\n  }\n  else if ((24 > lat) && (lat >= 16)) {\n    LetterDesignator = \'Q\';\n  }\n  else if ((16 > lat) && (lat >= 8)) {\n    LetterDesignator = \'P\';\n  }\n  else if ((8 > lat) && (lat >= 0)) {\n    LetterDesignator = \'N\';\n  }\n  else if ((0 > lat) && (lat >= -8)) {\n    LetterDesignator = \'M\';\n  }\n  else if ((-8 > lat) && (lat >= -16)) {\n    LetterDesignator = \'L\';\n  }\n  else if ((-16 > lat) && (lat >= -24)) {\n    LetterDesignator = \'K\';\n  }\n  else if ((-24 > lat) && (lat >= -32)) {\n    LetterDesignator = \'J\';\n  }\n  else if ((-32 > lat) && (lat >= -40)) {\n    LetterDesignator = \'H\';\n  }\n  else if ((-40 > lat) && (lat >= -48)) {\n    LetterDesignator = \'G\';\n  }\n  else if ((-48 > lat) && (lat >= -56)) {\n    LetterDesignator = \'F\';\n  }\n  else if ((-56 > lat) && (lat >= -64)) {\n    LetterDesignator = \'E\';\n  }\n  else if ((-64 > lat) && (lat >= -72)) {\n    LetterDesignator = \'D\';\n  }\n  else if ((-72 > lat) && (lat >= -80)) {\n    LetterDesignator = \'C\';\n  }\n  return LetterDesignator;\n}\n\n/**\n * Encodes a UTM location as MGRS string.\n *\n * @private\n * @param {object} utm An object literal with easting, northing,\n *     zoneLetter, zoneNumber\n * @param {number} accuracy Accuracy in digits (1-5).\n * @return {string} MGRS string for the given UTM location.\n */\nfunction encode(utm, accuracy) {\n  // prepend with leading zeroes\n  var seasting = "00000" + utm.easting,\n    snorthing = "00000" + utm.northing;\n\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\n\n/**\n * Get the two letter 100k designator for a given UTM easting,\n * northing and zone number value.\n *\n * @private\n * @param {number} easting\n * @param {number} northing\n * @param {number} zoneNumber\n * @return the two letter 100k designator for the given UTM location.\n */\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 100000);\n  var setRow = Math.floor(northing / 100000) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\n\n/**\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\n *\n * @private\n * @param {number} i An UTM zone number.\n * @return {number} the 100k set the UTM zone is in.\n */\nfunction get100kSetForZone(i) {\n  var setParm = i % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n\n  return setParm;\n}\n\n/**\n * Get the two-letter MGRS 100k designator given information\n * translated from the UTM northing, easting and zone number.\n *\n * @private\n * @param {number} column the column index as it relates to the MGRS\n *        100k set spreadsheet, created from the UTM easting.\n *        Values are 1-8.\n * @param {number} row the row index as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM northing value. Values\n *        are from 0-19.\n * @param {number} parm the set block, as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM zone. Values are from\n *        1-60.\n * @return two letter MGRS 100k code.\n */\nfunction getLetter100kID(column, row, parm) {\n  // colOrigin and rowOrigin are the letters at the origin of the set\n  var index = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n  // colInt and rowInt are the letters to build to return\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n\n  if (colInt > mgrs_Z) {\n    colInt = colInt - mgrs_Z + mgrs_A - 1;\n    rollover = true;\n  }\n\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n    colInt++;\n  }\n\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n    colInt++;\n\n    if (colInt === I) {\n      colInt++;\n    }\n  }\n\n  if (colInt > mgrs_Z) {\n    colInt = colInt - mgrs_Z + mgrs_A - 1;\n  }\n\n  if (rowInt > mgrs_V) {\n    rowInt = rowInt - mgrs_V + mgrs_A - 1;\n    rollover = true;\n  }\n  else {\n    rollover = false;\n  }\n\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n    rowInt++;\n  }\n\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n    rowInt++;\n\n    if (rowInt === I) {\n      rowInt++;\n    }\n  }\n\n  if (rowInt > mgrs_V) {\n    rowInt = rowInt - mgrs_V + mgrs_A - 1;\n  }\n\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\n\n/**\n * Decode the UTM parameters from a MGRS string.\n *\n * @private\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n * @return {object} An object literal with easting, northing, zoneLetter,\n *     zoneNumber and accuracy (in meters) properties.\n */\nfunction decode(mgrsString) {\n\n  if (mgrsString && mgrsString.length === 0) {\n    throw ("MGRSPoint coverting from nothing");\n  }\n\n  var length = mgrsString.length;\n\n  var hunK = null;\n  var sb = "";\n  var testChar;\n  var i = 0;\n\n  // get Zone number\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n    if (i >= 2) {\n      throw ("MGRSPoint bad conversion from: " + mgrsString);\n    }\n    sb += testChar;\n    i++;\n  }\n\n  var zoneNumber = parseInt(sb, 10);\n\n  if (i === 0 || i + 3 > length) {\n    // A good MGRS string has to be 4-5 digits long,\n    // ##AAA/#AAA at least.\n    throw ("MGRSPoint bad conversion from: " + mgrsString);\n  }\n\n  var zoneLetter = mgrsString.charAt(i++);\n\n  // Should we check the zone letter here? Why not.\n  if (zoneLetter <= \'A\' || zoneLetter === \'B\' || zoneLetter === \'Y\' || zoneLetter >= \'Z\' || zoneLetter === \'I\' || zoneLetter === \'O\') {\n    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);\n  }\n\n  hunK = mgrsString.substring(i, i += 2);\n\n  var set = get100kSetForZone(zoneNumber);\n\n  var east100k = getEastingFromChar(hunK.charAt(0), set);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n  // We have a bug where the northing may be 2000000 too low.\n  // How\n  // do we know when to roll over?\n\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2000000;\n  }\n\n  // calculate the char index for easting/northing separator\n  var remainder = length - i;\n\n  if (remainder % 2 !== 0) {\n    throw ("MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters" + mgrsString);\n  }\n\n  var sep = remainder / 2;\n\n  var sepEasting = 0.0;\n  var sepNorthing = 0.0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 100000.0 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i, i + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n\n  return {\n    easting: easting,\n    northing: northing,\n    zoneLetter: zoneLetter,\n    zoneNumber: zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\n\n/**\n * Given the first letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the easting value that\n * should be added to the other, secondary easting value.\n *\n * @private\n * @param {char} e The first letter from a two-letter MGRS 100´k zone.\n * @param {number} set The MGRS table set for the zone number.\n * @return {number} The easting value for the given letter and set.\n */\nfunction getEastingFromChar(e, set) {\n  // colOrigin is the letter at the origin of the set for the\n  // column\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n  var eastingValue = 100000.0;\n  var rewindMarker = false;\n\n  while (curCol !== e.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I) {\n      curCol++;\n    }\n    if (curCol === O) {\n      curCol++;\n    }\n    if (curCol > mgrs_Z) {\n      if (rewindMarker) {\n        throw ("Bad character: " + e);\n      }\n      curCol = mgrs_A;\n      rewindMarker = true;\n    }\n    eastingValue += 100000.0;\n  }\n\n  return eastingValue;\n}\n\n/**\n * Given the second letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the northing value that\n * should be added to the other, secondary northing value. You have to\n * remember that Northings are determined from the equator, and the vertical\n * cycle of letters mean a 2000000 additional northing meters. This happens\n * approx. every 18 degrees of latitude. This method does *NOT* count any\n * additional northings. You have to figure out how many 2000000 meters need\n * to be added for the zone letter of the MGRS coordinate.\n *\n * @private\n * @param {char} n Second letter of the MGRS 100k zone\n * @param {number} set The MGRS table set number, which is dependent on the\n *     UTM zone number.\n * @return {number} The northing value for the given letter and set.\n */\nfunction getNorthingFromChar(n, set) {\n\n  if (n > \'V\') {\n    throw ("MGRSPoint given invalid Northing " + n);\n  }\n\n  // rowOrigin is the letter at the origin of the set for the\n  // column\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n  var northingValue = 0.0;\n  var rewindMarker = false;\n\n  while (curRow !== n.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I) {\n      curRow++;\n    }\n    if (curRow === O) {\n      curRow++;\n    }\n    // fixing a bug making whole application hang in this loop\n    // when \'n\' is a wrong character\n    if (curRow > mgrs_V) {\n      if (rewindMarker) { // making sure that this loop ends\n        throw ("Bad character: " + n);\n      }\n      curRow = mgrs_A;\n      rewindMarker = true;\n    }\n    northingValue += 100000.0;\n  }\n\n  return northingValue;\n}\n\n/**\n * The function getMinNorthing returns the minimum northing value of a MGRS\n * zone.\n *\n * Ported from Geotrans\' c Lattitude_Band_Value structure table.\n *\n * @private\n * @param {char} zoneLetter The MGRS zone to get the min northing for.\n * @return {number}\n */\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n  case \'C\':\n    northing = 1100000.0;\n    break;\n  case \'D\':\n    northing = 2000000.0;\n    break;\n  case \'E\':\n    northing = 2800000.0;\n    break;\n  case \'F\':\n    northing = 3700000.0;\n    break;\n  case \'G\':\n    northing = 4600000.0;\n    break;\n  case \'H\':\n    northing = 5500000.0;\n    break;\n  case \'J\':\n    northing = 6400000.0;\n    break;\n  case \'K\':\n    northing = 7300000.0;\n    break;\n  case \'L\':\n    northing = 8200000.0;\n    break;\n  case \'M\':\n    northing = 9100000.0;\n    break;\n  case \'N\':\n    northing = 0.0;\n    break;\n  case \'P\':\n    northing = 800000.0;\n    break;\n  case \'Q\':\n    northing = 1700000.0;\n    break;\n  case \'R\':\n    northing = 2600000.0;\n    break;\n  case \'S\':\n    northing = 3500000.0;\n    break;\n  case \'T\':\n    northing = 4400000.0;\n    break;\n  case \'U\':\n    northing = 5300000.0;\n    break;\n  case \'V\':\n    northing = 6200000.0;\n    break;\n  case \'W\':\n    northing = 7000000.0;\n    break;\n  case \'X\':\n    northing = 7900000.0;\n    break;\n  default:\n    northing = -1.0;\n  }\n  if (northing >= 0.0) {\n    return northing;\n  }\n  else {\n    throw ("Invalid zone letter: " + zoneLetter);\n  }\n\n}\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/Point.js\n\n\nfunction Point_Point(x, y, z) {\n  if (!(this instanceof Point_Point)) {\n    return new Point_Point(x, y, z);\n  }\n  if (Array.isArray(x)) {\n    this.x = x[0];\n    this.y = x[1];\n    this.z = x[2] || 0.0;\n  } else if(typeof x === \'object\') {\n    this.x = x.x;\n    this.y = x.y;\n    this.z = x.z || 0.0;\n  } else if (typeof x === \'string\' && typeof y === \'undefined\') {\n    var coords = x.split(\',\');\n    this.x = parseFloat(coords[0], 10);\n    this.y = parseFloat(coords[1], 10);\n    this.z = parseFloat(coords[2], 10) || 0.0;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z || 0.0;\n  }\n  console.warn(\'proj4.Point will be removed in version 3, use proj4.toPoint\');\n}\n\nPoint_Point.fromMGRS = function(mgrsStr) {\n  return new Point_Point(mgrs_toPoint(mgrsStr));\n};\nPoint_Point.prototype.toMGRS = function(accuracy) {\n  return mgrs_forward([this.x, this.y], accuracy);\n};\n/* harmony default export */ var lib_Point = (Point_Point);\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_enfn.js\nvar C00 = 1;\nvar C02 = 0.25;\nvar C04 = 0.046875;\nvar C06 = 0.01953125;\nvar C08 = 0.01068115234375;\nvar C22 = 0.75;\nvar C44 = 0.46875;\nvar C46 = 0.01302083333333333333;\nvar C48 = 0.00712076822916666666;\nvar C66 = 0.36458333333333333333;\nvar C68 = 0.00569661458333333333;\nvar C88 = 0.3076171875;\n\n/* harmony default export */ var pj_enfn = (function(es) {\n  var en = [];\n  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));\n  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));\n  var t = es * es;\n  en[2] = t * (C44 - es * (C46 + es * C48));\n  t *= es;\n  en[3] = t * (C66 - es * C68);\n  en[4] = t * es * C88;\n  return en;\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_mlfn.js\n/* harmony default export */ var pj_mlfn = (function(phi, sphi, cphi, en) {\n  cphi *= sphi;\n  sphi *= sphi;\n  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_inv_mlfn.js\n\n\n\nvar MAX_ITER = 20;\n\n/* harmony default export */ var pj_inv_mlfn = (function(arg, es, en) {\n  var k = 1 / (1 - es);\n  var phi = arg;\n  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */\n    var s = Math.sin(phi);\n    var t = 1 - es * s * s;\n    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;\n    //phi -= t * (t * Math.sqrt(t)) * k;\n    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;\n    phi -= t;\n    if (Math.abs(t) < EPSLN) {\n      return phi;\n    }\n  }\n  //..reportError("cass:pj_inv_mlfn: Convergence error");\n  return phi;\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tmerc.js\n// Heavily based on this tmerc projection implementation\n// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js\n\n\n\n\n\n\n\n\n\nfunction tmerc_init() {\n  this.x0 = this.x0 !== undefined ? this.x0 : 0;\n  this.y0 = this.y0 !== undefined ? this.y0 : 0;\n  this.long0 = this.long0 !== undefined ? this.long0 : 0;\n  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;\n\n  if (this.es) {\n    this.en = pj_enfn(this.es);\n    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);\n  }\n}\n\n/**\n    Transverse Mercator Forward  - long/lat to x/y\n    long/lat in radians\n  */\nfunction tmerc_forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var con;\n  var x, y;\n  var sin_phi = Math.sin(lat);\n  var cos_phi = Math.cos(lat);\n\n  if (!this.es) {\n    var b = cos_phi * Math.sin(delta_lon);\n\n    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {\n      return (93);\n    }\n    else {\n      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;\n      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));\n      b = Math.abs(y);\n\n      if (b >= 1) {\n        if ((b - 1) > EPSLN) {\n          return (93);\n        }\n        else {\n          y = 0;\n        }\n      }\n      else {\n        y = Math.acos(y);\n      }\n\n      if (lat < 0) {\n        y = -y;\n      }\n\n      y = this.a * this.k0 * (y - this.lat0) + this.y0;\n    }\n  }\n  else {\n    var al = cos_phi * delta_lon;\n    var als = Math.pow(al, 2);\n    var c = this.ep2 * Math.pow(cos_phi, 2);\n    var cs = Math.pow(c, 2);\n    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;\n    var t = Math.pow(tq, 2);\n    var ts = Math.pow(t, 2);\n    con = 1 - this.es * Math.pow(sin_phi, 2);\n    al = al / Math.sqrt(con);\n    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);\n\n    x = this.a * (this.k0 * al * (1 +\n      als / 6 * (1 - t + c +\n      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +\n      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +\n      this.x0;\n\n    y = this.a * (this.k0 * (ml - this.ml0 +\n      sin_phi * delta_lon * al / 2 * (1 +\n      als / 12 * (5 - t + 9 * c + 4 * cs +\n      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +\n      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +\n      this.y0;\n  }\n\n  p.x = x;\n  p.y = y;\n\n  return p;\n}\n\n/**\n    Transverse Mercator Inverse  -  x/y to long/lat\n  */\nfunction tmerc_inverse(p) {\n  var con, phi;\n  var lat, lon;\n  var x = (p.x - this.x0) * (1 / this.a);\n  var y = (p.y - this.y0) * (1 / this.a);\n\n  if (!this.es) {\n    var f = Math.exp(x / this.k0);\n    var g = 0.5 * (f - 1 / f);\n    var temp = this.lat0 + y / this.k0;\n    var h = Math.cos(temp);\n    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));\n    lat = Math.asin(con);\n\n    if (y < 0) {\n      lat = -lat;\n    }\n\n    if ((g === 0) && (h === 0)) {\n      lon = 0;\n    }\n    else {\n      lon = adjust_lon(Math.atan2(g, h) + this.long0);\n    }\n  }\n  else { // ellipsoidal form\n    con = this.ml0 + y / this.k0;\n    phi = pj_inv_mlfn(con, this.es, this.en);\n\n    if (Math.abs(phi) < HALF_PI) {\n      var sin_phi = Math.sin(phi);\n      var cos_phi = Math.cos(phi);\n      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;\n      var c = this.ep2 * Math.pow(cos_phi, 2);\n      var cs = Math.pow(c, 2);\n      var t = Math.pow(tan_phi, 2);\n      var ts = Math.pow(t, 2);\n      con = 1 - this.es * Math.pow(sin_phi, 2);\n      var d = x * Math.sqrt(con) / this.k0;\n      var ds = Math.pow(d, 2);\n      con = con * tan_phi;\n\n      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -\n        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -\n        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -\n        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));\n\n      lon = adjust_lon(this.long0 + (d * (1 -\n        ds / 6 * (1 + 2 * t + c -\n        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -\n        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));\n    }\n    else {\n      lat = HALF_PI * sign(y);\n      lon = 0;\n    }\n  }\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nvar tmerc_names = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];\n/* harmony default export */ var tmerc = ({\n  init: tmerc_init,\n  forward: tmerc_forward,\n  inverse: tmerc_inverse,\n  names: tmerc_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sinh.js\n/* harmony default export */ var sinh = (function(x) {\n  var r = Math.exp(x);\n  r = (r - 1 / r) / 2;\n  return r;\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/hypot.js\n/* harmony default export */ var hypot = (function(x, y) {\n  x = Math.abs(x);\n  y = Math.abs(y);\n  var a = Math.max(x, y);\n  var b = Math.min(x, y) / (a ? a : 1);\n\n  return a * Math.sqrt(1 + Math.pow(b, 2));\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/log1py.js\n/* harmony default export */ var log1py = (function(x) {\n  var y = 1 + x;\n  var z = y - 1;\n\n  return z === 0 ? x : x * Math.log(y) / z;\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinhy.js\n\n\n\n/* harmony default export */ var asinhy = (function(x) {\n  var y = Math.abs(x);\n  y = log1py(y * (1 + y / (hypot(1, y) + 1)));\n\n  return x < 0 ? -y : y;\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gatg.js\n/* harmony default export */ var gatg = (function(pp, B) {\n  var cos_2B = 2 * Math.cos(2 * B);\n  var i = pp.length - 1;\n  var h1 = pp[i];\n  var h2 = 0;\n  var h;\n\n  while (--i >= 0) {\n    h = -h2 + cos_2B * h1 + pp[i];\n    h2 = h1;\n    h1 = h;\n  }\n\n  return (B + h * Math.sin(2 * B));\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens.js\n/* harmony default export */ var clens = (function(pp, arg_r) {\n  var r = 2 * Math.cos(arg_r);\n  var i = pp.length - 1;\n  var hr1 = pp[i];\n  var hr2 = 0;\n  var hr;\n\n  while (--i >= 0) {\n    hr = -hr2 + r * hr1 + pp[i];\n    hr2 = hr1;\n    hr1 = hr;\n  }\n\n  return Math.sin(arg_r) * hr;\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/cosh.js\n/* harmony default export */ var cosh = (function(x) {\n  var r = Math.exp(x);\n  r = (r + 1 / r) / 2;\n  return r;\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens_cmplx.js\n\n\n\n/* harmony default export */ var clens_cmplx = (function(pp, arg_r, arg_i) {\n  var sin_arg_r = Math.sin(arg_r);\n  var cos_arg_r = Math.cos(arg_r);\n  var sinh_arg_i = sinh(arg_i);\n  var cosh_arg_i = cosh(arg_i);\n  var r = 2 * cos_arg_r * cosh_arg_i;\n  var i = -2 * sin_arg_r * sinh_arg_i;\n  var j = pp.length - 1;\n  var hr = pp[j];\n  var hi1 = 0;\n  var hr1 = 0;\n  var hi = 0;\n  var hr2;\n  var hi2;\n\n  while (--j >= 0) {\n    hr2 = hr1;\n    hi2 = hi1;\n    hr1 = hr;\n    hi1 = hi;\n    hr = -hr2 + r * hr1 - i * hi1 + pp[j];\n    hi = -hi2 + i * hr1 + r * hi1;\n  }\n\n  r = sin_arg_r * cosh_arg_i;\n  i = cos_arg_r * sinh_arg_i;\n\n  return [r * hr - i * hi, r * hi + i * hr];\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/etmerc.js\n// Heavily based on this etmerc projection implementation\n// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js\n\n\n\n\n\n\n\n\n\n\nfunction etmerc_init() {\n  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {\n    throw new Error(\'Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.\');\n  }\n  if (this.approx) {\n    // When \'+approx\' is set, use tmerc instead\n    tmerc.init.apply(this);\n    this.forward = tmerc.forward;\n    this.inverse = tmerc.inverse;\n  }\n\n  this.x0 = this.x0 !== undefined ? this.x0 : 0;\n  this.y0 = this.y0 !== undefined ? this.y0 : 0;\n  this.long0 = this.long0 !== undefined ? this.long0 : 0;\n  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;\n\n  this.cgb = [];\n  this.cbg = [];\n  this.utg = [];\n  this.gtu = [];\n\n  var f = this.es / (1 + Math.sqrt(1 - this.es));\n  var n = f / (2 - f);\n  var np = n;\n\n  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));\n  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));\n\n  np = np * n;\n  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));\n  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));\n\n  np = np * n;\n  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));\n  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));\n\n  np = np * n;\n  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));\n  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));\n\n  np = np * n;\n  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));\n  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));\n\n  np = np * n;\n  this.cgb[5] = np * (601676 / 22275);\n  this.cbg[5] = np * (444337 / 155925);\n\n  np = Math.pow(n, 2);\n  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));\n\n  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));\n  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));\n\n  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));\n  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));\n\n  np = np * n;\n  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));\n  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));\n\n  np = np * n;\n  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));\n  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));\n\n  np = np * n;\n  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));\n  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));\n\n  np = np * n;\n  this.utg[5] = np * (-20648693 / 638668800);\n  this.gtu[5] = np * (212378941 / 319334400);\n\n  var Z = gatg(this.cbg, this.lat0);\n  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));\n}\n\nfunction etmerc_forward(p) {\n  var Ce = adjust_lon(p.x - this.long0);\n  var Cn = p.y;\n\n  Cn = gatg(this.cbg, Cn);\n  var sin_Cn = Math.sin(Cn);\n  var cos_Cn = Math.cos(Cn);\n  var sin_Ce = Math.sin(Ce);\n  var cos_Ce = Math.cos(Ce);\n\n  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);\n  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));\n  Ce = asinhy(Math.tan(Ce));\n\n  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);\n\n  Cn = Cn + tmp[0];\n  Ce = Ce + tmp[1];\n\n  var x;\n  var y;\n\n  if (Math.abs(Ce) <= 2.623395162778) {\n    x = this.a * (this.Qn * Ce) + this.x0;\n    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;\n  }\n  else {\n    x = Infinity;\n    y = Infinity;\n  }\n\n  p.x = x;\n  p.y = y;\n\n  return p;\n}\n\nfunction etmerc_inverse(p) {\n  var Ce = (p.x - this.x0) * (1 / this.a);\n  var Cn = (p.y - this.y0) * (1 / this.a);\n\n  Cn = (Cn - this.Zb) / this.Qn;\n  Ce = Ce / this.Qn;\n\n  var lon;\n  var lat;\n\n  if (Math.abs(Ce) <= 2.623395162778) {\n    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);\n\n    Cn = Cn + tmp[0];\n    Ce = Ce + tmp[1];\n    Ce = Math.atan(sinh(Ce));\n\n    var sin_Cn = Math.sin(Cn);\n    var cos_Cn = Math.cos(Cn);\n    var sin_Ce = Math.sin(Ce);\n    var cos_Ce = Math.cos(Ce);\n\n    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));\n    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);\n\n    lon = adjust_lon(Ce + this.long0);\n    lat = gatg(this.cgb, Cn);\n  }\n  else {\n    lon = Infinity;\n    lat = Infinity;\n  }\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nvar etmerc_names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];\n/* harmony default export */ var etmerc = ({\n  init: etmerc_init,\n  forward: etmerc_forward,\n  inverse: etmerc_inverse,\n  names: etmerc_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_zone.js\n\n\n/* harmony default export */ var adjust_zone = (function(zone, lon) {\n  if (zone === undefined) {\n    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;\n\n    if (zone < 0) {\n      return 0;\n    } else if (zone > 60) {\n      return 60;\n    }\n  }\n  return zone;\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/utm.js\n\n\nvar dependsOn = \'etmerc\';\n\n\n\nfunction utm_init() {\n  var zone = adjust_zone(this.zone, this.long0);\n  if (zone === undefined) {\n    throw new Error(\'unknown utm zone\');\n  }\n  this.lat0 = 0;\n  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;\n  this.x0 = 500000;\n  this.y0 = this.utmSouth ? 10000000 : 0;\n  this.k0 = 0.9996;\n\n  etmerc.init.apply(this);\n  this.forward = etmerc.forward;\n  this.inverse = etmerc.inverse;\n}\n\nvar utm_names = ["Universal Transverse Mercator System", "utm"];\n/* harmony default export */ var utm = ({\n  init: utm_init,\n  names: utm_names,\n  dependsOn: dependsOn\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/srat.js\n/* harmony default export */ var srat = (function(esinp, exp) {\n  return (Math.pow((1 - esinp) / (1 + esinp), exp));\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gauss.js\n\nvar gauss_MAX_ITER = 20;\n\n\nfunction gauss_init() {\n  var sphi = Math.sin(this.lat0);\n  var cphi = Math.cos(this.lat0);\n  cphi *= cphi;\n  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);\n  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));\n  this.phic0 = Math.asin(sphi / this.C);\n  this.ratexp = 0.5 * this.C * this.e;\n  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));\n}\n\nfunction gauss_forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;\n  p.x = this.C * lon;\n  return p;\n}\n\nfunction gauss_inverse(p) {\n  var DEL_TOL = 1e-14;\n  var lon = p.x / this.C;\n  var lat = p.y;\n  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);\n  for (var i = gauss_MAX_ITER; i > 0; --i) {\n    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;\n    if (Math.abs(lat - p.y) < DEL_TOL) {\n      break;\n    }\n    p.y = lat;\n  }\n  /* convergence failed */\n  if (!i) {\n    return null;\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar gauss_names = ["gauss"];\n/* harmony default export */ var gauss = ({\n  init: gauss_init,\n  forward: gauss_forward,\n  inverse: gauss_inverse,\n  names: gauss_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sterea.js\n\n\n\nfunction sterea_init() {\n  gauss.init.apply(this);\n  if (!this.rc) {\n    return;\n  }\n  this.sinc0 = Math.sin(this.phic0);\n  this.cosc0 = Math.cos(this.phic0);\n  this.R2 = 2 * this.rc;\n  if (!this.title) {\n    this.title = "Oblique Stereographic Alternative";\n  }\n}\n\nfunction sterea_forward(p) {\n  var sinc, cosc, cosl, k;\n  p.x = adjust_lon(p.x - this.long0);\n  gauss.forward.apply(this, [p]);\n  sinc = Math.sin(p.y);\n  cosc = Math.cos(p.y);\n  cosl = Math.cos(p.x);\n  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);\n  p.x = k * cosc * Math.sin(p.x);\n  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);\n  p.x = this.a * p.x + this.x0;\n  p.y = this.a * p.y + this.y0;\n  return p;\n}\n\nfunction sterea_inverse(p) {\n  var sinc, cosc, lon, lat, rho;\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    var c = 2 * Math.atan2(rho, this.R2);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);\n    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  gauss.inverse.apply(this, [p]);\n  p.x = adjust_lon(p.x + this.long0);\n  return p;\n}\n\nvar sterea_names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];\n/* harmony default export */ var sterea = ({\n  init: sterea_init,\n  forward: sterea_forward,\n  inverse: sterea_inverse,\n  names: sterea_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/stere.js\n\n\n\n\n\n\n\n\nfunction ssfn_(phit, sinphi, eccen) {\n  sinphi *= eccen;\n  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));\n}\n\nfunction stere_init() {\n  this.coslat0 = Math.cos(this.lat0);\n  this.sinlat0 = Math.sin(this.lat0);\n  if (this.sphere) {\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));\n    }\n  }\n  else {\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      if (this.lat0 > 0) {\n        //North pole\n        //trace(\'stere:north pole\');\n        this.con = 1;\n      }\n      else {\n        //South pole\n        //trace(\'stere:south pole\');\n        this.con = -1;\n      }\n    }\n    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));\n    }\n    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);\n    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;\n    this.cosX0 = Math.cos(this.X0);\n    this.sinX0 = Math.sin(this.X0);\n  }\n}\n\n// Stereographic forward equations--mapping lat,long to x,y\nfunction stere_forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var sinlat = Math.sin(lat);\n  var coslat = Math.cos(lat);\n  var A, X, sinX, cosX, ts, rh;\n  var dlon = adjust_lon(lon - this.long0);\n\n  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {\n    //case of the origine point\n    //trace(\'stere:this is the origin point\');\n    p.x = NaN;\n    p.y = NaN;\n    return p;\n  }\n  if (this.sphere) {\n    //trace(\'stere:sphere case\');\n    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));\n    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;\n    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;\n    return p;\n  }\n  else {\n    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;\n    cosX = Math.cos(X);\n    sinX = Math.sin(X);\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);\n      rh = 2 * this.a * this.k0 * ts / this.cons;\n      p.x = this.x0 + rh * Math.sin(lon - this.long0);\n      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);\n      //trace(p.toString());\n      return p;\n    }\n    else if (Math.abs(this.sinlat0) < EPSLN) {\n      //Eq\n      //trace(\'stere:equateur\');\n      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));\n      p.y = A * sinX;\n    }\n    else {\n      //other case\n      //trace(\'stere:normal case\');\n      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));\n      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;\n    }\n    p.x = A * cosX * Math.sin(dlon) + this.x0;\n  }\n  //trace(p.toString());\n  return p;\n}\n\n//* Stereographic inverse equations--mapping x,y to lat/long\nfunction stere_inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var lon, lat, ts, ce, Chi;\n  var rh = Math.sqrt(p.x * p.x + p.y * p.y);\n  if (this.sphere) {\n    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));\n    lon = this.long0;\n    lat = this.lat0;\n    if (rh <= EPSLN) {\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);\n    if (Math.abs(this.coslat0) < EPSLN) {\n      if (this.lat0 > 0) {\n        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));\n      }\n      else {\n        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n      }\n    }\n    else {\n      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));\n    }\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      if (rh <= EPSLN) {\n        lat = this.lat0;\n        lon = this.long0;\n        p.x = lon;\n        p.y = lat;\n        //trace(p.toString());\n        return p;\n      }\n      p.x *= this.con;\n      p.y *= this.con;\n      ts = rh * this.cons / (2 * this.a * this.k0);\n      lat = this.con * phi2z(this.e, ts);\n      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));\n    }\n    else {\n      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));\n      lon = this.long0;\n      if (rh <= EPSLN) {\n        Chi = this.X0;\n      }\n      else {\n        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);\n        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));\n      }\n      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n\n  //trace(p.toString());\n  return p;\n\n}\n\nvar stere_names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];\n/* harmony default export */ var stere = ({\n  init: stere_init,\n  forward: stere_forward,\n  inverse: stere_inverse,\n  names: stere_names,\n  ssfn_: ssfn_\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/somerc.js\n/*\n  references:\n    Formules et constantes pour le Calcul pour la\n    projection cylindrique conforme à axe oblique et pour la transformation entre\n    des systèmes de référence.\n    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf\n  */\n\nfunction somerc_init() {\n  var phy0 = this.lat0;\n  this.lambda0 = this.long0;\n  var sinPhy0 = Math.sin(phy0);\n  var semiMajorAxis = this.a;\n  var invF = this.rf;\n  var flattening = 1 / invF;\n  var e2 = 2 * flattening - Math.pow(flattening, 2);\n  var e = this.e = Math.sqrt(e2);\n  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));\n  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));\n  this.b0 = Math.asin(sinPhy0 / this.alpha);\n  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));\n  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));\n  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));\n  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;\n}\n\nfunction somerc_forward(p) {\n  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));\n  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));\n  var S = -this.alpha * (Sa1 + Sa2) + this.K;\n\n  // spheric latitude\n  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);\n\n  // spheric longitude\n  var I = this.alpha * (p.x - this.lambda0);\n\n  // psoeudo equatorial rotation\n  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));\n\n  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));\n\n  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;\n  p.x = this.R * rotI + this.x0;\n  return p;\n}\n\nfunction somerc_inverse(p) {\n  var Y = p.x - this.x0;\n  var X = p.y - this.y0;\n\n  var rotI = Y / this.R;\n  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);\n\n  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));\n  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));\n\n  var lambda = this.lambda0 + I / this.alpha;\n\n  var S = 0;\n  var phy = b;\n  var prevPhy = -1000;\n  var iteration = 0;\n  while (Math.abs(phy - prevPhy) > 0.0000001) {\n    if (++iteration > 20) {\n      //...reportError("omercFwdInfinity");\n      return;\n    }\n    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));\n    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));\n    prevPhy = phy;\n    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;\n  }\n\n  p.x = lambda;\n  p.y = phy;\n  return p;\n}\n\nvar somerc_names = ["somerc"];\n/* harmony default export */ var somerc = ({\n  init: somerc_init,\n  forward: somerc_forward,\n  inverse: somerc_inverse,\n  names: somerc_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/omerc.js\n\n\n\n\n\nvar TOL = 1e-7;\n\nfunction isTypeA(P) {\n  var typeAProjections = [\'Hotine_Oblique_Mercator\',\'Hotine_Oblique_Mercator_Azimuth_Natural_Origin\'];\n  var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;\n  \n  return \'no_uoff\' in P || \'no_off\' in P || typeAProjections.indexOf(projectionName) !== -1;\n}\n\n\n/* Initialize the Oblique Mercator  projection\n    ------------------------------------------*/\nfunction omerc_init() {  \n  var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,\n    gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0, AB;\n  \n  // only Type A uses the no_off or no_uoff property\n  // https://github.com/OSGeo/proj.4/issues/104\n  this.no_off = isTypeA(this);\n  this.no_rot = \'no_rot\' in this;\n  \n  var alp = false;\n  if ("alpha" in this) {\n    alp = true;\n  }\n\n  var gam = false;\n  if ("rectified_grid_angle" in this) {\n    gam = true;\n  }\n\n  if (alp) {\n    alpha_c = this.alpha;\n  }\n  \n  if (gam) {\n    gamma = (this.rectified_grid_angle * D2R);\n  }\n  \n  if (alp || gam) {\n    lamc = this.longc;\n  } else {\n    lam1 = this.long1;\n    phi1 = this.lat1;\n    lam2 = this.long2;\n    phi2 = this.lat2;\n    \n    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||\n        Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||\n        Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {\n      throw new Error();\n    }\n  }\n  \n  var one_es = 1.0 - this.es;\n  com = Math.sqrt(one_es);\n  \n  if (Math.abs(this.lat0) > EPSLN) {\n    sinph0 = Math.sin(this.lat0);\n    cosph0 = Math.cos(this.lat0);\n    con = 1 - this.es * sinph0 * sinph0;\n    this.B = cosph0 * cosph0;\n    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);\n    this.A = this.B * this.k0 * com / con;\n    D = this.B * com / (cosph0 * Math.sqrt(con));\n    F = D * D -1;\n    \n    if (F <= 0) {\n      F = 0;\n    } else {\n      F = Math.sqrt(F);\n      if (this.lat0 < 0) {\n        F = -F;\n      }\n    }\n    \n    this.E = F += D;\n    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);\n  } else {\n    this.B = 1 / com;\n    this.A = this.k0;\n    this.E = D = F = 1;\n  }\n  \n  if (alp || gam) {\n    if (alp) {\n      gamma0 = Math.asin(Math.sin(alpha_c) / D);\n      if (!gam) {\n        gamma = alpha_c;\n      }\n    } else {\n      gamma0 = gamma;\n      alpha_c = Math.asin(D * Math.sin(gamma0));\n    }\n    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;\n  } else {\n    H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);\n    L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);\n    F = this.E / H;\n    p = (L - H) / (L + H);\n    J = this.E * this.E;\n    J = (J - L * H) / (J + L * H);\n    con = lam1 - lam2;\n    \n    if (con < -Math.pi) {\n      lam2 -=TWO_PI;\n    } else if (con > Math.pi) {\n      lam2 += TWO_PI;\n    }\n    \n    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);\n    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));\n    gamma = alpha_c = Math.asin(D * Math.sin(gamma0));\n  }\n  \n  this.singam = Math.sin(gamma0);\n  this.cosgam = Math.cos(gamma0);\n  this.sinrot = Math.sin(gamma);\n  this.cosrot = Math.cos(gamma);\n  \n  this.rB = 1 / this.B;\n  this.ArB = this.A * this.rB;\n  this.BrA = 1 / this.ArB;\n  AB = this.A * this.B;\n  \n  if (this.no_off) {\n    this.u_0 = 0;\n  } else {\n    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));\n    \n    if (this.lat0 < 0) {\n      this.u_0 = - this.u_0;\n    }  \n  }\n    \n  F = 0.5 * gamma0;\n  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));\n  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));\n}\n\n\n/* Oblique Mercator forward equations--mapping lat,long to x,y\n    ----------------------------------------------------------*/\nfunction omerc_forward(p) {\n  var coords = {};\n  var S, T, U, V, W, temp, u, v;\n  p.x = p.x - this.lam0;\n  \n  if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {\n    W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);\n    \n    temp = 1 / W;\n    S = 0.5 * (W - temp);\n    T = 0.5 * (W + temp);\n    V = Math.sin(this.B * p.x);\n    U = (S * this.singam - V * this.cosgam) / T;\n        \n    if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {\n      throw new Error();\n    }\n    \n    v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));\n    temp = Math.cos(this.B * p.x);\n    \n    if (Math.abs(temp) < TOL) {\n      u = this.A * p.x;\n    } else {\n      u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);\n    }    \n  } else {\n    v = p.y > 0 ? this.v_pole_n : this.v_pole_s;\n    u = this.ArB * p.y;\n  }\n     \n  if (this.no_rot) {\n    coords.x = u;\n    coords.y = v;\n  } else {\n    u -= this.u_0;\n    coords.x = v * this.cosrot + u * this.sinrot;\n    coords.y = u * this.cosrot - v * this.sinrot;\n  }\n  \n  coords.x = (this.a * coords.x + this.x0);\n  coords.y = (this.a * coords.y + this.y0);\n  \n  return coords;\n}\n\nfunction omerc_inverse(p) {\n  var u, v, Qp, Sp, Tp, Vp, Up;\n  var coords = {};\n  \n  p.x = (p.x - this.x0) * (1.0 / this.a);\n  p.y = (p.y - this.y0) * (1.0 / this.a);\n\n  if (this.no_rot) {\n    v = p.y;\n    u = p.x;\n  } else {\n    v = p.x * this.cosrot - p.y * this.sinrot;\n    u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;\n  }\n  \n  Qp = Math.exp(-this.BrA * v);\n  Sp = 0.5 * (Qp - 1 / Qp);\n  Tp = 0.5 * (Qp + 1 / Qp);\n  Vp = Math.sin(this.BrA * u);\n  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;\n  \n  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {\n    coords.x = 0;\n    coords.y = Up < 0 ? -HALF_PI : HALF_PI;\n  } else {\n    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));\n    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));\n    \n    if (coords.y === Infinity) {\n      throw new Error();\n    }\n        \n    coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));\n  }\n  \n  coords.x += this.lam0;\n  \n  return coords;\n}\n\nvar omerc_names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];\n/* harmony default export */ var omerc = ({\n  init: omerc_init,\n  forward: omerc_forward,\n  inverse: omerc_inverse,\n  names: omerc_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/lcc.js\n\n\n\n\n\n\nfunction lcc_init() {\n  \n  //double lat0;                    /* the reference latitude               */\n  //double long0;                   /* the reference longitude              */\n  //double lat1;                    /* first standard parallel              */\n  //double lat2;                    /* second standard parallel             */\n  //double r_maj;                   /* major axis                           */\n  //double r_min;                   /* minor axis                           */\n  //double false_east;              /* x offset in meters                   */\n  //double false_north;             /* y offset in meters                   */\n  \n  //the above value can be set with proj4.defs\n  //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");\n\n  if (!this.lat2) {\n    this.lat2 = this.lat1;\n  } //if lat2 is not defined\n  if (!this.k0) {\n    this.k0 = 1;\n  }\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n\n  var temp = this.b / this.a;\n  this.e = Math.sqrt(1 - temp * temp);\n\n  var sin1 = Math.sin(this.lat1);\n  var cos1 = Math.cos(this.lat1);\n  var ms1 = msfnz(this.e, sin1, cos1);\n  var ts1 = tsfnz(this.e, this.lat1, sin1);\n\n  var sin2 = Math.sin(this.lat2);\n  var cos2 = Math.cos(this.lat2);\n  var ms2 = msfnz(this.e, sin2, cos2);\n  var ts2 = tsfnz(this.e, this.lat2, sin2);\n\n  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));\n\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);\n  }\n  else {\n    this.ns = sin1;\n  }\n  if (isNaN(this.ns)) {\n    this.ns = sin1;\n  }\n  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));\n  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);\n  if (!this.title) {\n    this.title = "Lambert Conformal Conic";\n  }\n}\n\n// Lambert Conformal conic forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nfunction lcc_forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  // singular cases :\n  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {\n    lat = sign(lat) * (HALF_PI - 2 * EPSLN);\n  }\n\n  var con = Math.abs(Math.abs(lat) - HALF_PI);\n  var ts, rh1;\n  if (con > EPSLN) {\n    ts = tsfnz(this.e, lat, Math.sin(lat));\n    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);\n  }\n  else {\n    con = lat * this.ns;\n    if (con <= 0) {\n      return null;\n    }\n    rh1 = 0;\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;\n  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;\n\n  return p;\n}\n\n// Lambert Conformal Conic inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nfunction lcc_inverse(p) {\n\n  var rh1, con, ts;\n  var lat, lon;\n  var x = (p.x - this.x0) / this.k0;\n  var y = (this.rh - (p.y - this.y0) / this.k0);\n  if (this.ns > 0) {\n    rh1 = Math.sqrt(x * x + y * y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(x * x + y * y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2((con * x), (con * y));\n  }\n  if ((rh1 !== 0) || (this.ns > 0)) {\n    con = 1 / this.ns;\n    ts = Math.pow((rh1 / (this.a * this.f0)), con);\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  else {\n    lat = -HALF_PI;\n  }\n  lon = adjust_lon(theta / this.ns + this.long0);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar lcc_names = [\n  "Lambert Tangential Conformal Conic Projection",\n  "Lambert_Conformal_Conic",\n  "Lambert_Conformal_Conic_1SP",\n  "Lambert_Conformal_Conic_2SP",\n  "lcc",\n  "Lambert Conic Conformal (1SP)",\n  "Lambert Conic Conformal (2SP)"\n];\n\n/* harmony default export */ var lcc = ({\n  init: lcc_init,\n  forward: lcc_forward,\n  inverse: lcc_inverse,\n  names: lcc_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/krovak.js\n\n\nfunction krovak_init() {\n  this.a = 6377397.155;\n  this.es = 0.006674372230614;\n  this.e = Math.sqrt(this.es);\n  if (!this.lat0) {\n    this.lat0 = 0.863937979737193;\n  }\n  if (!this.long0) {\n    this.long0 = 0.7417649320975901 - 0.308341501185665;\n  }\n  /* if scale not set default to 0.9999 */\n  if (!this.k0) {\n    this.k0 = 0.9999;\n  }\n  this.s45 = 0.785398163397448; /* 45 */\n  this.s90 = 2 * this.s45;\n  this.fi0 = this.lat0;\n  this.e2 = this.es;\n  this.e = Math.sqrt(this.e2);\n  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));\n  this.uq = 1.04216856380474;\n  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);\n  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);\n  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;\n  this.k1 = this.k0;\n  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));\n  this.s0 = 1.37008346281555;\n  this.n = Math.sin(this.s0);\n  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);\n  this.ad = this.s90 - this.uq;\n}\n\n/* ellipsoid */\n/* calculate xy from lat/lon */\n/* Constants, identical to inverse transform function */\nfunction krovak_forward(p) {\n  var gfi, u, deltav, s, d, eps, ro;\n  var lon = p.x;\n  var lat = p.y;\n  var delta_lon = adjust_lon(lon - this.long0);\n  /* Transformation */\n  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));\n  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);\n  deltav = -delta_lon * this.alfa;\n  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));\n  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));\n  eps = this.n * d;\n  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);\n  p.y = ro * Math.cos(eps) / 1;\n  p.x = ro * Math.sin(eps) / 1;\n\n  if (!this.czech) {\n    p.y *= -1;\n    p.x *= -1;\n  }\n  return (p);\n}\n\n/* calculate lat/lon from xy */\nfunction krovak_inverse(p) {\n  var u, deltav, s, d, eps, ro, fi1;\n  var ok;\n\n  /* Transformation */\n  /* revert y, x*/\n  var tmp = p.x;\n  p.x = p.y;\n  p.y = tmp;\n  if (!this.czech) {\n    p.y *= -1;\n    p.x *= -1;\n  }\n  ro = Math.sqrt(p.x * p.x + p.y * p.y);\n  eps = Math.atan2(p.y, p.x);\n  d = eps / Math.sin(this.s0);\n  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);\n  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));\n  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));\n  p.x = this.long0 - deltav / this.alfa;\n  fi1 = u;\n  ok = 0;\n  var iter = 0;\n  do {\n    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);\n    if (Math.abs(fi1 - p.y) < 0.0000000001) {\n      ok = 1;\n    }\n    fi1 = p.y;\n    iter += 1;\n  } while (ok === 0 && iter < 15);\n  if (iter >= 15) {\n    return null;\n  }\n\n  return (p);\n}\n\nvar krovak_names = ["Krovak", "krovak"];\n/* harmony default export */ var krovak = ({\n  init: krovak_init,\n  forward: krovak_forward,\n  inverse: krovak_inverse,\n  names: krovak_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/mlfn.js\n/* harmony default export */ var mlfn = (function(e0, e1, e2, e3, phi) {\n  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e0fn.js\n/* harmony default export */ var e0fn = (function(x) {\n  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e1fn.js\n/* harmony default export */ var e1fn = (function(x) {\n  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e2fn.js\n/* harmony default export */ var e2fn = (function(x) {\n  return (0.05859375 * x * x * (1 + 0.75 * x));\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e3fn.js\n/* harmony default export */ var e3fn = (function(x) {\n  return (x * x * x * (35 / 3072));\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gN.js\n/* harmony default export */ var gN = (function(a, e, sinphi) {\n  var temp = e * sinphi;\n  return a / Math.sqrt(1 - temp * temp);\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lat.js\n\n\n\n/* harmony default export */ var adjust_lat = (function(x) {\n  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/imlfn.js\n/* harmony default export */ var imlfn = (function(ml, e0, e1, e2, e3) {\n  var phi;\n  var dphi;\n\n  phi = ml / e0;\n  for (var i = 0; i < 15; i++) {\n    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n\n  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");\n  return NaN;\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cass.js\n\n\n\n\n\n\n\n\n\n\n\nfunction cass_init() {\n  if (!this.sphere) {\n    this.e0 = e0fn(this.es);\n    this.e1 = e1fn(this.es);\n    this.e2 = e2fn(this.es);\n    this.e3 = e3fn(this.es);\n    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  }\n}\n\n/* Cassini forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nfunction cass_forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y;\n  var lam = p.x;\n  var phi = p.y;\n  lam = adjust_lon(lam - this.long0);\n\n  if (this.sphere) {\n    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));\n    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);\n  }\n  else {\n    //ellipsoid\n    var sinphi = Math.sin(phi);\n    var cosphi = Math.cos(phi);\n    var nl = gN(this.a, this.e, sinphi);\n    var tl = Math.tan(phi) * Math.tan(phi);\n    var al = lam * Math.cos(phi);\n    var asq = al * al;\n    var cl = this.es * cosphi * cosphi / (1 - this.es);\n    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n\n    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));\n    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);\n\n\n  }\n\n  p.x = x + this.x0;\n  p.y = y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nfunction cass_inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var phi, lam;\n\n  if (this.sphere) {\n    var dd = y + this.lat0;\n    phi = Math.asin(Math.sin(dd) * Math.cos(x));\n    lam = Math.atan2(Math.tan(x), Math.cos(dd));\n  }\n  else {\n    /* ellipsoid */\n    var ml1 = this.ml0 / this.a + y;\n    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);\n    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {\n      p.x = this.long0;\n      p.y = HALF_PI;\n      if (y < 0) {\n        p.y *= -1;\n      }\n      return p;\n    }\n    var nl1 = gN(this.a, this.e, Math.sin(phi1));\n\n    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);\n    var tl1 = Math.pow(Math.tan(phi1), 2);\n    var dl = x * this.a / nl1;\n    var dsq = dl * dl;\n    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);\n    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);\n\n  }\n\n  p.x = adjust_lon(lam + this.long0);\n  p.y = adjust_lat(phi);\n  return p;\n\n}\n\nvar cass_names = ["Cassini", "Cassini_Soldner", "cass"];\n/* harmony default export */ var cass = ({\n  init: cass_init,\n  forward: cass_forward,\n  inverse: cass_inverse,\n  names: cass_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/qsfnz.js\n/* harmony default export */ var qsfnz = (function(eccent, sinphi) {\n  var con;\n  if (eccent > 1.0e-7) {\n    con = eccent * sinphi;\n    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));\n  }\n  else {\n    return (2 * sinphi);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/laea.js\n\n\n\n\n\n\n/*\n  reference\n    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\nvar S_POLE = 1;\n\nvar N_POLE = 2;\nvar EQUIT = 3;\nvar OBLIQ = 4;\n\n/* Initialize the Lambert Azimuthal Equal Area projection\n  ------------------------------------------------------*/\nfunction laea_init() {\n  var t = Math.abs(this.lat0);\n  if (Math.abs(t - HALF_PI) < EPSLN) {\n    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;\n  }\n  else if (Math.abs(t) < EPSLN) {\n    this.mode = this.EQUIT;\n  }\n  else {\n    this.mode = this.OBLIQ;\n  }\n  if (this.es > 0) {\n    var sinphi;\n\n    this.qp = qsfnz(this.e, 1);\n    this.mmf = 0.5 / (1 - this.es);\n    this.apa = authset(this.es);\n    switch (this.mode) {\n    case this.N_POLE:\n      this.dd = 1;\n      break;\n    case this.S_POLE:\n      this.dd = 1;\n      break;\n    case this.EQUIT:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      this.dd = 1 / this.rq;\n      this.xmf = 1;\n      this.ymf = 0.5 * this.qp;\n      break;\n    case this.OBLIQ:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      sinphi = Math.sin(this.lat0);\n      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;\n      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);\n      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);\n      this.ymf = (this.xmf = this.rq) / this.dd;\n      this.xmf *= this.dd;\n      break;\n    }\n  }\n  else {\n    if (this.mode === this.OBLIQ) {\n      this.sinph0 = Math.sin(this.lat0);\n      this.cosph0 = Math.cos(this.lat0);\n    }\n  }\n}\n\n/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nfunction laea_forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;\n  var lam = p.x;\n  var phi = p.y;\n\n  lam = adjust_lon(lam - this.long0);\n  if (this.sphere) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    coslam = Math.cos(lam);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n      if (y <= EPSLN) {\n        return null;\n      }\n      y = Math.sqrt(2 / y);\n      x = y * cosphi * Math.sin(lam);\n      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        coslam = -coslam;\n      }\n      if (Math.abs(phi + this.lat0) < EPSLN) {\n        return null;\n      }\n      y = FORTPI - phi * 0.5;\n      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));\n      x = y * Math.sin(lam);\n      y *= coslam;\n    }\n  }\n  else {\n    sinb = 0;\n    cosb = 0;\n    b = 0;\n    coslam = Math.cos(lam);\n    sinlam = Math.sin(lam);\n    sinphi = Math.sin(phi);\n    q = qsfnz(this.e, sinphi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinb = q / this.qp;\n      cosb = Math.sqrt(1 - sinb * sinb);\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;\n      break;\n    case this.EQUIT:\n      b = 1 + cosb * coslam;\n      break;\n    case this.N_POLE:\n      b = HALF_PI + phi;\n      q = this.qp - q;\n      break;\n    case this.S_POLE:\n      b = phi - HALF_PI;\n      q = this.qp + q;\n      break;\n    }\n    if (Math.abs(b) < EPSLN) {\n      return null;\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n    case this.EQUIT:\n      b = Math.sqrt(2 / b);\n      if (this.mode === this.OBLIQ) {\n        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);\n      }\n      else {\n        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;\n      }\n      x = this.xmf * b * cosb * sinlam;\n      break;\n    case this.N_POLE:\n    case this.S_POLE:\n      if (q >= 0) {\n        x = (b = Math.sqrt(q)) * sinlam;\n        y = coslam * ((this.mode === this.S_POLE) ? b : -b);\n      }\n      else {\n        x = y = 0;\n      }\n      break;\n    }\n  }\n\n  p.x = this.a * x + this.x0;\n  p.y = this.a * y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nfunction laea_inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var lam, phi, cCe, sCe, q, rho, ab;\n  if (this.sphere) {\n    var cosz = 0,\n      rh, sinz = 0;\n\n    rh = Math.sqrt(x * x + y * y);\n    phi = rh * 0.5;\n    if (phi > 1) {\n      return null;\n    }\n    phi = 2 * Math.asin(phi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinz = Math.sin(phi);\n      cosz = Math.cos(phi);\n    }\n    switch (this.mode) {\n    case this.EQUIT:\n      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);\n      x *= sinz;\n      y = cosz * rh;\n      break;\n    case this.OBLIQ:\n      phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);\n      x *= sinz * this.cosph0;\n      y = (cosz - Math.sin(phi) * this.sinph0) * rh;\n      break;\n    case this.N_POLE:\n      y = -y;\n      phi = HALF_PI - phi;\n      break;\n    case this.S_POLE:\n      phi -= HALF_PI;\n      break;\n    }\n    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);\n  }\n  else {\n    ab = 0;\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      x /= this.dd;\n      y *= this.dd;\n      rho = Math.sqrt(x * x + y * y);\n      if (rho < EPSLN) {\n        p.x = this.long0;\n        p.y = this.lat0;\n        return p;\n      }\n      sCe = 2 * Math.asin(0.5 * rho / this.rq);\n      cCe = Math.cos(sCe);\n      x *= (sCe = Math.sin(sCe));\n      if (this.mode === this.OBLIQ) {\n        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;\n        q = this.qp * ab;\n        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;\n      }\n      else {\n        ab = y * sCe / rho;\n        q = this.qp * ab;\n        y = rho * cCe;\n      }\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        y = -y;\n      }\n      q = (x * x + y * y);\n      if (!q) {\n        p.x = this.long0;\n        p.y = this.lat0;\n        return p;\n      }\n      ab = 1 - q / this.qp;\n      if (this.mode === this.S_POLE) {\n        ab = -ab;\n      }\n    }\n    lam = Math.atan2(x, y);\n    phi = authlat(Math.asin(ab), this.apa);\n  }\n\n  p.x = adjust_lon(this.long0 + lam);\n  p.y = phi;\n  return p;\n}\n\n/* determine latitude from authalic latitude */\nvar P00 = 0.33333333333333333333;\n\nvar P01 = 0.17222222222222222222;\nvar P02 = 0.10257936507936507936;\nvar P10 = 0.06388888888888888888;\nvar P11 = 0.06640211640211640211;\nvar P20 = 0.01641501294219154443;\n\nfunction authset(es) {\n  var t;\n  var APA = [];\n  APA[0] = es * P00;\n  t = es * es;\n  APA[0] += t * P01;\n  APA[1] = t * P10;\n  t *= es;\n  APA[0] += t * P02;\n  APA[1] += t * P11;\n  APA[2] = t * P20;\n  return APA;\n}\n\nfunction authlat(beta, APA) {\n  var t = beta + beta;\n  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));\n}\n\nvar laea_names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];\n/* harmony default export */ var laea = ({\n  init: laea_init,\n  forward: laea_forward,\n  inverse: laea_inverse,\n  names: laea_names,\n  S_POLE: S_POLE,\n  N_POLE: N_POLE,\n  EQUIT: EQUIT,\n  OBLIQ: OBLIQ\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinz.js\n/* harmony default export */ var asinz = (function(x) {\n  if (Math.abs(x) > 1) {\n    x = (x > 1) ? 1 : -1;\n  }\n  return Math.asin(x);\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aea.js\n\n\n\n\n\n\nfunction aea_init() {\n\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e3 = Math.sqrt(this.es);\n\n  this.sin_po = Math.sin(this.lat1);\n  this.cos_po = Math.cos(this.lat1);\n  this.t1 = this.sin_po;\n  this.con = this.sin_po;\n  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);\n  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  this.sin_po = Math.sin(this.lat2);\n  this.cos_po = Math.cos(this.lat2);\n  this.t2 = this.sin_po;\n  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);\n  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  this.sin_po = Math.sin(this.lat0);\n  this.cos_po = Math.cos(this.lat0);\n  this.t3 = this.sin_po;\n  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);\n  }\n  else {\n    this.ns0 = this.con;\n  }\n  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;\n  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;\n}\n\n/* Albers Conical Equal Area forward equations--mapping lat,long to x,y\n  -------------------------------------------------------------------*/\nfunction aea_forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  this.sin_phi = Math.sin(lat);\n  this.cos_phi = Math.cos(lat);\n\n  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);\n  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;\n  var theta = this.ns0 * adjust_lon(lon - this.long0);\n  var x = rh1 * Math.sin(theta) + this.x0;\n  var y = this.rh - rh1 * Math.cos(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nfunction aea_inverse(p) {\n  var rh1, qs, con, theta, lon, lat;\n\n  p.x -= this.x0;\n  p.y = this.rh - p.y + this.y0;\n  if (this.ns0 >= 0) {\n    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n    con = -1;\n  }\n  theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p.x, con * p.y);\n  }\n  con = rh1 * this.ns0 / this.a;\n  if (this.sphere) {\n    lat = Math.asin((this.c - con * con) / (2 * this.ns0));\n  }\n  else {\n    qs = (this.c - con * con) / this.ns0;\n    lat = this.phi1z(this.e3, qs);\n  }\n\n  lon = adjust_lon(theta / this.ns0 + this.long0);\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\n/* Function to compute phi1, the latitude for the inverse of the\n   Albers Conical Equal-Area projection.\n-------------------------------------------*/\nfunction phi1z(eccent, qs) {\n  var sinphi, cosphi, con, com, dphi;\n  var phi = asinz(0.5 * qs);\n  if (eccent < EPSLN) {\n    return phi;\n  }\n\n  var eccnts = eccent * eccent;\n  for (var i = 1; i <= 25; i++) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    con = eccent * sinphi;\n    com = 1 - con * con;\n    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi = phi + dphi;\n    if (Math.abs(dphi) <= 1e-7) {\n      return phi;\n    }\n  }\n  return null;\n}\n\nvar aea_names = ["Albers_Conic_Equal_Area", "Albers", "aea"];\n/* harmony default export */ var aea = ({\n  init: aea_init,\n  forward: aea_forward,\n  inverse: aea_inverse,\n  names: aea_names,\n  phi1z: phi1z\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gnom.js\n\n\n\n\n/*\n  reference:\n    Wolfram Mathworld "Gnomonic Projection"\n    http://mathworld.wolfram.com/GnomonicProjection.html\n    Accessed: 12th November 2009\n  */\nfunction gnom_init() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n  // Approximation for projecting points to the horizon (infinity)\n  this.infinity_dist = 1000 * this.a;\n  this.rc = 1;\n}\n\n/* Gnomonic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nfunction gnom_forward(p) {\n  var sinphi, cosphi; /* sin and cos value        */\n  var dlon; /* delta longitude value      */\n  var coslon; /* cos of longitude        */\n  var ksp; /* scale factor          */\n  var g;\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  dlon = adjust_lon(lon - this.long0);\n\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if ((g > 0) || (Math.abs(g) <= EPSLN)) {\n    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;\n  }\n  else {\n\n    // Point is in the opposing hemisphere and is unprojectable\n    // We still need to return a reasonable point, so we project\n    // to infinity, on a bearing\n    // equivalent to the northern hemisphere equivalent\n    // This is a reasonable approximation for short shapes and lines that\n    // straddle the horizon.\n\n    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);\n    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nfunction gnom_inverse(p) {\n  var rh; /* Rho */\n  var sinc, cosc;\n  var c;\n  var lon, lat;\n\n  /* Inverse equations\n      -----------------*/\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n\n  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    c = Math.atan2(rh, this.rc);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n\n    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);\n    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);\n    lon = adjust_lon(this.long0 + lon);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar gnom_names = ["gnom"];\n/* harmony default export */ var gnom = ({\n  init: gnom_init,\n  forward: gnom_forward,\n  inverse: gnom_inverse,\n  names: gnom_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/common/iqsfnz.js\n\n\n/* harmony default export */ var iqsfnz = (function(eccent, q) {\n  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));\n  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {\n    if (q < 0) {\n      return (-1 * HALF_PI);\n    }\n    else {\n      return HALF_PI;\n    }\n  }\n  //var phi = 0.5* q/(1-eccent*eccent);\n  var phi = Math.asin(0.5 * q);\n  var dphi;\n  var sin_phi;\n  var cos_phi;\n  var con;\n  for (var i = 0; i < 30; i++) {\n    sin_phi = Math.sin(phi);\n    cos_phi = Math.cos(phi);\n    con = eccent * sin_phi;\n    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n\n  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");\n  return NaN;\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cea.js\n\n\n\n\n\n/*\n  reference:\n    "Cartographic Projection Procedures for the UNIX Environment-\n    A User\'s Manual" by Gerald I. Evenden,\n    USGS Open File Report 90-284and Release 4 Interim Reports (2003)\n*/\nfunction cea_init() {\n  //no-op\n  if (!this.sphere) {\n    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n  }\n}\n\n/* Cylindrical Equal Area forward equations--mapping lat,long to x,y\n    ------------------------------------------------------------*/\nfunction cea_forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var x, y;\n  /* Forward equations\n      -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  if (this.sphere) {\n    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);\n    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);\n  }\n  else {\n    var qs = qsfnz(this.e, Math.sin(lat));\n    x = this.x0 + this.a * this.k0 * dlon;\n    y = this.y0 + this.a * qs * 0.5 / this.k0;\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long\n    ------------------------------------------------------------*/\nfunction cea_inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));\n    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));\n  }\n  else {\n    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);\n    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar cea_names = ["cea"];\n/* harmony default export */ var cea = ({\n  init: cea_init,\n  forward: cea_forward,\n  inverse: cea_inverse,\n  names: cea_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqc.js\n\n\n\nfunction eqc_init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";\n\n  this.rc = Math.cos(this.lat_ts);\n}\n\n// forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nfunction eqc_forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  var dlon = adjust_lon(lon - this.long0);\n  var dlat = adjust_lat(lat - this.lat0);\n  p.x = this.x0 + (this.a * dlon * this.rc);\n  p.y = this.y0 + (this.a * dlat);\n  return p;\n}\n\n// inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nfunction eqc_inverse(p) {\n\n  var x = p.x;\n  var y = p.y;\n\n  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));\n  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));\n  return p;\n}\n\nvar eqc_names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];\n/* harmony default export */ var eqc = ({\n  init: eqc_init,\n  forward: eqc_forward,\n  inverse: eqc_inverse,\n  names: eqc_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/poly.js\n\n\n\n\n\n\n\n\n\n\nvar poly_MAX_ITER = 20;\n\nfunction poly_init() {\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles\n  this.e = Math.sqrt(this.es);\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas\n}\n\n/* Polyconic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nfunction poly_forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var x, y, el;\n  var dlon = adjust_lon(lon - this.long0);\n  el = dlon * Math.sin(lat);\n  if (this.sphere) {\n    if (Math.abs(lat) <= EPSLN) {\n      x = this.a * dlon;\n      y = -1 * this.a * this.lat0;\n    }\n    else {\n      x = this.a * Math.sin(el) / Math.tan(lat);\n      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));\n    }\n  }\n  else {\n    if (Math.abs(lat) <= EPSLN) {\n      x = this.a * dlon;\n      y = -1 * this.ml0;\n    }\n    else {\n      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);\n      x = nl * Math.sin(el);\n      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));\n    }\n\n  }\n  p.x = x + this.x0;\n  p.y = y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nfunction poly_inverse(p) {\n  var lon, lat, x, y, i;\n  var al, bl;\n  var phi, dphi;\n  x = p.x - this.x0;\n  y = p.y - this.y0;\n\n  if (this.sphere) {\n    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {\n      lon = adjust_lon(x / this.a + this.long0);\n      lat = 0;\n    }\n    else {\n      al = this.lat0 + y / this.a;\n      bl = x * x / this.a / this.a + al * al;\n      phi = al;\n      var tanphi;\n      for (i = poly_MAX_ITER; i; --i) {\n        tanphi = Math.tan(phi);\n        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);\n        phi += dphi;\n        if (Math.abs(dphi) <= EPSLN) {\n          lat = phi;\n          break;\n        }\n      }\n      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));\n    }\n  }\n  else {\n    if (Math.abs(y + this.ml0) <= EPSLN) {\n      lat = 0;\n      lon = adjust_lon(this.long0 + x / this.a);\n    }\n    else {\n\n      al = (this.ml0 + y) / this.a;\n      bl = x * x / this.a / this.a + al * al;\n      phi = al;\n      var cl, mln, mlnp, ma;\n      var con;\n      for (i = poly_MAX_ITER; i; --i) {\n        con = this.e * Math.sin(phi);\n        cl = Math.sqrt(1 - con * con) * Math.tan(phi);\n        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);\n        ma = mln / this.a;\n        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);\n        phi -= dphi;\n        if (Math.abs(dphi) <= EPSLN) {\n          lat = phi;\n          break;\n        }\n      }\n\n      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);\n      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);\n      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));\n    }\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar poly_names = ["Polyconic", "poly"];\n/* harmony default export */ var poly = ({\n  init: poly_init,\n  forward: poly_forward,\n  inverse: poly_inverse,\n  names: poly_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/nzmg.js\n\n\n/*\n  reference\n    Department of Land and Survey Technical Circular 1973/32\n      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf\n    OSG Technical Report 4.1\n      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf\n  */\n\n/**\n * iterations: Number of iterations to refine inverse transform.\n *     0 -> km accuracy\n *     1 -> m accuracy -- suitable for most mapping applications\n *     2 -> mm accuracy\n */\nvar iterations = 1;\n\nfunction nzmg_init() {\n  this.A = [];\n  this.A[1] = 0.6399175073;\n  this.A[2] = -0.1358797613;\n  this.A[3] = 0.063294409;\n  this.A[4] = -0.02526853;\n  this.A[5] = 0.0117879;\n  this.A[6] = -0.0055161;\n  this.A[7] = 0.0026906;\n  this.A[8] = -0.001333;\n  this.A[9] = 0.00067;\n  this.A[10] = -0.00034;\n\n  this.B_re = [];\n  this.B_im = [];\n  this.B_re[1] = 0.7557853228;\n  this.B_im[1] = 0;\n  this.B_re[2] = 0.249204646;\n  this.B_im[2] = 0.003371507;\n  this.B_re[3] = -0.001541739;\n  this.B_im[3] = 0.041058560;\n  this.B_re[4] = -0.10162907;\n  this.B_im[4] = 0.01727609;\n  this.B_re[5] = -0.26623489;\n  this.B_im[5] = -0.36249218;\n  this.B_re[6] = -0.6870983;\n  this.B_im[6] = -1.1651967;\n\n  this.C_re = [];\n  this.C_im = [];\n  this.C_re[1] = 1.3231270439;\n  this.C_im[1] = 0;\n  this.C_re[2] = -0.577245789;\n  this.C_im[2] = -0.007809598;\n  this.C_re[3] = 0.508307513;\n  this.C_im[3] = -0.112208952;\n  this.C_re[4] = -0.15094762;\n  this.C_im[4] = 0.18200602;\n  this.C_re[5] = 1.01418179;\n  this.C_im[5] = 1.64497696;\n  this.C_re[6] = 1.9660549;\n  this.C_im[6] = 2.5127645;\n\n  this.D = [];\n  this.D[1] = 1.5627014243;\n  this.D[2] = 0.5185406398;\n  this.D[3] = -0.03333098;\n  this.D[4] = -0.1052906;\n  this.D[5] = -0.0368594;\n  this.D[6] = 0.007317;\n  this.D[7] = 0.01220;\n  this.D[8] = 0.00394;\n  this.D[9] = -0.0013;\n}\n\n/**\n    New Zealand Map Grid Forward  - long/lat to x/y\n    long/lat in radians\n  */\nfunction nzmg_forward(p) {\n  var n;\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lat = lat - this.lat0;\n  var delta_lon = lon - this.long0;\n\n  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda\n  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.\n  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;\n  var d_lambda = delta_lon;\n  var d_phi_n = 1; // d_phi^0\n\n  var d_psi = 0;\n  for (n = 1; n <= 10; n++) {\n    d_phi_n = d_phi_n * d_phi;\n    d_psi = d_psi + this.A[n] * d_phi_n;\n  }\n\n  // 2. Calculate theta\n  var th_re = d_psi;\n  var th_im = d_lambda;\n\n  // 3. Calculate z\n  var th_n_re = 1;\n  var th_n_im = 0; // theta^0\n  var th_n_re1;\n  var th_n_im1;\n\n  var z_re = 0;\n  var z_im = 0;\n  for (n = 1; n <= 6; n++) {\n    th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n    th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n    th_n_re = th_n_re1;\n    th_n_im = th_n_im1;\n    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;\n    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;\n  }\n\n  // 4. Calculate easting and northing\n  p.x = (z_im * this.a) + this.x0;\n  p.y = (z_re * this.a) + this.y0;\n\n  return p;\n}\n\n/**\n    New Zealand Map Grid Inverse  -  x/y to long/lat\n  */\nfunction nzmg_inverse(p) {\n  var n;\n  var x = p.x;\n  var y = p.y;\n\n  var delta_x = x - this.x0;\n  var delta_y = y - this.y0;\n\n  // 1. Calculate z\n  var z_re = delta_y / this.a;\n  var z_im = delta_x / this.a;\n\n  // 2a. Calculate theta - first approximation gives km accuracy\n  var z_n_re = 1;\n  var z_n_im = 0; // z^0\n  var z_n_re1;\n  var z_n_im1;\n\n  var th_re = 0;\n  var th_im = 0;\n  for (n = 1; n <= 6; n++) {\n    z_n_re1 = z_n_re * z_re - z_n_im * z_im;\n    z_n_im1 = z_n_im * z_re + z_n_re * z_im;\n    z_n_re = z_n_re1;\n    z_n_im = z_n_im1;\n    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;\n    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;\n  }\n\n  // 2b. Iterate to refine the accuracy of the calculation\n  //        0 iterations gives km accuracy\n  //        1 iteration gives m accuracy -- good enough for most mapping applications\n  //        2 iterations bives mm accuracy\n  for (var i = 0; i < this.iterations; i++) {\n    var th_n_re = th_re;\n    var th_n_im = th_im;\n    var th_n_re1;\n    var th_n_im1;\n\n    var num_re = z_re;\n    var num_im = z_im;\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    th_n_re = 1;\n    th_n_im = 0;\n    var den_re = this.B_re[1];\n    var den_im = this.B_im[1];\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    // Complex division\n    var den2 = den_re * den_re + den_im * den_im;\n    th_re = (num_re * den_re + num_im * den_im) / den2;\n    th_im = (num_im * den_re - num_re * den_im) / den2;\n  }\n\n  // 3. Calculate d_phi              ...                                    // and d_lambda\n  var d_psi = th_re;\n  var d_lambda = th_im;\n  var d_psi_n = 1; // d_psi^0\n\n  var d_phi = 0;\n  for (n = 1; n <= 9; n++) {\n    d_psi_n = d_psi_n * d_psi;\n    d_phi = d_phi + this.D[n] * d_psi_n;\n  }\n\n  // 4. Calculate latitude and longitude\n  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.\n  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);\n  var lon = this.long0 + d_lambda;\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nvar nzmg_names = ["New_Zealand_Map_Grid", "nzmg"];\n/* harmony default export */ var nzmg = ({\n  init: nzmg_init,\n  forward: nzmg_forward,\n  inverse: nzmg_inverse,\n  names: nzmg_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/mill.js\n\n\n/*\n  reference\n    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\n\n/* Initialize the Miller Cylindrical projection\n  -------------------------------------------*/\nfunction mill_init() {\n  //no-op\n}\n\n/* Miller Cylindrical forward equations--mapping lat,long to x,y\n    ------------------------------------------------------------*/\nfunction mill_forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  var x = this.x0 + this.a * dlon;\n  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Miller Cylindrical inverse equations--mapping x,y to lat/long\n    ------------------------------------------------------------*/\nfunction mill_inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n\n  var lon = adjust_lon(this.long0 + p.x / this.a);\n  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar mill_names = ["Miller_Cylindrical", "mill"];\n/* harmony default export */ var mill = ({\n  init: mill_init,\n  forward: mill_forward,\n  inverse: mill_inverse,\n  names: mill_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sinu.js\n\n\n\nvar sinu_MAX_ITER = 20;\n\n\n\n\n\n\n\nfunction sinu_init() {\n  /* Place parameters in static storage for common use\n    -------------------------------------------------*/\n\n\n  if (!this.sphere) {\n    this.en = pj_enfn(this.es);\n  }\n  else {\n    this.n = 1;\n    this.m = 0;\n    this.es = 0;\n    this.C_y = Math.sqrt((this.m + 1) / this.n);\n    this.C_x = this.C_y / (this.m + 1);\n  }\n\n}\n\n/* Sinusoidal forward equations--mapping lat,long to x,y\n  -----------------------------------------------------*/\nfunction sinu_forward(p) {\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n    -----------------*/\n  lon = adjust_lon(lon - this.long0);\n\n  if (this.sphere) {\n    if (!this.m) {\n      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;\n    }\n    else {\n      var k = this.n * Math.sin(lat);\n      for (var i = sinu_MAX_ITER; i; --i) {\n        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));\n        lat -= V;\n        if (Math.abs(V) < EPSLN) {\n          break;\n        }\n      }\n    }\n    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));\n    y = this.a * this.C_y * lat;\n\n  }\n  else {\n\n    var s = Math.sin(lat);\n    var c = Math.cos(lat);\n    y = this.a * pj_mlfn(lat, s, c, this.en);\n    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nfunction sinu_inverse(p) {\n  var lat, temp, lon, s;\n\n  p.x -= this.x0;\n  lon = p.x / this.a;\n  p.y -= this.y0;\n  lat = p.y / this.a;\n\n  if (this.sphere) {\n    lat /= this.C_y;\n    lon = lon / (this.C_x * (this.m + Math.cos(lat)));\n    if (this.m) {\n      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);\n    }\n    else if (this.n !== 1) {\n      lat = asinz(Math.sin(lat) / this.n);\n    }\n    lon = adjust_lon(lon + this.long0);\n    lat = adjust_lat(lat);\n  }\n  else {\n    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);\n    s = Math.abs(lat);\n    if (s < HALF_PI) {\n      s = Math.sin(lat);\n      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));\n      //temp = this.long0 + p.x / (this.a * Math.cos(lat));\n      lon = adjust_lon(temp);\n    }\n    else if ((s - EPSLN) < HALF_PI) {\n      lon = this.long0;\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar sinu_names = ["Sinusoidal", "sinu"];\n/* harmony default export */ var sinu = ({\n  init: sinu_init,\n  forward: sinu_forward,\n  inverse: sinu_inverse,\n  names: sinu_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/moll.js\n\nfunction moll_init() {}\n\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\nfunction moll_forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n  while (true) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n  theta /= 2;\n\n  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"\n       this is done here because of precision problems with "cos(theta)"\n       --------------------------------------------------------------------------*/\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nfunction moll_inverse(p) {\n  var theta;\n  var arg;\n\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n\n  /* Because of division by zero problems, \'arg\' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));\n  if (lon < (-Math.PI)) {\n    lon = -Math.PI;\n  }\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n  var lat = Math.asin(arg);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar moll_names = ["Mollweide", "moll"];\n/* harmony default export */ var moll = ({\n  init: moll_init,\n  forward: moll_forward,\n  inverse: moll_inverse,\n  names: moll_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqdc.js\n\n\n\n\n\n\n\n\n\n\n\nfunction eqdc_init() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  this.lat2 = this.lat2 || this.lat1;\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e = Math.sqrt(this.es);\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n\n  this.sinphi = Math.sin(this.lat1);\n  this.cosphi = Math.cos(this.lat1);\n\n  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);\n  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);\n\n  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {\n    this.ns = this.sinphi;\n  }\n  else {\n    this.sinphi = Math.sin(this.lat2);\n    this.cosphi = Math.cos(this.lat2);\n    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);\n    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);\n    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);\n  }\n  this.g = this.ml1 + this.ms1 / this.ns;\n  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  this.rh = this.a * (this.g - this.ml0);\n}\n\n/* Equidistant Conic forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------*/\nfunction eqdc_forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var rh1;\n\n  /* Forward equations\n      -----------------*/\n  if (this.sphere) {\n    rh1 = this.a * (this.g - lat);\n  }\n  else {\n    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);\n    rh1 = this.a * (this.g - ml);\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  var x = this.x0 + rh1 * Math.sin(theta);\n  var y = this.y0 + this.rh - rh1 * Math.cos(theta);\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nfunction eqdc_inverse(p) {\n  p.x -= this.x0;\n  p.y = this.rh - p.y + this.y0;\n  var con, rh1, lat, lon;\n  if (this.ns >= 0) {\n    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p.x, con * p.y);\n  }\n\n  if (this.sphere) {\n    lon = adjust_lon(this.long0 + theta / this.ns);\n    lat = adjust_lat(this.g - rh1 / this.a);\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    var ml = this.g - rh1 / this.a;\n    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);\n    lon = adjust_lon(this.long0 + theta / this.ns);\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n\n}\n\nvar eqdc_names = ["Equidistant_Conic", "eqdc"];\n/* harmony default export */ var eqdc = ({\n  init: eqdc_init,\n  forward: eqdc_forward,\n  inverse: eqdc_inverse,\n  names: eqdc_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/vandg.js\n\n\n\n\n\n\n/* Initialize the Van Der Grinten projection\n  ----------------------------------------*/\nfunction vandg_init() {\n  //this.R = 6370997; //Radius of earth\n  this.R = this.a;\n}\n\nfunction vandg_forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  /* Forward equations\n    -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  var x, y;\n\n  if (Math.abs(lat) <= EPSLN) {\n    x = this.x0 + this.R * dlon;\n    y = this.y0;\n  }\n  var theta = asinz(2 * Math.abs(lat / Math.PI));\n  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {\n    x = this.x0;\n    if (lat >= 0) {\n      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);\n    }\n    else {\n      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);\n    }\n    //  return(OK);\n  }\n  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));\n  var asq = al * al;\n  var sinth = Math.sin(theta);\n  var costh = Math.cos(theta);\n\n  var g = costh / (sinth + costh - 1);\n  var gsq = g * g;\n  var m = g * (2 / sinth - 1);\n  var msq = m * m;\n  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);\n  if (dlon < 0) {\n    con = -con;\n  }\n  x = this.x0 + con;\n  //con = Math.abs(con / (Math.PI * this.R));\n  var q = asq + g;\n  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);\n  if (lat >= 0) {\n    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n    y = this.y0 + con;\n  }\n  else {\n    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n    y = this.y0 - con;\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Van Der Grinten inverse equations--mapping x,y to lat/long\n  ---------------------------------------------------------*/\nfunction vandg_inverse(p) {\n  var lon, lat;\n  var xx, yy, xys, c1, c2, c3;\n  var a1;\n  var m1;\n  var con;\n  var th1;\n  var d;\n\n  /* inverse equations\n    -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  con = Math.PI * this.R;\n  xx = p.x / con;\n  yy = p.y / con;\n  xys = xx * xx + yy * yy;\n  c1 = -Math.abs(yy) * (1 + xys);\n  c2 = c1 - 2 * yy * yy + xx * xx;\n  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;\n  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;\n  a1 = (c1 - c2 * c2 / 3 / c3) / c3;\n  m1 = 2 * Math.sqrt(-a1 / 3);\n  con = ((3 * d) / a1) / m1;\n  if (Math.abs(con) > 1) {\n    if (con >= 0) {\n      con = 1;\n    }\n    else {\n      con = -1;\n    }\n  }\n  th1 = Math.acos(con) / 3;\n  if (p.y >= 0) {\n    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n  else {\n    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n\n  if (Math.abs(xx) < EPSLN) {\n    lon = this.long0;\n  }\n  else {\n    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar vandg_names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];\n/* harmony default export */ var vandg = ({\n  init: vandg_init,\n  forward: vandg_forward,\n  inverse: vandg_inverse,\n  names: vandg_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aeqd.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction aeqd_init() {\n  this.sin_p12 = Math.sin(this.lat0);\n  this.cos_p12 = Math.cos(this.lat0);\n}\n\nfunction aeqd_forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var sinphi = Math.sin(p.y);\n  var cosphi = Math.cos(p.y);\n  var dlon = adjust_lon(lon - this.long0);\n  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;\n  if (this.sphere) {\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North Pole case\n      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);\n      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South Pole case\n      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);\n      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);\n      return p;\n    }\n    else {\n      //default case\n      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);\n      c = Math.acos(cos_c);\n      kp = c ? c / Math.sin(c) : 1;\n      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);\n      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));\n      return p;\n    }\n  }\n  else {\n    e0 = e0fn(this.es);\n    e1 = e1fn(this.es);\n    e2 = e2fn(this.es);\n    e3 = e3fn(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North Pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);\n      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South Pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);\n      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);\n      return p;\n    }\n    else {\n      //Default case\n      tanphi = sinphi / cosphi;\n      Nl1 = gN(this.a, this.e, this.sin_p12);\n      Nl = gN(this.a, this.e, sinphi);\n      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));\n      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));\n      if (Az === 0) {\n        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      }\n      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {\n        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      }\n      else {\n        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));\n      }\n      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);\n      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);\n      GH = G * H;\n      Hs = H * H;\n      s2 = s * s;\n      s3 = s2 * s;\n      s4 = s3 * s;\n      s5 = s4 * s;\n      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);\n      p.x = this.x0 + c * Math.sin(Az);\n      p.y = this.y0 + c * Math.cos(Az);\n      return p;\n    }\n  }\n\n\n}\n\nfunction aeqd_inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;\n  if (this.sphere) {\n    rh = Math.sqrt(p.x * p.x + p.y * p.y);\n    if (rh > (2 * HALF_PI * this.a)) {\n      return;\n    }\n    z = rh / this.a;\n\n    sinz = Math.sin(z);\n    cosz = Math.cos(z);\n\n    lon = this.long0;\n    if (Math.abs(rh) <= EPSLN) {\n      lat = this.lat0;\n    }\n    else {\n      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);\n      con = Math.abs(this.lat0) - HALF_PI;\n      if (Math.abs(con) <= EPSLN) {\n        if (this.lat0 >= 0) {\n          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));\n        }\n        else {\n          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));\n        }\n      }\n      else {\n        /*con = cosz - this.sin_p12 * Math.sin(lat);\n        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {\n          //no-op, just keep the lon value as is\n        } else {\n          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));\n          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));\n        }*/\n        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));\n      }\n    }\n\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    e0 = e0fn(this.es);\n    e1 = e1fn(this.es);\n    e2 = e2fn(this.es);\n    e3 = e3fn(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      M = Mlp - rh;\n      lat = imlfn(M / this.a, e0, e1, e2, e3);\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      M = rh - Mlp;\n\n      lat = imlfn(M / this.a, e0, e1, e2, e3);\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    else {\n      //default case\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      Az = Math.atan2(p.x, p.y);\n      N1 = gN(this.a, this.e, this.sin_p12);\n      cosAz = Math.cos(Az);\n      tmp = this.e * this.cos_p12 * cosAz;\n      A = -tmp * tmp / (1 - this.es);\n      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);\n      D = rh / N1;\n      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;\n      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;\n      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);\n      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));\n      sinpsi = Math.sin(psi);\n      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n  }\n\n}\n\nvar aeqd_names = ["Azimuthal_Equidistant", "aeqd"];\n/* harmony default export */ var aeqd = ({\n  init: aeqd_init,\n  forward: aeqd_forward,\n  inverse: aeqd_inverse,\n  names: aeqd_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/ortho.js\n\n\n\n\nfunction ortho_init() {\n  //double temp;      /* temporary variable    */\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n}\n\n/* Orthographic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nfunction ortho_forward(p) {\n  var sinphi, cosphi; /* sin and cos value        */\n  var dlon; /* delta longitude value      */\n  var coslon; /* cos of longitude        */\n  var ksp; /* scale factor          */\n  var g, x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  dlon = adjust_lon(lon - this.long0);\n\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if ((g > 0) || (Math.abs(g) <= EPSLN)) {\n    x = this.a * ksp * cosphi * Math.sin(dlon);\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nfunction ortho_inverse(p) {\n  var rh; /* height above ellipsoid      */\n  var z; /* angle          */\n  var sinz, cosz; /* sin of z and cos of z      */\n  var con;\n  var lon, lat;\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  rh = Math.sqrt(p.x * p.x + p.y * p.y);\n  z = asinz(rh / this.a);\n\n  sinz = Math.sin(z);\n  cosz = Math.cos(z);\n\n  lon = this.long0;\n  if (Math.abs(rh) <= EPSLN) {\n    lat = this.lat0;\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);\n  con = Math.abs(this.lat0) - HALF_PI;\n  if (Math.abs(con) <= EPSLN) {\n    if (this.lat0 >= 0) {\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));\n    }\n    else {\n      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));\n    }\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar ortho_names = ["ortho"];\n/* harmony default export */ var ortho = ({\n  init: ortho_init,\n  forward: ortho_forward,\n  inverse: ortho_inverse,\n  names: ortho_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/qsc.js\n// QSC projection rewritten from the original PROJ4\n// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\n\n\n\n/* constants */\nvar FACE_ENUM = {\n    FRONT: 1,\n    RIGHT: 2,\n    BACK: 3,\n    LEFT: 4,\n    TOP: 5,\n    BOTTOM: 6\n};\n\nvar AREA_ENUM = {\n    AREA_0: 1,\n    AREA_1: 2,\n    AREA_2: 3,\n    AREA_3: 4\n};\n\nfunction qsc_init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || "Quadrilateralized Spherical Cube";\n\n  /* Determine the cube face from the center of projection. */\n  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= FORTPI) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n\n  /* Fill in useful values for the ellipsoid <-> sphere shift\n   * described in [LK12]. */\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n}\n\n// QSC forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nfunction qsc_forward(p) {\n  var xy = {x: 0, y: 0};\n  var lat, lon;\n  var theta, phi;\n  var t, mu;\n  /* nu; */\n  var area = {value: 0};\n\n  // move lon according to projection\'s lon\n  p.x -= this.long0;\n\n  /* Convert the geodetic latitude to a geocentric latitude.\n   * This corresponds to the shift from the ellipsoid to the sphere\n   * described in [LK12]. */\n  if (this.es !== 0) {//if (P->es != 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n  } else {\n    lat = p.y;\n  }\n\n  /* Convert the input lat, lon into theta, phi as used by QSC.\n   * This depends on the cube face and the area on it.\n   * For the top and bottom face, we can compute theta and phi\n   * directly from phi, lam. For the other faces, we must use\n   * unit sphere cartesian coordinates as an intermediate step. */\n  lon = p.x; //lon = lp.lam;\n  if (this.face === FACE_ENUM.TOP) {\n    phi = HALF_PI - lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - HALF_PI;\n    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = (lon > 0.0 ? lon - SPI : lon + SPI);\n    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = HALF_PI + lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + HALF_PI;\n    } else if (lon < FORTPI && lon >= -FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);\n    }\n  } else {\n    var q, r, s;\n    var sinlat, coslat;\n    var sinlon, coslon;\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n    }\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q = coslat * coslon;\n    r = coslat * sinlon;\n    s = sinlat;\n\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q);\n      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r);\n      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q);\n      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r);\n      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n    } else {\n      /* Impossible */\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n\n  /* Compute mu and nu for the area of definition.\n   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n\n  /* Apply the result to the real area. */\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += HALF_PI;\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += SPI;\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * SPI;\n  }\n\n  /* Now compute x, y from mu and nu */\n  xy.x = t * Math.cos(mu);\n  xy.y = t * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n\n  p.x = xy.x;\n  p.y = xy.y;\n  return p;\n}\n\n// QSC inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nfunction qsc_inverse(p) {\n  var lp = {lam: 0, phi: 0};\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t;\n  var area = {value: 0};\n\n  /* de-offset */\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  /* Convert the input x, y to the mu and nu angles as used by QSC.\n   * This depends on the area of the cube face. */\n  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n  mu = Math.atan2(p.y, p.x);\n  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= HALF_PI;\n  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = (mu < 0.0 ? mu + SPI : mu - SPI);\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += HALF_PI;\n  }\n\n  /* Compute phi and theta for the area of definition.\n   * The inverse projection is not described in the original paper, but some\n   * good hints can be found here (as of 2011-12-14):\n   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */\n  t = (SPI / 12) * Math.tan(mu);\n  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > +1) {\n    cosphi = +1;\n  }\n\n  /* Apply the result to the real area on the cube face.\n   * For the top and bottom face, we can compute phi and lam directly.\n   * For the other faces, we must use unit sphere cartesian coordinates\n   * as an intermediate step. */\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = HALF_PI - phi;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = theta;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - HALF_PI;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);\n    }\n  } else {\n    /* Compute phi and lam via cartesian unit sphere coordinates. */\n    var q, r, s;\n    q = cosphi;\n    t = q * q;\n    if (t >= 1) {\n      s = 0;\n    } else {\n      s = Math.sqrt(1 - t) * Math.sin(theta);\n    }\n    t += s * s;\n    if (t >= 1) {\n      r = 0;\n    } else {\n      r = Math.sqrt(1 - t);\n    }\n    /* Rotate q,r,s into the correct area. */\n    if (area.value === AREA_ENUM.AREA_1) {\n      t = r;\n      r = -s;\n      s = t;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r = -r;\n      s = -s;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t = r;\n      r = s;\n      s = -t;\n    }\n    /* Rotate q,r,s into the correct cube face. */\n    if (this.face === FACE_ENUM.RIGHT) {\n      t = q;\n      q = -r;\n      r = t;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q = -q;\n      r = -r;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t = q;\n      q = r;\n      r = -t;\n    }\n    /* Now compute phi and lam from the unit sphere coordinates. */\n    lp.phi = Math.acos(-s) - HALF_PI;\n    lp.lam = Math.atan2(r, q);\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n    }\n  }\n\n  /* Apply the shift from the sphere to the ellipsoid as described\n   * in [LK12]. */\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = (lp.phi < 0 ? 1 : 0);\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n\n  lp.lam += this.long0;\n  p.x = lp.lam;\n  p.y = lp.phi;\n  return p;\n}\n\n/* Helper function for forward projection: compute the theta angle\n * and determine the area number. */\nfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n  var theta;\n  if (phi < EPSLN) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0.0;\n  } else {\n    theta = Math.atan2(y, x);\n    if (Math.abs(theta) <= FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= HALF_PI;\n    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += HALF_PI;\n    }\n  }\n  return theta;\n}\n\n/* Helper function: shift the longitude. */\nfunction qsc_shift_lon_origin(lon, offset) {\n  var slon = lon + offset;\n  if (slon < -SPI) {\n    slon += TWO_PI;\n  } else if (slon > +SPI) {\n    slon -= TWO_PI;\n  }\n  return slon;\n}\n\nvar qsc_names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];\n/* harmony default export */ var qsc = ({\n  init: qsc_init,\n  forward: qsc_forward,\n  inverse: qsc_inverse,\n  names: qsc_names\n});\n\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/robin.js\n// Robinson projection\n// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c\n// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039\n\n\n\n\nvar COEFS_X = [\n    [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],\n    [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],\n    [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],\n    [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],\n    [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],\n    [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],\n    [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],\n    [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],\n    [0.9216, -0.00467746, -0.00010457, 4.81243e-06],\n    [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],\n    [0.8679, -0.00609363, -0.000113898, 3.32484e-06],\n    [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],\n    [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],\n    [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],\n    [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],\n    [0.6732, -0.00986209, -0.000199569, 1.91974e-05],\n    [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],\n    [0.5722, -0.00906601, 0.000182, 6.24051e-06],\n    [0.5322, -0.00677797, 0.000275608, 6.24051e-06]\n];\n\nvar COEFS_Y = [\n    [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],\n    [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],\n    [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],\n    [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],\n    [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],\n    [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],\n    [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],\n    [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],\n    [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],\n    [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],\n    [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],\n    [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],\n    [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],\n    [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],\n    [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],\n    [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],\n    [0.9394, 0.00840947, -0.000192841, -4.2106e-06],\n    [0.9761, 0.00616527, -0.000256, -4.2106e-06],\n    [1.0000, 0.00328947, -0.000319159, -4.2106e-06]\n];\n\nvar FXC = 0.8487;\nvar FYC = 1.3523;\nvar C1 = R2D/5; // rad to 5-degree interval\nvar RC1 = 1/C1;\nvar NODES = 18;\n\nvar poly3_val = function(coefs, x) {\n    return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));\n};\n\nvar poly3_der = function(coefs, x) {\n    return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);\n};\n\nfunction newton_rapshon(f_df, start, max_err, iters) {\n    var x = start;\n    for (; iters; --iters) {\n        var upd = f_df(x);\n        x -= upd;\n        if (Math.abs(upd) < max_err) {\n            break;\n        }\n    }\n    return x;\n}\n\nfunction robin_init() {\n    this.x0 = this.x0 || 0;\n    this.y0 = this.y0 || 0;\n    this.long0 = this.long0 || 0;\n    this.es = 0;\n    this.title = this.title || "Robinson";\n}\n\nfunction robin_forward(ll) {\n    var lon = adjust_lon(ll.x - this.long0);\n\n    var dphi = Math.abs(ll.y);\n    var i = Math.floor(dphi * C1);\n    if (i < 0) {\n        i = 0;\n    } else if (i >= NODES) {\n        i = NODES - 1;\n    }\n    dphi = R2D * (dphi - RC1 * i);\n    var xy = {\n        x: poly3_val(COEFS_X[i], dphi) * lon,\n        y: poly3_val(COEFS_Y[i], dphi)\n    };\n    if (ll.y < 0) {\n        xy.y = -xy.y;\n    }\n\n    xy.x = xy.x * this.a * FXC + this.x0;\n    xy.y = xy.y * this.a * FYC + this.y0;\n    return xy;\n}\n\nfunction robin_inverse(xy) {\n    var ll = {\n        x: (xy.x - this.x0) / (this.a * FXC),\n        y: Math.abs(xy.y - this.y0) / (this.a * FYC)\n    };\n\n    if (ll.y >= 1) { // pathologic case\n        ll.x /= COEFS_X[NODES][0];\n        ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;\n    } else {\n        // find table interval\n        var i = Math.floor(ll.y * NODES);\n        if (i < 0) {\n            i = 0;\n        } else if (i >= NODES) {\n            i = NODES - 1;\n        }\n        for (;;) {\n            if (COEFS_Y[i][0] > ll.y) {\n                --i;\n            } else if (COEFS_Y[i+1][0] <= ll.y) {\n                ++i;\n            } else {\n                break;\n            }\n        }\n        // linear interpolation in 5 degree interval\n        var coefs = COEFS_Y[i];\n        var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);\n        // find t so that poly3_val(coefs, t) = ll.y\n        t = newton_rapshon(function(x) {\n            return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);\n        }, t, EPSLN, 100);\n\n        ll.x /= poly3_val(COEFS_X[i], t);\n        ll.y = (5 * i + t) * D2R;\n        if (xy.y < 0) {\n            ll.y = -ll.y;\n        }\n    }\n\n    ll.x = adjust_lon(ll.x + this.long0);\n    return ll;\n}\n\nvar robin_names = ["Robinson", "robin"];\n/* harmony default export */ var robin = ({\n  init: robin_init,\n  forward: robin_forward,\n  inverse: robin_inverse,\n  names: robin_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/geocent.js\n\n\nfunction geocent_init() {\n    this.name = \'geocent\';\n\n}\n\nfunction geocent_forward(p) {\n    var point = geodeticToGeocentric(p, this.es, this.a);\n    return point;\n}\n\nfunction geocent_inverse(p) {\n    var point = geocentricToGeodetic(p, this.es, this.a, this.b);\n    return point;\n}\n\nvar geocent_names = ["Geocentric", \'geocentric\', "geocent", "Geocent"];\n/* harmony default export */ var geocent = ({\n    init: geocent_init,\n    forward: geocent_forward,\n    inverse: geocent_inverse,\n    names: geocent_names\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tpers.js\n\nvar mode = {\n  N_POLE: 0,\n  S_POLE: 1,\n  EQUIT: 2,\n  OBLIQ: 3\n};\n\n\n\n\nvar tpers_params = {\n  h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7\n  azi:   { def: 0, num: true, degrees: true }, // default is North\n  tilt:  { def: 0, num: true, degrees: true }, // default is Nadir\n  long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic\n  lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic\n};\n\nfunction tpers_init() {\n  Object.keys(tpers_params).forEach(function (p) {\n    if (typeof this[p] === "undefined") {\n      this[p] = tpers_params[p].def;\n    } else if (tpers_params[p].num && isNaN(this[p])) {\n      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);\n    } else if (tpers_params[p].num) {\n      this[p] = parseFloat(this[p]);\n    }\n    if (tpers_params[p].degrees) {\n      this[p] = this[p] * D2R;\n    }\n  }.bind(this));\n\n  if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {\n    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;\n  } else if (Math.abs(this.lat0) < EPSLN) {\n    this.mode = mode.EQUIT;\n  } else {\n    this.mode = mode.OBLIQ;\n    this.sinph0 = Math.sin(this.lat0);\n    this.cosph0 = Math.cos(this.lat0);\n  }\n\n  this.pn1 = this.h / this.a;  // Normalize relative to the Earth\'s radius\n\n  if (this.pn1 <= 0 || this.pn1 > 1e10) {\n    throw new Error("Invalid height");\n  }\n  \n  this.p = 1 + this.pn1;\n  this.rp = 1 / this.p;\n  this.h1 = 1 / this.pn1;\n  this.pfact = (this.p + 1) * this.h1;\n  this.es = 0;\n\n  var omega = this.tilt;\n  var gamma = this.azi;\n  this.cg = Math.cos(gamma);\n  this.sg = Math.sin(gamma);\n  this.cw = Math.cos(omega);\n  this.sw = Math.sin(omega);\n}\n\nfunction tpers_forward(p) {\n  p.x -= this.long0;\n  var sinphi = Math.sin(p.y);\n  var cosphi = Math.cos(p.y);\n  var coslam = Math.cos(p.x);\n  var x, y;\n  switch (this.mode) {\n    case mode.OBLIQ:\n      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n      break;\n    case mode.EQUIT:\n      y = cosphi * coslam;\n      break;\n    case mode.S_POLE:\n      y = -sinphi;\n      break;\n    case mode.N_POLE:\n      y = sinphi;\n      break;\n  }\n  y = this.pn1 / (this.p - y);\n  x = y * cosphi * Math.sin(p.x);\n\n  switch (this.mode) {\n    case mode.OBLIQ:\n      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n      break;\n    case mode.EQUIT:\n      y *= sinphi;\n      break;\n    case mode.N_POLE:\n      y *= -(cosphi * coslam);\n      break;\n    case mode.S_POLE:\n      y *= cosphi * coslam;\n      break;\n  }\n\n  // Tilt \n  var yt, ba;\n  yt = y * this.cg + x * this.sg;\n  ba = 1 / (yt * this.sw * this.h1 + this.cw);\n  x = (x * this.cg - y * this.sg) * this.cw * ba;\n  y = yt * ba;\n\n  p.x = x * this.a;\n  p.y = y * this.a;\n  return p;\n}\n\nfunction tpers_inverse(p) {\n  p.x /= this.a;\n  p.y /= this.a;\n  var r = { x: p.x, y: p.y };\n\n  // Un-Tilt\n  var bm, bq, yt;\n  yt = 1 / (this.pn1 - p.y * this.sw);\n  bm = this.pn1 * p.x * yt;\n  bq = this.pn1 * p.y * this.cw * yt;\n  p.x = bm * this.cg + bq * this.sg;\n  p.y = bq * this.cg - bm * this.sg;\n\n  var rh = hypot(p.x, p.y);\n  if (Math.abs(rh) < EPSLN) {\n    r.x = 0;\n    r.y = p.y;\n  } else {\n    var cosz, sinz;\n    sinz = 1 - rh * rh * this.pfact;\n    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);\n    cosz = Math.sqrt(1 - sinz * sinz);\n    switch (this.mode) {\n      case mode.OBLIQ:\n        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);\n        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;\n        p.x *= sinz * this.cosph0;\n        break;\n      case mode.EQUIT:\n        r.y = Math.asin(p.y * sinz / rh);\n        p.y = cosz * rh;\n        p.x *= sinz;\n        break;\n      case mode.N_POLE:\n        r.y = Math.asin(cosz);\n        p.y = -p.y;\n        break;\n      case mode.S_POLE:\n        r.y = -Math.asin(cosz);\n        break;\n    }\n    r.x = Math.atan2(p.x, p.y);\n  }\n\n  p.x = r.x + this.long0;\n  p.y = r.y;\n  return p;\n}\n\nvar tpers_names = ["Tilted_Perspective", "tpers"];\n/* harmony default export */ var tpers = ({\n  init: tpers_init,\n  forward: tpers_forward,\n  inverse: tpers_inverse,\n  names: tpers_names\n});\n\n// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/geos.js\n\n\nfunction geos_init() {\n    this.flip_axis = (this.sweep === \'x\' ? 1 : 0);\n    this.h = Number(this.h);\n    this.radius_g_1 = this.h / this.a;\n\n    if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {\n        throw new Error();\n    }\n\n    this.radius_g = 1.0 + this.radius_g_1;\n    this.C = this.radius_g * this.radius_g - 1.0;\n\n    if (this.es !== 0.0) {\n        var one_es = 1.0 - this.es;\n        var rone_es = 1 / one_es;\n\n        this.radius_p = Math.sqrt(one_es);\n        this.radius_p2 = one_es;\n        this.radius_p_inv2 = rone_es;\n\n        this.shape = \'ellipse\'; // Use as a condition in the forward and inverse functions.\n    } else {\n        this.radius_p = 1.0;\n        this.radius_p2 = 1.0;\n        this.radius_p_inv2 = 1.0;\n\n        this.shape = \'sphere\';  // Use as a condition in the forward and inverse functions.\n    }\n\n    if (!this.title) {\n        this.title = "Geostationary Satellite View";\n    }\n}\n\nfunction geos_forward(p) {\n    var lon = p.x;\n    var lat = p.y;\n    var tmp, v_x, v_y, v_z;\n    lon = lon - this.long0;\n\n    if (this.shape === \'ellipse\') {\n        lat = Math.atan(this.radius_p2 * Math.tan(lat));\n        var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));\n\n        v_x = r * Math.cos(lon) * Math.cos(lat);\n        v_y = r * Math.sin(lon) * Math.cos(lat);\n        v_z = r * Math.sin(lat);\n\n        if (((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2) < 0.0) {\n            p.x = Number.NaN;\n            p.y = Number.NaN;\n            return p;\n        }\n\n        tmp = this.radius_g - v_x;\n        if (this.flip_axis) {\n            p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));\n            p.y = this.radius_g_1 * Math.atan(v_z / tmp);\n        } else {\n            p.x = this.radius_g_1 * Math.atan(v_y / tmp);\n            p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));\n        }\n    } else if (this.shape === \'sphere\') {\n        tmp = Math.cos(lat);\n        v_x = Math.cos(lon) * tmp;\n        v_y = Math.sin(lon) * tmp;\n        v_z = Math.sin(lat);\n        tmp = this.radius_g - v_x;\n\n        if (this.flip_axis) {\n            p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));\n            p.y = this.radius_g_1 * Math.atan(v_z / tmp);\n        } else {\n            p.x = this.radius_g_1 * Math.atan(v_y / tmp);\n            p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));\n        }\n    }\n    p.x = p.x * this.a;\n    p.y = p.y * this.a;\n    return p;\n}\n\nfunction geos_inverse(p) {\n    var v_x = -1.0;\n    var v_y = 0.0;\n    var v_z = 0.0;\n    var a, b, det, k;\n\n    p.x = p.x / this.a;\n    p.y = p.y / this.a;\n\n    if (this.shape === \'ellipse\') {\n        if (this.flip_axis) {\n            v_z = Math.tan(p.y / this.radius_g_1);\n            v_y = Math.tan(p.x / this.radius_g_1) * hypot(1.0, v_z);\n        } else {\n            v_y = Math.tan(p.x / this.radius_g_1);\n            v_z = Math.tan(p.y / this.radius_g_1) * hypot(1.0, v_y);\n        }\n\n        var v_zp = v_z / this.radius_p;\n        a = v_y * v_y + v_zp * v_zp + v_x * v_x;\n        b = 2 * this.radius_g * v_x;\n        det = (b * b) - 4 * a * this.C;\n\n        if (det < 0.0) {\n            p.x = Number.NaN;\n            p.y = Number.NaN;\n            return p;\n        }\n\n        k = (-b - Math.sqrt(det)) / (2.0 * a);\n        v_x = this.radius_g + k * v_x;\n        v_y *= k;\n        v_z *= k;\n\n        p.x = Math.atan2(v_y, v_x);\n        p.y = Math.atan(v_z * Math.cos(p.x) / v_x);\n        p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));\n    } else if (this.shape === \'sphere\') {\n        if (this.flip_axis) {\n            v_z = Math.tan(p.y / this.radius_g_1);\n            v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1.0 + v_z * v_z);\n        } else {\n            v_y = Math.tan(p.x / this.radius_g_1);\n            v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1.0 + v_y * v_y);\n        }\n\n        a = v_y * v_y + v_z * v_z + v_x * v_x;\n        b = 2 * this.radius_g * v_x;\n        det = (b * b) - 4 * a * this.C;\n        if (det < 0.0) {\n            p.x = Number.NaN;\n            p.y = Number.NaN;\n            return p;\n        }\n\n        k = (-b - Math.sqrt(det)) / (2.0 * a);\n        v_x = this.radius_g + k * v_x;\n        v_y *= k;\n        v_z *= k;\n\n        p.x = Math.atan2(v_y, v_x);\n        p.y = Math.atan(v_z * Math.cos(p.x) / v_x);\n    }\n    p.x = p.x + this.long0;\n    return p;\n}\n\nvar geos_names = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];\n/* harmony default export */ var geos = ({\n    init: geos_init,\n    forward: geos_forward,\n    inverse: geos_inverse,\n    names: geos_names,\n});\n\n\n// CONCATENATED MODULE: ./node_modules/proj4/projs.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var proj4_projs = (function(proj4){\n  proj4.Proj.projections.add(tmerc);\n  proj4.Proj.projections.add(etmerc);\n  proj4.Proj.projections.add(utm);\n  proj4.Proj.projections.add(sterea);\n  proj4.Proj.projections.add(stere);\n  proj4.Proj.projections.add(somerc);\n  proj4.Proj.projections.add(omerc);\n  proj4.Proj.projections.add(lcc);\n  proj4.Proj.projections.add(krovak);\n  proj4.Proj.projections.add(cass);\n  proj4.Proj.projections.add(laea);\n  proj4.Proj.projections.add(aea);\n  proj4.Proj.projections.add(gnom);\n  proj4.Proj.projections.add(cea);\n  proj4.Proj.projections.add(eqc);\n  proj4.Proj.projections.add(poly);\n  proj4.Proj.projections.add(nzmg);\n  proj4.Proj.projections.add(mill);\n  proj4.Proj.projections.add(sinu);\n  proj4.Proj.projections.add(moll);\n  proj4.Proj.projections.add(eqdc);\n  proj4.Proj.projections.add(vandg);\n  proj4.Proj.projections.add(aeqd);\n  proj4.Proj.projections.add(ortho);\n  proj4.Proj.projections.add(qsc);\n  proj4.Proj.projections.add(robin);\n  proj4.Proj.projections.add(geocent);\n  proj4.Proj.projections.add(tpers);\n  proj4.Proj.projections.add(geos);\n});\n// CONCATENATED MODULE: ./node_modules/proj4/lib/index.js\n\n\n\n\n\n\n\n\n\n\ncore.defaultDatum = \'WGS84\'; //default datum\ncore.Proj = Proj;\ncore.WGS84 = new core.Proj(\'WGS84\');\ncore.Point = lib_Point;\ncore.toPoint = toPoint;\ncore.defs = lib_defs;\ncore.nadgrid = nadgrid;\ncore.transform = transform;\ncore.mgrs = mgrs;\ncore.version = \'__VERSION__\';\nproj4_projs(core);\n/* harmony default export */ var lib = (core);\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-leaflet/core/Proj4Leaflet.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\r\n * This program are made available under the terms of the Apache License, Version 2.0\r\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\r\n/**\r\n * Inspired by https://github.com/kartena/Proj4Leaflet\r\n */\r\n\r\n\r\n\r\nwindow.proj4 = lib;\r\nwindow.Proj4js = lib;\r\nleaflet_src_default.a.Proj = leaflet_src_default.a.Proj || {};\r\n\r\nleaflet_src_default.a.Proj._isProj4Obj = function(a) {\r\n    return typeof a.inverse !== \'undefined\' && typeof a.forward !== \'undefined\';\r\n};\r\n\r\n/**\r\n * @class L.Proj.Projection\r\n * @private\r\n * @classdesc Proj 投影定义类。\r\n * @category BaseTypes Projection\r\n * @extends {L.Class}\r\n * @param {string} code - proj srsCode\r\n * @param {string} def - 投影的 proj4 定义。{@link [详细]{https://iclient.supermap.io/web/introduction/leafletDevelop.html#projection}}\r\n * @param {L.Bounds} bounds -  投影范围参数\r\n */\r\nleaflet_src_default.a.Proj.Projection = leaflet_src_default.a.Class.extend({\r\n    initialize: function(code, def, bounds, wrapLng) {\r\n        var isP4 = leaflet_src_default.a.Proj._isProj4Obj(code);\r\n        this._proj = isP4 ? code : this._projFromCodeDef(code, def);\r\n        var boundsOption = bounds;\r\n        if (leaflet_src_default.a.Util.isArray(bounds)) {\r\n            boundsOption = leaflet_src_default.a.bounds(bounds);\r\n        }\r\n        this.bounds = isP4 ? def : boundsOption;\r\n        this.wrapLng = wrapLng;\r\n    },\r\n\r\n    /**\r\n     * @function L.Proj.Projection.prototype.project\r\n     * @description 通过地理坐标得到投影坐标。\r\n     * @param  {L.Latlng} latlng -  经纬度坐标。\r\n     * @returns {L.Point} 返回投影坐标点。\r\n     */\r\n    project: function(latlng) {\r\n        var point = this._proj.forward([latlng.lng, latlng.lat]);\r\n        return new leaflet_src_default.a.Point(point[0], point[1]);\r\n    },\r\n\r\n    /**\r\n     * @function L.Proj.Projection.prototype.unproject\r\n     * @description 通过投影坐标得到地理坐标。\r\n     * @param {L.Point} point - 坐标点。\r\n     * @param {number} unbounded - 坐标点高程值等。\r\n     * @returns {L.LatLng} 返回经纬度坐标\r\n     */\r\n    unproject: function(point, zoom) {\r\n        if (this.bounds && !this.wrapLng) {\r\n            point.x =\r\n                point.x < this.bounds.min.x\r\n                    ? this.bounds.min.x\r\n                    : point.x > this.bounds.max.x\r\n                    ? this.bounds.max.x\r\n                    : point.x;\r\n            point.y =\r\n                point.y < this.bounds.min.y\r\n                    ? this.bounds.min.y\r\n                    : point.y > this.bounds.max.y\r\n                    ? this.bounds.max.y\r\n                    : point.y;\r\n        }\r\n        var point2 = this._proj.inverse([point.x, point.y]);\r\n        return new leaflet_src_default.a.LatLng(point2[1], point2[0], zoom);\r\n    },\r\n\r\n    _projFromCodeDef: function(code, def) {\r\n        if (def) {\r\n            lib.defs(code, def);\r\n        } else if (lib.defs[code] === undefined) {\r\n            var urn = code.split(\':\');\r\n            if (urn.length > 3) {\r\n                code = urn[urn.length - 3] + \':\' + urn[urn.length - 1];\r\n            }\r\n            if (lib.defs[code] === undefined) {\r\n                throw \'No projection definition for code \' + code;\r\n            }\r\n        }\r\n\r\n        return lib(code);\r\n    },\r\n    getUnits: function() {\r\n        return this._proj.oProj.units || \'degrees\';\r\n    }\r\n});\r\n\r\n/**\r\n * @class CRS\r\n * @aliasclass Proj.CRS\r\n * @deprecatedclass L.Proj.CRS\r\n * @deprecatedclassinstance L.supermap.Proj.crs\r\n * @classdesc 基于 Proj4 坐标系统扩展类。\r\n * 为计算级别，`options.scales` `options.scaleDenominators` `options.resolutions` `options.bounds` 必须指定一个，先后顺序已按优先级排列。\r\n * 当指定`options.bounds` 时，第 0 级为一张 256 切片包含整个 bounds，即`Math.max(bounds.getSize().x, bounds.getSize().y)/256` 。\r\n * 为保证切片行列号正确，`options.origin` `options.bounds` 必须指定一个。\r\n * 当指定`options.bounds` 时，切片原点为 bounds 的左上角。\r\n * @category BaseTypes Projection\r\n * @extends {L.Class}\r\n * @param {string} srsCode - proj srsCode。\r\n * @param {Object} options - 参数。\r\n * @param {string} options.def - 投影的proj4定义。[详细]{@link https://iclient.supermap.io/web/introduction/leafletDevelop.html#multiProjection}\r\n * @param {(Array.<number>|L.Point)} [options.origin] - 原点。\r\n * @param {Array.<number>} [options.scales] - 比例尺数组。\r\n * @param {Array.<number>} [options.scaleDenominators] - 比例尺分母数组。\r\n * @param {Array.<number>} [options.resolutions] - 分辨率数组。\r\n * @param {(Array.<number>|L.Bounds)} [options.bounds] - 范围。\r\n * @param {number} [options.dpi=96] - dpi。\r\n * @param {number} [options.wrapLng] - 定义经度（水平）坐标轴是否在给定范围内环绕。大多数情况下默认为[-180，180]。\r\n * @example\r\n *    var crs =new CRS("EPSG:4326",{\r\n *          origin: [-180,90],\r\n *          scaleDenominators: [2000,1000,500,200,100,50,20,10],\r\n *    });\r\n *    var map=L.map(\'map\', {\r\n *       crs: crs\r\n *      ...\r\n *    })\r\n * @usage\r\n */\r\nvar CRS = leaflet_src_default.a.Class.extend({\r\n    includes: leaflet_src_default.a.CRS,\r\n\r\n    options: {\r\n        transformation: new leaflet_src_default.a.Transformation(1, 0, -1, 0)\r\n    },\r\n\r\n    initialize: function(srsCode, options) {\r\n        var code, proj, def;\r\n\r\n        if (leaflet_src_default.a.Proj._isProj4Obj(srsCode)) {\r\n            proj = srsCode;\r\n            code = proj.srsCode;\r\n            options = options || {};\r\n\r\n            this.projection = new leaflet_src_default.a.Proj.Projection(proj, options.bounds,options.wrapLng);\r\n        } else {\r\n            code = srsCode;\r\n            options = options || {};\r\n            def = options.def || \'\';\r\n            this.projection = new leaflet_src_default.a.Proj.Projection(code, def, options.bounds,options.wrapLng);\r\n        }\r\n\r\n        leaflet_src_default.a.Util.setOptions(this, options);\r\n        if (this.options.wrapLng) {\r\n            this.wrapLng = this.options.wrapLng;\r\n        }\r\n        this.code = code;\r\n        this.transformation = this.options.transformation;\r\n        this.options.dpi = this.options.dpi || 96;\r\n        if (this.options.bounds) {\r\n            this.options.bounds = leaflet_src_default.a.bounds(this.options.bounds);\r\n        }\r\n        if (!this.options.origin && this.options.bounds) {\r\n            this.options.origin = [this.options.bounds.min.x, this.options.bounds.max.y];\r\n        }\r\n        if (this.options.origin) {\r\n            if (this.options.origin instanceof leaflet_src_default.a.Point) {\r\n                this.options.origin = [this.options.origin.x, this.options.origin.y];\r\n            }\r\n            this.transformation = new leaflet_src_default.a.Transformation(1, -this.options.origin[0], -1, this.options.origin[1]);\r\n        }\r\n\r\n        if (this.options.scales && this.options.scales.length > 0) {\r\n            this.scales = this.options.scales;\r\n            this._scales = this._toProj4Scales(this.options.scales, this.options.dpi);\r\n        } else if (this.options.scaleDenominators && this.options.scaleDenominators.length > 0) {\r\n            this.scales = [];\r\n            for (let i = 0; i < this.options.scaleDenominators.length; i++) {\r\n                this.scales[i] = 1 / this.options.scaleDenominators[i];\r\n            }\r\n            this._scales = this._toProj4Scales(this.scales, this.options.dpi);\r\n        } else if (this.options.resolutions && this.options.resolutions.length > 0) {\r\n            this._scales = [];\r\n            for (let i = this.options.resolutions.length - 1; i >= 0; i--) {\r\n                if (this.options.resolutions[i]) {\r\n                    this._scales[i] = 1 / this.options.resolutions[i];\r\n                }\r\n            }\r\n        } else if (this.options.bounds) {\r\n            this._scales = this._getDefaultProj4ScalesByBounds(this.options.bounds);\r\n        }\r\n        this._rectify();\r\n        this.infinite = !this.options.bounds;\r\n    },\r\n    _rectify: function() {\r\n        if (this._scales) {\r\n            if (!this.resolutions) {\r\n                this.resolutions = [];\r\n                this.resolutions = this._proj4ScalesToResolutions(this._scales);\r\n            }\r\n            if (!this.scales) {\r\n                this.scales = [];\r\n                for (let i = 0; i < this.resolutions.length; i++) {\r\n                    var scaleD =\r\n                        this.resolutions[i] *\r\n                        this.options.dpi *\r\n                        (1 / 0.0254) *\r\n                        this._getMeterPerMapUnit(this.projection.getUnits());\r\n                    this.scales[i] = 1.0 / scaleD;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    /**\r\n     * @function CRS.prototype.scale\r\n     * @description 通过缩放级别获取比例尺值。\r\n     * @param {number} zoom - 缩放级别。\r\n     * @returns 比例尺值。\r\n     */\r\n    scale: function(zoom) {\r\n        var iZoom = Math.floor(zoom),\r\n            baseScale,\r\n            nextScale,\r\n            scaleDiff,\r\n            zDiff;\r\n        if (zoom === iZoom) {\r\n            return this._scales[zoom];\r\n        } else {\r\n            // Non-integer zoom, interpolate\r\n            baseScale = this._scales[iZoom];\r\n            nextScale = this._scales[iZoom + 1];\r\n            scaleDiff = nextScale - baseScale;\r\n            zDiff = zoom - iZoom;\r\n            return baseScale + scaleDiff * zDiff;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @function CRS.prototype.zoom\r\n     * @description 根据比例尺返回缩放级别。\r\n     * @param {number} scale - 比例尺。\r\n     * @returns {number} 缩放级别。\r\n     */\r\n    zoom: function(scale) {\r\n        // Find closest number in this._scales, down\r\n        var downScale = this._closestElement(this._scales, scale),\r\n            downZoom = this._scales.indexOf(downScale),\r\n            nextScale,\r\n            nextZoom,\r\n            scaleDiff;\r\n        // Check if scale is downScale => return array index\r\n        if (!downScale) {\r\n            return 0;\r\n        }\r\n        if (scale === downScale) {\r\n            return downZoom;\r\n        }\r\n        // Interpolate\r\n        nextZoom = downZoom + 1;\r\n        nextScale = this._scales[nextZoom];\r\n        if (nextScale === undefined) {\r\n            return downZoom;\r\n        }\r\n        scaleDiff = nextScale - downScale;\r\n        return (scale - downScale) / scaleDiff + downZoom;\r\n    },\r\n\r\n    distance: leaflet_src_default.a.CRS.Earth.distance,\r\n\r\n    R: leaflet_src_default.a.CRS.Earth.R,\r\n\r\n    /* Get the closest lowest element in an array */\r\n    _closestElement: function(array, element) {\r\n        var low;\r\n        for (var i = array.length; i--; ) {\r\n            if (array[i] <= element && (low === undefined || low < array[i])) {\r\n                low = array[i];\r\n            }\r\n        }\r\n        return low;\r\n    },\r\n    _proj4ScalesToResolutions(_scales) {\r\n        var resolutions = [];\r\n        if (!_scales) {\r\n            return resolutions;\r\n        }\r\n        for (var i = 0; i < _scales.length; i++) {\r\n            resolutions[i] = 1.0 / _scales[i];\r\n        }\r\n        return resolutions;\r\n    },\r\n    _toProj4Scales: function(scales, dpi) {\r\n        var proj4Scales = [];\r\n        if (!scales) {\r\n            return proj4Scales;\r\n        }\r\n        for (var i = 0; i < scales.length; i++) {\r\n            var a = this.projection ? this._getMeterPerMapUnit(this.projection.getUnits()) : 1;\r\n            proj4Scales[i] = 1 / (0.0254 / ((dpi || 96) * scales[i]) / a);\r\n        }\r\n        return proj4Scales;\r\n    },\r\n    _getMeterPerMapUnit: function(mapUnit) {\r\n        var earchRadiusInMeters = 6378137;\r\n        var meterPerMapUnit = 1;\r\n        if (mapUnit === \'meter\') {\r\n            meterPerMapUnit = 1;\r\n        } else if (mapUnit === \'degrees\') {\r\n            // 每度表示多少米。\r\n            meterPerMapUnit = (Math.PI * 2 * earchRadiusInMeters) / 360;\r\n        } else if (mapUnit === \'kilometer\') {\r\n            meterPerMapUnit = 1.0e-3;\r\n        } else if (mapUnit === \'inch\') {\r\n            meterPerMapUnit = 1 / 2.5399999918e-2;\r\n        } else if (mapUnit === \'feet\') {\r\n            meterPerMapUnit = 0.3048;\r\n        }\r\n        return meterPerMapUnit;\r\n    },\r\n    _getDefaultProj4ScalesByBounds: function(bounds) {\r\n        if (!bounds) {\r\n            return [];\r\n        }\r\n        var boundsSize = bounds.getSize();\r\n        var extendsSize = Math.max(boundsSize.x, boundsSize.y);\r\n        var resolution = extendsSize / 256;\r\n        var scales = [];\r\n        var maxZoom = 23;\r\n        for (var i = 0; i < maxZoom; i++) {\r\n            scales[i] = Math.pow(2, i) / resolution;\r\n        }\r\n        return scales;\r\n    }\r\n});\r\nvar Proj4Leaflet_crs = function(srsCode, options) {\r\n    return new CRS(srsCode, options);\r\n};\r\n\r\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-leaflet/core/Attributions.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\r\n * This program are made available under the terms of the Apache License, Version 2.0\r\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\r\n/**\r\n * @enum attribution\r\n * @description 版权相关配置。\r\n * @type {string}\r\n * @private\r\n */\r\n\r\nlet Attributions = {\r\n\r\n    Prefix: `<a href=\'https://leafletjs.com\' title=\'A JS library for interactive maps\'>Leaflet</a>\r\n                with <span>© <a href=\'https://iclient.supermap.io\' title=\'SuperMap iClient\' target=\'_blank\'>SuperMap iClient</a></span>`,\r\n\r\n    Common: {\r\n        attribution: `Map Data <span>© <a href=\'http://support.supermap.com.cn/product/iServer.aspx\' title=\'SuperMap iServer\' target=\'_blank\'>SuperMap iServer</a></span>`\r\n    },\r\n\r\n    Online: {\r\n        attribution: `Map Data <span>© <a href=\'https://www.supermapol.com\' title=\'SuperMap Online\' target=\'_blank\'>SuperMap Online</a></span>`\r\n    },\r\n\r\n    ECharts: {\r\n        attribution: `© 2018 百度 ECharts`\r\n    },\r\n\r\n    MapV: {\r\n        attribution: `© 2018 百度 MapV `\r\n    },\r\n\r\n    Turf: {\r\n        attribution: `<span>© <a href=\'https://turfjs.org/\' title=\'turfjs\' target=\'_blank\'>turfjs</a></span>`\r\n    },\r\n\r\n    Baidu: {\r\n        attribution: `Map Data © 2018 Baidu - GS(2016)2089号 - Data © 长地万方`\r\n    },\r\n\r\n    Cloud: {\r\n        attribution: `Map Data ©2014 SuperMap - GS(2014)6070号-data©Navinfo`\r\n    },\r\n\r\n    Tianditu: {\r\n        attribution: `Map Data <a href=\'https://www.tianditu.gov.cn\' target=\'_blank\'><img style=\'background-color:transparent;bottom:2px;opacity:1;\' src=\'https://api.tianditu.gov.cn/img/map/logo.png\' width=\'53px\' height=\'22px\' opacity=\'0\'></a>`\r\n    }\r\n};\r\n\r\n/* harmony default export */ var core_Attributions = (Attributions);\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-leaflet/core/Base.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\r\n * This program are made available under the terms of the Apache License, Version 2.0\r\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\r\n\r\n\r\n\r\n\r\nleaflet_src_default.a.Control.Attribution.include({\r\n    options: {\r\n        position: \'bottomright\',\r\n        prefix: core_Attributions.Prefix\r\n    }\r\n});\r\nleaflet_src_default.a.Map.include({\r\n    /*\r\n     * 获取精确的像素坐标.\r\n     * 当需要绘制比较平滑的曲线的时候可调用此方法代替latLngToContainerPoint\r\n     * @param latlng\r\n     */\r\n    latLngToAccurateContainerPoint: function (latlng) {\r\n        var projectedPoint = this.project(leaflet_src_default.a.latLng(latlng));\r\n        var layerPoint = projectedPoint._subtract(this.getPixelOrigin());\r\n        return leaflet_src_default.a.point(layerPoint).add(this._getMapPanePos());\r\n    }\r\n});\r\nwrapToGeoJSON([leaflet_src_default.a.Polyline, leaflet_src_default.a.Polygon, leaflet_src_default.a.Marker, leaflet_src_default.a.CircleMarker, leaflet_src_default.a.Circle, leaflet_src_default.a.LayerGroup]);\r\n\r\nfunction wrapToGeoJSON(objClassArray) {\r\n    objClassArray.map((objClass) => {\r\n        objClass.defaultFunction = objClass.prototype.toGeoJSON;\r\n        objClass.include({\r\n            toGeoJSON: function (precision) {\r\n                return objClass.defaultFunction.call(this, precision || 10);\r\n            }\r\n        })\r\n        return objClass;\r\n    })\r\n\r\n}\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/BaseTypes.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n \n\n/**\n * @function inherit\n * @description 除了 C 和 P 两个必要参数外，可以传递任意数量的对象，这些对象都将继承C。\n * @param {Object} C - 继承的类。\n * @param {Object} P - 被继承的父类。\n * @private\n */\nvar inheritExt = function (C, P) {\n    var F = function () {\n    };\n    F.prototype = P.prototype;\n    C.prototype = new F;\n    var i, l, o;\n    for (i = 2, l = arguments.length; i < l; i++) {\n        o = arguments[i];\n        if (typeof o === "function") {\n            o = o.prototype;\n        }\n        Util.extend(C.prototype, o);\n    }\n};\n\n\n/**\n * @function mixinExt\n * @description 实现多重继承。\n * @param {Class|Object} ...mixins - 继承的类。\n * @private\n */\nvar mixinExt = function (...mixins) {\n\n    class Mix {\n        constructor(options) {\n            for (var index = 0; index < mixins.length; index++) {\n                copyProperties(this, new mixins[index](options));\n            }\n        }\n    }\n\n    for (var index = 0; index < mixins.length; index++) {\n        var mixin = mixins[index];\n        copyProperties(Mix, mixin);\n        copyProperties(Mix.prototype, mixin.prototype);\n        copyProperties(Mix.prototype, new mixin());\n    }\n    return Mix;\n\n    function copyProperties(target, source) {\n        var ownKeys = Object.getOwnPropertyNames(source);\n        if (Object.getOwnPropertySymbols) {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source));\n        }\n        for (var index = 0; index < ownKeys.length; index++) {\n            var key = ownKeys[index];\n            if (key !== "constructor"\n                && key !== "prototype"\n                && key !== "name" && key !== "length") {\n                let desc = Object.getOwnPropertyDescriptor(source, key);\n                if (window["ActiveXObject"]) {\n                    Object.defineProperty(target, key, desc || {});\n                } else {\n                    Object.defineProperty(target, key, desc);\n                }\n            }\n        }\n    }\n};\n\n/**\n * @name String\n * @namespace\n * @category BaseTypes Util\n * @description 字符串操作的一系列常用扩展函数。\n * @private\n */\nvar StringExt = {\n\n    /**\n     * @function StringExt.startsWith\n     * @description 判断目标字符串是否以指定的子字符串开头。\n     * @param {string} str - 目标字符串。\n     * @param {string} sub - 查找的子字符串。\n     * @returns {boolean} 目标字符串以指定的子字符串开头，则返回 true；否则返回 false。\n     */\n    startsWith: function (str, sub) {\n        return (str.indexOf(sub) == 0);\n    },\n\n    /**\n     * @function StringExt.contains\n     * @description 判断目标字符串是否包含指定的子字符串。\n     * @param {string} str - 目标字符串。\n     * @param {string} sub - 查找的子字符串。\n     * @returns {boolean} 目标字符串中包含指定的子字符串，则返回 true；否则返回 false。\n     */\n    contains: function (str, sub) {\n        return (str.indexOf(sub) != -1);\n    },\n\n    /**\n     * @function StringExt.trim\n     * @description 删除一个字符串的开头和结尾处的所有空白字符。\n     * @param {string} str - （可能）存在空白字符填塞的字符串。\n     * @returns {string} 删除开头和结尾处空白字符后的字符串。\n     */\n    trim: function (str) {\n        return str.replace(/^\\s\\s*/, \'\').replace(/\\s\\s*$/, \'\');\n    },\n\n    /**\n     * @function StringExt.camelize\n     * @description 骆驼式("-")连字符的字符串处理。\n     * 例如："chicken-head" becomes "chickenHead",\n     *       "-chicken-head" becomes "ChickenHead"。\n     * @param {string} str - 要处理的字符串，原始内容不应被修改。\n     * @returns {string}\n     */\n    camelize: function (str) {\n        var oStringList = str.split(\'-\');\n        var camelizedString = oStringList[0];\n        for (var i = 1, len = oStringList.length; i < len; i++) {\n            var s = oStringList[i];\n            camelizedString += s.charAt(0).toUpperCase() + s.substring(1);\n        }\n        return camelizedString;\n    },\n\n    /**\n     * @function StringExt.format\n     * @description 提供带 ${token} 标记的字符串, 返回 context 对象属性中指定标记的属性值。\n     * @example\n     * 示例：\n     * (code)\n     * 1、template = "${value,getValue}";\n     *         context = {value: {getValue:function(){return Math.max.apply(null,argument);}}};\n     *         args = [2,23,12,36,21];\n     *       返回值:36\n     * (end)\n     * 示例:\n     * (code)\n     * 2、template = "$${{value,getValue}}";\n     *         context = {value: {getValue:function(){return Math.max.apply(null,argument);}}};\n     *         args = [2,23,12,36,21];\n     *       返回值:"${36}"\n     * (end)\n     * 示例:\n     * (code)\n     * 3、template = "${a,b}";\n     *         context = {a: {b:"format"}};\n     *         args = null;\n     *       返回值:"format"\n     * (end)\n     * 示例:\n     * (code)\n     * 3、template = "${a,b}";\n     *         context = null;\n     *         args = null;\n     *       返回值:"${a.b}"\n     * (end)\n     * @param {string} template - 带标记的字符串将要被替换。参数 template 格式为"${token}"，此处的 token 标记会替换为 context["token"] 属性的值。\n     * @param {Object} [context=window] - 带有属性的可选对象的属性用于匹配格式化字符串中的标记。如果该参数为空，将使用 window 对象。\n     * @param {Array.<number>} [args] - 可选参数传递给在 context 对象上找到的函数。\n     * @returns {string} 从 context 对象属性中替换字符串标记位的字符串。\n     */\n    format: function (template, context, args) {\n        if (!context) {\n            context = window;\n        }\n\n        // Example matching:\n        // str   = ${foo.bar}\n        // match = foo.bar\n        var replacer = function (str, match) {\n            var replacement;\n\n            // Loop through all subs. Example: ${a.b.c}\n            // 0 -> replacement = context[a];\n            // 1 -> replacement = context[a][b];\n            // 2 -> replacement = context[a][b][c];\n            var subs = match.split(/\\.+/);\n            for (var i = 0; i < subs.length; i++) {\n                if (i == 0) {\n                    replacement = context;\n                }\n\n                replacement = replacement[subs[i]];\n            }\n\n            if (typeof replacement === "function") {\n                replacement = args ?\n                    replacement.apply(null, args) :\n                    replacement();\n            }\n\n            // If replacement is undefined, return the string \'undefined\'.\n            // This is a workaround for a bugs in browsers not properly\n            // dealing with non-participating groups in regular expressions:\n            // http://blog.stevenlevithan.com/archives/npcg-javascript\n            if (typeof replacement == \'undefined\') {\n                return \'undefined\';\n            } else {\n                return replacement;\n            }\n        };\n\n        return template.replace(StringExt.tokenRegEx, replacer);\n    },\n\n    /**\n     * @member {RegExp} [StringExt.tokenRegEx]\n     * @description 寻找带 token 的字符串，默认为 tokenRegEx=/\\$\\{([\\w.]+?)\\}/g。\n     * @example\n     * Examples: ${a}, ${a.b.c}, ${a-b}, ${5}\n     */\n    tokenRegEx: /\\$\\{([\\w.]+?)\\}/g,\n\n    /**\n     * @member {RegExp} [StringExt.numberRegEx]\n     * @description 判断一个字符串是否只包含一个数值，默认为 numberRegEx=/^([+-]?)(?=\\d|\\.\\d)\\d*(\\.\\d*)?([Ee]([+-]?\\d+))?$/。\n     */\n    numberRegEx: /^([+-]?)(?=\\d|\\.\\d)\\d*(\\.\\d*)?([Ee]([+-]?\\d+))?$/,\n\n    /**\n     * @function StringExt.isNumeric\n     * @description 判断一个字符串是否只包含一个数值。\n     * @example\n     * (code)\n     * StringExt.isNumeric("6.02e23") // true\n     * StringExt.isNumeric("12 dozen") // false\n     * StringExt.isNumeric("4") // true\n     * StringExt.isNumeric(" 4 ") // false\n     * (end)\n     * @returns {boolean} 字符串包含唯一的数值，返回 true；否则返回 false。\n     */\n    isNumeric: function (value) {\n        return StringExt.numberRegEx.test(value);\n    },\n\n    /**\n     * @function StringExt.numericIf\n     * @description 把一个看似数值型的字符串转化为一个数值。\n     * @returns {(number|string)} 如果能转换为数值则返回数值，否则返回字符串本身。\n     */\n    numericIf: function (value) {\n        return StringExt.isNumeric(value) ? parseFloat(value) : value;\n    }\n\n};\n\n/**\n * @name Number\n * @namespace\n * @category BaseTypes Util\n * @description 数值操作的一系列常用扩展函数。\n * @private\n */\nvar NumberExt = {\n\n    /**\n     * @member {string} [NumberExt.decimalSeparator=\'.\']\n     * @description 格式化数字时默认的小数点分隔符。\n     * @constant\n     */\n    decimalSeparator: ".",\n\n    /**\n     * @member {string} [NumberExt.thousandsSeparator=\',\']\n     * @description 格式化数字时默认的千位分隔符。\n     * @constant\n     */\n    thousandsSeparator: ",",\n\n    /**\n     * @function NumberExt.limitSigDigs\n     * @description 限制浮点数的有效数字位数。\n     * @param {number} num - 浮点数。\n     * @param {number} sig - 有效位数。\n     * @returns {number} 将数字四舍五入到指定数量的有效位数。\n     */\n    limitSigDigs: function (num, sig) {\n        var fig = 0;\n        if (sig > 0) {\n            fig = parseFloat(num.toPrecision(sig));\n        }\n        return fig;\n    },\n\n    /**\n     * @function NumberExt.format\n     * @description 数字格式化输出。\n     * @param {number} num - 数字。\n     * @param {number} [dec=0]  - 数字的小数部分四舍五入到指定的位数。设置为 null 值时小数部分不变。\n     * @param {string} [tsep=\',\'] - 千位分隔符。\n     * @param {string} [dsep=\'.\'] - 小数点分隔符。\n     * @returns {string} 数字格式化后的字符串。\n     */\n    format: function (num, dec, tsep, dsep) {\n        dec = (typeof dec != "undefined") ? dec : 0;\n        tsep = (typeof tsep != "undefined") ? tsep :\n        NumberExt.thousandsSeparator;\n        dsep = (typeof dsep != "undefined") ? dsep :\n        NumberExt.decimalSeparator;\n\n        if (dec != null) {\n            num = parseFloat(num.toFixed(dec));\n        }\n\n        var parts = num.toString().split(".");\n        if (parts.length === 1 && dec == null) {\n            // integer where we do not want to touch the decimals\n            dec = 0;\n        }\n\n        var integer = parts[0];\n        if (tsep) {\n            var thousands = /(-?[0-9]+)([0-9]{3})/;\n            while (thousands.test(integer)) {\n                integer = integer.replace(thousands, "$1" + tsep + "$2");\n            }\n        }\n\n        var str;\n        if (dec == 0) {\n            str = integer;\n        } else {\n            var rem = parts.length > 1 ? parts[1] : "0";\n            if (dec != null) {\n                rem = rem + new Array(dec - rem.length + 1).join("0");\n            }\n            str = integer + dsep + rem;\n        }\n        return str;\n    }\n};\n\nif (!Number.prototype.limitSigDigs) {\n    /**\n     * APIMethod: Number.limitSigDigs\n     * 限制浮点数的有效数字位数.\n     * @param {number} sig -有效位数。\n     * @returns {number} 将数字四舍五入到指定数量的有效位数。\n     *           如果传入值 为 null、0、或者是负数, 返回值 0。\n     */\n    Number.prototype.limitSigDigs = function (sig) {\n        return NumberExt.limitSigDigs(this, sig);\n    };\n}\n\n/**\n * @name Function\n * @namespace\n * @category BaseTypes Util\n * @description 函数操作的一系列常用扩展函数。\n * @private\n */\nvar FunctionExt = {\n    /**\n     * @function FunctionExt.bind\n     * @description 绑定函数到对象。方便创建 this 的作用域。\n     * @param {function} func - 输入函数。\n     * @param {Object} object - 对象绑定到输入函数（作为输入函数的 this 对象）。\n     * @returns {function} object 参数作为 func 函数的 this 对象。\n     */\n    bind: function (func, object) {\n        // create a reference to all arguments past the second one\n        var args = Array.prototype.slice.apply(arguments, [2]);\n        return function () {\n            // Push on any additional arguments from the actual function call.\n            // These will come after those sent to the bind call.\n            var newArgs = args.concat(\n                Array.prototype.slice.apply(arguments, [0])\n            );\n            return func.apply(object, newArgs);\n        };\n    },\n\n    /**\n     * @function FunctionExt.bindAsEventListener\n     * @description 绑定函数到对象，在调用该函数时配置并使用事件对象作为第一个参数。\n     * @param {function} func - 用于监听事件的函数。\n     * @param {Object} object - this 对象的引用。\n     * @returns {function}\n     */\n    bindAsEventListener: function (func, object) {\n        return function (event) {\n            return func.call(object, event || window.event);\n        };\n    },\n\n    /**\n     * @function FunctionExt.False\n     * @description 该函数仅仅返回 false。该函数主要是避免在 IE8 以下浏览中 DOM 事件句柄的匿名函数问题。\n     * @example\n     * document.onclick = FunctionExt.False;\n     * @returns {boolean}\n     */\n    False: function () {\n        return false;\n    },\n\n    /**\n     * @function FunctionExt.True\n     * @description 该函数仅仅返回 true。该函数主要是避免在 IE8 以下浏览中 DOM 事件句柄的匿名函数问题。\n     * @example\n     * document.onclick = FunctionExt.True;\n     * @returns {boolean}\n     */\n    True: function () {\n        return true;\n    },\n\n    /**\n     * @function FunctionExt.Void\n     * @description 可重用函数，仅仅返回 "undefined"。\n     * @returns {undefined}\n     */\n    Void: function () {\n    }\n\n};\n\n/**\n * @name Array\n * @namespace\n * @category BaseTypes Util\n * @description 数组操作的一系列常用扩展函数。\n * @private\n */\nvar ArrayExt = {\n\n    /**\n     * @function ArrayExt.filter\n     * @description 过滤数组，提供了 ECMA-262 标准中 Array.prototype.filter 函数的扩展。详见：{@link http://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter}\n     * @param {Array} array - 要过滤的数组。\n     * @param {function} callback - 数组中的每一个元素调用该函数。</br>\n     *     如果函数的返回值为 true，该元素将包含在返回的数组中。该函数有三个参数: 数组中的元素，元素的索引，数组自身。</br>\n     *     如果设置了可选参数 caller，在调用 callback 时，使用可选参数 caller 设置为 callback 的参数。</br>\n     * @param {Object} [caller] - 在调用 callback 时，使用参数 caller 设置为 callback 的参数。\n     * @returns {Array} callback 函数返回 true 时的元素将作为返回数组中的元素。\n     */\n    filter: function (array, callback, caller) {\n        var selected = [];\n        if (Array.prototype.filter) {\n            selected = array.filter(callback, caller);\n        } else {\n            var len = array.length;\n            if (typeof callback != "function") {\n                throw new TypeError();\n            }\n            for (var i = 0; i < len; i++) {\n                if (i in array) {\n                    var val = array[i];\n                    if (callback.call(caller, val, i, array)) {\n                        selected.push(val);\n                    }\n                }\n            }\n        }\n        return selected;\n    }\n\n};\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/Geometry.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n// import {WKT} from \'../format/WKT\';\n// import {Vector} from \'./Vector\';\n\n\n/**\n * @class Geometry\n * @deprecatedclass SuperMap.Geometry\n * @category BaseTypes Geometry\n * @classdesc 几何对象类，描述地理对象的几何图形。\n * @usage\n */\nclass Geometry_Geometry {\n\n\n    constructor() {\n        this.CLASS_NAME = "SuperMap.Geometry";\n        /**\n         * @member {string} Geometry.prototype.id\n         * @description  几何对象的唯一标示符。\n         *\n         */\n        this.id = Util.createUniqueID(this.CLASS_NAME + "_");\n\n        /**\n         * @member {Geometry} Geometry.prototype.parent\n         * @description 父类几何对象。\n         */\n        this.parent = null;\n\n        /**\n         * @member {Bounds} Geometry.prototype.bounds\n         * @description 几何对象的范围。\n         *\n         */\n        this.bounds = null;\n\n        /**\n         * @member {number} Geometry.prototype.SRID\n         * @description 投影坐标参数。通过该参数，服务器判断 Geometry 对象的坐标参考系是否与数据集相同，如果不同，则在数据入库前进行投影变换。\n         * @example\n         * var geometry= new Geometry();\n         * geometry. SRID=4326;\n         *\n         */\n        this.SRID = null;\n    }\n\n\n    /**\n     * @function Geometry.prototype.destroy\n     * @description 解构 Geometry 类，释放资源。\n     */\n    destroy() {\n        this.id = null;\n        this.bounds = null;\n        this.SRID = null;\n    }\n\n\n    /**\n     * @function Geometry.prototype.clone\n     * @description 克隆几何图形。克隆的几何图形不设置非标准的属性。\n     * @returns {Geometry} 克隆的几何图形。\n     */\n    clone() {\n        return new Geometry_Geometry();\n    }\n\n\n    /**\n     * @function Geometry.prototype.setBounds\n     * @description 设置几何对象的 bounds。\n     * @param {Bounds} bounds - 范围。\n     */\n    setBounds(bounds) {\n        if (bounds) {\n            this.bounds = bounds.clone();\n        }\n    }\n\n\n    /**\n     * @function Geometry.prototype.clearBounds\n     * @description 清除几何对象的 bounds。\n     * 如果该对象有父类，也会清除父类几何对象的 bounds。\n     */\n    clearBounds() {\n        this.bounds = null;\n        if (this.parent) {\n            this.parent.clearBounds();\n        }\n    }\n\n\n    /**\n     * @function Geometry.prototype.extendBounds\n     * @description 扩展现有边界以包含新边界。如果尚未设置几何边界，则设置新边界。\n     * @param {Bounds} newBounds - 几何对象的 bounds。\n     */\n    extendBounds(newBounds) {\n        var bounds = this.getBounds();\n        if (!bounds) {\n            this.setBounds(newBounds);\n        } else {\n            this.bounds.extend(newBounds);\n        }\n    }\n\n\n    /**\n     * @function Geometry.prototype.getBounds\n     * @description 获得几何图形的边界。如果没有设置边界，可通过计算获得。\n     * @returns {Bounds} 几何对象的边界。\n     */\n    getBounds() {\n        if (this.bounds == null) {\n            this.calculateBounds();\n        }\n        return this.bounds;\n    }\n\n\n    /**\n     * @function Geometry.prototype.calculateBounds\n     * @description 重新计算几何图形的边界（需要在子类中实现此方法）。\n     */\n    calculateBounds() {\n        //\n        // This should be overridden by subclasses.\n        //\n    }\n\n    /**\n     * @function Geometry.prototype.getVertices\n     * @description 返回几何图形的所有顶点的列表（需要在子类中实现此方法）。\n     * @param {boolean} [nodes] - 如果是 true，线则只返回线的末端点，如果 false，仅仅返回顶点，如果没有设置，则返回顶点。\n     * @returns {Array} 几何图形的顶点列表。\n     */\n    getVertices(nodes) { // eslint-disable-line no-unused-vars\n    }\n\n    /**\n     * @function Geometry.prototype.getArea\n     * @description 计算几何对象的面积 ，此方法需要在子类中定义。\n     * @returns {number} 计算后的对象面积。\n     */\n    getArea() {\n        //to be overridden by geometries that actually have an area\n        //\n        return 0.0;\n    }\n\n\n    // /**\n    //  * @function Geometry.prototype.toString\n    //  * @description 返回geometry对象的字符串表述，需要引入{@link WKTFormat}。此方法只能在子类实现，在父类使用会报错。\n    //  * @returns {string} geometry对象的字符串表述(Well-Known Text)\n    //  */\n    // toString() {\n    // var string;\n    // if (WKT) {\n    //     var wkt = new WKT();\n    //     string = wkt.write(new Vector(this));\n    // } else {\n    //     string = Object.prototype.toString.call(this);\n    // }\n    // return string;\n    // }\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/Util.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n/**\n * @description 浏览器名称，依赖于 userAgent 属性，BROWSER_NAME 可以是空，或者以下浏览器：\n *     * "opera" -- Opera\n *     * "msie"  -- Internet Explorer\n *     * "safari" -- Safari\n *     * "firefox" -- Firefox\n *     * "mozilla" -- Mozilla\n * @category BaseTypes Constant\n * @constant {Object}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.Browser.name;\n *\n * <\/script>\n * // ES6 Import\n * import { Browser } from \'{npm}\';\n *\n * const result = Browser.name;\n * ```\n */\nconst Browser = (function () {\n  var name = \'\',\n    version = \'\',\n    device = \'pc\',\n    uaMatch;\n  //以下进行测试\n  var ua = navigator.userAgent.toLowerCase();\n  if (ua.indexOf(\'msie\') > -1 || (ua.indexOf(\'trident\') > -1 && ua.indexOf(\'rv\') > -1)) {\n    name = \'msie\';\n    uaMatch = ua.match(/msie ([\\d.]+)/) || ua.match(/rv:([\\d.]+)/);\n  } else if (ua.indexOf(\'chrome\') > -1) {\n    name = \'chrome\';\n    uaMatch = ua.match(/chrome\\/([\\d.]+)/);\n  } else if (ua.indexOf(\'firefox\') > -1) {\n    name = \'firefox\';\n    uaMatch = ua.match(/firefox\\/([\\d.]+)/);\n  } else if (ua.indexOf(\'opera\') > -1) {\n    name = \'opera\';\n    uaMatch = ua.match(/version\\/([\\d.]+)/);\n  } else if (ua.indexOf(\'safari\') > -1) {\n    name = \'safari\';\n    uaMatch = ua.match(/version\\/([\\d.]+)/);\n  }\n  version = uaMatch ? uaMatch[1] : \'\';\n\n  if (ua.indexOf(\'ipad\') > -1 || ua.indexOf(\'ipod\') > -1 || ua.indexOf(\'iphone\') > -1) {\n    device = \'apple\';\n  } else if (ua.indexOf(\'android\') > -1) {\n    uaMatch = ua.match(/version\\/([\\d.]+)/);\n    version = uaMatch ? uaMatch[1] : \'\';\n    device = \'android\';\n  }\n  return { name: name, version: version, device: device };\n})();\n\nconst isSupportCanvas = (function () {\n  var checkRes = true,\n    broz = Browser;\n  if (document.createElement(\'canvas\').getContext) {\n    if (broz.name === \'firefox\' && parseFloat(broz.version) < 5) {\n      checkRes = false;\n    }\n    if (broz.name === \'safari\' && parseFloat(broz.version) < 4) {\n      checkRes = false;\n    }\n    if (broz.name === \'opera\' && parseFloat(broz.version) < 10) {\n      checkRes = false;\n    }\n    if (broz.name === \'msie\' && parseFloat(broz.version) < 9) {\n      checkRes = false;\n    }\n  } else {\n    checkRes = false;\n  }\n  return checkRes;\n})();\n\n/**\n * @description 如果 userAgent 捕获到浏览器使用的是 Gecko 引擎则返回 true。\n * @constant {number}\n * @private\n */\nconst IS_GECKO = (function () {\n  var ua = navigator.userAgent.toLowerCase();\n  return ua.indexOf(\'webkit\') === -1 && ua.indexOf(\'gecko\') !== -1;\n})();\n\n/**\n * @constant {number}\n * @default\n * @description 分辨率与比例尺之间转换的常量。\n * @private\n */\nconst DOTS_PER_INCH = 96;\n\n/**\n * @name CommonUtil\n * @namespace\n * @category BaseTypes Util\n * @description common 工具类。\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.CommonUtil.getElement();\n *\n *   // 弃用的写法\n *   const result = SuperMap.Util.getElement();\n *\n * <\/script>\n *\n * // ES6 Import\n * import { CommonUtil } from \'{npm}\';\n *\n * const result = CommonUtil.getElement();\n * ```\n */\n\nconst Util = {\n  /**\n   * @memberOf CommonUtil\n   * @description 复制源对象的所有属性到目标对象上，源对象上的没有定义的属性在目标对象上也不会被设置。\n   * @example\n   * 要复制 Size 对象的所有属性到自定义对象上，使用方法如下:\n   *     var size = new Size(100, 100);\n   *     var obj = {}；\n   *     CommonUtil.extend(obj, size);\n   * @param {Object} [destination] - 目标对象。\n   * @param {Object} source - 源对象，其属性将被设置到目标对象上。\n   * @returns {Object} 目标对象。\n   */\n\n  extend: function (destination, source) {\n    destination = destination || {};\n    if (source) {\n      for (var property in source) {\n        var value = source[property];\n        if (value !== undefined) {\n          destination[property] = value;\n        }\n      }\n\n      /**\n       * IE doesn\'t include the toString property when iterating over an object\'s\n       * properties with the for(property in object) syntax.  Explicitly check if\n       * the source has its own toString property.\n       */\n\n      /*\n       * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative\n       * prototype object" when calling hawOwnProperty if the source object\n       * is an instance of window.Event.\n       */\n\n      var sourceIsEvt = typeof window.Event === \'function\' && source instanceof window.Event;\n\n      if (!sourceIsEvt && source.hasOwnProperty && source.hasOwnProperty(\'toString\')) {\n        destination.toString = source.toString;\n      }\n    }\n    return destination;\n  },\n  /**\n   * @memberOf CommonUtil\n   * @description 对象拷贝。\n   * @param {Object} [des] - 目标对象。\n   * @param {Object} soc - 源对象。\n   */\n  copy: function (des, soc) {\n    des = des || {};\n    var v;\n    if (soc) {\n      for (var p in des) {\n        v = soc[p];\n        if (typeof v !== \'undefined\') {\n          des[p] = v;\n        }\n      }\n    }\n  },\n  /**\n   * @memberOf CommonUtil\n   * @description 销毁对象，将其属性置空。\n   * @param {Object} [obj] - 目标对象。\n   */\n  reset: function (obj) {\n    obj = obj || {};\n    for (var p in obj) {\n      if (obj.hasOwnProperty(p)) {\n        if (typeof obj[p] === \'object\' && obj[p] instanceof Array) {\n          for (var i in obj[p]) {\n            if (obj[p][i].destroy) {\n              obj[p][i].destroy();\n            }\n          }\n          obj[p].length = 0;\n        } else if (typeof obj[p] === \'object\' && obj[p] instanceof Object) {\n          if (obj[p].destroy) {\n            obj[p].destroy();\n          }\n        }\n        obj[p] = null;\n      }\n    }\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 获取 HTML 元素数组。\n   * @returns {Array.<HTMLElement>} HTML 元素数组。\n   */\n  getElement: function () {\n    var elements = [];\n\n    for (var i = 0, len = arguments.length; i < len; i++) {\n      var element = arguments[i];\n      if (typeof element === \'string\') {\n        element = document.getElementById(element);\n      }\n      if (arguments.length === 1) {\n        return element;\n      }\n      elements.push(element);\n    }\n    return elements;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description instance of 的跨浏览器实现。\n   * @param {Object} o - 对象。\n   * @returns {boolean} 是否是页面元素。\n   */\n  isElement: function (o) {\n    return !!(o && o.nodeType === 1);\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 判断一个对象是否是数组。\n   * @param {Object} a - 对象。\n   * @returns {boolean} 是否是数组。\n   */\n  isArray: function (a) {\n    return Object.prototype.toString.call(a) === \'[object Array]\';\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 从数组中删除某一项。\n   * @param {Array} array - 数组。\n   * @param {Object} item - 数组中要删除的一项。\n   * @returns {Array} 执行删除操作后的数组。\n   */\n  removeItem: function (array, item) {\n    for (var i = array.length - 1; i >= 0; i--) {\n      if (array[i] === item) {\n        array.splice(i, 1);\n        //break;more than once??\n      }\n    }\n    return array;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 获取某对象在数组中的索引值。\n   * @param {Array.<Object>} array - 数组。\n   * @param {Object} obj - 对象。\n   * @returns {number} 某对象在数组中的索引值。\n   */\n  indexOf: function (array, obj) {\n    if (array == null) {\n      return -1;\n    } else {\n      // use the build-in function if available.\n      if (typeof array.indexOf === \'function\') {\n        return array.indexOf(obj);\n      } else {\n        for (var i = 0, len = array.length; i < len; i++) {\n          if (array[i] === obj) {\n            return i;\n          }\n        }\n        return -1;\n      }\n    }\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 修改某 DOM 元素的许多属性。\n   * @param {HTMLElement} element - 待修改的 DOM 元素。\n   * @param {string} [id] - DOM 元素的 ID。\n   * @param {Pixel} [px] - DOM 元素的 style 属性的 left 和 top 属性。\n   * @param {Size} [sz] - DOM 元素的 width 和 height 属性。\n   * @param {string} [position] - DOM 元素的 position 属性。\n   * @param {string} [border] - DOM 元素的 style 属性的 border 属性。\n   * @param {string} [overflow] - DOM 元素的 style 属性的 overflow 属性。\n   * @param {number} [opacity] - 不透明度值。取值范围为(0.0 - 1.0)。\n   */\n  modifyDOMElement: function (element, id, px, sz, position, border, overflow, opacity) {\n    if (id) {\n      element.id = id;\n    }\n    if (px) {\n      element.style.left = px.x + \'px\';\n      element.style.top = px.y + \'px\';\n    }\n    if (sz) {\n      element.style.width = sz.w + \'px\';\n      element.style.height = sz.h + \'px\';\n    }\n    if (position) {\n      element.style.position = position;\n    }\n    if (border) {\n      element.style.border = border;\n    }\n    if (overflow) {\n      element.style.overflow = overflow;\n    }\n    if (parseFloat(opacity) >= 0.0 && parseFloat(opacity) < 1.0) {\n      element.style.filter = \'alpha(opacity=\' + opacity * 100 + \')\';\n      element.style.opacity = opacity;\n    } else if (parseFloat(opacity) === 1.0) {\n      element.style.filter = \'\';\n      element.style.opacity = \'\';\n    }\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 比较两个对象并合并。\n   * @param {Object} [to] - 目标对象。\n   * @param {Object} from - 源对象。\n   * @returns {Object} 返回合并后的对象。\n   */\n  applyDefaults: function (to, from) {\n    to = to || {};\n    /*\n     * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative\n     * prototype object" when calling hawOwnProperty if the source object is an\n     * instance of window.Event.\n     */\n    var fromIsEvt = typeof window.Event === \'function\' && from instanceof window.Event;\n\n    for (var key in from) {\n      if (\n        to[key] === undefined ||\n        (!fromIsEvt && from.hasOwnProperty && from.hasOwnProperty(key) && !to.hasOwnProperty(key))\n      ) {\n        to[key] = from[key];\n      }\n    }\n    /**\n     * IE doesn\'t include the toString property when iterating over an object\'s\n     * properties with the for(property in object) syntax.  Explicitly check if\n     * the source has its own toString property.\n     */\n    if (\n      !fromIsEvt &&\n      from &&\n      from.hasOwnProperty &&\n      from.hasOwnProperty(\'toString\') &&\n      !to.hasOwnProperty(\'toString\')\n    ) {\n      to.toString = from.toString;\n    }\n\n    return to;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 将参数对象转换为 HTTP 的 GET 请求中的参数字符串。例如："key1=value1&key2=value2&key3=value3"。\n   * @param {Object} params - 参数对象。\n   * @returns {string} HTTP 的 GET 请求中的参数字符串。\n   */\n  getParameterString: function (params) {\n    var paramsArray = [];\n\n    for (var key in params) {\n      var value = params[key];\n      if (value != null && typeof value !== \'function\') {\n        var encodedValue;\n        if (Array.isArray(value) || value.toString() === \'[object Object]\') {\n          encodedValue = encodeURIComponent(JSON.stringify(value));\n        } else {\n          /* value is a string; simply encode */\n          encodedValue = encodeURIComponent(value);\n        }\n        paramsArray.push(encodeURIComponent(key) + \'=\' + encodedValue);\n      }\n    }\n\n    return paramsArray.join(\'&\');\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 给 URL 追加查询参数。\n   * @param {string} url - 待追加参数的 URL 字符串。\n   * @param {string} paramStr - 待追加的查询参数。\n   * @returns {string} 新的 URL。\n   */\n  urlAppend: function (url, paramStr) {\n    var newUrl = url;\n    if (paramStr) {\n      if (paramStr.indexOf(\'?\') === 0) {\n        paramStr = paramStr.substring(1);\n      }\n      var parts = (url + \' \').split(/[?&]/);\n      newUrl += parts.pop() === \' \' ? paramStr : parts.length ? \'&\' + paramStr : \'?\' + paramStr;\n    }\n    return newUrl;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 给 URL 追加 path 参数。\n   * @param {string} url - 待追加参数的 URL 字符串。\n   * @param {string} paramStr - 待追加的path参数。\n   * @returns {string} 新的 URL。\n   */\n  urlPathAppend: function (url, pathStr) {\n    let newUrl = url;\n    if (!pathStr) {\n      return newUrl;\n    }\n    if (pathStr.indexOf(\'/\') === 0) {\n      pathStr = pathStr.substring(1);\n    }\n    const parts = url.split(\'?\');\n    if (parts[0].indexOf(\'/\', parts[0].length - 1) < 0) {\n      parts[0] += \'/\';\n    }\n    newUrl = `${parts[0]}${pathStr}${parts.length > 1 ? `?${parts[1]}` : \'\'}`;\n    return newUrl;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 为了避免浮点精度错误而保留的有效位数。\n   * @type {number}\n   * @default 14\n   */\n  DEFAULT_PRECISION: 14,\n\n  /**\n   * @memberOf CommonUtil\n   * @description 将字符串以接近的精度转换为数字。\n   * @param {string} number - 字符串。\n   * @param {number} [precision=14] - 精度。\n   * @returns {number} 转化后的数字。\n   */\n  toFloat: function (number, precision) {\n    if (precision == null) {\n      precision = Util.DEFAULT_PRECISION;\n    }\n    if (typeof number !== \'number\') {\n      number = parseFloat(number);\n    }\n    return precision === 0 ? number : parseFloat(number.toPrecision(precision));\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 角度转弧度。\n   * @param {number} x - 角度。\n   * @returns {number} 转化后的弧度。\n   */\n  rad: function (x) {\n    return (x * Math.PI) / 180;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 从 URL 字符串中解析出参数对象。\n   * @param {string} url - URL。\n   * @returns {Object} 解析出的参数对象。\n   */\n  getParameters: function (url) {\n    // if no url specified, take it from the location bar\n    url = url === null || url === undefined ? window.location.href : url;\n\n    //parse out parameters portion of url string\n    var paramsString = \'\';\n    if (StringExt.contains(url, \'?\')) {\n      var start = url.indexOf(\'?\') + 1;\n      var end = StringExt.contains(url, \'#\') ? url.indexOf(\'#\') : url.length;\n      paramsString = url.substring(start, end);\n    }\n\n    var parameters = {};\n    var pairs = paramsString.split(/[&;]/);\n    for (var i = 0, len = pairs.length; i < len; ++i) {\n      var keyValue = pairs[i].split(\'=\');\n      if (keyValue[0]) {\n        var key = keyValue[0];\n        try {\n          key = decodeURIComponent(key);\n        } catch (err) {\n          key = unescape(key);\n        }\n\n        // being liberal by replacing "+" with " "\n        var value = (keyValue[1] || \'\').replace(/\\+/g, \' \');\n\n        try {\n          value = decodeURIComponent(value);\n        } catch (err) {\n          value = unescape(value);\n        }\n\n        // follow OGC convention of comma delimited values\n        value = value.split(\',\');\n\n        //if there\'s only one value, do not return as array\n        if (value.length == 1) {\n          value = value[0];\n        }\n\n        parameters[key] = value;\n      }\n    }\n    return parameters;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 不断递增计数变量，用于生成唯一 ID。\n   * @type {number}\n   * @default 0\n   */\n  lastSeqID: 0,\n\n  /**\n   * @memberOf CommonUtil\n   * @description 创建唯一 ID 值。\n   * @param {string} [prefix] - 前缀。\n   * @returns {string} 唯一的 ID 值。\n   */\n  createUniqueID: function (prefix) {\n    if (prefix == null) {\n      prefix = \'id_\';\n    }\n    Util.lastSeqID += 1;\n    return prefix + Util.lastSeqID;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 判断并转化比例尺。\n   * @param {number} scale - 比例尺。\n   * @returns {number} 正常的 scale 值。\n   */\n  normalizeScale: function (scale) {\n    var normScale = scale > 1.0 ? 1.0 / scale : scale;\n    return normScale;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 比例尺转分辨率。\n   * @param {number} scale - 比例尺。\n   * @param {string} [units=\'degrees\'] - 比例尺单位。\n   * @returns {number} 转化后的分辨率。\n   */\n  getResolutionFromScale: function (scale, units) {\n    var resolution;\n    if (scale) {\n      if (units == null) {\n        units = \'degrees\';\n      }\n      var normScale = Util.normalizeScale(scale);\n      resolution = 1 / (normScale * INCHES_PER_UNIT[units] * DOTS_PER_INCH);\n    }\n    return resolution;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 分辨率转比例尺。\n   * @param {number} resolution - 分辨率。\n   * @param {string} [units=\'degrees\'] - 分辨率单位。\n   * @returns {number} 转化后的比例尺。\n   */\n  getScaleFromResolution: function (resolution, units) {\n    if (units == null) {\n      units = \'degrees\';\n    }\n\n    var scale = resolution * INCHES_PER_UNIT[units] * DOTS_PER_INCH;\n    return scale;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 获取浏览器相关信息。支持的浏览器包括：Opera，Internet Explorer，Safari，Firefox。\n   * @returns {Object} 浏览器名称、版本、设备名称。对应的属性分别为 name, version, device。\n   */\n  getBrowser: function () {\n    return Browser;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 浏览器是否支持 Canvas。\n   * @returns {boolean} 当前浏览器是否支持 HTML5 Canvas。\n   */\n  isSupportCanvas,\n\n  /**\n   * @memberOf CommonUtil\n   * @description 判断；浏览器是否支持 Canvas。\n   * @returns {boolean} 当前浏览器是否支持 HTML5 Canvas 。\n   */\n  supportCanvas: function () {\n    return Util.isSupportCanvas;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 判断一个 URL 请求是否在当前域中。\n   * @param {string} url - URL 请求字符串。\n   * @returns {boolean} URL 请求是否在当前域中。\n   */\n  isInTheSameDomain: function (url) {\n    if (!url) {\n      return true;\n    }\n    var index = url.indexOf(\'//\');\n    var documentUrl = document.location.toString();\n    var documentIndex = documentUrl.indexOf(\'//\');\n    if (index === -1) {\n      return true;\n    } else {\n      var protocol;\n      var substring = (protocol = url.substring(0, index));\n      var documentSubString = documentUrl.substring(documentIndex + 2);\n      documentIndex = documentSubString.indexOf(\'/\');\n      var documentPortIndex = documentSubString.indexOf(\':\');\n      var documentDomainWithPort = documentSubString.substring(0, documentIndex);\n      //var documentPort;\n\n      var documentprotocol = document.location.protocol;\n      if (documentPortIndex !== -1) {\n        // documentPort = +documentSubString.substring(documentPortIndex, documentIndex);\n      } else {\n        documentDomainWithPort += \':\' + (documentprotocol.toLowerCase() === \'http:\' ? 80 : 443);\n      }\n      if (documentprotocol.toLowerCase() !== substring.toLowerCase()) {\n        return false;\n      }\n      substring = url.substring(index + 2);\n      var portIndex = substring.indexOf(\':\');\n      index = substring.indexOf(\'/\');\n      var domainWithPort = substring.substring(0, index);\n      var domain;\n      if (portIndex !== -1) {\n        domain = substring.substring(0, portIndex);\n      } else {\n        domain = substring.substring(0, index);\n        domainWithPort += \':\' + (protocol.toLowerCase() === \'http:\' ? 80 : 443);\n      }\n      var documentDomain = document.domain;\n      if (domain === documentDomain && domainWithPort === documentDomainWithPort) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 计算 iServer 服务的 REST 图层的显示分辨率，需要从 iServer 的 REST 图层表述中获取 viewBounds、viewer、scale、coordUnit、datumAxis 五个参数，来进行计算。\n   * @param {Bounds} viewBounds - 地图的参照可视范围，即地图初始化时默认的地图显示范围。\n   * @param {Size} viewer - 地图初始化时默认的地图图片的尺寸。\n   * @param {number} scale - 地图初始化时默认的显示比例尺。\n   * @param {string} [coordUnit=\'degrees\'] - 投影坐标系统的地图单位。\n   * @param {number} [datumAxis=6378137] - 地理坐标系统椭球体长半轴。用户自定义地图的 Options 时，若未指定该参数的值，则系统默认为 WGS84 参考系的椭球体长半轴 6378137。\n   * @returns {number} 图层显示分辨率。\n   */\n  calculateDpi: function (viewBounds, viewer, scale, coordUnit, datumAxis) {\n    //10000 是 0.1毫米与米的转换。DPI的计算公式：Viewer / DPI *  0.0254 * 10000 = ViewBounds * scale ，公式中的10000是为了提高计算结果的精度，以下出现的ratio皆为如此。\n    if (!viewBounds || !viewer || !scale) {\n      return;\n    }\n    var ratio = 10000,\n      rvbWidth = viewBounds.getWidth(),\n      rvbHeight = viewBounds.getHeight(),\n      rvWidth = viewer.w,\n      rvHeight = viewer.h;\n    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。\n    datumAxis = datumAxis || 6378137;\n    coordUnit = coordUnit || \'degrees\';\n    var dpi;\n    if (\n      coordUnit.toLowerCase() === \'degree\' ||\n      coordUnit.toLowerCase() === \'degrees\' ||\n      coordUnit.toLowerCase() === \'dd\'\n    ) {\n      let num1 = rvbWidth / rvWidth,\n        num2 = rvbHeight / rvHeight,\n        resolution = num1 > num2 ? num1 : num2;\n      dpi = (0.0254 * ratio) / resolution / scale / ((Math.PI * 2 * datumAxis) / 360) / ratio;\n    } else {\n      let resolution = rvbWidth / rvWidth;\n      dpi = (0.0254 * ratio) / resolution / scale / ratio;\n    }\n    return dpi;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 将对象转换成 JSON 字符串。\n   * @param {Object} obj - 要转换成 JSON 的 Object 对象。\n   * @returns {string} 转换后的 JSON 对象。\n   */\n  toJSON: function (obj) {\n    var objInn = obj;\n    if (objInn == null) {\n      return null;\n    }\n    switch (objInn.constructor) {\n      case String:\n        //s = "\'" + str.replace(/(["\\\\])/g, "\\\\$1") + "\'";   string含有单引号出错\n        objInn = \'"\' + objInn.replace(/(["\\\\])/g, \'\\\\$1\') + \'"\';\n        objInn = objInn.replace(/\\n/g, \'\\\\n\');\n        objInn = objInn.replace(/\\r/g, \'\\\\r\');\n        objInn = objInn.replace(\'<\', \'&lt;\');\n        objInn = objInn.replace(\'>\', \'&gt;\');\n        objInn = objInn.replace(/%/g, \'%25\');\n        objInn = objInn.replace(/&/g, \'%26\');\n        return objInn;\n      case Array:\n        var arr = \'\';\n        for (var i = 0, len = objInn.length; i < len; i++) {\n          arr += Util.toJSON(objInn[i]);\n          if (i !== objInn.length - 1) {\n            arr += \',\';\n          }\n        }\n        return "[" + arr + "]";\n      case Number:\n        return isFinite(objInn) ? String(objInn) : null;\n      case Boolean:\n        return String(objInn);\n      case Date:\n        var dateStr =\n          \'{\' +\n          \'\\\'__type\\\':"System.DateTime",\' +\n          "\'Year\':" +\n          objInn.getFullYear() +\n          \',\' +\n          "\'Month\':" +\n          (objInn.getMonth() + 1) +\n          \',\' +\n          "\'Day\':" +\n          objInn.getDate() +\n          \',\' +\n          "\'Hour\':" +\n          objInn.getHours() +\n          \',\' +\n          "\'Minute\':" +\n          objInn.getMinutes() +\n          \',\' +\n          "\'Second\':" +\n          objInn.getSeconds() +\n          \',\' +\n          "\'Millisecond\':" +\n          objInn.getMilliseconds() +\n          \',\' +\n          "\'TimezoneOffset\':" +\n          objInn.getTimezoneOffset() +\n          \'}\';\n        return dateStr;\n      default:\n        if (objInn[\'toJSON\'] != null && typeof objInn[\'toJSON\'] === \'function\') {\n          return objInn.toJSON();\n        }\n        if (typeof objInn === \'object\') {\n          if (objInn.length) {\n            let arr = [];\n            for (let i = 0, len = objInn.length; i < len; i++) {\n              arr.push(Util.toJSON(objInn[i]));\n            }\n            return \'[\' + arr.join(\',\') + \']\';\n          }\n          let arr = [];\n          for (let attr in objInn) {\n            //为解决Geometry类型头json时堆栈溢出的问题，attr == "parent"时不进行json转换\n            if (typeof objInn[attr] !== \'function\' && attr !== \'CLASS_NAME\' && attr !== \'parent\') {\n              arr.push("\'" + attr + "\':" + Util.toJSON(objInn[attr]));\n            }\n          }\n\n          if (arr.length > 0) {\n            return \'{\' + arr.join(\',\') + \'}\';\n          } else {\n            return \'{}\';\n          }\n        }\n        return objInn.toString();\n    }\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 根据比例尺和 dpi 计算屏幕分辨率。\n   * @category BaseTypes Util\n   * @param {number} scale - 比例尺。\n   * @param {number} dpi - 图像分辨率，表示每英寸内的像素个数。\n   * @param {string} [coordUnit] - 投影坐标系统的地图单位。\n   * @param {number} [datumAxis=6378137] - 地理坐标系统椭球体长半轴。用户自定义地图的 Options 时，若未指定该参数的值，则 DPI 默认按照 WGS84 参考系的椭球体长半轴 6378137 来计算。\n   * @returns {number} 当前比例尺下的屏幕分辨率。\n   */\n  getResolutionFromScaleDpi: function (scale, dpi, coordUnit, datumAxis) {\n    var resolution = null,\n      ratio = 10000;\n    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。\n    datumAxis = datumAxis || 6378137;\n    coordUnit = coordUnit || \'\';\n    if (scale > 0 && dpi > 0) {\n      scale = Util.normalizeScale(scale);\n      if (\n        coordUnit.toLowerCase() === \'degree\' ||\n        coordUnit.toLowerCase() === \'degrees\' ||\n        coordUnit.toLowerCase() === \'dd\'\n      ) {\n        //scale = Util.normalizeScale(scale);\n        resolution = (0.0254 * ratio) / dpi / scale / ((Math.PI * 2 * datumAxis) / 360) / ratio;\n        return resolution;\n      } else {\n        resolution = (0.0254 * ratio) / dpi / scale / ratio;\n        return resolution;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 根据 resolution、dpi、coordUnit 和 datumAxis 计算比例尺。\n   * @param {number} resolution - 用于计算比例尺的地图分辨率。\n   * @param {number} dpi - 图像分辨率，表示每英寸内的像素个数。\n   * @param {string} [coordUnit] - 投影坐标系统的地图单位。\n   * @param {number} [datumAxis=6378137] - 地理坐标系统椭球体长半轴。用户自定义地图的 Options 时，若未指定该参数的值，则 DPI 默认按照 WGS84 参考系的椭球体长半轴 6378137 来计算。\n   * @returns {number} 当前屏幕分辨率下的比例尺。\n   */\n  getScaleFromResolutionDpi: function (resolution, dpi, coordUnit, datumAxis) {\n    var scale = null,\n      ratio = 10000;\n    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。\n    datumAxis = datumAxis || 6378137;\n    coordUnit = coordUnit || \'\';\n    if (resolution > 0 && dpi > 0) {\n      if (\n        coordUnit.toLowerCase() === \'degree\' ||\n        coordUnit.toLowerCase() === \'degrees\' ||\n        coordUnit.toLowerCase() === \'dd\'\n      ) {\n        scale = (0.0254 * ratio) / dpi / resolution / ((Math.PI * 2 * datumAxis) / 360) / ratio;\n        return scale;\n      } else {\n        scale = (0.0254 * ratio) / dpi / resolution / ratio;\n        return scale;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 转换查询结果。\n   * @param {Object} result - 查询结果。\n   * @returns {Object} 转换后的查询结果。\n   */\n  transformResult: function (result) {\n    if (result.responseText && typeof result.responseText === \'string\') {\n      result = JSON.parse(result.responseText);\n    }\n    return result;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 属性拷贝，不拷贝方法类名(CLASS_NAME)等。\n   * @param {Object} [destination] - 拷贝目标。\n   * @param {Object} source - 源对象。\n   *\n   */\n  copyAttributes: function (destination, source) {\n    destination = destination || {};\n    if (source) {\n      for (var property in source) {\n        var value = source[property];\n        if (value !== undefined && property !== \'CLASS_NAME\' && typeof value !== \'function\') {\n          destination[property] = value;\n        }\n      }\n    }\n    return destination;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 将源对象上的属性拷贝到目标对象上。（不拷贝 CLASS_NAME 和方法）\n   * @param {Object} [destination] - 目标对象。\n   * @param {Object} source - 源对象。\n   * @param {Array.<string>} clip - 源对象中禁止拷贝到目标对象的属性，目的是防止目标对象上不可修改的属性被篡改。\n   *\n   */\n  copyAttributesWithClip: function (destination, source, clip) {\n    destination = destination || {};\n    if (source) {\n      for (var property in source) {\n        //去掉禁止拷贝的属性\n        var isInClip = false;\n        if (clip && clip.length) {\n          for (var i = 0, len = clip.length; i < len; i++) {\n            if (property === clip[i]) {\n              isInClip = true;\n              break;\n            }\n          }\n        }\n        if (isInClip === true) {\n          continue;\n        }\n\n        var value = source[property];\n        if (value !== undefined && property !== \'CLASS_NAME\' && typeof value !== \'function\') {\n          destination[property] = value;\n        }\n      }\n    }\n    return destination;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 克隆一个 Object 对象\n   * @param {Object} obj - 需要克隆的对象。\n   * @returns {Object} 对象的拷贝对象，注意是新的对象，不是指向。\n   */\n  cloneObject: function (obj) {\n    // Handle the 3 simple types, and null or undefined\n    if (null === obj || \'object\' !== typeof obj) {\n      return obj;\n    }\n\n    // Handle Date\n    if (obj instanceof Date) {\n      let copy = new Date();\n      copy.setTime(obj.getTime());\n      return copy;\n    }\n\n    // Handle Array\n    if (obj instanceof Array) {\n      let copy = obj.slice(0);\n      return copy;\n    }\n\n    // Handle Object\n    if (obj instanceof Object) {\n      let copy = {};\n      for (var attr in obj) {\n        if (obj.hasOwnProperty(attr)) {\n          copy[attr] = Util.cloneObject(obj[attr]);\n        }\n      }\n      return copy;\n    }\n\n    throw new Error("Unable to copy obj! Its type isn\'t supported.");\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 判断两条线段是不是有交点。\n   * @param {GeometryPoint} a1 - 第一条线段的起始节点。\n   * @param {GeometryPoint} a2 - 第一条线段的结束节点。\n   * @param {GeometryPoint} b1 - 第二条线段的起始节点。\n   * @param {GeometryPoint} b2 - 第二条线段的结束节点。\n   * @returns {Object} 如果相交返回交点，如果不相交返回两条线段的位置关系。\n   */\n  lineIntersection: function (a1, a2, b1, b2) {\n    var intersectValue = null;\n    var k1;\n    var k2;\n    var b = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n    var a = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);\n    var ab = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n    //ab==0代表两条线断的斜率一样\n    if (ab != 0) {\n      k1 = b / ab;\n      k2 = a / ab;\n\n      if (k1 >= 0 && k2 <= 1 && k1 <= 1 && k2 >= 0) {\n        intersectValue = new Geometry_Geometry.Point(a1.x + k1 * (a2.x - a1.x), a1.y + k1 * (a2.y - a1.y));\n      } else {\n        intersectValue = \'No Intersection\';\n      }\n    } else {\n      if (b == 0 && a == 0) {\n        var maxy = Math.max(a1.y, a2.y);\n        var miny = Math.min(a1.y, a2.y);\n        var maxx = Math.max(a1.x, a2.x);\n        var minx = Math.min(a1.x, a2.x);\n        if (\n          (((b1.y >= miny && b1.y <= maxy) || (b2.y >= miny && b2.y <= maxy)) && b1.x >= minx && b1.x <= maxx) ||\n          (b2.x >= minx && b2.x <= maxx)\n        ) {\n          intersectValue = \'Coincident\'; //重合\n        } else {\n          intersectValue = \'Parallel\'; //平行\n        }\n      } else {\n        intersectValue = \'Parallel\'; //平行\n      }\n    }\n    return intersectValue;\n  },\n\n  /**\n   * @memberOf CommonUtil\n   * @description 获取文本外接矩形宽度与高度。\n   * @param {ThemeStyle} style - 文本样式。\n   * @param {string} text - 文本内容。\n   * @param {Object} element - DOM 元素。\n   * @returns {Object} 裁剪后的宽度，高度信息。\n   */\n  getTextBounds: function (style, text, element) {\n    document.body.appendChild(element);\n    element.style.width = \'auto\';\n    element.style.height = \'auto\';\n    if (style.fontSize) {\n      element.style.fontSize = style.fontSize;\n    }\n    if (style.fontFamily) {\n      element.style.fontFamily = style.fontFamily;\n    }\n    if (style.fontWeight) {\n      element.style.fontWeight = style.fontWeight;\n    }\n    element.style.position = \'relative\';\n    element.style.visibility = \'hidden\';\n    //fix 在某些情况下，element内的文本变成竖起排列，导致宽度计算不正确的bug\n    element.style.display = \'inline-block\';\n    element.innerHTML = text;\n    var textWidth = element.clientWidth;\n    var textHeight = element.clientHeight;\n    document.body.removeChild(element);\n    return {\n      textWidth: textWidth,\n      textHeight: textHeight\n    };\n  },\n  /**\n   * @memberOf CommonUtil\n   * @description 获取转换后的path路径。\n   * @param {string} path - 待转换的path, 包含`{param}`。\n   * @param {Object} pathParams - path中待替换的参数。\n   * @returns {string} 转换后的path路径\n   */\n  convertPath: function (path, pathParams) {\n    if (!pathParams) {\n      return path;\n    }\n    return path.replace(/\\{([\\w-\\.]+)\\}/g, (fullMatch, key) => {\n      var value;\n      if (pathParams.hasOwnProperty(key)) {\n        value = paramToString(pathParams[key]);\n      } else {\n        value = fullMatch;\n      }\n      return encodeURIComponent(value);\n    });\n  }\n};\n\n/**\n * @enum INCHES_PER_UNIT\n * @description 每单位的英尺数。\n * @type {number}\n * @private\n */\nconst INCHES_PER_UNIT = {\n  inches: 1.0,\n  ft: 12.0,\n  mi: 63360.0,\n  m: 39.3701,\n  km: 39370.1,\n  dd: 4374754,\n  yd: 36\n};\nINCHES_PER_UNIT[\'in\'] = INCHES_PER_UNIT.inches;\nINCHES_PER_UNIT[\'degrees\'] = INCHES_PER_UNIT.dd;\nINCHES_PER_UNIT[\'nmi\'] = 1852 * INCHES_PER_UNIT.m;\n\n// Units from CS-Map\nconst METERS_PER_INCH = 0.0254000508001016002;\nUtil.extend(INCHES_PER_UNIT, {\n  Inch: INCHES_PER_UNIT.inches,\n  Meter: 1.0 / METERS_PER_INCH, //EPSG:9001\n  Foot: 0.30480060960121920243 / METERS_PER_INCH, //EPSG:9003\n  IFoot: 0.3048 / METERS_PER_INCH, //EPSG:9002\n  ClarkeFoot: 0.3047972651151 / METERS_PER_INCH, //EPSG:9005\n  SearsFoot: 0.30479947153867624624 / METERS_PER_INCH, //EPSG:9041\n  GoldCoastFoot: 0.30479971018150881758 / METERS_PER_INCH, //EPSG:9094\n  IInch: 0.0254 / METERS_PER_INCH,\n  MicroInch: 0.0000254 / METERS_PER_INCH,\n  Mil: 0.0000000254 / METERS_PER_INCH,\n  Centimeter: 0.01 / METERS_PER_INCH,\n  Kilometer: 1000.0 / METERS_PER_INCH, //EPSG:9036\n  Yard: 0.91440182880365760731 / METERS_PER_INCH,\n  SearsYard: 0.914398414616029 / METERS_PER_INCH, //EPSG:9040\n  IndianYard: 0.91439853074444079983 / METERS_PER_INCH, //EPSG:9084\n  IndianYd37: 0.91439523 / METERS_PER_INCH, //EPSG:9085\n  IndianYd62: 0.9143988 / METERS_PER_INCH, //EPSG:9086\n  IndianYd75: 0.9143985 / METERS_PER_INCH, //EPSG:9087\n  IndianFoot: 0.30479951 / METERS_PER_INCH, //EPSG:9080\n  IndianFt37: 0.30479841 / METERS_PER_INCH, //EPSG:9081\n  IndianFt62: 0.3047996 / METERS_PER_INCH, //EPSG:9082\n  IndianFt75: 0.3047995 / METERS_PER_INCH, //EPSG:9083\n  Mile: 1609.34721869443738887477 / METERS_PER_INCH,\n  IYard: 0.9144 / METERS_PER_INCH, //EPSG:9096\n  IMile: 1609.344 / METERS_PER_INCH, //EPSG:9093\n  NautM: 1852.0 / METERS_PER_INCH, //EPSG:9030\n  \'Lat-66\': 110943.316488932731 / METERS_PER_INCH,\n  \'Lat-83\': 110946.25736872234125 / METERS_PER_INCH,\n  Decimeter: 0.1 / METERS_PER_INCH,\n  Millimeter: 0.001 / METERS_PER_INCH,\n  Dekameter: 10.0 / METERS_PER_INCH,\n  Decameter: 10.0 / METERS_PER_INCH,\n  Hectometer: 100.0 / METERS_PER_INCH,\n  GermanMeter: 1.0000135965 / METERS_PER_INCH, //EPSG:9031\n  CaGrid: 0.999738 / METERS_PER_INCH,\n  ClarkeChain: 20.1166194976 / METERS_PER_INCH, //EPSG:9038\n  GunterChain: 20.11684023368047 / METERS_PER_INCH, //EPSG:9033\n  BenoitChain: 20.116782494375872 / METERS_PER_INCH, //EPSG:9062\n  SearsChain: 20.11676512155 / METERS_PER_INCH, //EPSG:9042\n  ClarkeLink: 0.201166194976 / METERS_PER_INCH, //EPSG:9039\n  GunterLink: 0.2011684023368047 / METERS_PER_INCH, //EPSG:9034\n  BenoitLink: 0.20116782494375872 / METERS_PER_INCH, //EPSG:9063\n  SearsLink: 0.2011676512155 / METERS_PER_INCH, //EPSG:9043\n  Rod: 5.02921005842012 / METERS_PER_INCH,\n  IntnlChain: 20.1168 / METERS_PER_INCH, //EPSG:9097\n  IntnlLink: 0.201168 / METERS_PER_INCH, //EPSG:9098\n  Perch: 5.02921005842012 / METERS_PER_INCH,\n  Pole: 5.02921005842012 / METERS_PER_INCH,\n  Furlong: 201.1684023368046 / METERS_PER_INCH,\n  Rood: 3.778266898 / METERS_PER_INCH,\n  CapeFoot: 0.3047972615 / METERS_PER_INCH,\n  Brealey: 375.0 / METERS_PER_INCH,\n  ModAmFt: 0.304812252984505969011938 / METERS_PER_INCH,\n  Fathom: 1.8288 / METERS_PER_INCH,\n  \'NautM-UK\': 1853.184 / METERS_PER_INCH,\n  \'50kilometers\': 50000.0 / METERS_PER_INCH,\n  \'150kilometers\': 150000.0 / METERS_PER_INCH\n});\n\n//unit abbreviations supported by PROJ.4\nUtil.extend(INCHES_PER_UNIT, {\n  mm: INCHES_PER_UNIT[\'Meter\'] / 1000.0,\n  cm: INCHES_PER_UNIT[\'Meter\'] / 100.0,\n  dm: INCHES_PER_UNIT[\'Meter\'] * 100.0,\n  km: INCHES_PER_UNIT[\'Meter\'] * 1000.0,\n  kmi: INCHES_PER_UNIT[\'nmi\'], //International Nautical Mile\n  fath: INCHES_PER_UNIT[\'Fathom\'], //International Fathom\n  ch: INCHES_PER_UNIT[\'IntnlChain\'], //International Chain\n  link: INCHES_PER_UNIT[\'IntnlLink\'], //International Link\n  \'us-in\': INCHES_PER_UNIT[\'inches\'], //U.S. Surveyor\'s Inch\n  \'us-ft\': INCHES_PER_UNIT[\'Foot\'], //U.S. Surveyor\'s Foot\n  \'us-yd\': INCHES_PER_UNIT[\'Yard\'], //U.S. Surveyor\'s Yard\n  \'us-ch\': INCHES_PER_UNIT[\'GunterChain\'], //U.S. Surveyor\'s Chain\n  \'us-mi\': INCHES_PER_UNIT[\'Mile\'], //U.S. Surveyor\'s Statute Mile\n  \'ind-yd\': INCHES_PER_UNIT[\'IndianYd37\'], //Indian Yard\n  \'ind-ft\': INCHES_PER_UNIT[\'IndianFt37\'], //Indian Foot\n  \'ind-ch\': 20.11669506 / METERS_PER_INCH //Indian Chain\n});\n\n//将服务端的地图单位转成SuperMap的地图单位\nINCHES_PER_UNIT[\'degree\'] = INCHES_PER_UNIT.dd;\nINCHES_PER_UNIT[\'meter\'] = INCHES_PER_UNIT.m;\nINCHES_PER_UNIT[\'foot\'] = INCHES_PER_UNIT.ft;\nINCHES_PER_UNIT[\'inch\'] = INCHES_PER_UNIT.inches;\nINCHES_PER_UNIT[\'mile\'] = INCHES_PER_UNIT.mi;\nINCHES_PER_UNIT[\'kilometer\'] = INCHES_PER_UNIT.km;\nINCHES_PER_UNIT[\'yard\'] = INCHES_PER_UNIT.yd;\n\nfunction paramToString(param) {\n  if (param == undefined || param == null) {\n    return \'\';\n  }\n  if (param instanceof Date) {\n    return param.toJSON();\n  }\n  if (canBeJsonified(param)) {\n    return JSON.stringify(param);\n  }\n\n  return param.toString();\n}\n\nfunction canBeJsonified(str) {\n  if (typeof str !== \'string\' && typeof str !== \'object\') {\n    return false;\n  }\n  try {\n    const type = str.toString();\n    return type === \'[object Object]\' || type === \'[object Array]\';\n  } catch (err) {\n    return false;\n  }\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/promise-polyfill/dist/polyfill.js\nvar polyfill = __webpack_require__("146a");\n\n// EXTERNAL MODULE: ./node_modules/fetch-ie8/fetch.js\nvar fetch_ie8_fetch = __webpack_require__("e901");\n\n// EXTERNAL MODULE: ./node_modules/fetch-jsonp/build/fetch-jsonp.js\nvar fetch_jsonp = __webpack_require__("d871");\nvar fetch_jsonp_default = /*#__PURE__*/__webpack_require__.n(fetch_jsonp);\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/util/FetchRequest.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n\n\nlet FetchRequest_fetch = window.fetch;\nvar setFetch = function (newFetch) {\n    FetchRequest_fetch = newFetch;\n}\nvar RequestJSONPPromise = {\n  limitLength: 1500,\n  queryKeys: [],\n  queryValues: [],\n  supermap_callbacks: {},\n  addQueryStrings: function (values) {\n      var me = this;\n      for (var key in values) {\n          me.queryKeys.push(key);\n          if (typeof values[key] !== \'string\') {\n              values[key] = Util.toJSON(values[key]);\n          }\n          var tempValue = encodeURIComponent(values[key]);\n          me.queryValues.push(tempValue);\n      }\n  },\n  issue: function (config) {\n      var me = this,\n          uid = me.getUid(),\n          url = config.url,\n          splitQuestUrl = [];\n      var p = new Promise(function (resolve) {\n          me.supermap_callbacks[uid] = function (response) {\n              delete me.supermap_callbacks[uid];\n              resolve(response);\n          };\n      });\n\n      // me.addQueryStrings({\n      //     callback: "RequestJSONPPromise.supermap_callbacks[" + uid + "]"\n      // });\n      var sectionURL = url,\n          keysCount = 0; //此次sectionURL中有多少个key\n      var length = me.queryKeys ? me.queryKeys.length : 0;\n      for (var i = 0; i < length; i++) {\n          if (sectionURL.length + me.queryKeys[i].length + 2 >= me.limitLength) {\n              //+2 for ("&"or"?")and"="\n              if (keysCount == 0) {\n                  return false;\n              }\n              splitQuestUrl.push(sectionURL);\n              sectionURL = url;\n              keysCount = 0;\n              i--;\n          } else {\n              if (sectionURL.length + me.queryKeys[i].length + 2 + me.queryValues[i].length > me.limitLength) {\n                  var leftValue = me.queryValues[i];\n                  while (leftValue.length > 0) {\n                      var leftLength = me.limitLength - sectionURL.length - me.queryKeys[i].length - 2; //+2 for ("&"or"?")and"="\n                      if (sectionURL.indexOf(\'?\') > -1) {\n                          sectionURL += \'&\';\n                      } else {\n                          sectionURL += \'?\';\n                      }\n                      var tempLeftValue = leftValue.substring(0, leftLength);\n                      //避免 截断sectionURL时，将类似于%22这样的符号截成两半，从而导致服务端组装sectionURL时发生错误\n                      if (tempLeftValue.substring(leftLength - 1, leftLength) === \'%\') {\n                          leftLength -= 1;\n                          tempLeftValue = leftValue.substring(0, leftLength);\n                      } else if (tempLeftValue.substring(leftLength - 2, leftLength - 1) === \'%\') {\n                          leftLength -= 2;\n                          tempLeftValue = leftValue.substring(0, leftLength);\n                      }\n\n                      sectionURL += me.queryKeys[i] + \'=\' + tempLeftValue;\n                      leftValue = leftValue.substring(leftLength);\n                      if (tempLeftValue.length > 0) {\n                          splitQuestUrl.push(sectionURL);\n                          sectionURL = url;\n                          keysCount = 0;\n                      }\n                  }\n              } else {\n                  keysCount++;\n                  if (sectionURL.indexOf(\'?\') > -1) {\n                      sectionURL += \'&\';\n                  } else {\n                      sectionURL += \'?\';\n                  }\n                  sectionURL += me.queryKeys[i] + \'=\' + me.queryValues[i];\n              }\n          }\n      }\n      splitQuestUrl.push(sectionURL);\n      me.send(\n          splitQuestUrl,\n          \'RequestJSONPPromise.supermap_callbacks[\' + uid + \']\',\n          config && config.proxy\n      );\n      return p;\n  },\n\n  getUid: function () {\n      var uid = new Date().getTime(),\n          random = Math.floor(Math.random() * 1e17);\n      return uid * 1000 + random;\n  },\n\n  send: function (splitQuestUrl, callback, proxy) {\n      var len = splitQuestUrl.length;\n      if (len > 0) {\n          var jsonpUserID = new Date().getTime();\n          for (var i = 0; i < len; i++) {\n              var url = splitQuestUrl[i];\n              if (url.indexOf(\'?\') > -1) {\n                  url += \'&\';\n              } else {\n                  url += \'?\';\n              }\n              url += \'sectionCount=\' + len;\n              url += \'&sectionIndex=\' + i;\n              url += \'&jsonpUserID=\' + jsonpUserID;\n              if (proxy) {\n                  url = decodeURIComponent(url);\n                  url = proxy + encodeURIComponent(url);\n              }\n              fetch_jsonp_default()(url, {\n                  jsonpCallbackFunction: callback,\n                  timeout: 30000\n              });\n          }\n      }\n  },\n\n  GET: function (config) {\n      var me = this;\n      me.queryKeys.length = 0;\n      me.queryValues.length = 0;\n      me.addQueryStrings(config.params);\n      return me.issue(config);\n  },\n\n  POST: function (config) {\n      var me = this;\n      me.queryKeys.length = 0;\n      me.queryValues.length = 0;\n      me.addQueryStrings({\n          requestEntity: config.data\n      });\n      return me.issue(config);\n  },\n\n  PUT: function (config) {\n      var me = this;\n      me.queryKeys.length = 0;\n      me.queryValues.length = 0;\n      me.addQueryStrings({\n          requestEntity: config.data\n      });\n      return me.issue(config);\n  },\n  DELETE: function (config) {\n      var me = this;\n      me.queryKeys.length = 0;\n      me.queryValues.length = 0;\n      me.addQueryStrings({\n          requestEntity: config.data\n      });\n      return me.issue(config);\n  }\n};\n\nvar CORS;\nvar RequestTimeout;\n/**\n * @function setCORS\n * @description 设置是否允许跨域请求，全局配置，优先级低于 service 下的 crossOring 参数。\n * @category BaseTypes Util\n * @param {boolean} cors - 是否允许跨域请求。\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   {namespace}.setCORS(cors);\n *\n *   // 弃用的写法\n *   SuperMap.setCORS(cors);\n *\n * <\/script>\n *\n * // ES6 Import\n * import { setCORS } from \'{npm}\';\n *\n * setCORS(cors);\n * ```\n */\nvar setCORS = function (cors) {\n    CORS = cors;\n}\n/**\n * @function isCORS\n * @description 是是否允许跨域请求。\n * @category BaseTypes Util\n * @returns {boolean} 是否允许跨域请求。\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.isCORS();\n *\n *   // 弃用的写法\n *   const result = SuperMap.isCORS();\n *\n * <\/script>\n *\n * // ES6 Import\n * import { isCORS } from \'{npm}\';\n *\n * const result = isCORS();\n * ```\n */\nvar isCORS = function () {\n    if (CORS != undefined) {\n        return CORS;\n    }\n    return window.XMLHttpRequest && \'withCredentials\' in new window.XMLHttpRequest();\n}\n/**\n * @function setRequestTimeout\n * @description 设置请求超时时间。\n * @param {number} [timeout=45] - 请求超时时间，单位秒。\n * @private\n * @usage\n * ```\n * // 浏览器\n  <script type="text/javascript" src="{cdn}"><\/script>\n  <script>\n    {namespace}.setRequestTimeout(timeout);\n\n    // 弃用的写法\n    SuperMap.setRequestTimeout(timeout);\n\n  <\/script>\n\n  // ES6 Import\n  import { setRequestTimeout } from \'{npm}\';\n\n  setRequestTimeout(timeout);\n * ```\n */\nvar setRequestTimeout = function (timeout) {\n    return RequestTimeout = timeout;\n}\n/**\n * @function getRequestTimeout\n * @description 获取请求超时时间。\n * @returns {number} 请求超时时间。\n * @private\n * @usage\n * ```\n * // 浏览器\n  <script type="text/javascript" src="{cdn}"><\/script>\n  <script>\n    {namespace}.getRequestTimeout();\n\n    // 弃用的写法\n    SuperMap.getRequestTimeout();\n\n  <\/script>\n\n  // ES6 Import\n  import { getRequestTimeout } from \'{npm}\';\n\n  getRequestTimeout();\n * ```\n */\nvar getRequestTimeout = function () {\n    return RequestTimeout || 45000;\n}\n\n/**\n * @name FetchRequest\n * @namespace\n * @category BaseTypes Util\n * @description 获取请求。\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.FetchRequest.commit(method, url, params, options);\n *\n * <\/script>\n *\n * // ES6 Import\n * import { FetchRequest } from \'{npm}\';\n *\n * const result = FetchRequest.commit(method, url, params, options);\n *\n * ```\n */\nvar FetchRequest = {\n    /**\n     * @function FetchRequest.commit\n     * @description commit 请求。\n     * @param {string} method - 请求方法。\n     * @param {string} url - 请求地址。\n     * @param {string} params - 请求参数。\n     * @param {Object} options - 请求的配置属性。\n     * @returns {Promise} Promise 对象。\n     */\n    commit: function (method, url, params, options) {\n        method = method ? method.toUpperCase() : method;\n        switch (method) {\n            case \'GET\':\n                return this.get(url, params, options);\n            case \'POST\':\n                return this.post(url, params, options);\n            case \'PUT\':\n                return this.put(url, params, options);\n            case \'DELETE\':\n                return this.delete(url, params, options);\n            default:\n                return this.get(url, params, options);\n        }\n    },\n    /**\n     * @function FetchRequest.supportDirectRequest\n     * @description supportDirectRequest 请求。\n     * @param {string} url - 请求地址。\n     * @param {Object} options - 请求的配置属性。\n     * @returns {boolean} 是否允许跨域请求。\n     */\n    supportDirectRequest: function (url, options) {\n        if (Util.isInTheSameDomain(url)) {\n            return true;\n        }\n        if (options.crossOrigin != undefined) {\n            return options.crossOrigin;\n        } else {\n            return isCORS() || options.proxy;\n        }\n    },\n    /**\n     * @function FetchRequest.get\n     * @description get 请求。\n     * @param {string} url - 请求地址。\n     * @param {string} params - 请求参数。\n     * @param {Object} options - 请求的配置属性。\n     * @returns {Promise} Promise 对象。\n     */\n    get: function (url, params, options) {\n        options = options || {};\n        var type = \'GET\';\n        url = Util.urlAppend(url, this._getParameterString(params || {}));\n        url = this._processUrl(url, options);\n        if (!this.supportDirectRequest(url, options)) {\n            url = url.replace(\'.json\', \'.jsonp\');\n            var config = {\n                url: url,\n                data: params\n            };\n            return RequestJSONPPromise.GET(config);\n        }\n        if (!this.urlIsLong(url)) {\n            return this._fetch(url, params, options, type);\n        } else {\n            return this._postSimulatie(type, url.substring(0, url.indexOf(\'?\') - 1), params, options);\n        }\n    },\n    /**\n     * @function FetchRequest.delete\n     * @description delete 请求。\n     * @param {string} url - 请求地址。\n     * @param {string} params - 请求参数。\n     * @param {Object} options -请求的配置属性。\n     * @returns {Promise} Promise 对象。\n     */\n    delete: function (url, params, options) {\n        options = options || {};\n        var type = \'DELETE\';\n        url = Util.urlAppend(url, this._getParameterString(params || {}));\n        url = this._processUrl(url, options);\n        if (!this.supportDirectRequest(url, options)) {\n            url = url.replace(\'.json\', \'.jsonp\');\n            var config = {\n                url: url += "&_method=DELETE",\n                data: params\n            };\n            return RequestJSONPPromise.DELETE(config);\n        }\n        if (this.urlIsLong(url)) {\n            return this._postSimulatie(type, url.substring(0, url.indexOf(\'?\') - 1), params, options);\n        }\n        return this._fetch(url, params, options, type);\n    },\n    /**\n     * @function FetchRequest.post\n     * @description post 请求。\n     * @param {string} url - 请求地址。\n     * @param {string} params - 请求参数。\n     * @param {Object} options - 请求的配置属性。\n     * @returns {Promise} Promise 对象。\n     */\n    post: function (url, params, options) {\n        options = options || {};\n        if (!this.supportDirectRequest(url, options)) {\n            url = url.replace(\'.json\', \'.jsonp\');\n            var config = {\n                url: url += "&_method=POST",\n                data: params\n            };\n            return RequestJSONPPromise.POST(config);\n        }\n        return this._fetch(this._processUrl(url, options), params, options, \'POST\');\n    },\n    /**\n     * @function FetchRequest.put\n     * @description put 请求。\n     * @param {string} url - 请求地址。\n     * @param {string} params - 请求参数。\n     * @param {Object} options - 请求的配置属性。\n     * @returns {Promise} Promise 对象。\n     */\n    put: function (url, params, options) {\n        options = options || {};\n        url = this._processUrl(url, options);\n        if (!this.supportDirectRequest(url, options)) {\n            url = url.replace(\'.json\', \'.jsonp\');\n            var config = {\n                url: url += "&_method=PUT",\n                data: params\n            };\n            return RequestJSONPPromise.PUT(config);\n        }\n        return this._fetch(url, params, options, \'PUT\');\n    },\n    /**\n     * @function FetchRequest.urlIsLong\n     * @description url 的字节长度是否太长。\n     * @param {string} url - 请求地址。\n     * @returns {boolean} url 的字节长度是否太长。\n     */\n    urlIsLong: function (url) {\n        //当前url的字节长度。\n        var totalLength = 0,\n            charCode = null;\n        for (var i = 0, len = url.length; i < len; i++) {\n            //转化为Unicode编码\n            charCode = url.charCodeAt(i);\n            if (charCode < 0x007f) {\n                totalLength++;\n            } else if ((0x0080 <= charCode) && (charCode <= 0x07ff)) {\n                totalLength += 2;\n            } else if ((0x0800 <= charCode) && (charCode <= 0xffff)) {\n                totalLength += 3;\n            }\n        }\n        return totalLength < 2000 ? false : true;\n    },\n    _postSimulatie: function (type, url, params, options) {\n        var separator = url.indexOf(\'?\') > -1 ? \'&\' : \'?\';\n        url += separator + \'_method=\' + type;\n        if (typeof params !== \'string\') {\n            params = JSON.stringify(params);\n        }\n        return this.post(url, params, options);\n    },\n\n    _processUrl: function (url, options) {\n        if (this._isMVTRequest(url)) {\n            return url;\n        }\n\n        if (url.indexOf(\'.json\') === -1 && !options.withoutFormatSuffix) {\n            if (url.indexOf(\'?\') < 0) {\n                url += \'.json\';\n            } else {\n                var urlArrays = url.split(\'?\');\n                if (urlArrays.length === 2) {\n                    url = urlArrays[0] + \'.json?\' + urlArrays[1];\n                }\n            }\n        }\n        if (options && options.proxy) {\n            if (typeof options.proxy === \'function\') {\n                url = options.proxy(url);\n            } else {\n                url = decodeURIComponent(url);\n                url = options.proxy + encodeURIComponent(url);\n            }\n        }\n        return url;\n    },\n\n    _fetch: function (url, params, options, type) {\n        options = options || {};\n        options.headers = options.headers || {};\n        if (!options.headers[\'Content-Type\'] && !FormData.prototype.isPrototypeOf(params)) {\n            options.headers[\'Content-Type\'] = \'application/x-www-form-urlencoded;charset=UTF-8\';\n        }\n        if (options.timeout) {\n            return this._timeout(\n                options.timeout,\n                FetchRequest_fetch(url, {\n                    method: type,\n                    headers: options.headers,\n                    body: type === \'PUT\' || type === \'POST\' ? params : undefined,\n                    credentials: this._getWithCredentials(options),\n                    mode: \'cors\',\n                    timeout: getRequestTimeout()\n                }).then(function (response) {\n                    return response;\n                })\n            );\n        }\n        return FetchRequest_fetch(url, {\n            method: type,\n            body: type === \'PUT\' || type === \'POST\' ? params : undefined,\n            headers: options.headers,\n            credentials: this._getWithCredentials(options),\n            mode: \'cors\',\n            timeout: getRequestTimeout()\n        }).then(function (response) {\n            return response;\n        });\n    },\n\n    _getWithCredentials: function (options) {\n        if (options.withCredentials === true) {\n            return \'include\';\n        }\n        if (options.withCredentials === false) {\n            return \'omit\';\n        }\n        return \'same-origin\';\n    },\n\n    _fetchJsonp: function (url, options) {\n        options = options || {};\n        return fetch_jsonp_default()(url, {\n            method: \'GET\',\n            timeout: options.timeout\n        }).then(function (response) {\n            return response;\n        });\n    },\n\n    _timeout: function (seconds, promise) {\n        return new Promise(function (resolve, reject) {\n            setTimeout(function () {\n                reject(new Error(\'timeout\'));\n            }, seconds);\n            promise.then(resolve, reject);\n        });\n    },\n\n    _getParameterString: function (params) {\n        var paramsArray = [];\n        for (var key in params) {\n            var value = params[key];\n            if (value != null && typeof value !== \'function\') {\n                var encodedValue;\n                if (Array.isArray(value) || value.toString() === \'[object Object]\') {\n                    encodedValue = encodeURIComponent(JSON.stringify(value));\n                } else {\n                    encodedValue = encodeURIComponent(value);\n                }\n                paramsArray.push(encodeURIComponent(key) + \'=\' + encodedValue);\n            }\n        }\n        return paramsArray.join(\'&\');\n    },\n\n    _isMVTRequest: function (url) {\n        return url.indexOf(\'.mvt\') > -1 || url.indexOf(\'.pbf\') > -1;\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/Credential.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n/**\n * @class Credential\n * @deprecatedclass SuperMap.Credential\n * @category Security\n * @classdesc SuperMap 的安全证书类，其中包括 token 等安全验证信息。</br>\n * 需要使用用户名和密码在："http://localhost:8090/iserver/services/security/tokens" 下申请 value。</br>\n * 获得形如："2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ.." 的 value。</br>\n * 目前支持的功能包括：地图服务、专题图、量算、查询、公交换乘、空间分析、网络分析，不支持轮询功能。</br>\n * @param {string} value - 访问受安全限制的服务时用于通过安全认证的验证信息。\n * @param {string} [name=\'token\'] - 验证信息前缀，name=value 部分的 name 部分。\n * @example\n * var pixcel = new Credential("valueString","token");\n * pixcel.destroy();\n * @usage\n */\nclass Credential {\n\n    constructor(value, name) {\n\n        /**\n         * @member {string} Credential.prototype.value\n         * @description 访问受安全限制的服务时用于通过安全认证的验证信息。\n         */\n        this.value = value ? value : "";\n\n        /**\n         * @member {string} [Credential.prototype.name=\'token\']\n         * @description 验证信息前缀，name=value 部分的 name 部分。\n         */\n        this.name = name ? name : "token";\n        this.CLASS_NAME = "SuperMap.Credential";\n    }\n\n    /**\n     * @function Credential.prototype.getUrlParameters\n     * @description 获取 name=value 的表达式。\n     * @example\n     * var credential = new Credential("valueString","token");\n     * //这里 str = "token=valueString";\n     * var str = credential.getUrlParameters();\n     * @returns {string} 安全信息组成的 url 片段。\n     */\n    getUrlParameters() {\n        //当需要其他安全信息的时候，则需要return this.name + "=" + this.value + "&" + "...";的形式添加。\n        return this.name + "=" + this.value;\n    }\n\n\n    /**\n     * @function Credential.prototype.getValue\n     * @description 获取 value。\n     * @example\n     * var credential = new Credential("2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ..","token");\n     * //这里 str = "2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ..";\n     * var str = credential.getValue();\n     * @returns {string} value 字符串，在 iServer 服务下该 value 值即为 token 值。\n     */\n    getValue() {\n        return this.value;\n    }\n\n    /**\n     *\n     * @function Credential.prototype.destroy\n     * @description 销毁此对象。销毁后此对象的所有属性为 null，而不是初始值。\n     * @example\n     * var credential = new Credential("valueString","token");\n     * credential.destroy();\n     */\n    destroy() {\n        this.value = null;\n        this.name = null;\n    }\n\n}\n\n/**\n * @member {Credential} Credential.CREDENTIAL\n * @description 这个对象保存一个安全类的实例，在服务端需要安全验证的时候必须进行设置。\n * @example\n * 代码实例:\n *  // 当iServer启用服务安全的时候，下边的代码是必须的。安全证书类能够接收一个value和一个name参数。\n *  var value = "(以iServer为例，这里是申请的token值)";\n *  var name = "token";\n *  // 默认name参数为token，所以当使用iServer服务的时候可以不进行设置。\n *  Credential.CREDENTIAL = new Credential(value, name);\n *\n */\n\n Credential.CREDENTIAL = null;\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/security/SecurityManager.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n\n/**\n * @class SecurityManager\n * @deprecatedclass SuperMap.SecurityManager\n * @category Security\n * @classdesc 安全管理中心，提供 iServer,iPortal,Online 统一权限认证管理。\n *  > 使用说明：\n *  > 创建任何一个服务之前调用 {@link SecurityManager.registerToken}或\n *  > {@link SecurityManager.registerKey}注册凭据。\n *  > 发送请求时根据 url 或者服务 id 获取相应的 key 或者 token 并自动添加到服务地址中。\n * @usage\n */\nclass SecurityManager_SecurityManager {\n    /**\n     * @description 从服务器获取一个token,在此之前要注册服务器信息。\n     * @function SecurityManager.generateToken\n     * @param {string} url - 服务器域名+端口，如：http://localhost:8092。\n     * @param {TokenServiceParameter} tokenParam - token 申请参数。\n     * @returns {Promise} 包含 token 信息的 Promise 对象。\n     */\n\n    static generateToken(url, tokenParam) {\n        var serverInfo = this.servers[url];\n        if (!serverInfo) {\n            return;\n        }\n        return FetchRequest.post(serverInfo.tokenServiceUrl, JSON.stringify(tokenParam.toJSON())).then(function(\n            response\n        ) {\n            return response.text();\n        });\n    }\n\n    /**\n     * @description 注册安全服务器相关信息。\n     * @function SecurityManager.registerServers\n     * @param {ServerInfo} serverInfos - 服务器信息。\n     */\n    static registerServers(serverInfos) {\n        this.servers = this.servers || {};\n        if (!Util.isArray(serverInfos)) {\n            serverInfos = [serverInfos];\n        }\n        for (var i = 0; i < serverInfos.length; i++) {\n            var serverInfo = serverInfos[i];\n            this.servers[serverInfo.server] = serverInfo;\n        }\n    }\n\n    /**\n     * @description 服务请求都会自动带上这个 token。\n     * @function SecurityManager.registerToken\n     * @param {string} url -服务器域名+端口：如http://localhost:8090。\n     * @param {string} token - token\n     */\n    static registerToken(url, token) {\n        this.tokens = this.tokens || {};\n        if (!url || !token) {\n            return;\n        }\n        var domain = this._getTokenStorageKey(url);\n        this.tokens[domain] = token;\n    }\n\n    /**\n     * @description 注册 key,ids 为数组(存在一个 key 对应多个服务)。\n     * @function SecurityManager.registerKey\n     * @param {Array} ids - 可以是服务 id 数组或者 url 地址数组或者 webAPI 类型数组。\n     * @param {string} key - key\n     */\n    static registerKey(ids, key) {\n        this.keys = this.keys || {};\n        if (!ids || ids.length < 1 || !key) {\n            return;\n        }\n\n        ids = Util.isArray(ids) ? ids : [ids];\n        for (var i = 0; i < ids.length; i++) {\n            var id = this._getUrlRestString(ids[0]) || ids[0];\n            this.keys[id] = key;\n        }\n    }\n\n    /**\n     * @description 获取服务器信息。\n     * @function SecurityManager.getServerInfo\n     * @param {string} url - 服务器域名+端口，如：http://localhost:8092。\n     * @returns {ServerInfo} 服务器信息。\n     */\n    static getServerInfo(url) {\n        this.servers = this.servers || {};\n        return this.servers[url];\n    }\n\n    /**\n     * @description 根据 Url 获取token。\n     * @function SecurityManager.getToken\n     * @param {string} url - 服务器域名+端口，如：http://localhost:8092。\n     * @returns {string} token\n     */\n    static getToken(url) {\n        if (!url) {\n            return;\n        }\n        this.tokens = this.tokens || {};\n        var domain = this._getTokenStorageKey(url);\n        return this.tokens[domain];\n    }\n\n    /**\n     * @description 根据 Url 获取 key。\n     * @function SecurityManager.getKey\n     * @param {string} id - id\n     * @returns {string} key\n     */\n    static getKey(id) {\n        this.keys = this.keys || {};\n        var key = this._getUrlRestString(id) || id;\n        return this.keys[key];\n    }\n\n    /**\n     * @description iServer 登录验证。\n     * @function SecurityManager.loginiServer\n     * @param {string} url - iServer 首页地址，如：http://localhost:8090/iserver。\n     * @param {string} username - 用户名。\n     * @param {string} password - 密码。\n     * @param {boolean} [rememberme=false] - 是否记住。\n     * @returns {Promise} 包含 iServer 登录请求结果的 Promise 对象。\n     */\n    static loginiServer(url, username, password, rememberme) {\n        url = Util.urlPathAppend(url, \'services/security/login\');\n        var loginInfo = {\n            username: username && username.toString(),\n            password: password && password.toString(),\n            rememberme: rememberme\n        };\n        loginInfo = JSON.stringify(loginInfo);\n        var requestOptions = {\n            headers: {\n                \'Content-Type\': \'application/x-www-form-urlencoded; charset=UTF-8\'\n            }\n        };\n        return FetchRequest.post(url, loginInfo, requestOptions).then(function(response) {\n            return response.json();\n        });\n    }\n\n    /**\n     * @description iServer登出。\n     * @function SecurityManager.logoutiServer\n     * @param {string} url - iServer 首页地址,如：http://localhost:8090/iserver。\n     * @returns {Promise} 是否登出成功。\n     */\n    static logoutiServer(url) {\n        url = Util.urlPathAppend(url, \'services/security/logout\');\n        var requestOptions = {\n            headers: {\n                \'Content-Type\': \'application/x-www-form-urlencoded; charset=UTF-8\'\n            },\n            withoutFormatSuffix: true\n        };\n        return FetchRequest.get(url, \'\', requestOptions)\n            .then(function() {\n                return true;\n            })\n            .catch(function() {\n                return false;\n            });\n    }\n\n    /**\n     * @description Online 登录验证。\n     * @function SecurityManager.loginOnline\n     * @param {string} callbackLocation - 跳转位置。\n     * @param {boolean} [newTab=true] - 是否新窗口打开。\n     */\n    static loginOnline(callbackLocation, newTab) {\n        var loginUrl = SecurityManager_SecurityManager.SSO + \'/login?service=\' + callbackLocation;\n        this._open(loginUrl, newTab);\n    }\n\n    /**\n     * @description iPortal登录验证。\n     * @function SecurityManager.loginiPortal\n     * @param {string} url - iportal 首页地址,如：http://localhost:8092/iportal.\n     * @param {string} username - 用户名。\n     * @param {string} password - 密码。\n     * @returns {Promise} 包含 iPortal 登录请求结果的 Promise 对象。\n     */\n    static loginiPortal(url, username, password) {\n        url = Util.urlPathAppend(url, \'web/login\');\n        var loginInfo = {\n            username: username && username.toString(),\n            password: password && password.toString()\n        };\n        loginInfo = JSON.stringify(loginInfo);\n        var requestOptions = {\n            headers: {\n                \'Content-Type\': \'application/x-www-form-urlencoded; charset=UTF-8\'\n            },\n            withCredentials: true\n        };\n        return FetchRequest.post(url, loginInfo, requestOptions).then(function(response) {\n            return response.json();\n        });\n    }\n\n    /**\n     * @description iPortal 登出。\n     * @function SecurityManager.logoutiPortal\n     * @param {string} url - iportal 首页地址,如：http://localhost:8092/iportal.\n     * @returns {Promise} 如果登出成功，返回 true;否则返回 false。\n     */\n    static logoutiPortal(url) {\n        url = Util.urlPathAppend(url, \'services/security/logout\');\n        var requestOptions = {\n            headers: {\n                \'Content-Type\': \'application/x-www-form-urlencoded; charset=UTF-8\'\n            },\n            withCredentials: true,\n            withoutFormatSuffix: true\n        };\n        return FetchRequest.get(url, \'\', requestOptions)\n            .then(function() {\n                return true;\n            })\n            .catch(function() {\n                return false;\n            });\n    }\n\n    /**\n     * @description iManager 登录验证。\n     * @function SecurityManager.loginManager\n     * @param {string} url - iManager 地址。地址参数为 iManager 首页地址，如： http://localhost:8390/imanager。\n     * @param {Object} [loginInfoParams] - iManager 登录参数。\n     * @param {string} loginInfoParams.userName - 用户名。\n     * @param {string} loginInfoParams.password - 密码。\n     * @param {Object} options\n     * @param {boolean} [options.isNewTab=true] - 不同域时是否在新窗口打开登录页面。\n     * @returns {Promise} 包含 iManager 登录请求结果的 Promise 对象。\n     */\n    static loginManager(url, loginInfoParams, options) {\n        if (!Util.isInTheSameDomain(url)) {\n            var isNewTab = options ? options.isNewTab : true;\n            this._open(url, isNewTab);\n            return;\n        }\n        var requestUrl = Util.urlPathAppend(url, \'icloud/security/tokens\');\n        var params = loginInfoParams || {};\n        var loginInfo = {\n            username: params.userName && params.userName.toString(),\n            password: params.password && params.password.toString()\n        };\n        loginInfo = JSON.stringify(loginInfo);\n        var requestOptions = {\n            headers: {\n                Accept: \'*/*\',\n                \'Content-Type\': \'application/json\'\n            }\n        };\n        var me = this;\n        return FetchRequest.post(requestUrl, loginInfo, requestOptions).then(function(response) {\n            response.text().then(function(result) {\n                me.imanagerToken = result;\n                return result;\n            });\n        });\n    }\n\n    /**\n     * @description 清空全部验证信息。\n     * @function SecurityManager.destroyAllCredentials\n     */\n    static destroyAllCredentials() {\n        this.keys = null;\n        this.tokens = null;\n        this.servers = null;\n    }\n\n    /**\n     * @description 清空令牌信息。\n     * @function SecurityManager.destroyToken\n     * @param {string} url - iportal 首页地址,如：http://localhost:8092/iportal.\n     */\n    static destroyToken(url) {\n        if (!url) {\n            return;\n        }\n        var domain = this._getTokenStorageKey(url);\n        this.tokens = this.tokens || {};\n        if (this.tokens[domain]) {\n            delete this.tokens[domain];\n        }\n    }\n\n    /**\n     * @description 清空服务授权码。\n     * @function SecurityManager.destroyKey\n     * @param {string} url - iServer 首页地址,如：http://localhost:8090/iserver。\n     */\n    static destroyKey(url) {\n        if (!url) {\n            return;\n        }\n        this.keys = this.keys || {};\n        var key = this._getUrlRestString(url) || url;\n        if (this.keys[key]) {\n            delete this.keys[key];\n        }\n    }\n\n    /**\n     * @description 服务URL追加授权信息，授权信息需先通过SecurityManager.registerKey或SecurityManager.registerToken注册。\n     * @version 10.1.2\n     * @function SecurityManager.appendCredential\n     * @param {string} url - 服务URL\n     * @returns {string} 绑定了token或者key的服务URL\n     */\n    static appendCredential(url) {\n        var newUrl = url;\n        var value = this.getToken(url);\n        var credential = value ? new Credential(value, \'token\') : null;\n\t\tif (!credential) {\n            value = this.getKey(url);\n            credential = value ? new Credential(value, \'key\') : null;\n          }\n        if (credential) {\n            newUrl = Util.urlAppend(newUrl, credential.getUrlParameters());\n        }\n        return newUrl;\n    }\n\n    static _open(url, newTab) {\n        newTab = newTab != null ? newTab : true;\n        var offsetX = window.screen.availWidth / 2 - this.INNER_WINDOW_WIDTH / 2;\n        var offsetY = window.screen.availHeight / 2 - this.INNER_WINDOW_HEIGHT / 2;\n        var options =\n            \'height=\' +\n            this.INNER_WINDOW_HEIGHT +\n            \', width=\' +\n            this.INNER_WINDOW_WIDTH +\n            \',top=\' +\n            offsetY +\n            \', left=\' +\n            offsetX +\n            \',toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no\';\n        if (newTab) {\n            window.open(url, \'login\');\n        } else {\n            window.open(url, \'login\', options);\n        }\n    }\n\n    static _getTokenStorageKey(url) {\n        var patten = /(.*?):\\/\\/([^\\/]+)/i;\n        var result = url.match(patten);\n        if (!result) {\n            return url;\n        }\n        return result[0];\n    }\n\n    static _getUrlRestString(url) {\n        if (!url) {\n            return url;\n        }\n        // var patten = /http:\\/\\/(.*\\/rest)/i;\n        var patten = /(http|https):\\/\\/(.*\\/rest)/i;\n        var result = url.match(patten);\n        if (!result) {\n            return url;\n        }\n        return result[0];\n    }\n}\nSecurityManager_SecurityManager.INNER_WINDOW_WIDTH = 600;\nSecurityManager_SecurityManager.INNER_WINDOW_HEIGHT = 600;\nSecurityManager_SecurityManager.SSO = \'https://sso.supermap.com\';\nSecurityManager_SecurityManager.ONLINE = \'https://www.supermapol.com\';\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/Size.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n/**\n * @class  Size\n * @deprecatedclass SuperMap.Size\n * @category BaseTypes Style\n * @classdesc 此类描绘一对高宽值的实例。\n * @param {number} [w=0.0] - 宽度。\n * @param {number} [h=0.0] - 高度。\n *\n * @example\n * var size = new Size(31,46);\n * @usage\n */\nclass Size {\n\n    constructor(w, h) {\n        /**\n         * @member {number} [Size.prototype.w=0.0]\n         * @description 宽度。\n         */\n        this.w = w ? parseFloat(w) : 0.0;\n\n        /**\n         * @member {number} [Size.prototype.h=0.0]\n         * @description 高度。\n         */\n        this.h = w ? parseFloat(h) : 0.0;\n        this.CLASS_NAME = "SuperMap.Size";\n    }\n\n\n    /**\n     * @function Size.prototype.toString\n     * @description 返回字符串形式。\n     * @example\n     * var size = new Size(10,5);\n     * var str = size.toString();\n     * @returns {string} 例如："w=10,h=5"。\n     */\n    toString() {\n        return ("w=" + this.w + ",h=" + this.h);\n    }\n\n\n    /**\n     * @function Size.prototype.clone\n     * @description 克隆当前size对象。\n     * @example\n     * var size = new Size(31,46);\n     * var size2 = size.clone();\n     * @returns {Size}  新的与当前 size 对象有相同宽、高的 Size 对象。\n     */\n    clone() {\n        return new Size(this.w, this.h);\n    }\n\n\n    /**\n     *\n     * @function Size.prototype.equals\n     * @description 比较两个 size 对象是否相等。\n     * @example\n     * var size = new Size(31,46);\n     * var size2 = new Size(31,46);\n     * var isEquals = size.equals(size2);\n     *\n     * @param {Size} sz - 用于比较相等的 Size 对象。\n     * @returns {boolean} 传入的 size 和当前 size 高宽相等，注意：如果传入的 size 为空则返回 false。\n     *\n     */\n    equals(sz) {\n        var equals = false;\n        if (sz != null) {\n            equals = ((this.w === sz.w && this.h === sz.h) ||\n                (isNaN(this.w) && isNaN(this.h) && isNaN(sz.w) && isNaN(sz.h)));\n        }\n        return equals;\n    }\n\n    /**\n     *\n     * @function Size.prototype.destroy\n     * @description 销毁此对象。销毁后此对象的所有属性为 null，而不是初始值。\n     * @example\n     * var size = new Size(31,46);\n     * size.destroy();\n     */\n    destroy() {\n        this.w = null;\n        this.h = null;\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/Pixel.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n/**\n * @class Pixel\n * @deprecatedclass SuperMap.Pixel\n * @category BaseTypes Geometry\n * @classdesc 用 x,y 坐标描绘屏幕坐标（像素点）。\n * @param {number} [x=0.0] - x 坐标。\n * @param {number} [y=0.0] - y 坐标。\n * @param {Pixel.Mode} [mode=Pixel.Mode.LeftTop] - 坐标模式。\n *\n * @example\n * //单独创建一个对象\n * var pixcel = new Pixel(100,50);\n *\n * //依据 size 创建\n *  var size = new Size(21,25);\n *  var offset = new Pixel(-(size.w/2), -size.h);\n * @usage\n */\nclass Pixel {\n  constructor(x, y, mode) {\n    /**\n     * @member {number} [Pixel.prototype.x=0.0]\n     * @description x 坐标。\n     */\n    this.x = x ? parseFloat(x) : 0.0;\n\n    /**\n     * @member {number} [Pixel.prototype.y=0.0]\n     * @description y 坐标。\n     */\n    this.y = y ? parseFloat(y) : 0.0;\n\n    /**\n     * @member {Pixel.Mode} [Pixel.prototype.mode=Pixel.Mode.LeftTop]\n     * @description 坐标模式，有左上、右上、右下、左下这几种模式，分别表示相对于左上角、右上角、右下角、左下角的坐标。\n     */\n    this.mode = mode;\n    this.CLASS_NAME = \'SuperMap.Pixel\';\n  }\n\n  /**\n   * @function Pixel.prototype.toString\n   * @description 返回此对象的字符串形式。\n   * @example\n   *\n   * var pixcel = new Pixel(100,50);\n   * var str = pixcel.toString();\n   *\n   * @returns {string} 例如: "x=200.4,y=242.2"\n   */\n  toString() {\n    return \'x=\' + this.x + \',y=\' + this.y;\n  }\n\n  /**\n   * @function Pixel.prototype.clone\n   * @description 克隆当前的 pixel 对象。\n   * @example\n   * var pixcel = new Pixel(100,50);\n   * var pixcel2 = pixcel.clone();\n   * @returns {Pixel} 新的与当前 pixel 对象有相同 x、y 坐标的 pixel 对象。\n   */\n  clone() {\n    return new Pixel(this.x, this.y, this.mode);\n  }\n\n  /**\n   * @function Pixel.prototype.equals\n   * @description 比较两 pixel 是否相等。\n   * @example\n   * var pixcel = new Pixel(100,50);\n   * var pixcel2 = new Pixel(100,50);\n   * var isEquals = pixcel.equals(pixcel2);\n   *\n   * @param {Pixel} px - 用于比较相等的 pixel 对象。\n   * @returns {boolean} 如果传入的像素点和当前像素点相同返回 true，如果不同或传入参数为 NULL 则返回 false。\n   */\n  equals(px) {\n    var equals = false;\n    if (px != null) {\n      equals = (this.x == px.x && this.y == px.y) || (isNaN(this.x) && isNaN(this.y) && isNaN(px.x) && isNaN(px.y));\n    }\n    return equals;\n  }\n\n  /**\n   * @function Pixel.prototype.distanceTo\n   * @description 返回两个 pixel 的距离。\n   * @example\n   * var pixcel = new Pixel(100,50);\n   * var pixcel2 = new Pixel(110,30);\n   * var distance = pixcel.distanceTo(pixcel2);\n   *\n   * @param {Pixel} px - 需要计算的 pixel。\n   * @returns {number} 作为参数传入的像素与当前像素点的距离。\n   */\n  distanceTo(px) {\n    return Math.sqrt(Math.pow(this.x - px.x, 2) + Math.pow(this.y - px.y, 2));\n  }\n\n  /**\n   * @function Pixel.prototype.add\n   * @description 在原来像素坐标基础上，x 值加上传入的 x 参数，y 值加上传入的 y 参数。\n   * @example\n   * var pixcel = new Pixel(100,50);\n   * //pixcel2是新的对象\n   * var pixcel2 = pixcel.add(20,30);\n   *\n   * @param {number} x - 传入的 x 值。\n   * @param {number} y - 传入的 y 值。\n   * @returns {Pixel} 新的 pixel 对象，该 pixel 是由当前的 pixel 与传入的 x，y 相加得到。\n   */\n  add(x, y) {\n    if (x == null || y == null) {\n      throw new TypeError(\'Pixel.add cannot receive null values\');\n    }\n    return new Pixel(this.x + x, this.y + y);\n  }\n\n  /**\n   * @function Pixel.prototype.offset\n   * @description 通过传入的 {@link Pixel} 参数对原屏幕坐标进行偏移。\n   * @example\n   * var pixcel = new Pixel(100,50);\n   * var pixcel2 = new Pixel(130,20);\n   * //pixcel3 是新的对象\n   * var pixcel3 = pixcel.offset(pixcel2);\n   *\n   * @param {Pixel} px - 传入的 {@link Pixel} 对象。\n   * @returns {Pixel} 新的 pixel，该 pixel 是由当前的 pixel 对象的 x，y 值与传入的 Pixel 对象的 x，y 值相加得到。\n   */\n  offset(px) {\n    var newPx = this.clone();\n    if (px) {\n      newPx = this.add(px.x, px.y);\n    }\n    return newPx;\n  }\n\n  /**\n   *\n   * @function Pixel.prototype.destroy\n   * @description 销毁此对象。销毁后此对象的所有属性为 null，而不是初始值。\n   * @example\n   * var pixcel = new Pixel(100,50);\n   * pixcel.destroy();\n   */\n  destroy() {\n    this.x = null;\n    this.y = null;\n    this.mode = null;\n  }\n}\n/**\n * @enum Mode\n * @memberOf Pixel\n * @readonly\n * @description 模式。\n * @type {string}\n */\nPixel.Mode = {\n  /** 左上模式。*/\n  LeftTop: \'lefttop\',\n  /** 右上模式。 */\n  RightTop: \'righttop\',\n  /** 右下模式。 */\n  RightBottom: \'rightbottom\',\n  /** 左下模式。 */\n  LeftBottom: \'leftbottom\'\n};\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/LonLat.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n/**\n * @class LonLat\n * @category BaseTypes Geometry\n * @classdesc  这个类用来表示经度和纬度对。\n * @param {number|Array.<number>} [lon=0.0] - 地图单位上的 X 轴坐标或者横纵坐标组成的数组；如果地图是地理投影，则此值是经度，否则，此值是地图地理位置的 x 坐标。\n * @param {number} [lat=0.0] - 地图单位上的 Y 轴坐标，如果地图是地理投影，则此值是纬度，否则，此值是地图地理位置的 y 坐标。\n * @example\n * var lonLat = new LonLat(30,45);\n * @usage\n */\nclass LonLat_LonLat {\n\n\n    constructor(lon, lat) {\n        if (Util.isArray(lon)) {\n            lat = lon[1];\n            lon = lon[0];\n        }\n        /**\n         * @member {number} [LonLat.prototype.lon=0.0]\n         * @description 地图的单位的 X 轴（横轴）坐标。\n         */\n        this.lon = lon ? Util.toFloat(lon) : 0.0;\n\n        /**\n         * @member {number} [LonLat.prototype.lat=0.0]\n         * @description 地图的单位的 Y 轴（纵轴）坐标。\n         */\n        this.lat = lat ? Util.toFloat(lat) : 0.0;\n        this.CLASS_NAME = "SuperMap.LonLat";\n    }\n\n    /**\n     * @function LonLat.prototype.toString\n     * @description 返回此对象的字符串形式\n     * @example\n     * var lonLat = new LonLat(100,50);\n     * var str = lonLat.toString();\n     * @returns {string} 例如: "lon=100,lat=50"\n     */\n    toString() {\n        return ("lon=" + this.lon + ",lat=" + this.lat);\n    }\n\n    /**\n     * @function LonLat.prototype.toShortString\n     * @description 将经度纬度转换成简单字符串。\n     * @example\n     * var lonLat = new LonLat(100,50);\n     * var str = lonLat.toShortString();\n     * @returns {string} 处理后的经纬度字符串。例如："100,50"\n     */\n    toShortString() {\n        return (this.lon + "," + this.lat);\n    }\n\n    /**\n     * @function LonLat.prototype.clone\n     * @description 复制坐标对象，并返回复制后的新对象。\n     * @example\n     * var lonLat1 = new LonLat(100,50);\n     * var lonLat2 = lonLat1.clone();\n     * @returns {LonLat}  相同坐标值的新的坐标对象。\n     */\n    clone() {\n        return new LonLat_LonLat(this.lon, this.lat);\n    }\n\n    /**\n     * @function LonLat.prototype.add\n     * @description 在已有坐标对象的经纬度基础上加上新的坐标经纬度，并返回新的坐标对象。\n     * @example\n     * var lonLat1 = new LonLat(100,50);\n     * //lonLat2 是新的对象\n     * var lonLat2 = lonLat1.add(100,50);\n     * @param {number} lon - 经度参数。\n     * @param {number} lat - 纬度参数。\n     * @returns {LonLat} 新的 LonLat 对象，此对象的经纬度是由传入的经纬度与当前的经纬度相加所得。\n     */\n    add(lon, lat) {\n        if ((lon == null) || (lat == null)) {\n            throw new TypeError(\'LonLat.add cannot receive null values\');\n        }\n        return new LonLat_LonLat(this.lon + Util.toFloat(lon),\n            this.lat + Util.toFloat(lat));\n    }\n\n    /**\n     * @function LonLat.prototype.equals\n     * @description 判断两个坐标对象是否相等。\n     * @example\n     * var lonLat1 = new LonLat(100,50);\n     * var lonLat2 = new LonLat(100,50);\n     * var isEquals = lonLat1.equals(lonLat2);\n     * @param {LonLat} ll - 需要进行比较的坐标对象。\n     * @returns {boolean} 如果LonLat对象的经纬度和传入的经纬度一致则返回true,不一\n     *      致或传入的ll参数为NULL则返回false。\n     */\n    equals(ll) {\n        var equals = false;\n        if (ll != null) {\n            equals = ((this.lon === ll.lon && this.lat === ll.lat) ||\n                (isNaN(this.lon) && isNaN(this.lat) && isNaN(ll.lon) && isNaN(ll.lat)));\n        }\n        return equals;\n    }\n\n    /**\n     * @function LonLat.prototype.wrapDateLine\n     * @description 通过传入的范围对象对坐标对象转换到该范围内。\n     * 如果经度小于给定范围最小精度，则在原经度基础上加上范围宽度，直到精度在范围内为止，如果经度大于给定范围则在原经度基础上减去范围宽度。\n     * 即指将不在经度范围内的坐标转换到范围以内（只会转换 lon，不会转换 lat，主要用于转移到日界线以内）。\n     * @example\n     * var lonLat1 = new LonLat(420,50);\n     * var lonLat2 = lonLat1.wrapDateLine(\n     *      new Bounds(-180,-90,180,90)\n     *  );\n     * @param {Bounds} maxExtent - 最大边界的范围。\n     * @returns {LonLat} 将坐标转换到范围对象以内，并返回新的坐标。\n     */\n    wrapDateLine(maxExtent) {\n\n        var newLonLat = this.clone();\n\n        if (maxExtent) {\n            //shift right?\n            while (newLonLat.lon < maxExtent.left) {\n                newLonLat.lon += maxExtent.getWidth();\n            }\n\n            //shift left?\n            while (newLonLat.lon > maxExtent.right) {\n                newLonLat.lon -= maxExtent.getWidth();\n            }\n        }\n\n        return newLonLat;\n    }\n\n    /**\n     *\n     * @function LonLat.prototype.destroy\n     * @description 销毁此对象。\n     * 销毁后此对象的所有属性为 null，而不是初始值。\n     * @example\n     * var lonLat = new LonLat(100,50);\n     * lonLat.destroy();\n     */\n    destroy() {\n        this.lon = null;\n        this.lat = null;\n    }\n\n    /**\n     * @function LonLat.fromString\n     * @description 通过字符串生成一个 {@link LonLat} 对象。\n     * @example\n     * var str = "100,50";\n     * var lonLat = LonLat.fromString(str);\n     * @param {string} str - 字符串的格式：Lon+","+Lat。如："100,50"。\n     * @returns {LonLat} {@link LonLat} 对象。\n     */\n    static fromString(str) {\n        var pair = str.split(",");\n        return new LonLat_LonLat(pair[0], pair[1]);\n    }\n\n    /**\n     * @function LonLat.fromArray\n     * @description 通过数组生成一个 {@link LonLat} 对象。\n     * @param {Array.<number>} arr - 数组的格式，长度只能为2,：[Lon,Lat]。如：[5,-42]。\n     * @returns {LonLat} {@link LonLat} 对象。\n     */\n    static fromArray(arr) {\n        var gotArr = Util.isArray(arr),\n            lon = gotArr && arr[0],\n            lat = gotArr && arr[1];\n        return new LonLat_LonLat(lon, lat);\n    }\n\n\n}\n\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/Bounds.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n\n\n/**\n * @class Bounds\n * @deprecatedclass SuperMap.Bounds\n * @category BaseTypes Geometry\n * @classdesc 表示边界类实例。使用 bounds 之前需要设置 left，bottom，right，top 四个属性，这些属性的初始值为 null。\n * @param {number|Array.<number>} [left] - 如果是number，则表示左边界，注意考虑宽度，理论上小于 right 值。如果是数组，则表示 [left, bottom, right, top] 左下右上组成的数组。\n * @param {number} [bottom] - 下边界。考虑高度，理论上小于 top 值。\n * @param {number} [right] - 右边界。\n * @param {number} [top] - 上边界。\n * @example\n * var bounds = new Bounds();\n * bounds.extend(new LonLat(4,5));\n * bounds.extend(new LonLat(5,6));\n * bounds.toBBOX(); // returns 4,5,5,6\n * @usage\n */\nclass Bounds_Bounds {\n\n\n    constructor(left, bottom, right, top) {\n        if (Util.isArray(left)) {\n            top = left[3];\n            right = left[2];\n            bottom = left[1];\n            left = left[0];\n        }\n        /**\n         * @member {number} Bounds.prototype.left\n         * @description 最小的水平坐标系。\n         */\n        this.left = left != null ? Util.toFloat(left) : this.left;\n\n        /**\n         * @member {number} Bounds.prototype.bottom\n         * @description 最小的垂直坐标系。\n         */\n        this.bottom = bottom != null ? Util.toFloat(bottom) : this.bottom;\n\n        /**\n         * @member {number} Bounds.prototype.right\n         * @description 最大的水平坐标系。\n         */\n        this.right = right != null ? Util.toFloat(right) : this.right;\n\n        /**\n         * @member {number} Bounds.prototype.top\n         * @description 最大的垂直坐标系。\n         */\n        this.top = top != null ? Util.toFloat(top) : this.top;\n\n        /**\n         * @member {LonLat} Bounds.prototype.centerLonLat\n         * @description bounds 的地图空间的中心点。用 getCenterLonLat() 获得。\n         */\n        this.centerLonLat = null;\n        this.CLASS_NAME = "SuperMap.Bounds";\n    }\n\n    /**\n     * @function Bounds.prototype.clone\n     * @description 复制当前 bounds 对象。\n     * @example\n     * var bounds1 = new Bounds(-180,-90,180,90);\n     * var bounds2 = bounds1.clone();\n     * @returns {Bounds} 克隆后的 bounds。\n     */\n    clone() {\n        return new Bounds_Bounds(this.left, this.bottom,\n            this.right, this.top);\n    }\n\n    /**\n     * @function Bounds.prototype.equals\n     * @description 判断两个 bounds 对象是否相等。\n     * @example\n     * var bounds1 = new Bounds(-180,-90,180,90);\n     * var bounds2 = new Bounds(-180,-90,180,90);\n     * var isEquals = bounds1.equals(bounds2);\n     * @param {Bounds} bounds - 需要进行计较的 bounds。\n     * @returns {boolean} 如果 bounds 对象的边和传入的 bounds 一致则返回 true，不一致或传入的 bounds 参数为 NULL 则返回 false。\n     */\n    equals(bounds) {\n        var equals = false;\n        if (bounds != null) {\n            equals = ((this.left === bounds.left) &&\n                (this.right === bounds.right) &&\n                (this.top === bounds.top) &&\n                (this.bottom === bounds.bottom));\n        }\n        return equals;\n    }\n\n    /**\n     * @function Bounds.prototype.toString\n     * @description 返回此对象的字符串形式。\n     * @example\n     * var bounds = new Bounds(-180,-90,180,90);\n     * var str = bounds.toString();\n     * @returns {string} 边界对象的字符串表示形式（left,bottom,right,top），例如: "-180,-90,180,90"。\n     */\n    toString() {\n        return [this.left, this.bottom, this.right, this.top].join(",");\n    }\n\n    /**\n     * @function Bounds.prototype.toArray\n     * @description 边界对象的数组表示形式。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * //array1 = [-180,-90,100,80];\n     * var array1 = bounds.toArray();\n     * //array1 = [-90,-180,80,100];\n     * var array2 = bounds.toArray(true);\n     * @param {boolean} [reverseAxisOrder=false] - 是否反转轴顺序。\n     * 如果设为 true，则倒转顺序（bottom,left,top,right），否则按正常轴顺序（left,bottom,right,top）。\n     * @returns {Array.<number>} left, bottom, right, top 数组。\n     */\n    toArray(reverseAxisOrder) {\n        if (reverseAxisOrder === true) {\n            return [this.bottom, this.left, this.top, this.right];\n        } else {\n            return [this.left, this.bottom, this.right, this.top];\n        }\n    }\n\n    /**\n     * @function Bounds.prototype.toBBOX\n     * @description 取小数点后 decimal 位数字进行四舍五入再转换为 BBOX 字符串。\n     * @example\n     * var bounds = new Bounds(-1.1234567,-1.7654321,1.4444444,1.5555555);\n     * //str1 = "-1.123457,-1.765432,1.444444,1.555556";\n     * var str1 = bounds.toBBOX();\n     * //str2 = "-1.1,-1.8,1.4,1.6";\n     * var str2 = bounds.toBBOX(1);\n     * //str2 = "-1.8,-1.1,1.6,1.4";\n     * var str2 = bounds.toBBOX(1,true);\n     * @param {number} [decimal=6] - 边界方位坐标的有效数字个数。\n     * @param {boolean} [reverseAxisOrder=false] - 是否是反转轴顺序。\n     * 如果设为true，则倒转顺序（bottom,left,top,right）,否则按正常轴顺序（left,bottom,right,top）。\n     * @returns {string} 边界对象的字符串表示形式，如："5,42,10,45"。\n     */\n    toBBOX(decimal, reverseAxisOrder) {\n        if (decimal == null) {\n            decimal = 6;\n        }\n        var mult = Math.pow(10, decimal);\n        var xmin = Math.round(this.left * mult) / mult;\n        var ymin = Math.round(this.bottom * mult) / mult;\n        var xmax = Math.round(this.right * mult) / mult;\n        var ymax = Math.round(this.top * mult) / mult;\n        if (reverseAxisOrder === true) {\n            return ymin + "," + xmin + "," + ymax + "," + xmax;\n        } else {\n            return xmin + "," + ymin + "," + xmax + "," + ymax;\n        }\n    }\n\n    ///**\n    // * @function Bounds.prototype.toGeometry\n    // * @description 基于当前边界范围创建一个新的多边形对象。\n    // * @example\n    // * var bounds = new Bounds(-180,-90,100,80);\n    // * // Polygon对象\n    // * var geo = bounds.toGeometry();\n    // * @returns {GeometryPolygon} 基于当前 bounds 坐标创建的新的多边形。\n    // */\n    // toGeometry() {\n    //     return new Polygon([\n    //         new LinearRing([\n    //             new Point(this.left, this.bottom),\n    //             new Point(this.right, this.bottom),\n    //             new Point(this.right, this.top),\n    //             new Point(this.left, this.top)\n    //         ])\n    //     ]);\n    // }\n\n    /**\n     * @function Bounds.prototype.getWidth\n     * @description 获取 bounds 的宽度。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * //width = 280;\n     * var width = bounds.getWidth();\n     * @returns {number} 获取当前 bounds 的宽度（right 减去 left）。\n     */\n    getWidth() {\n        return (this.right - this.left);\n    }\n\n    /**\n     * @function Bounds.prototype.getHeight\n     * @description 获取 bounds 的高度。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * //height = 170;\n     * var height = bounds.getHeight();\n     * @returns {number} 边界高度（top 减去 bottom）。\n     */\n    getHeight() {\n        return (this.top - this.bottom);\n    }\n\n    /**\n     * @function Bounds.prototype.getSize\n     * @description 获取边框大小。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * var size = bounds.getSize();\n     * @returns {Size} 边框大小。\n     */\n    getSize() {\n        return new Size(this.getWidth(), this.getHeight());\n    }\n\n    /**\n     * @function Bounds.prototype.getCenterPixel\n     * @description 获取像素格式的范围中心点。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * var pixel = bounds.getCenterPixel();\n     * @returns {Pixel} 像素格式的当前范围的中心点。\n     */\n    getCenterPixel() {\n        return new Pixel((this.left + this.right) / 2,\n            (this.bottom + this.top) / 2);\n    }\n\n    /**\n     * @function Bounds.prototype.getCenterLonLat\n     * @description 获取地理格式的范围中心点。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * var lonlat = bounds.getCenterLonLat();\n     * @returns {LonLat} 当前地理范围的中心点。\n     */\n    getCenterLonLat() {\n        if (!this.centerLonLat) {\n            this.centerLonLat = new LonLat_LonLat(\n                (this.left + this.right) / 2, (this.bottom + this.top) / 2\n            );\n        }\n        return this.centerLonLat;\n    }\n\n    /**\n     * @function Bounds.prototype.scale\n     * @description 按照比例扩大/缩小出一个新的 bounds。\n     * @example\n     * var bounds = new Bounds(-50,-50,40,40);\n     * var bounds2 = bounds.scale(2);\n     * @param {number} [ratio=1] - 需要扩大的比例。\n     * @param {(Pixel|LonLat)} [origin] - 扩大时的基准点，默认为当前 bounds 的中心点。\n     * @returns {Bounds} 通过 ratio、origin 计算得到的新的边界范围。\n     */\n    scale(ratio, origin) {\n        ratio = ratio ? ratio : 1;\n        if (origin == null) {\n            origin = this.getCenterLonLat();\n        }\n\n        var origx, origy;\n\n        // get origin coordinates\n        if (origin.CLASS_NAME === "SuperMap.LonLat") {\n            origx = origin.lon;\n            origy = origin.lat;\n        } else {\n            origx = origin.x;\n            origy = origin.y;\n        }\n\n        var left = (this.left - origx) * ratio + origx;\n        var bottom = (this.bottom - origy) * ratio + origy;\n        var right = (this.right - origx) * ratio + origx;\n        var top = (this.top - origy) * ratio + origy;\n\n        return new Bounds_Bounds(left, bottom, right, top);\n    }\n\n    /**\n     * @function Bounds.prototype.add\n     * @description 在当前的 Bounds 上按照传入的坐标点进行平移，返回新的范围。\n     * @example\n     * var bounds1 = new Bounds(-50,-50,40,40);\n     * //bounds2 是新的 bounds\n     * var bounds2 = bounds.add(20,10);\n     * @param {number} x - 坐标点的 x 坐标。\n     * @param {number} y - 坐标点的 y 坐标。\n     * @returns {Bounds} 新的 bounds，此 bounds 的坐标是由传入的 x，y 参数与当前 bounds 坐标计算所得。\n     */\n    add(x, y) {\n        if ((x == null) || (y == null)) {\n            throw new TypeError(\'Bounds.add cannot receive null values\');\n        }\n        return new Bounds_Bounds(this.left + x, this.bottom + y,\n            this.right + x, this.top + y);\n    }\n\n    /**\n     * @function Bounds.prototype.extend\n     * @description 在当前 bounds 上扩展 bounds，支持 point，lanlat 和 bounds。扩展后的 bounds 的范围是两者的结合。\n     * @example\n     * var bounds1 = new Bounds(-50,-50,40,40);\n     * //bounds 改变\n     * bounds.extend(new LonLat(50,60));\n     * @param {GeometryPoint|LonLat|Bounds} object - 可以是 point、lonlat 和 bounds。\n     */\n    extend(object) {\n        var bounds = null;\n        if (object) {\n            // clear cached center location\n            switch (object.CLASS_NAME) {\n                case "SuperMap.LonLat":\n                    bounds = new Bounds_Bounds(object.lon, object.lat,\n                        object.lon, object.lat);\n                    break;\n                case "SuperMap.Geometry.Point":\n                    bounds = new Bounds_Bounds(object.x, object.y,\n                        object.x, object.y);\n                    break;\n\n                case "SuperMap.Bounds":\n                    bounds = object;\n                    break;\n            }\n\n            if (bounds) {\n                this.centerLonLat = null;\n                if ((this.left == null) || (bounds.left < this.left)) {\n                    this.left = bounds.left;\n                }\n                if ((this.bottom == null) || (bounds.bottom < this.bottom)) {\n                    this.bottom = bounds.bottom;\n                }\n                if ((this.right == null) || (bounds.right > this.right)) {\n                    this.right = bounds.right;\n                }\n                if ((this.top == null) || (bounds.top > this.top)) {\n                    this.top = bounds.top;\n                }\n            }\n        }\n    }\n\n    /**\n     * @function Bounds.prototype.containsLonLat\n     * @description 判断传入的坐标是否在范围内。\n     * @example\n     * var bounds1 = new Bounds(-50,-50,40,40);\n     * //isContains1 = true\n     * //这里的第二个参数可以直接为 boolean 类型，也就是inclusive\n     * var isContains1 = bounds.containsLonLat(new LonLat(40,40),true);\n     *\n     * //(40,40)在范围内，同样(40+360,40)也在范围内\n     * var bounds2 = new Bounds(-50,-50,40,40);\n     * //isContains2 = true;\n     * var isContains2 = bounds2.containsLonLat(\n     *      new LonLat(400,40),\n     *      {\n     *           inclusive:true,\n     *           //全球的范围\n     *           worldBounds: new Bounds(-180,-90,180,90)\n     *      }\n     * );\n     * @param {(LonLat|Object)} ll - <LonLat> 对象或者是一个包含 \'lon\' 与 \'lat\' 属性的对象。\n     * @param {Object} options - 可选参数。\n     * @param {boolean} [options.inclusive=true] - 是否包含边界。\n     * @param {Bounds} [options.worldBounds] - 如果提供 worldBounds 参数, 如果 ll 参数提供的坐标超出了世界边界（worldBounds），\n     *        但是通过日界线的转化可以被包含, 它将被认为是包含在该范围内的。\n     * @returns {boolean} 传入坐标是否包含在范围内。\n     */\n    containsLonLat(ll, options) {\n        if (typeof options === "boolean") {\n            options = {inclusive: options};\n        }\n        options = options || {};\n        var contains = this.contains(ll.lon, ll.lat, options.inclusive),\n            worldBounds = options.worldBounds;\n        //日界线以外的也有可能算包含，\n        if (worldBounds && !contains) {\n            var worldWidth = worldBounds.getWidth();\n            var worldCenterX = (worldBounds.left + worldBounds.right) / 2;\n            //这一步很关键\n            var worldsAway = Math.round((ll.lon - worldCenterX) / worldWidth);\n            contains = this.containsLonLat({\n                lon: ll.lon - worldsAway * worldWidth,\n                lat: ll.lat\n            }, {inclusive: options.inclusive});\n        }\n        return contains;\n    }\n\n    /**\n     * @function Bounds.prototype.containsPixel\n     * @description 判断传入的像素是否在范围内。直接匹配大小，不涉及像素和地理转换。\n     * @example\n     * var bounds = new Bounds(-50,-50,40,40);\n     * //isContains = true\n     * var isContains = bounds.containsPixel(new Pixel(40,40),true);\n     * @param {Pixel} px - 提供的像素参数。\n     * @param {boolean} [inclusive=true] - 是否包含边界。\n     * @returns {boolean} 传入的 pixel 在当前边界范围之内。\n     */\n    containsPixel(px, inclusive) {\n        return this.contains(px.x, px.y, inclusive);\n    }\n\n    /**\n     * @function Bounds.prototype.contains\n     * @description 判断传入的 x，y 坐标值是否在范围内。\n     * @example\n     * var bounds = new Bounds(-50,-50,40,40);\n     * //isContains = true\n     * var isContains = bounds.contains(40,40,true);\n     * @param {number} x - x 坐标值。\n     * @param {number} y - y 坐标值。\n     * @param {boolean} [inclusive=true] - 是否包含边界。\n     * @returns {boolean} 传入的 x，y 坐标是否在当前范围内。\n     */\n    contains(x, y, inclusive) {\n        //set default\n        if (inclusive == null) {\n            inclusive = true;\n        }\n\n        if (x == null || y == null) {\n            return false;\n        }\n\n        //x = Util.toFloat(x);\n        //y = Util.toFloat(y);\n\n        var contains = false;\n        if (inclusive) {\n            contains = ((x >= this.left) && (x <= this.right) &&\n                (y >= this.bottom) && (y <= this.top));\n        } else {\n            contains = ((x > this.left) && (x < this.right) &&\n                (y > this.bottom) && (y < this.top));\n        }\n        return contains;\n    }\n\n    /**\n     * @function Bounds.prototype.intersectsBounds\n     * @description 判断目标边界范围是否与当前边界范围相交。如果两个边界范围中的任意\n     *              边缘相交或者一个边界包含了另外一个就认为这两个边界相交。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * var isIntersects = bounds.intersectsBounds(\n     *      new Bounds(-170,-90,120,80)\n     *  );\n     * @param {Bounds} bounds - 目标边界。\n     * @param {Object} options - 参数。\n     * @param {boolean} [options.inclusive=true] - 边缘重合也看成相交。如果是false，\n     *                               两个边界范围没有重叠部分仅仅是在边缘相接（重合），\n     *                               这种情况被认为没有相交。\n     * @param {Bounds} [options.worldBounds] - 提供了 worldBounds 参数, 如果他们相交时\n     *                               是在全球范围内, 两个边界将被视为相交。这仅适用于交叉或完全不在世界范围的边界。\n     * @returns {boolean} 传入的 bounds 对象与当前 bounds 相交。\n     */\n    intersectsBounds(bounds, options) {\n        if (typeof options === "boolean") {\n            options = {inclusive: options};\n        }\n        options = options || {};\n        if (options.worldBounds) {\n            var self = this.wrapDateLine(options.worldBounds);\n            bounds = bounds.wrapDateLine(options.worldBounds);\n        } else {\n            self = this;\n        }\n        if (options.inclusive == null) {\n            options.inclusive = true;\n        }\n        var intersects = false;\n        var mightTouch = (\n            self.left === bounds.right ||\n            self.right === bounds.left ||\n            self.top === bounds.bottom ||\n            self.bottom === bounds.top\n        );\n\n        // if the two bounds only touch at an edge, and inclusive is false,\n        // then the bounds don\'t *really* intersect.\n        if (options.inclusive || !mightTouch) {\n            // otherwise, if one of the boundaries even partially contains another,\n            // inclusive of the edges, then they do intersect.\n            var inBottom = (\n                ((bounds.bottom >= self.bottom) && (bounds.bottom <= self.top)) ||\n                ((self.bottom >= bounds.bottom) && (self.bottom <= bounds.top))\n            );\n            var inTop = (\n                ((bounds.top >= self.bottom) && (bounds.top <= self.top)) ||\n                ((self.top > bounds.bottom) && (self.top < bounds.top))\n            );\n            var inLeft = (\n                ((bounds.left >= self.left) && (bounds.left <= self.right)) ||\n                ((self.left >= bounds.left) && (self.left <= bounds.right))\n            );\n            var inRight = (\n                ((bounds.right >= self.left) && (bounds.right <= self.right)) ||\n                ((self.right >= bounds.left) && (self.right <= bounds.right))\n            );\n            intersects = ((inBottom || inTop) && (inLeft || inRight));\n        }\n        // document me\n        if (options.worldBounds && !intersects) {\n            var world = options.worldBounds;\n            var width = world.getWidth();\n            var selfCrosses = !world.containsBounds(self);\n            var boundsCrosses = !world.containsBounds(bounds);\n            if (selfCrosses && !boundsCrosses) {\n                bounds = bounds.add(-width, 0);\n                intersects = self.intersectsBounds(bounds, {inclusive: options.inclusive});\n            } else if (boundsCrosses && !selfCrosses) {\n                self = self.add(-width, 0);\n                intersects = bounds.intersectsBounds(self, {inclusive: options.inclusive});\n            }\n        }\n        return intersects;\n    }\n\n    /**\n     * @function Bounds.prototype.containsBounds\n     * @description 判断目标边界是否被当前边界包含在内。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * var isContains = bounds.containsBounds(\n     *      new Bounds(-170,-90,100,80),true,true\n     *  );\n     * @param {Bounds} bounds - 目标边界。\n     * @param {boolean} [partial=false] - 目标边界的任意部分都包含在当前边界中则被认为是包含关系。\n     * 如果设为 false，整个目标边界全部被包含在当前边界范围内。\n     * @param {boolean} [inclusive=true] - 边缘共享是否被视为包含。\n     * @returns {boolean} 传入的边界是否被当前边界包含。\n     */\n    containsBounds(bounds, partial, inclusive) {\n        if (partial == null) {\n            partial = false;\n        }\n        if (inclusive == null) {\n            inclusive = true;\n        }\n        var bottomLeft = this.contains(bounds.left, bounds.bottom, inclusive);\n        var bottomRight = this.contains(bounds.right, bounds.bottom, inclusive);\n        var topLeft = this.contains(bounds.left, bounds.top, inclusive);\n        var topRight = this.contains(bounds.right, bounds.top, inclusive);\n\n        return (partial) ? (bottomLeft || bottomRight || topLeft || topRight)\n            : (bottomLeft && bottomRight && topLeft && topRight);\n    }\n\n    /**\n     * @function Bounds.prototype.determineQuadrant\n     * @description 判断传入坐标是否在 bounds 范围内的象限。以 bounds 中心点为坐标原点。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * //str = "tr";\n     * var str = bounds.determineQuadrant(\n     *      new LonLat(20,20)\n     *  );\n     * @param {LonLat} lonlat - 传入的坐标对象。\n     * @returns {string} 传入坐标所在的象限（"br" "tr" "tl" "bl" 分别对应"右下"，"右上"，"左上" "左下"）。\n     */\n    determineQuadrant(lonlat) {\n\n        var quadrant = "";\n        var center = this.getCenterLonLat();\n\n        quadrant += (lonlat.lat < center.lat) ? "b" : "t";\n        quadrant += (lonlat.lon < center.lon) ? "l" : "r";\n\n        return quadrant;\n    }\n\n    /**\n     * @function Bounds.prototype.wrapDateLine\n     * @description 将当前 bounds 移动到最大边界范围内部（所谓的内部是相交或者内部）。\n     * @example\n     * var bounds = new Bounds(380,-40,400,-20);\n     * var maxExtent = new Bounds(-180,-90,100,80);\n     * //新的bounds\n     * var newBounds = bounds.wrapDateLine(maxExtent);\n     * @param {Bounds} maxExtent - 最大的边界范围（一般是全球范围）。\n     * @param {Object} options - 可选选项参数。\n     * @param {number} [options.leftTolerance=0] - left 允许的误差。\n     * @param {number} [options.rightTolerance=0] - right 允许的误差。\n     * @returns {Bounds} 克隆当前边界。如果当前边界完全在最大范围之外此函数则返回一个不同值的边界，\n     *                            若落在最大边界的左边，则给当前的bounds值加上最大范围的宽度，即向右移动，\n     *                            若落在右边，则向左移动，即给当前的bounds值加上负的最大范围的宽度。\n     */\n    wrapDateLine(maxExtent, options) {\n        options = options || {};\n\n        var leftTolerance = options.leftTolerance || 0;\n        var rightTolerance = options.rightTolerance || 0;\n\n        var newBounds = this.clone();\n\n        if (maxExtent) {\n            var width = maxExtent.getWidth();\n            //如果 newBounds 在 maxExtent 的左边，那么一直向右移动，直到相交或者包含为止，每次移动width\n            //shift right?\n            while (newBounds.left < maxExtent.left &&\n            newBounds.right - rightTolerance <= maxExtent.left) {\n                newBounds = newBounds.add(width, 0);\n            }\n            //如果 newBounds 在 maxExtent 的右边，那么一直向左移动，直到相交或者包含为止，每次移动width\n            //shift left?\n            while (newBounds.left + leftTolerance >= maxExtent.right &&\n            newBounds.right > maxExtent.right) {\n                newBounds = newBounds.add(-width, 0);\n            }\n            //如果和右边相交，左边又在内部，那么再次向左边移动一次\n            // crosses right only? force left\n            var newLeft = newBounds.left + leftTolerance;\n            if (newLeft < maxExtent.right && newLeft > maxExtent.left &&\n                newBounds.right - rightTolerance > maxExtent.right) {\n                newBounds = newBounds.add(-width, 0);\n            }\n        }\n\n        return newBounds;\n    }\n\n    /**\n     * @function Bounds.prototype.toServerJSONObject\n     * @description 转换成对应的 JSON 格式对象。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * var obj = bounds.toServerJSONObject();\n     * @returns {Object} JSON 格式的 Object 对象。\n     */\n    toServerJSONObject() {\n        var jsonObject = {\n            rightTop: {x: this.right, y: this.top},\n            leftBottom: {x: this.left, y: this.bottom},\n            left: this.left,\n            right: this.right,\n            top: this.top,\n            bottom: this.bottom\n        }\n        return jsonObject;\n    }\n\n    /**\n     *\n     * @function Bounds.prototype.destroy\n     * @description 销毁此对象。\n     * 销毁后此对象的所有属性为 null，而不是初始值。\n     * @example\n     * var bounds = new Bounds(-180,-90,100,80);\n     * bounds.destroy();\n     */\n    destroy() {\n        this.left = null;\n        this.right = null;\n        this.top = null;\n        this.bottom = null;\n        this.centerLonLat = null;\n    }\n\n    /**\n     * @function Bounds.fromString\n     * @description 通过字符串参数创建新的 bounds 的构造函数。\n     * @example\n     * var bounds = Bounds.fromString("-180,-90,100,80");\n     * @param {string} str - 边界字符串，用逗号隔开（e.g. <i>"5,42,10,45"</i>）。\n     * @param {boolean} [reverseAxisOrder=false] - 是否反转轴顺序。\n     * 如果设为true，则倒转顺序（bottom,left,top,right），否则按正常轴顺序（left,bottom,right,top）。\n     * @returns {Bounds} 给定的字符串创建的新的边界对象。\n     */\n    static fromString(str, reverseAxisOrder) {\n        var bounds = str.split(",");\n        return Bounds_Bounds.fromArray(bounds, reverseAxisOrder);\n    }\n\n    /**\n     * @function Bounds.fromArray\n     * @description 通过边界框数组创建 Bounds。\n     * @example\n     * var bounds = Bounds.fromArray([-180,-90,100,80]);\n     * @param {Array.<number>} bbox - 边界值数组。（e.g. <i>[5,42,10,45]</i>）。\n     * @param {boolean} [reverseAxisOrder=false] - 是否是反转轴顺序。如果设为true，则倒转顺序（bottom,left,top,right），否则按正常轴顺序（left,bottom,right,top）。\n     * @returns {Bounds} 根据传入的数组创建的新的边界对象。\n     */\n    static fromArray(bbox, reverseAxisOrder) {\n        return reverseAxisOrder === true ?\n            new Bounds_Bounds(bbox[1], bbox[0], bbox[3], bbox[2]) :\n            new Bounds_Bounds(bbox[0], bbox[1], bbox[2], bbox[3]);\n    }\n\n    /**\n     * @function Bounds.fromSize\n     * @description 通过传入的边界大小来创建新的边界。\n     * @example\n     * var bounds = Bounds.fromSize(new Size(20,10));\n     * @param {Size} size - 边界大小。\n     * @returns {Bounds} 根据传入的边界大小的创建新的边界。\n     */\n    static fromSize(size) {\n        return new Bounds_Bounds(0,\n            size.h,\n            size.w,\n            0);\n    }\n\n    /**\n     * @function Bounds.oppositeQuadrant\n     * @description 反转象限。"t"和"b" 交换，"r"和"l"交换, 如："tl"变为"br"。\n     * @param {string} quadrant - 代表象限的字符串，如："tl"。\n     * @returns {string} 反转后的象限。\n     */\n    static oppositeQuadrant(quadrant) {\n        var opp = "";\n\n        opp += (quadrant.charAt(0) === \'t\') ? \'b\' : \'t\';\n        opp += (quadrant.charAt(1) === \'l\') ? \'r\' : \'l\';\n\n        return opp;\n    }\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/geometry/Point.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n\n/**\n * @class GeometryPoint\n * @aliasclass Geometry.Point\n * @deprecatedclass SuperMap.Geometry.Point\n * @classdesc 点几何对象类。\n * @category BaseTypes Geometry\n * @extends {Geometry}\n * @param {number} x - x 坐标。\n * @param {number} y - y 坐标。\n * @param {string} [type = \'Point\'] - 点的类型。\n * @param {number} [tag] - 额外的属性，比如差值分析中的 Z 值。\n * @example\n * var point = new GeometryPoint(-111.04, 45.68);\n * @usage\n */\nclass geometry_Point_Point extends Geometry_Geometry {\n\n\n    constructor(x, y, type, tag) {\n        super(x, y, type, tag);\n        /**\n         * @member {number} GeometryPoint.prototype.x\n         * @description 横坐标。\n         */\n        this.x = parseFloat(x);\n\n        /**\n         * @member {number} GeometryPoint.prototype.y\n         * @description 纵坐标。\n         */\n        this.y = parseFloat(y);\n\n        /**\n         * @member {string} GeometryPoint.prototype.tag\n         * @description  用来存储额外的属性，比如差值分析中的 Z 值。\n         */\n        this.tag = (tag || tag == 0) ? parseFloat(tag) : null;\n\n        /**\n         * @member {string} GeometryPoint.prototype.type\n         * @description  用来存储点的类型\n         */\n        this.type = type || "Point";\n        this.CLASS_NAME = "SuperMap.Geometry.Point";\n        this.geometryType = "Point";\n    }\n\n    /**\n     * @function GeometryPoint.prototype.clone\n     * @description 克隆点对象。\n     * @returns {GeometryPoint} 克隆后的点对象。\n     */\n    clone(obj) {\n        if (obj == null) {\n            obj = new geometry_Point_Point(this.x, this.y);\n        }\n\n        // catch any randomly tagged-on properties\n        Util.applyDefaults(obj, this);\n\n        return obj;\n    }\n\n    /**\n     * @function GeometryPoint.prototype.calculateBounds\n     * @description 计算点对象的范围。\n     */\n    calculateBounds() {\n        this.bounds = new Bounds_Bounds(this.x, this.y,\n            this.x, this.y);\n    }\n\n    /**\n     * @function GeometryPoint.prototype.equals\n     * @description 判断两个点对象是否相等。如果两个点对象具有相同的坐标，则认为是相等的。\n     * @example\n     * var point= new GeometryPoint(0,0);\n     * var point1={x:0,y:0};\n     * var result= point.equals(point1);\n     * @param {GeometryPoint} geom - 需要判断的点对象。\n     * @returns {boolean} 两个点对象是否相等（true 为相等，false 为不等）。\n     */\n    equals(geom) {\n        var equals = false;\n        if (geom != null) {\n            equals = ((this.x === geom.x && this.y === geom.y) ||\n                (isNaN(this.x) && isNaN(this.y) && isNaN(geom.x) && isNaN(geom.y)));\n        }\n        return equals;\n    }\n\n\n    /**\n     * @function GeometryPoint.prototype.move\n     * @description 沿着 x、y 轴的正方向上按照给定的位移移动点对象，move 不仅改变了几何对象的位置并且清理了边界缓存。\n     * @param {number} x - x 轴正方向上的偏移量。\n     * @param {number} y - y 轴正方向上偏移量。\n     */\n    move(x, y) {\n        this.x = this.x + x;\n        this.y = this.y + y;\n        this.clearBounds();\n    }\n\n    /**\n     * @function GeometryPoint.prototype.toShortString\n     * @description 将 x/y 坐标转换成简单字符串。\n     * @returns {string} 字符串代表点对象。(ex. <i>"5, 42"</i>)\n     */\n    toShortString() {\n        return (this.x + ", " + this.y);\n    }\n\n    /**\n     * @function GeometryPoint.prototype.destroy\n     * @description 释放点对象的资源。\n     */\n    destroy() {\n        this.x = null;\n        this.y = null;\n        this.tag = null;\n        super.destroy();\n    }\n\n    /**\n     * @function GeometryPoint.prototype.getVertices\n     * @description 获取几何图形所有顶点的列表。\n     * @returns {Array} 几何图形的顶点列表。\n     */\n    getVertices() {\n        return [this];\n    }\n\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/geometry/Collection.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n\n/**\n * @class GeometryCollection\n * @aliasclass Geometry.Collection\n * @deprecatedclass SuperMap.Geometry.Collection\n * @classdesc 几何对象集合类，存储在本地的 components 属性中（可作为参数传递给构造函数）。<br>\n *            随着新的几何图形添加到集合中，将不能被克隆，当移动几何图形时，需要指定参照物。<br>\n *            getArea 和 getLength 函数只能通过遍历存储几何对象的 components 数组，总计所有几何图形的面积和长度。\n * @category BaseTypes Geometry\n * @extends {Geometry}\n * @param {Array.<Geometry>} components - 几何对象数组。\n * @example\n * var point1 = new GeometryPoint(10,20);\n * var point2 = new GeometryPoint(30,40);\n * var col = new GeometryCollection([point1,point2]);\n * @usage\n */\nclass Collection_Collection extends Geometry_Geometry {\n\n\n    constructor(components) {\n        super();\n\n        /**\n         * @description 存储几何对象的数组。\n         * @member {Array.<Geometry>} GeometryCollection.prototype.components\n         */\n        this.components = [];\n\n        /**\n         * @member {Array.<string>} GeometryCollection.prototype.componentTypes\n         * @description components 存储的的几何对象所支持的几何类型数组，为空表示类型不受限制。\n         */\n        this.componentTypes = null;\n        if (components != null) {\n            this.addComponents(components);\n        }\n        this.CLASS_NAME = "SuperMap.Geometry.Collection";\n        this.geometryType = "Collection";\n    }\n\n    /**\n     * @function GeometryCollection.prototype.destroy\n     * @description 销毁几何图形。\n     */\n    destroy() {\n        this.components.length = 0;\n        this.components = null;\n        super.destroy();\n    }\n\n    /**\n     * @function GeometryCollection.prototype.clone\n     * @description 克隆当前几何对象。\n     * @returns {GeometryCollection} 克隆的几何对象集合。\n     */\n    clone() {\n        var geometry = new Collection_Collection();\n        for (var i = 0, len = this.components.length; i < len; i++) {\n            geometry.addComponent(this.components[i].clone());\n        }\n\n        // catch any randomly tagged-on properties\n        Util.applyDefaults(geometry, this);\n\n        return geometry;\n    }\n\n    /**\n     * @function GeometryCollection.prototype.getComponentsString\n     * @description 获取 components 字符串。\n     * @returns {string} components 字符串。\n     */\n    getComponentsString() {\n        var strings = [];\n        for (var i = 0, len = this.components.length; i < len; i++) {\n            strings.push(this.components[i].toShortString());\n        }\n        return strings.join(",");\n    }\n\n    /**\n     * @function GeometryCollection.prototype.calculateBounds\n     * @description 通过遍历数组重新计算边界，在遍历每一子项中时调用 extend 方法。\n     */\n    calculateBounds() {\n        this.bounds = null;\n        var bounds = new Bounds_Bounds();\n        var components = this.components;\n        if (components) {\n            for (var i = 0, len = components.length; i < len; i++) {\n                bounds.extend(components[i].getBounds());\n            }\n        }\n        // to preserve old behavior, we only set bounds if non-null\n        // in the future, we could add bounds.isEmpty()\n        if (bounds.left != null && bounds.bottom != null &&\n            bounds.right != null && bounds.top != null) {\n            this.setBounds(bounds);\n        }\n    }\n\n    /**\n     * @function GeometryCollection.prototype.addComponents\n     * @description 给几何图形对象添加元素。\n     * @param {Array.<Geometry>} components - 几何对象组件。\n     * @example\n     * var geometryCollection = new GeometryCollection();\n     * geometryCollection.addComponents(new SuerpMap.Geometry.Point(10,10));\n     */\n    addComponents(components) {\n        if (!(Util.isArray(components))) {\n            components = [components];\n        }\n        for (var i = 0, len = components.length; i < len; i++) {\n            this.addComponent(components[i]);\n        }\n    }\n\n    /**\n     * @function GeometryCollection.prototype.addComponent\n     * @description 添加几何对象到集合中。如果设置了 componentTypes 类型，则添加的几何对象必须是 componentTypes 中的类型。\n     * @param {Geometry} component - 待添加的几何对象。\n     * @param {number} [index] - 几何对象插入的位置。\n     * @returns {boolean} 是否添加成功。\n     */\n    addComponent(component, index) {\n        var added = false;\n        if (component) {\n            if (this.componentTypes == null ||\n                (Util.indexOf(this.componentTypes,\n                    component.CLASS_NAME) > -1)) {\n\n                if (index != null && (index < this.components.length)) {\n                    var components1 = this.components.slice(0, index);\n                    var components2 = this.components.slice(index,\n                        this.components.length);\n                    components1.push(component);\n                    this.components = components1.concat(components2);\n                } else {\n                    this.components.push(component);\n                }\n                component.parent = this;\n                this.clearBounds();\n                added = true;\n            }\n        }\n        return added;\n    }\n\n    /**\n     * @function GeometryCollection.prototype.removeComponents\n     * @description 清除几何对象。\n     * @param {Array.<Geometry>} components - 需要清除的几何对象。\n     * @returns {boolean} 元素是否被删除。\n     */\n    removeComponents(components) {\n        var removed = false;\n\n        if (!(Util.isArray(components))) {\n            components = [components];\n        }\n        for (var i = components.length - 1; i >= 0; --i) {\n            removed = this.removeComponent(components[i]) || removed;\n        }\n        return removed;\n    }\n\n    /**\n     * @function GeometryCollection.prototype.removeComponent\n     * @description 从集合中移除几何对象。\n     * @param {Geometry} component - 要移除的几何对象。\n     * @returns {boolean} 几何对象是否移除成功。\n     */\n    removeComponent(component) {\n        Util.removeItem(this.components, component);\n\n        // clearBounds() so that it gets recalculated on the next call\n        // to this.getBounds();\n        this.clearBounds();\n        return true;\n    }\n\n    /**\n     * @function GeometryCollection.prototype.getArea\n     * @description 计算几何对象的面积。注意，这个方法在 {@link GeometryPolygon} 类中需要重写。\n     * @returns {number} 几何图形的面积，是几何对象中所有组成部分的面积之和。\n     */\n    getArea() {\n        var area = 0.0;\n        for (var i = 0, len = this.components.length; i < len; i++) {\n            area += this.components[i].getArea();\n        }\n        return area;\n    }\n\n    /**\n     * @function GeometryCollection.prototype.equals\n     * @description 判断两个几何图形是否相等。如果所有的 components 具有相同的坐标，则认为是相等的。\n     * @param {Geometry} geometry - 需要判断的几何图形。\n     * @returns {boolean} 输入的几何图形与当前几何图形是否相等。\n     */\n    equals(geometry) {\n        var equivalent = true;\n        if (!geometry || !geometry.CLASS_NAME ||\n            (this.CLASS_NAME !== geometry.CLASS_NAME)) {\n            equivalent = false;\n        } else if (!(Util.isArray(geometry.components)) ||\n            (geometry.components.length !== this.components.length)) {\n            equivalent = false;\n        } else {\n            for (var i = 0, len = this.components.length; i < len; ++i) {\n                if (!this.components[i].equals(geometry.components[i])) {\n                    equivalent = false;\n                    break;\n                }\n            }\n        }\n        return equivalent;\n    }\n\n\n    /**\n     * @function GeometryCollection.prototype.getVertices\n     * @description 返回几何对象的所有结点的列表。\n     * @param {boolean} [nodes] - 对于线来说，仅仅返回作为端点的顶点，如果设为 false，则返回非端点的顶点如果没有设置此参数，则返回所有顶点。\n     * @returns {Array} 几何对象的顶点列表。\n     */\n    getVertices(nodes) {\n        var vertices = [];\n        for (var i = 0, len = this.components.length; i < len; ++i) {\n            Array.prototype.push.apply(\n                vertices, this.components[i].getVertices(nodes)\n            );\n        }\n        return vertices;\n    }\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/geometry/MultiPoint.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n/**\n * @class GeometryMultiPoint\n * @aliasclass Geometry.MultiPoint\n * @deprecatedclass SuperMap.Geometry.MultiPoint\n * @classdesc 几何对象多点类。\n * @category BaseTypes Geometry\n * @extends GeometryCollection\n * @param {Array.<GeometryPoint>} components - 点对象数组。\n * @example\n * var point1 = new GeometryPoint(5,6);\n * var poine2 = new GeometryMultiPoint(7,8);\n * var multiPoint = new MultiPoint([point1,point2]);\n * @usage\n */\nclass MultiPoint_MultiPoint extends Collection_Collection {\n\n\n    constructor(components) {\n        super(components);\n        /**\n         * @member {Array.<string>} [GeometryMultiPoint.prototype.componentTypes=["SuperMap.Geometry.Point"]]\n         * @description components 存储的的几何对象所支持的几何类型数组。\n         * @readonly\n         */\n        this.componentTypes = ["SuperMap.Geometry.Point"];\n        this.CLASS_NAME = "SuperMap.Geometry.MultiPoint";\n        this.geometryType = "MultiPoint";\n    }\n\n    /**\n     * @function GeometryMultiPoint.prototype.addPoint\n     * @description 添加点，封装了 {@link GeometryCollection|GeometryCollection.addComponent} 方法。\n     * @param {GeometryPoint} point - 添加的点。\n     * @param {number} [index] - 下标。\n     */\n    addPoint(point, index) {\n        this.addComponent(point, index);\n    }\n\n\n    /**\n     * @function GeometryMultiPoint.prototype.removePoint\n     * @description 移除点，封装了 {@link GeometryCollection|GeometryCollection.removeComponent} 方法。\n     * @param {GeometryPoint} point - 移除的点对象。\n     */\n    removePoint(point) {\n        this.removeComponent(point);\n    }\n\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/geometry/Curve.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n/**\n * @class GeometryCurve\n * @aliasclass Geometry.Curve\n * @deprecatedclass SuperMap.Geometry.Curve\n * @classdesc 几何对象曲线类。\n * @category BaseTypes Geometry\n * @extends GeometryMultiPoint\n * @param {Array.<GeometryPoint>} components - 几何对象数组。\n * @example\n * var point1 = new GeometryPoint(10,20);\n * var point2 = new GeometryPoint(30,40);\n * var curve = new Curve([point1,point2]);\n * @usage\n */\nclass Curve_Curve extends MultiPoint_MultiPoint {\n\n    constructor(components) {\n        super(components);\n        /**\n         * @member {Array.<string>} [GeometryCurve.prototype.componentTypes=["SuperMap.Geometry.Point", "SuperMap.PointWithMeasure"]]\n         * @description components 存储的的几何对象所支持的几何类型数组。\n         * @readonly\n         */\n        this.componentTypes = ["SuperMap.Geometry.Point", "SuperMap.PointWithMeasure"];\n        this.CLASS_NAME = "SuperMap.Geometry.Curve";\n        this.geometryType = "Curve";\n\n    }\n\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/geometry/LineString.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n/**\n * @class GeometryLineString\n * @aliasclass Geometry.LineString\n * @deprecatedclass SuperMap.Geometry.LineString\n * @classdesc 几何对象线串类。\n * @category BaseTypes Geometry\n * @param {Array.<GeometryPoint>} points - 用来生成线串的点数组。\n * @extends GeometryCurve\n * @example\n * var points = [new GeometryPoint(4933.319287022352, -3337.3849141502124),\n *     new GeometryPoint(4960.9674060199022, -3349.3316322355736),\n *     new GeometryPoint(5006.0235999418364, -3358.8890067038628),\n *     new GeometryPoint(5075.3145648369318, -3378.0037556404409),\n *     new GeometryPoint(5305.19551436013, -3376.9669111768926)],\n * var roadLine = new GeometryLineString(points)；\n * @usage\n */\nclass LineString_LineString extends Curve_Curve {\n\n    constructor(points) {\n        super(points);\n        this.CLASS_NAME = "SuperMap.Geometry.LineString";\n        this.geometryType = "LineString";\n    }\n\n    /**\n     * @function GeometryLineString.prototype.removeComponent\n     * @description 只有在线串上有三个或更多的点的时候，才会允许移除点（否则结果将会是单一的点）。\n     * @param {GeometryPoint} point - 将被删除的点。\n     * @returns {boolean} 删除的点。\n     */\n    removeComponent(point) { // eslint-disable-line no-unused-vars\n        var removed = this.components && (this.components.length > 2);\n        if (removed) {\n            super.removeComponent.apply(this, arguments);\n        }\n        return removed;\n    }\n\n    /**\n     * @function GeometryLineString.prototype.getSortedSegments\n     * @description 获取升序排列的点坐标对象数组。\n     * @returns {Array} 升序排列的点坐标对象数组。\n     */\n    getSortedSegments() {\n        var numSeg = this.components.length - 1;\n        var segments = new Array(numSeg), point1, point2;\n        for (var i = 0; i < numSeg; ++i) {\n            point1 = this.components[i];\n            point2 = this.components[i + 1];\n            if (point1.x < point2.x) {\n                segments[i] = {\n                    x1: point1.x,\n                    y1: point1.y,\n                    x2: point2.x,\n                    y2: point2.y\n                };\n            } else {\n                segments[i] = {\n                    x1: point2.x,\n                    y1: point2.y,\n                    x2: point1.x,\n                    y2: point1.y\n                };\n            }\n        }\n\n        // more efficient to define this somewhere static\n        function byX1(seg1, seg2) {\n            return seg1.x1 - seg2.x1;\n        }\n\n        return segments.sort(byX1);\n    }\n\n    /**\n     * @function GeometryLineString.prototype.getVertices\n     * @description 返回几何图形的所有顶点的列表。\n     * @param {boolean} [nodes] - 对于线来说，仅仅返回作为端点的顶点，如果设为 false，则返回非端点的顶点。如果没有设置此参数，则返回所有顶点。\n     * @returns {Array} 几何图形的顶点列表。\n     */\n    getVertices(nodes) {\n        var vertices;\n        if (nodes === true) {\n            vertices = [\n                this.components[0],\n                this.components[this.components.length - 1]\n            ];\n        } else if (nodes === false) {\n            vertices = this.components.slice(1, this.components.length - 1);\n        } else {\n            vertices = this.components.slice();\n        }\n        return vertices;\n    }\n\n    /**\n     * @function GeometryLineString.calculateCircle\n     * @description 三点画圆弧。\n     * @param {Array.<GeometryPoint>} points - 传入的待计算的初始点串。\n     * @returns {Array.<GeometryPoint>} 计算出相应的圆弧控制点。\n     * @example\n     * var points = [];\n     * points.push(new GeometryPoint(-50,30));\n     * points.push(new GeometryPoint(-30,50));\n     * points.push(new GeometryPoint(2,60));\n     * var circle = GeometryLineString.calculateCircle(points);\n     */\n    static calculateCircle(points) {\n        if (points.length < 3) {\n            return points\n        }\n        var centerPoint = {},\n            p1 = points[0],\n            p2 = points[1],\n            p3 = points[2];\n        var R = 0,\n            dStep = 0,\n            direc = true,\n            dRotation = 0,\n            dRotationBegin = 0,\n            dRotationAngle = 0,\n            nSegmentCount = 72,\n            circlePoints = [];\n\n        var KTan13 = (p3.y - p1.y) / (p3.x - p1.x);\n        var B13 = p3.y - KTan13 * p3.x;\n        if ((((p3.x != p1.x) && (p3.y != p1.y)) && (p2.y == KTan13 * p2.x + B13)) ||\n            ((p3.x == p1.x) && (p2.x == p1.x)) || ((p3.y == p1.y) && (p2.y == p1.y)) ||\n            ((p3.x == p1.x) && (p3.y == p1.y)) || ((p3.x == p2.x) && (p3.y == p2.y)) || ((p1.x == p2.x) && (p1.y == p2.y))) {\n            circlePoints.push(p1);\n            circlePoints.push(p2);\n            circlePoints.push(p3);\n        } else {\n            var D = ((p2.x * p2.x + p2.y * p2.y) - (p1.x * p1.x + p1.y * p1.y)) * (2 * (p3.y - p1.y)) - ((p3.x * p3.x + p3.y * p3.y) -\n                (p1.x * p1.x + p1.y * p1.y)) * (2 * (p2.y - p1.y));\n            var E = (2 * (p2.x - p1.x)) * ((p3.x * p3.x + p3.y * p3.y) - (p1.x * p1.x + p1.y * p1.y)) -\n                (2 * (p3.x - p1.x)) * ((p2.x * p2.x + p2.y * p2.y) - (p1.x * p1.x + p1.y * p1.y));\n            var F = 4 * ((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y));\n            centerPoint.x = D / F;\n            centerPoint.y = E / F;\n            R = Math.sqrt((p1.x - centerPoint.x) * (p1.x - centerPoint.x) + (p1.y - centerPoint.y) * (p1.y - centerPoint.y));\n\n            var dis = (p1.x - p3.x) * (p1.x - p3.x) + (p1.y - p3.y) * (p1.y - p3.y);\n            var cons = (2 * R * R - dis) / (2 * R * R);\n            cons = cons >= 1 ? 1 : cons;\n            cons = cons <= -1 ? -1 : cons;\n            dRotationAngle = Math.acos(cons) * 180 / Math.PI;\n\n            if (p3.x == p1.x) {\n                dRotationAngle = ((centerPoint.x > p1.x && p2.x > p1.x) || (centerPoint.x < p1.x && p2.x < p1.x)) ? (360 - dRotationAngle) : dRotationAngle;\n            } else {\n                dRotationAngle = ((centerPoint.y > (KTan13 * centerPoint.x + B13) && p2.y > (KTan13 * p2.x + B13)) ||\n                    (centerPoint.y < (KTan13 * centerPoint.x + B13) && p2.y < (KTan13 * p2.x + B13))) ? (360 - dRotationAngle) : dRotationAngle;\n            }\n            dStep = dRotationAngle / 72;\n\n            if (p3.y != p1.y) {\n                if (p3.x == p1.x) {\n                    if (p3.y > p1.y) {\n                        if (p2.x < p1.x) {\n                            direc = false;\n                        }\n                    } else {\n                        if (p2.x > p1.x) {\n                            direc = false;\n                        }\n                    }\n                } else if (p3.x < p1.x) {\n                    if (p2.y < KTan13 * p2.x + B13) {\n                        direc = false;\n                    }\n                } else {\n                    if (p2.y > KTan13 * p2.x + B13) {\n                        direc = false;\n                    }\n                }\n            } else {\n                if (p3.x > p1.x) {\n                    if (p2.y > p1.y) {\n                        direc = false;\n                    }\n                } else {\n                    if (p2.y < p1.y) {\n                        direc = false;\n                    }\n                }\n            }\n\n            var K10 = (p1.y - centerPoint.y) / (p1.x - centerPoint.x);\n            var atan10 = K10 >= 0 ? Math.atan(K10) * 180 / Math.PI : Math.abs(Math.atan(K10) * 180 / Math.PI) + 90;\n\n            var CY = Math.abs(centerPoint.y);\n            if ((p1.y == CY) && (CY == p3.y)) {\n                if (p1.x < p3.x) {\n                    atan10 = atan10 + 180;\n                }\n            }\n\n            var newPY = p1.y - centerPoint.y;\n            circlePoints.push(p1);\n            for (var i = 1; i < nSegmentCount; i++) {\n                dRotation = dStep * i;\n                dRotationBegin = atan10;\n\n                if (direc) {\n                    if (newPY >= 0) {\n                        if (K10 >= 0) {\n                            dRotationBegin = dRotationBegin + dRotation;\n                        } else {\n                            dRotationBegin = (180 - (dRotationBegin - 90)) + dRotation;\n                        }\n                    } else {\n                        if (K10 > 0) {\n                            dRotationBegin = (dRotationBegin - 180) + dRotation;\n                        } else {\n                            dRotationBegin = (90 - dRotationBegin) + dRotation;\n                        }\n                    }\n                } else {\n                    if (newPY >= 0) {\n                        if (K10 >= 0) {\n                            dRotationBegin = dRotationBegin - dRotation;\n                        } else {\n                            dRotationBegin = (180 - (dRotationBegin - 90)) - dRotation;\n                        }\n                    } else {\n                        if (K10 >= 0) {\n                            dRotationBegin = (dRotationBegin - 180) - dRotation;\n                        } else {\n                            dRotationBegin = (90 - dRotationBegin) - dRotation;\n                        }\n                    }\n                }\n\n                dRotationBegin = dRotationBegin * Math.PI / 180;\n                var x = centerPoint.x + R * Math.cos(dRotationBegin);\n                var y = centerPoint.y + R * Math.sin(dRotationBegin);\n                circlePoints.push(new geometry_Point_Point(x, y));\n            }\n            circlePoints.push(p3);\n        }\n        return circlePoints;\n    }\n\n    /**\n     * @function GeometryLineString.createLineEPS\n     * @description 根据点的类型画出不同类型的曲线。\n     * 点的类型有三种：LTypeArc，LTypeCurve，NONE。\n     * @param {Array.<GeometryPoint>} points - 传入的待计算的初始点串。\n     * @returns {Array.<GeometryPoint>} 计算出相应的 lineEPS 控制点。\n     * @example\n     * var points = [];\n     * points.push(new GeometryPoint(-50,30));\n     * points.push(new GeometryPoint(-30,50,"LTypeArc"));\n     * points.push(new GeometryPoint(2,60));\n     * points.push(new GeometryPoint(8,20));\n     * var lineEPS = GeometryLineString.createLineEPS(points);\n     */\n    static createLineEPS(points) {\n        var list = [],\n            len = points.length;\n        if (len < 2) {\n            return points;\n        }\n        for (var i = 0; i < len;) {\n            var type = points[i].type;\n            if (type == \'LTypeArc\') {\n                var listObj = LineString_LineString.createLineArc(list, i, len, points);\n                list = listObj[0];\n                i = listObj[1];\n            } else {\n                list.push(points[i]);\n                i++;\n            }\n        }\n        return list;\n    }\n\n    static createLineArc(list, i, len, points) {\n        if (i == 0) {\n            let bezierPtsObj = LineString_LineString.addPointEPS(points, i, len, \'LTypeArc\');\n            Array.prototype.push.apply(list, bezierPtsObj[0]);\n            i = bezierPtsObj[1] + 1;\n        } else if (i == len - 1) {\n            var bezierP = [points[i - 1], points[i]],\n                bezierPts = LineString_LineString.calculateCircle(bezierP);\n            Array.prototype.push.apply(list, bezierPts);\n            i++;\n        } else {\n            let bezierPtsObj = LineString_LineString.addPointEPS(points, i, len, \'LTypeArc\');\n            list.pop();\n            Array.prototype.push.apply(list, bezierPtsObj[0]);\n            i = bezierPtsObj[1] + 1;\n        }\n        return [list, i];\n    }\n\n    static addPointEPS(points, i, len, type) {\n        var bezierP = [], j = i + 1;\n        if (i == 0) {\n            Array.prototype.push.apply(bezierP, [points[i], points[i + 1]]);\n        } else if (i == len - 1) {\n            Array.prototype.push.apply(bezierP, [points[i - 1], points[i]]);\n        } else {\n            Array.prototype.push.apply(bezierP, [points[i - 1], points[i], points[i + 1]]);\n        }\n        var bezierPts;\n        if (type == \'LTypeCurve\') {\n            bezierPts = LineString_LineString.calculatePointsFBZN(bezierP);\n        } else if (type == \'LTypeArc\') {\n            bezierPts = LineString_LineString.calculateCircle(bezierP);\n        }\n        return [bezierPts, j];\n    }\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/geometry/LinearRing.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n/**\n * @class  GeometryLinearRing\n * @aliasclass Geometry.LinearRing\n * @deprecatedclass SuperMap.Geometry.LinearRing\n * @classdesc 几何对象线环类，是一个特殊的封闭的线串，在每次 addPoint/removePoint 之后会通过添加一个点（此点是复制的第一个点得到的）\n * 作为最后的一个点来自动关闭线环。\n * @category BaseTypes Geometry\n * @extends GeometryLineString\n * @param {Array.<GeometryPoint>} points - 组成线性环的点。\n * @example\n * var points = [new GeometryPoint(4933.319287022352, -3337.3849141502124),\n *      new GeometryPoint(4960.9674060199022, -3349.3316322355736),\n *      new GeometryPoint(5006.0235999418364, -3358.8890067038628),\n *      new GeometryPoint(5075.3145648369318, -3378.0037556404409),\n *      new GeometryPoint(5305.19551436013, -3376.9669111768926)],\n * var linearRing = new GeometryLinearRing(points);\n * @usage\n */\nclass LinearRing_LinearRing extends LineString_LineString {\n\n\n    constructor(points) {\n        super(points);\n        /**\n         * @member {Array.<string>} [GeometryLinearRing.prototype.componentTypes=["SuperMap.Geometry.Point"]]\n         * @description components 存储的的几何对象所支持的几何类型数组，为空表示类型不受限制。\n         * @readonly\n         */\n        this.componentTypes = ["SuperMap.Geometry.Point"];\n        this.CLASS_NAME = "SuperMap.Geometry.LinearRing";\n        this.geometryType = "LinearRing";\n    }\n\n    /**\n     * @function GeometryLinearRing.prototype.addComponent\n     * @description 添加一个点到几何图形数组中，如果这个点将要被添加到组件数组的末端，并且与数组中已经存在的最后一个点相同，\n     * 重复的点是不能被添加的。这将影响未关闭环的关闭。\n     * 这个方法可以通过将非空索引（组件数组的下标）作为第二个参数重写。\n     * @param {GeometryPoint} point - 点对象。\n     * @param {number} [index] - 插入组件数组的下标。\n     * @returns {boolean} 点对象是否添加成功。\n     */\n    addComponent(point, index) {\n        var added = false;\n\n        //remove last point\n        var lastPoint = this.components.pop();\n\n        // given an index, add the point\n        // without an index only add non-duplicate points\n        if (index != null || !point.equals(lastPoint)) {\n            added = super.addComponent.apply(this, arguments);\n        }\n\n        //append copy of first point\n        var firstPoint = this.components[0];\n        super.addComponent.apply(this, [firstPoint]);\n\n        return added;\n    }\n\n    /**\n     * @function GeometryLinearRing.prototype.removeComponent\n     * @description 从几何组件中删除一个点。\n     * @param {GeometryPoint} point - 点对象。\n     * @returns {boolean} 点对象是否删除。\n     */\n    removeComponent(point) { // eslint-disable-line no-unused-vars\n        var removed = this.components && (this.components.length > 3);\n        if (removed) {\n            //remove last point\n            this.components.pop();\n\n            //remove our point\n            super.removeComponent.apply(this, arguments);\n            //append copy of first point\n            var firstPoint = this.components[0];\n            super.addComponent.apply(this, [firstPoint]);\n        }\n        return removed;\n    }\n\n    /**\n     * @function GeometryLinearRing.prototype.getArea\n     * @description 获得当前几何对象区域大小，如果是沿顺时针方向的环则是正值，否则为负值。\n     * @returns {number} 环的面积。\n     */\n    getArea() {\n        var area = 0.0;\n        if (this.components && (this.components.length > 2)) {\n            var sum = 0.0;\n            for (var i = 0, len = this.components.length; i < len - 1; i++) {\n                var b = this.components[i];\n                var c = this.components[i + 1];\n                sum += (b.x + c.x) * (c.y - b.y);\n            }\n            area = -sum / 2.0;\n        }\n        return area;\n    }\n\n    /**\n     * @function GeometryLinearRing.prototype.getVertices\n     * @description 返回几何图形的所有点的列表。\n     * @param {boolean} [nodes] - 对于线来说，仅仅返回作为端点的顶点，如果设为 false ，则返回非端点的顶点，如果没有设置此参数，则返回所有顶点。\n     * @returns {Array} 几何对象所有点的列表。\n     */\n    getVertices(nodes) {\n        return (nodes === true) ? [] : this.components.slice(0, this.components.length - 1);\n    }\n\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/geometry/MultiLineString.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n\n/**\n * @class GeometryMultiLineString\n * @aliasclass Geometry.MultiLineString\n * @deprecatedclass SuperMap.Geometry.MultiLineString\n * @classdesc 几何对象多线类。\n * @category BaseTypes Geometry\n * @extends GeometryCollection\n * @param {Array.<GeometryLineString>} components - GeometryLineString 数组。\n * @example\n * var multi = new GeometryMultiLineString([\n *      new GeometryLineString([\n *          new GeometryPoint(1, 0),\n *          new GeometryPoint(0, 1)\n *      ])\n *  ]);\n * @usage\n */\nclass MultiLineString_MultiLineString extends Collection_Collection {\n\n\n    constructor(components) {\n        super(components);\n        /**\n         * @member {Array.<string>} [GeometryMultiLineString.prototype.componentTypes=["SuperMap.Geometry.LineString"]]\n         * @description components 存储的的几何对象所支持的几何类型数组。\n         * @readonly\n         */\n        this.componentTypes = ["SuperMap.Geometry.LineString"];\n        this.CLASS_NAME = "SuperMap.Geometry.MultiLineString";\n        this.geometryType = "MultiLineString";\n    }\n\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/geometry/Polygon.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n\n\n/**\n * @class GeometryPolygon\n * @aliasclass Geometry.Polygon\n * @deprecatedclass SuperMap.Geometry.Polygon\n * @classdesc  多边形几何对象类。\n * @category BaseTypes Geometry\n * @extends GeometryCollection\n * @param {Array.<GeometryLinearRing>} components - 多边形的线环数组。\n * @example\n * var points =[new GeometryPoint(0,4010338),\n *      new GeometryPoint(1063524,4010338),\n *      new GeometryPoint(1063524,3150322),\n *      new GeometryPoint(0,3150322)\n *  ],\n *  var linearRings = new GeometryLinearRing(points),\n *  var  region = new GeometryPolygon([linearRings]);\n * @usage\n */\nclass Polygon_Polygon extends Collection_Collection {\n\n\n    constructor(components) {\n        super(components);\n        /**\n         * @member {Array.<string>} [GeometryPolygon.prototype.componentTypes=["SuperMap.Geometry.LinearRing"]]\n         * @description components 存储的的几何对象所支持的几何类型数组。\n         * @readonly\n         */\n        this.componentTypes = ["SuperMap.Geometry.LinearRing"];\n        this.CLASS_NAME = "SuperMap.Geometry.Polygon";\n        this.geometryType = "Polygon";\n    }\n\n    /**\n     * @function GeometryMultiPoint.prototype.getArea\n     * @description 获得区域面积，从区域的外部口径减去计此区域内部口径算所得的面积。\n     * @returns {number} 几何对象的面积。\n     */\n    getArea() {\n        var area = 0.0;\n        if (this.components && (this.components.length > 0)) {\n            area += Math.abs(this.components[0].getArea());\n            for (var i = 1, len = this.components.length; i < len; i++) {\n                area -= Math.abs(this.components[i].getArea());\n            }\n        }\n        return area;\n    }\n\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/geometry/MultiPolygon.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n/**\n * @class GeometryMultiPolygon\n * @aliasclass Geometry.MultiPolygon\n * @deprecatedclass SuperMap.Geometry.MultiPolygon\n * @classdesc 几何对象多多边形类。\n * @category BaseTypes Geometry\n * @extends GeometryCollection\n * @param  {Array.<GeometryPolygon>} components - 形成 GeometryMultiPolygon 的多边形数组。\n * @example\n * var points1 = [new GeometryPoint(10,10),new GeometryPoint(0,0)];\n * var points2 = [new GeometryPoint(10,10),new GeometryPoint(0,0),new GeometryPoint(3,3),new GeometryPoint(10,10)];\n *\n * var linearRing1 = new GeometryLinearRing(points1);\n * var linearRing2 = new GeometryLinearRing(points2);\n *\n * var polygon1 = new GeometryPolygon([linearRing1]);\n * var polygon2 = new GeometryPolygon([linearRing2]);\n *\n * var multiPolygon1 = new GeometryMultiPolygon([polygon1,polygon2]);\n * @usage\n */\nclass MultiPolygon_MultiPolygon extends Collection_Collection {\n\n\n    constructor(components) {\n        super(components);\n        /**\n         * @member {Array.<string>} [GeometryMultiPolygon.prototype.componentTypes=["SuperMap.Geometry.Polygon"]]\n         * @description components 存储的的几何对象所支持的几何类型数组。\n         * @readonly\n         */\n        this.componentTypes = ["SuperMap.Geometry.Polygon"];\n        this.CLASS_NAME = "SuperMap.Geometry.MultiPolygon";\n        this.geometryType = "MultiPolygon";\n    }\n\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/iServer/ServerColor.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n/**\n * @class ServerColor\n * @deprecatedclass SuperMap.ServerColor\n * @category iServer Map Theme\n * @classdesc 颜色类。该类使用三原色（ RGB ）来表达颜色。\n * @param {Object} options - 可选参数。\n * @param {number} [options.red=255] - 获取或设置红色值。\n * @param {number} [options.green=0] - 获取或设置绿色值。\n * @param {number} [options.blue=0] - 获取或设置蓝色值。\n * @usage\n */\nclass ServerColor {\n\n    constructor(red, green, blue) {\n\n        /**\n         * @member {number} [ServerColor.prototype.red=255]\n         * @description 获取或设置红色值。\n         */\n        this.red = (!red && red != 0)?255:red;\n\n        /**\n         * @member {number} [ServerColor.prototype.green=0]\n         * @description 获取或设置绿色值。\n         */\n        this.green = green||0;\n\n        /**\n         * @member {number} [ServerColor.prototype.blue=0]\n         * @description 获取或设置蓝色值。\n         */\n        this.blue = blue||0;\n\n        this.CLASS_NAME = "SuperMap.ServerColor";\n    }\n\n    /**\n     * @function ServerColor.prototype.destroy\n     * @description 释放资源，将引用资源的属性置空。\n     */\n    destroy() {\n        var me = this;\n        me.red = null;\n        me.green = null;\n        me.blue = null;\n    }\n\n\n    /**\n     * @function ServerColor.formJson\n     * @description 将 JSON 对象转化为 ServerColor 对象。\n     * @param {Object} jsonObject - 要转换的 JSON 对象。\n     * @returns {ServerColor} 转化后的 ServerColor 对象。\n     */\n    static fromJson(jsonObject) {\n        if (!jsonObject) {\n            return;\n        }\n        var color = new ServerColor();\n        var red = 255;\n        if (jsonObject.red !== null) {\n            red = Number(jsonObject.red);\n        }\n        color.red = red;\n\n        var green = 0;\n        if (jsonObject.green !== null) {\n            green = Number(jsonObject.green);\n        }\n        color.green = green;\n\n        var blue = 0;\n        if (jsonObject.blue !== null) {\n            blue = Number(jsonObject.blue);\n        }\n        color.blue = blue;\n        return color;\n    }\n\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/iServer/ServerStyle.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n/**\n * @class ServerStyle\n * @deprecatedclass SuperMap.ServerStyle\n * @category  iServer Map Theme\n * @classdesc 服务端矢量要素风格类。该类用于定义点状符号、线状符号、填充符号风格及其相关属性。\n * @param {Object} options - 参数。\n * @param {FillGradientMode} options.fillGradientMode - 渐变填充风格的渐变类型。\n * @param {ServerColor} [options.fillBackColor=[255,255,255]] - 填充背景颜色。\n * @param {boolean} [options.fillBackOpaque=false] - 背景是否不透明。\n * @param {ServerColor} [options.fillForeColor=[255,0,0]] - 填充颜色。\n * @param {number} [options.fillGradientAngle=0] - 渐变填充的旋转角度。\n * @param {number} [options.fillGradientOffsetRatioX=0] - 渐变填充中心点相对于填充区域范围中心点的水平偏移百分比。\n * @param {number} [options.fillGradientOffsetRatioY=0] - 填充中心点相对于填充区域范围中心点的垂直偏移百分比。\n * @param {number} [options.fillOpaqueRate=100] - 填充不透明度。\n * @param {number} [options.fillSymbolID=0] - 填充符号的编码。\n * @param {ServerColor} [options.lineColor] - 矢量要素的边线颜色。默认 lineColor = new ServerColor(0, 0, 0)。\n * @param {number} [options.lineSymbolID=0] - 线状符号的编码。\n * @param {number} [options.lineWidth=1] - 边线的宽度。\n * @param {number} [options.markerAngle=0] - 点状符号的旋转角度。\n * @param {number} [options.markerSize=1] - 点状符号的大小。\n * @param {number} [options.markerSymbolID=-1] - 点状符号的编码。\n * @usage\n */\nclass ServerStyle_ServerStyle {\n\n    constructor(options) {\n        /**\n         * @member {ServerColor} ServerStyle.prototype.fillBackColor\n         * @description 填充背景颜色。当填充模式为渐变填充时，该颜色为填充终止色。\n         */\n        this.fillBackColor = new ServerColor(255, 255, 255);\n\n        /**\n         * @member {boolean} [ServerStyle.prototype.fillBackOpaque=false]\n         * @description 背景是否不透明。false 表示透明。\n         */\n        this.fillBackOpaque = false;\n\n        /**\n         * @member {ServerColor} ServerStyle.prototype.fillForeColor\n         * @description 填充颜色。当填充模式为渐变填充时，该颜色为填充起始颜色。\n         */\n        this.fillForeColor = new ServerColor(255, 0, 0);\n\n        /**\n         * @member {FillGradientMode} ServerStyle.prototype.fillGradientMode\n         * @description 渐变填充风格的渐变类型。\n         */\n        this.fillGradientMode = null;\n\n        /**\n         * @member {number} ServerStyle.prototype.fillGradientAngle -\n         * @description 渐变填充的旋转角度。单位为度，精确到 0.1 度，逆时针方向为正方向。\n         */\n        this.fillGradientAngle = 0;\n\n        /**\n         * @member {number} ServerStyle.prototype.fillGradientOffsetRatioX\n         * @description 渐变填充中心点相对于填充区域范围中心点的水平偏移百分比。它们的关系如下：设填充区域范围中心点的坐标为（x0, y0），\n         *              填充中心点的坐标为（x, y），填充区域范围的宽度为 a，水平偏移百分比为 dx，则 x=x0 + a*dx/100。\n         */\n        this.fillGradientOffsetRatioX = 0;\n\n        /**\n         * @member {number} ServerStyle.prototype.fillGradientOffsetRatioY\n         * @description 填充中心点相对于填充区域范围中心点的垂直偏移百分比。它们的关系如下：<br>\n         *              设填充区域范围中心点的坐标为（x0, y0），填充中心点的坐标为（x, y），填充区域范围的高度为 b，垂直偏移百分比为 dy，则 y=y0 + b*dx/100。\n         */\n        this.fillGradientOffsetRatioY = 0;\n\n        /**\n         * @member {number} [ServerStyle.prototype.fillOpaqueRate=100]\n         * @description 填充不透明度。合法值为 0 - 100 的数值。其中为 0 表示完全透明；\n         *              100 表示完全不透明。赋值小于 0 时按照 0 处理，大于 100 时按照 100 处理。\n         */\n        this.fillOpaqueRate = 100;\n\n        /**\n         * @member {number} ServerStyle.prototype.fillSymbolID\n         * @description 填充符号的编码。此编码用于唯一标识各普通填充风格的填充符号。\n         *              关于填充符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。\n         */\n        this.fillSymbolID = 0;\n\n        /**\n         * @member {ServerColor} ServerStyle.prototype.lineColor\n         * @description 矢量要素的边线颜色。如果等级符号是点符号，点符号的颜色由 lineColor 控制。\n         */\n        this.lineColor = new ServerColor(0, 0, 0);\n\n        /**\n         * @member {number} [ServerStyle.prototype.lineSymbolID=0]\n         * @description 线状符号的编码。此编码用于唯一标识各普通填充风格的填充符号。\n         *              关于线状符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。\n         */\n        this.lineSymbolID = 0;\n\n        /**\n         * @member {number} [ServerStyle.prototype.lineWidth=1.0]\n         * @description 边线的宽度。单位为毫米，精度到 0.1。\n         */\n        this.lineWidth = 1;\n\n        /**\n         * @member {number} [ServerStyle.prototype.markerAngle=0]\n         * @description 点状符号的旋转角度。以度为单位，精确到 0.1 度，逆时针方向为正方向。\n         */\n        this.markerAngle = 0;\n\n        /**\n         * @member {number} [ServerStyle.prototype.markerSize=1.0]\n         * @description 点状符号的大小。单位为毫米，精度为 0.1。当该属性设置为0时，采用符号默认大小 1.0 显示。\n         *              当该属性设置为非法值时，交由服务器默认处理。\n         */\n        this.markerSize = 1;\n\n        /**\n         * @member {number} [ServerStyle.prototype.markerSymbolID=-1]\n         * @description 点状符号的编码。此编码用于唯一标识各点状符号。\n         *              关于线状符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。\n         */\n        this.markerSymbolID = -1;\n        if (options) {\n            Util.extend(this, options);\n        }\n\n        this.CLASS_NAME = "SuperMap.ServerStyle";\n    }\n\n    /**\n     * @function ServerStyle.prototype.destroy\n     * @description 释放资源，将引用资源的属性置空。\n     */\n    destroy() {\n        var me = this;\n        if (me.fillBackColor) {\n            me.fillBackColor.destroy();\n            me.fillBackColor = null;\n        }\n        me.fillBackOpaque = null;\n\n        if (me.fillForeColor) {\n            me.fillForeColor.destroy();\n            me.fillForeColor = null;\n        }\n        me.fillGradientMode = null;\n        me.fillGradientAngle = null;\n        me.fillGradientOffsetRatioX = null;\n        me.fillGradientOffsetRatioY = null;\n        me.fillOpaqueRate = null;\n        me.fillSymbolID = null;\n        if (me.lineColor) {\n            me.lineColor.destroy();\n            me.lineColor = null;\n        }\n        me.lineSymbolID = null;\n        me.lineWidth = null;\n        me.markerAngle = null;\n        me.markerSize = null;\n        me.markerSymbolID = null;\n    }\n\n    /**\n     * @function ServerStyle.prototype.toServerJSONObject\n     * @description 转换成对应的 JSON 格式对象。\n     * @returns {Object} 对应的 JSON 格式对象.\n     */\n    toServerJSONObject() {\n        var styleObj = {};\n        styleObj = Util.copyAttributes(styleObj, this);\n        //暂时先忽略serverColor往Json的转换\n        return styleObj;\n    }\n\n    /**\n     * @function ServerStyle.fromJson\n     * @description 将JSON对象转换为 ServerStyle 对象。\n     * @param {Object} jsonObject - 要转换的 JSON 对象。\n     * @returns {ServerStyle} 转化后的 ServerStyle 对象。\n     */\n    static fromJson(jsonObject) {\n        if (!jsonObject) {\n            return;\n        }\n        return new ServerStyle_ServerStyle({\n            fillBackColor: ServerColor.fromJson(jsonObject.fillBackColor),\n            fillBackOpaque: jsonObject.fillBackOpaque,\n            fillForeColor: ServerColor.fromJson(jsonObject.fillForeColor),\n            fillGradientMode: jsonObject.fillGradientMode,\n            fillGradientAngle: jsonObject.fillGradientAngle,\n            fillGradientOffsetRatioX: jsonObject.fillGradientOffsetRatioX,\n            fillGradientOffsetRatioY: jsonObject.fillGradientOffsetRatioY,\n            fillOpaqueRate: jsonObject.fillOpaqueRate,\n            fillSymbolID: jsonObject.fillSymbolID,\n            lineColor: ServerColor.fromJson(jsonObject.lineColor),\n            lineSymbolID: jsonObject.lineSymbolID,\n            lineWidth: jsonObject.lineWidth,\n            markerAngle: jsonObject.markerAngle,\n            markerSize: jsonObject.markerSize,\n            markerSymbolID: jsonObject.markerSymbolID\n        });\n    }\n\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/iServer/PointWithMeasure.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n/**\n * @class PointWithMeasure\n * @deprecatedclass SuperMap.PointWithMeasure\n * @category iServer SpatialAnalyst RouteLocator\n * @classdesc 路由点类。路由点是指具有线性度量值 (Measure) 的二维地理坐标点。\n * @param {Object} options - 参数。\n * @param {number} options.measure - 度量值，即路由对象属性值 M。\n * @param {number} options.x - 地理坐标系下的 X 坐标值。\n * @param {number} options.y - 地理坐标系下的 Y 坐标值。\n * @extends {GeometryPoint}\n * @usage\n */\nclass PointWithMeasure_PointWithMeasure extends geometry_Point_Point {\n\n    constructor(options) {\n        super(options);\n\n        /**\n         * @member {number} PointWithMeasure.prototype.measure\n         * @description 度量值，即路由对象属性值 M。\n         */\n        this.measure = null;\n\n        if (options) {\n            Util.extend(this, options);\n        }\n\n        this.CLASS_NAME = "SuperMap.PointWithMeasure";\n    }\n\n    /**\n     * @function PointWithMeasure.prototype.equals\n     * @description 判断两个路由点对象是否相等。如果两个路由点对象具有相同的坐标以及度量值，则认为是相等的。\n     * @param {PointWithMeasure} geom - 需要判断的路由点对象。\n     * @returns {boolean} 两个路由点对象是否相等（true 为相等，false 为不等）。\n     */\n    equals(geom) {\n        var equals = false;\n        if (geom != null) {\n            var isValueEquals = this.x === geom.x && this.y === geom.y && this.measure === geom.measure;\n            var isNaNValue = isNaN(this.x) && isNaN(this.y) && isNaN(this.measure);\n            var isNaNGeometry = isNaN(geom.x) && isNaN(geom.y) && isNaN(geom.measure);\n            equals = ( isValueEquals || ( isNaNValue && isNaNGeometry ));\n        }\n        return equals;\n    }\n\n\n    /**\n     * @function PointWithMeasure.prototype.toJson\n     * @description 转换为 JSON 对象。\n     * */\n     toJson() {\n        var result = "{";\n        if (this.measure != null && this.measure != undefined) {\n            result += "\\"measure\\":" + this.measure + ",";\n        }\n        result += "\\"x\\":" + this.x + ",";\n        result += "\\"y\\":" + this.y;\n        result += "}";\n        return result;\n    }\n\n\n     /**\n     * @function PointWithMeasure.prototype.destroy\n     * @description 释放资源，将引用资源的属性置空。\n     */\n    destroy() {\n        var me = this;\n        me.measure = null;\n        me.x = null;\n        me.y = null;\n    }\n\n    /**\n     * @function PointWithMeasure.fromJson\n     * @description 将 JSON 对象转换为{@link PointWithMeasure} 对象。\n     * @param {Object} jsonObject - JSON 对象表示的路由点。\n     * @returns {PointWithMeasure} 转化后的 PointWithMeasure 对象。\n     */\n    static fromJson(jsonObject) {\n        if (!jsonObject) {\n            return;\n        }\n        return new PointWithMeasure_PointWithMeasure({\n            x: jsonObject.x,\n            y: jsonObject.y,\n            measure: jsonObject.measure\n        });\n    }\n\n}\n\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/iServer/Route.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n\n\n\n/**\n * @class Route\n * @deprecatedclass SuperMap.Route\n * @category iServer SpatialAnalyst RouteCalculateMeasure\n * @classdesc 路由对象类。路由对象为一系列有序的带有属性值 M 的 x，y 坐标对，其中 M 值为该结点的距离属性（到已知点的距离）。\n * @param {Array.<Geometry>} points - 形成路由对象的线数组。\n * @param {Object} options - 参数。\n * @param {number} options.id - 路由对象在数据库中的 id。\n * @param {number} options.length - 路由对象的长度。单位与数据集的单位相同。\n * @param {number} [options.maxM] - 最大线性度量值，即所有结点到起始点的量算距离中最大值。\n * @param {number} [options.minM] - 最小线性度量值，即所有结点到起始点的量算距离中最小值。\n * @param {string} [options.type] - 数据类型，如："LINEM"。\n * @extends GeometryCollection\n * @usage\n */\nclass Route_Route extends Collection_Collection {\n\n    constructor(points, options) {\n        super(points, options);\n\n        /**\n         * @member {number} Route.prototype.id\n         * @description 路由对象在数据库中的 ID。\n         */\n        this.id = null;\n\n        /**\n         * @member {number} Route.prototype.center\n         * @description 路由对象的中心点。\n         */\n        this.center = null;\n\n        /**\n         * @member {string} Route.prototype.style\n         * @description 路由对象的样式。\n         */\n        this.style = null;\n\n        /**\n         * @member {number} Route.prototype.length\n         * @description 路由对象的长度。单位与数据集的单位相同。\n         */\n        this.length = null;\n\n        /**\n         *  @member {number} Route.prototype.maxM\n         *  @description 最大线性度量值，即所有结点到起始点的量算距离中最大值。\n         */\n        this.maxM = null;\n\n        /**\n         * @member {number} Route.prototype.minM\n         * @description 最小线性度量值，即所有结点到起始点的量算距离中最小值。\n         */\n        this.minM = null;\n\n        /**\n         * @member {Array.<number>} Route.prototype.parts\n         * @description 服务端几何对象中各个子对象所包含的节点个数。\n         */\n        this.parts = null;\n\n        /**\n         * @member {Array.<Object>} Route.prototype.points\n         * @description 路由对象的所有路由点。\n         * @example\n         * (start code)\n         * [\n         *  {\n         *      "measure": 0,\n         *      "y": -4377.027184298267,\n         *      "x": 4020.0045221720466\n         *  },\n         *  {\n         *      "measure": 37.33288381391519,\n         *      "y": -4381.569363260499,\n         *      "x": 4057.0600591960642\n         *  }\n         * ]\n         * (end)\n         */\n        this.points = null;\n\n        /**\n         * @member {string} Route.prototype.type\n         * @description 服务端几何对象类型。\n         */\n        this.type = null;\n\n        /**\n         * @member {Array.<string>} [Route.prototype.componentTypes=LineString]\n         * @description components 存储的的几何对象所支持的几何类型数组。\n         */\n        this.componentTypes = ["SuperMap.Geometry.LinearRing", "SuperMap.Geometry.LineString"];\n\n        if (options) {\n            Util.extend(this, options);\n        }\n\n        this.CLASS_NAME = "SuperMap.Route";\n        this.geometryType = "LINEM";\n    }\n\n    /**\n     *\n     * @function Route.prototype.toJson\n     * @description 转换为 JSON 对象。\n     * @returns {Object} JSON 对象。\n     */\n    toJson() {\n        var result = "{";\n        if (this.id != null && this.id != undefined) {\n            result += "\\"id\\":" + this.id + ",";\n        }\n        if (this.center != null && this.center != undefined) {\n            result += "\\"center\\":" + this.center + ",";\n        }\n        if (this.style != null && this.style != undefined) {\n            result += "\\"style\\":" + this.style + ",";\n        }\n        if (this.length != null && this.length != undefined) {\n            result += "\\"length\\":" + this.length + ",";\n        }\n        if (this.maxM != null && this.maxM != undefined) {\n            result += "\\"maxM\\":" + this.maxM + ",";\n        }\n        if (this.minM != null && this.minM != undefined) {\n            result += "\\"minM\\":" + this.minM + ",";\n        }\n        if (this.type != null && this.type != undefined) {\n            result += "\\"type\\":\\"" + this.type + "\\",";\n        }\n        if (this.parts != null && this.parts != undefined) {\n            result += "\\"parts\\":[" + this.parts[0];\n\n            for (var i = 1; i < this.parts.length; i++) {\n                result += "," + this.parts[i];\n            }\n            result += "],";\n        }\n        if (this.components != null && this.components.length > 0) {\n            result += "\\"points\\":[";\n            for (var j = 0, len = this.components.length; j < len; j++) {\n                for (var k = 0, len2 = this.components[j].components.length; k < len2; k++) {\n                    result += this.components[j].components[k].toJson() + ",";\n                }\n            }\n            result = result.replace(/,$/g, \'\');\n            result += "]";\n        }\n        result = result.replace(/,$/g, \'\');\n        result += "}";\n        return result;\n    }\n\n\n    /**\n     * @function Route.prototype.destroy\n     * @override\n     */\n    destroy() {\n        var me = this;\n        me.id = null;\n        me.center = null;\n        me.style = null;\n        me.length = null;\n        me.maxM = null;\n        me.minM = null;\n        me.type = null;\n        me.parts = null;\n        me.components.length = 0;\n        me.components = null;\n        me.componentTypes = null;\n    }\n\n\n    /**\n     * @function Route.fromJson\n     * @description 将 JSON 对象转换为 Route 对象。\n     * @param {Object} [jsonObject] - JSON 对象表示的路由对象。\n     * @returns {Route} 转化后的 Route 对象。\n     */\n    static fromJson(jsonObject) {\n        if (!jsonObject) {\n            return;\n        }\n\n        var geoParts = jsonObject.parts || [],\n            geoPoints = jsonObject.points || [],\n            len = geoParts.length,\n            lineList = [];\n        if (len > 0) {\n            for (var i = 0, pointIndex = 0, pointList = []; i < len; i++) {\n                for (var j = 0; j < geoParts[i]; j++) {\n                    pointList.push(PointWithMeasure_PointWithMeasure.fromJson(geoPoints[pointIndex + j]));\n                }\n                pointIndex += geoParts[i];\n                //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString\n                if (pointList[0].equals(pointList[geoParts[i] - 1])) {\n                    lineList.push(new LinearRing_LinearRing(pointList));\n                } else {\n                    lineList.push(new LineString_LineString(pointList));\n                }\n                pointList = [];\n            }\n\n        } else {\n            return null;\n        }\n\n        return new Route_Route(lineList, {\n            id: jsonObject.id,\n            center: jsonObject.center,\n            style: jsonObject.style,\n            length: jsonObject.length,\n            maxM: jsonObject.maxM,\n            minM: jsonObject.minM,\n            type: jsonObject.type,\n            parts: jsonObject.parts\n        });\n    }\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/REST.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n /**\n * @enum DataFormat\n * @description 服务请求返回结果数据类型\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.DataFormat.GEOJSON;\n *\n * <\/script>\n * // ES6 Import\n * import { DataFormat } from \'{npm}\';\n *\n * const result = DataFormat.GEOJSON;\n * ```\n */\nvar DataFormat = {\n    /** GEOJSON */\n    GEOJSON: "GEOJSON",\n    /** ISERVER */\n    ISERVER: "ISERVER"\n};\n\n/**\n * @enum ServerType\n * @description 服务器类型\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.ServerType.ISERVER;\n *\n * <\/script>\n * // ES6 Import\n * import { ServerType } from \'{npm}\';\n *\n * const result = ServerType.ISERVER;\n * ```\n */\nvar ServerType = {\n    /** ISERVER */\n    ISERVER: "ISERVER",\n    /** IPORTAL */\n    IPORTAL: "IPORTAL",\n    /** ONLINE */\n    ONLINE: "ONLINE"\n};\n\n/**\n * @enum GeometryType\n * @description 几何对象枚举,定义了一系列几何对象类型。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.GeometryType.LINE;\n *\n * <\/script>\n * // ES6 Import\n * import { GeometryType } from \'{npm}\';\n *\n * const result = GeometryType.LINE;\n * ```\n */\nvar GeometryType = {\n    /** LINE */\n    LINE: "LINE",\n    /** LINEM */\n    LINEM: "LINEM",\n    /** POINT */\n    POINT: "POINT",\n    /** REGION */\n    REGION: "REGION",\n    /** POINTEPS */\n    POINTEPS: "POINTEPS",\n    /** LINEEPS */\n    LINEEPS: "LINEEPS",\n    /** REGIONEPS */\n    REGIONEPS: "REGIONEPS",\n    /** ELLIPSE */\n    ELLIPSE: "ELLIPSE",\n    /** CIRCLE */\n    CIRCLE: "CIRCLE",\n    /** TEXT */\n    TEXT: "TEXT",\n    /** RECTANGLE */\n    RECTANGLE: "RECTANGLE",\n    /** UNKNOWN */\n    UNKNOWN: "UNKNOWN",\n    /** GEOCOMPOUND */\n    GEOCOMPOUND:"GEOCOMPOUND"\n};\n\n/**\n * @enum QueryOption\n * @description 查询结果类型枚举,描述查询结果返回类型，包括只返回属性、只返回几何实体以及返回属性和几何实体。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.QueryOption.ATTRIBUTE;\n *\n * <\/script>\n * // ES6 Import\n * import { QueryOption } from \'{npm}\';\n *\n * const result = QueryOption.ATTRIBUTE;\n * ```\n */\nvar QueryOption = {\n    /** 属性 */\n    ATTRIBUTE: "ATTRIBUTE",\n    /** 属性和几何对象 */\n    ATTRIBUTEANDGEOMETRY: "ATTRIBUTEANDGEOMETRY",\n    /** 几何对象 */\n    GEOMETRY: "GEOMETRY"\n};\n\n/**\n * @enum JoinType\n * @description 关联查询时的关联类型常量。\n * 该类定义了两个表之间的连接类型常量，决定了对两个表之间进行连接查询时，查询结果中得到的记录的情况。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.JoinType.INNERJOIN;\n *\n * <\/script>\n * // ES6 Import\n * import { JoinType } from \'{npm}\';\n *\n * const result = JoinType.INNERJOIN;\n * ```\n */\nvar JoinType = {\n    /** 内连接 */\n    INNERJOIN: "INNERJOIN",\n    /** 左连接 */\n    LEFTJOIN: "LEFTJOIN"\n};\n\n/**\n * @enum SpatialQueryMode\n * @description  空间查询模式枚举。该类定义了空间查询操作模式常量。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.SpatialQueryMode.CONTAIN;\n *\n * <\/script>\n * // ES6 Import\n * import { SpatialQueryMode } from \'{npm}\';\n *\n * const result = SpatialQueryMode.CONTAIN;\n * ```\n */\nvar SpatialQueryMode = {\n    /** 包含空间查询模式 */\n    CONTAIN: "CONTAIN",\n    /** 交叉空间查询模式 */\n    CROSS: "CROSS",\n    /** 分离空间查询模式 */\n    DISJOINT: "DISJOINT",\n    /** 重合空间查询模式 */\n    IDENTITY: "IDENTITY",\n    /** 相交空间查询模式 */\n    INTERSECT: "INTERSECT",\n    /** 无空间查询 */\n    NONE: "NONE",\n    /** 叠加空间查询模式 */\n    OVERLAP: "OVERLAP",\n    /** 邻接空间查询模式 */\n    TOUCH: "TOUCH",\n    /** 被包含空间查询模式 */\n    WITHIN: "WITHIN"\n};\n\n/**\n * @enum SpatialRelationType\n * @description  数据集对象间的空间关系枚举。\n * 该类定义了数据集对象间的空间关系类型常量。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.SpatialRelationType.CONTAIN;\n *\n * <\/script>\n * // ES6 Import\n * import { SpatialRelationType } from \'{npm}\';\n *\n * const result = {namespace}.SpatialRelationType.CONTAIN;\n * ```\n */\nvar SpatialRelationType = {\n    /** 包含关系 */\n    CONTAIN: "CONTAIN",\n    /** 相交关系 */\n    INTERSECT: "INTERSECT",\n    /** 被包含关系 */\n    WITHIN: "WITHIN"\n};\n\n/**\n * @enum MeasureMode\n * @type {string}\n * @description  量算模式枚举。\n * @category BaseTypes Constant\n * 该类定义了两种测量模式：距离测量和面积测量。\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.MeasureMode.DISTANCE;\n *\n * <\/script>\n * // ES6 Import\n * import { MeasureMode } from \'{npm}\';\n *\n * const result = MeasureMode.DISTANCE;\n * ```\n */\nvar MeasureMode = {\n    /** 距离测量 */\n    DISTANCE: "DISTANCE",\n    /** 面积测量 */\n    AREA: "AREA"\n};\n\n/**\n * @enum Unit\n * @description  距离单位枚举。\n * 该类定义了一系列距离单位类型。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.Unit.METER;\n *\n * <\/script>\n * // ES6 Import\n * import { Unit } from \'{npm}\';\n *\n * const result = Unit.METER;\n * ```\n */\nvar Unit = {\n    /**  米 */\n    METER: "METER",\n    /**  千米 */\n    KILOMETER: "KILOMETER",\n    /**  英里 */\n    MILE: "MILE",\n    /**  码 */\n    YARD: "YARD",\n    /**  度 */\n    DEGREE: "DEGREE",\n    /**  毫米 */\n    MILLIMETER: "MILLIMETER",\n    /**  厘米 */\n    CENTIMETER: "CENTIMETER",\n    /**  英寸 */\n    INCH: "INCH",\n    /**  分米 */\n    DECIMETER: "DECIMETER",\n    /**  英尺 */\n    FOOT: "FOOT",\n    /**  秒 */\n    SECOND: "SECOND",\n    /**  分 */\n    MINUTE: "MINUTE",\n    /**  弧度 */\n    RADIAN: "RADIAN"\n};\n\n/**\n * @enum BufferRadiusUnit\n * @description  缓冲区距离单位枚举。该类定义了一系列缓冲距离单位类型。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.BufferRadiusUnit.CENTIMETER;\n *\n * <\/script>\n * // ES6 Import\n * import { BufferRadiusUnit } from \'{npm}\';\n *\n * const result = BufferRadiusUnit.CENTIMETER;\n * ```\n */\nvar BufferRadiusUnit = {\n    /**  厘米 */\n    CENTIMETER: "CENTIMETER",\n    /**  分米 */\n    DECIMETER: "DECIMETER",\n    /**  英尺 */\n    FOOT: "FOOT",\n    /**  英寸 */\n    INCH: "INCH",\n    /**  千米 */\n    KILOMETER: "KILOMETER",\n    /**  米 */\n    METER: "METER",\n    /**  英里 */\n    MILE: "MILE",\n    /**  毫米 */\n    MILLIMETER: "MILLIMETER",\n    /**  码 */\n    YARD: "YARD"\n}\n\n/**\n * @enum EngineType\n * @description  数据源引擎类型枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.EngineType.IMAGEPLUGINS;\n *\n * <\/script>\n * // ES6 Import\n * import { EngineType } from \'{npm}\';\n *\n * const result = EngineType.IMAGEPLUGINS;\n * ```\n */\nvar EngineType = {\n    /** 影像只读引擎类型，文件引擎，针对通用影像格式如 BMP，JPG，TIFF 以及超图自定义影像格式 SIT 等。 */\n    IMAGEPLUGINS: "IMAGEPLUGINS",\n    /**  OGC 引擎类型，针对于 Web 数据源，Web 引擎，目前支持的类型有 WMS，WFS，WCS。 */\n    OGC: "OGC",\n    /**  Oracle 引擎类型，针对 Oracle 数据源，数据库引擎。 */\n    ORACLEPLUS: "ORACLEPLUS",\n    /**  SDB 引擎类型，文件引擎，即 SDB 数据源。 */\n    SDBPLUS: "SDBPLUS",\n    /**  SQL Server 引擎类型，针对 SQL Server 数据源，数据库引擎 */\n    SQLPLUS: "SQLPLUS",\n    /**  UDB 引擎类型，文件引擎。 */\n    UDB: "UDB"\n};\n\n/**\n * @enum ThemeGraphTextFormat\n * @description  统计专题图文本显示格式枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.ThemeGraphTextFormat.CAPTION;\n *\n * <\/script>\n * // ES6 Import\n * import { ThemeGraphTextFormat } from \'{npm}\';\n *\n * const result = ThemeGraphTextFormat.CAPTION;\n * ```\n */\nvar ThemeGraphTextFormat = {\n    /**  标题。以各子项的标题来进行标注。 */\n    CAPTION: "CAPTION",\n    /**  标题 + 百分数。以各子项的标题和所占的百分比来进行标注。 */\n    CAPTION_PERCENT: "CAPTION_PERCENT",\n    /**  标题 + 实际数值。以各子项的标题和真实数值来进行标注。 */\n    CAPTION_VALUE: "CAPTION_VALUE",\n    /**  百分数。以各子项所占的百分比来进行标注。 */\n    PERCENT: "PERCENT",\n    /**  实际数值。以各子项的真实数值来进行标注。 */\n    VALUE: "VALUE"\n\n};\n\n/**\n * @enum ThemeGraphType\n * @description  统计专题图类型枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.ThemeGraphType.AREA;\n *\n * <\/script>\n * // ES6 Import\n * import { ThemeGraphType } from \'{npm}\';\n *\n * const result = ThemeGraphType.AREA;\n * ```\n */\nvar ThemeGraphType = {\n    /**  面积图。 */\n    AREA: "AREA",\n    /**  柱状图。 */\n    BAR: "BAR",\n    /**  三维柱状图。 */\n    BAR3D: "BAR3D",\n    /**  折线图。 */\n    LINE: "LINE",\n    /**  饼图。 */\n    PIE: "PIE",\n    /**  三维饼图。 */\n    PIE3D: "PIE3D",\n    /**  点状图。 */\n    POINT: "POINT",\n    /**  环状图。 */\n    RING: "RING",\n    /**  玫瑰图。 */\n    ROSE: "ROSE",\n    /**  三维玫瑰图。 */\n    ROSE3D: "ROSE3D",\n    /**  堆叠柱状图。 */\n    STACK_BAR: "STACK_BAR",\n    /**  三维堆叠柱状图。 */\n    STACK_BAR3D: "STACK_BAR3D",\n    /**  阶梯图。 */\n    STEP: "STEP"\n};\n\n/**\n * @enum GraphAxesTextDisplayMode\n * @description  统计专题图坐标轴文本显示模式。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.GraphAxesTextDisplayMode.ALL;\n *\n * <\/script>\n * // ES6 Import\n * import { GraphAxesTextDisplayMode } from \'{npm}\';\n *\n * const result = GraphAxesTextDisplayMode.ALL;\n * ```\n */\nvar GraphAxesTextDisplayMode = {\n    /**  显示全部文本。 */\n    ALL: "ALL",\n    /**  不显示。 */\n    NONE: "NONE",\n    /**  显示Y轴的文本。 */\n    YAXES: "YAXES"\n};\n\n/**\n * @enum GraduatedMode\n * @description  专题图分级模式枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.GraduatedMode.CONSTANT;\n *\n * <\/script>\n * // ES6 Import\n * import { GraduatedMode } from \'{npm}\';\n *\n * const result = GraduatedMode.CONSTANT;\n * ```\n */\nvar GraduatedMode = {\n    /**  常量分级模式。 */\n    CONSTANT: "CONSTANT",\n    /** 对数分级模式。 */\n    LOGARITHM: "LOGARITHM",\n    /**  平方根分级模式。 */\n    SQUAREROOT: "SQUAREROOT"\n};\n\n/**\n * @enum RangeMode\n * @description  范围分段专题图分段方式枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.RangeMode.CUSTOMINTERVAL;\n *\n * <\/script>\n * // ES6 Import\n * import { RangeMode } from \'{npm}\';\n *\n * const result = RangeMode.CUSTOMINTERVAL;\n * ```\n */\nvar RangeMode = {\n    /**  自定义分段法。 */\n    CUSTOMINTERVAL: "CUSTOMINTERVAL",\n    /**  等距离分段法。 */\n    EQUALINTERVAL: "EQUALINTERVAL",\n    /**  对数分段法。 */\n    LOGARITHM: "LOGARITHM",\n    /**  等计数分段法。 */\n    QUANTILE: "QUANTILE",\n    /**  平方根分段法。 */\n    SQUAREROOT: "SQUAREROOT",\n    /**  标准差分段法。 */\n    STDDEVIATION: "STDDEVIATION"\n};\n\n/**\n * @enum ThemeType\n * @description  专题图类型枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.ThemeType.DOTDENSITY;\n *\n * <\/script>\n * // ES6 Import\n * import { ThemeType } from \'{npm}\';\n *\n * const result = ThemeType.DOTDENSITY;\n * ```\n */\nvar ThemeType = {\n    /** 点密度专题图。 */\n    DOTDENSITY: "DOTDENSITY",\n    /** 等级符号专题图。 */\n    GRADUATEDSYMBOL: "GRADUATEDSYMBOL",\n    /** 统计专题图。 */\n    GRAPH: "GRAPH",\n    /** 标签专题图。 */\n    LABEL: "LABEL",\n    /** 分段专题图。 */\n    RANGE: "RANGE",\n    /** 単值专题图。 */\n    UNIQUE: "UNIQUE"\n};\n\n/**\n * @enum ColorGradientType\n * @description  渐变颜色枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.ColorGradientType.BLACK_WHITE;\n *\n * <\/script>\n * // ES6 Import\n * import { ColorGradientType } from \'{npm}\';\n *\n * const result = ColorGradientType.BLACK_WHITE;\n * ```\n */\nvar ColorGradientType = {\n    /** 黑白渐变色。 */\n    BLACK_WHITE: "BLACKWHITE",\n    /** 蓝黑渐变色。 */\n    BLUE_BLACK: "BLUEBLACK",\n    /** 蓝红渐变色。 */\n    BLUE_RED: "BLUERED",\n    /** 蓝白渐变色。 */\n    BLUE_WHITE: "BLUEWHITE",\n    /** 青黑渐变色。 */\n    CYAN_BLACK: "CYANBLACK",\n    /** 青蓝渐变色。 */\n    CYAN_BLUE: "CYANBLUE",\n    /** 青绿渐变色。 */\n    CYAN_GREEN: "CYANGREEN",\n    /** 青白渐变色。 */\n    CYAN_WHITE: "CYANWHITE",\n    /** 绿黑渐变色。 */\n    GREEN_BLACK: "GREENBLACK",\n    /** 绿蓝渐变色。 */\n    GREEN_BLUE: "GREENBLUE",\n    /** 绿橙紫渐变色。 */\n    GREEN_ORANGE_VIOLET: "GREENORANGEVIOLET",\n    /** 绿红渐变色。 */\n    GREEN_RED: "GREENRED",\n    /** 蓝红渐变色。 */\n    GREEN_WHITE: "GREENWHITE",\n    /** 粉黑渐变色。 */\n    PINK_BLACK: "PINKBLACK",\n    /** 粉蓝渐变色。 */\n    PINK_BLUE: "PINKBLUE",\n    /** 粉红渐变色。 */\n    PINK_RED: "PINKRED",\n    /** 粉白渐变色。 */\n    PINK_WHITE: "PINKWHITE",\n    /** 彩虹色。 */\n    RAIN_BOW: "RAINBOW",\n    /** 红黑渐变色。 */\n    RED_BLACK: "REDBLACK",\n    /** 红白渐变色。 */\n    RED_WHITE: "REDWHITE",\n    /** 光谱渐变。 */\n    SPECTRUM: "SPECTRUM",\n    /** 地形渐变,用于三维显示效果较好。 */\n    TERRAIN: "TERRAIN",\n    /** 黄黑渐变色。 */\n    YELLOW_BLACK: "YELLOWBLACK",\n    /** 黄蓝渐变色。 */\n    YELLOW_BLUE: "YELLOWBLUE",\n    /** 黄绿渐变色。 */\n    YELLOW_GREEN: "YELLOWGREEN",\n    /** 黄红渐变色。 */\n    YELLOW_RED: "YELLOWRED",\n    /** 黄白渐变色。 */\n    YELLOW_WHITE: "YELLOWWHITE"\n};\n\n/**\n * @enum TextAlignment\n * @description  文本对齐枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.TextAlignment.TOPLEFT;\n *\n * <\/script>\n * // ES6 Import\n * import { TextAlignment } from \'{npm}\';\n *\n * const result = TextAlignment.TOPLEFT;\n * ```\n */\nvar TextAlignment = {\n    /** 左上角对齐。 */\n    TOPLEFT: "TOPLEFT",\n    /** 顶部居中对齐。 */\n    TOPCENTER: "TOPCENTER",\n    /** 右上角对齐。 */\n    TOPRIGHT: "TOPRIGHT",\n    /** 基准线左对齐。 */\n    BASELINELEFT: "BASELINELEFT",\n    /** 基准线居中对齐。 */\n    BASELINECENTER: "BASELINECENTER",\n    /** 基准线右对齐。 */\n    BASELINERIGHT: "BASELINERIGHT",\n    /** 左下角对齐。 */\n    BOTTOMLEFT: "BOTTOMLEFT",\n    /** 底部居中对齐。 */\n    BOTTOMCENTER: "BOTTOMCENTER",\n    /** 右下角对齐。 */\n    BOTTOMRIGHT: "BOTTOMRIGHT",\n    /** 左中对齐。 */\n    MIDDLELEFT: "MIDDLELEFT",\n    /** 中心对齐。 */\n    MIDDLECENTER: "MIDDLECENTER",\n    /** 右中对齐。 */\n    MIDDLERIGHT: "MIDDLERIGHT"\n};\n\n/**\n * @enum FillGradientMode\n * @description  渐变填充风格的渐变类型枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.FillGradientMode.NONE;\n *\n * <\/script>\n * // ES6 Import\n * import { FillGradientMode } from \'{npm}\';\n *\n * const result = FillGradientMode.NONE;\n * ```\n */\nvar FillGradientMode = {\n    /** 无渐变。 */\n    NONE: "NONE",\n    /** 线性渐变填充。 */\n    LINEAR: "LINEAR",\n    /** 辐射渐变填充。 */\n    RADIAL: "RADIAL",\n    /** 圆锥渐变填充。 */\n    CONICAL: "CONICAL",\n    /** 四角渐变填充。 */\n    SQUARE: "SQUARE"\n};\n\n/**\n * @enum AlongLineDirection\n * @description  标签沿线标注方向枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.AlongLineDirection.NORMAL;\n *\n * <\/script>\n * // ES6 Import\n * import { AlongLineDirection } from \'{npm}\';\n *\n * const result = AlongLineDirection.NORMAL;\n * ```\n */\nvar AlongLineDirection = {\n    /** 沿线的法线方向放置标签。 */\n    NORMAL: "ALONG_LINE_NORMAL",\n    /** 从下到上，从左到右放置。 */\n    LB_TO_RT: "LEFT_BOTTOM_TO_RIGHT_TOP",\n    /** 从上到下，从左到右放置。 */\n    LT_TO_RB: "LEFT_TOP_TO_RIGHT_BOTTOM",\n    /** 从下到上，从右到左放置。 */\n    RB_TO_LT: "RIGHT_BOTTOM_TO_LEFT_TOP",\n    /** 从上到下，从右到左放置。 */\n    RT_TO_LB: "RIGHT_TOP_TO_LEFT_BOTTOM"\n};\n\n/**\n * @enum LabelBackShape\n * @description  标签专题图中标签背景的形状枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.LabelBackShape.DIAMOND;\n *\n * <\/script>\n * // ES6 Import\n * import { LabelBackShape } from \'{npm}\';\n *\n * const result = LabelBackShape.DIAMOND;\n * ```\n */\nvar LabelBackShape = {\n    /** 菱形背景，即标签背景的形状为菱形。 */\n    DIAMOND: "DIAMOND",\n    /** 椭圆形背景，即标签背景的行状为椭圆形。 */\n    ELLIPSE: "ELLIPSE",\n    /** 符号背景，即标签背景的形状为设定的符号。 */\n    MARKER: "MARKER",\n    /** 空背景，即不使用任何形状作为标签的背景。 */\n    NONE: "NONE",\n    /** 矩形背景，即标签背景的形状为矩形。 */\n    RECT: "RECT",\n    /** 圆角矩形背景，即标签背景的形状为圆角矩形。 */\n    ROUNDRECT: "ROUNDRECT",\n    /** 三角形背景，即标签背景的形状为三角形。 */\n    TRIANGLE: "TRIANGLE"\n};\n\n/**\n * @enum LabelOverLengthMode\n * @description  标签专题图中超长标签的处理模式枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.LabelOverLengthMode.NEWLINE;\n *\n * <\/script>\n * // ES6 Import\n * import { LabelOverLengthMode } from \'{npm}\';\n *\n * const result = LabelOverLengthMode.NEWLINE;\n * ```\n */\nvar LabelOverLengthMode = {\n    /** 换行显示。 */\n    NEWLINE: "NEWLINE",\n    /** 对超长标签不进行处理。 */\n    NONE: "NONE",\n    /** 省略超出部分。 */\n    OMIT: "OMIT"\n};\n\n/**\n * @enum DirectionType\n * @description  网络分析中方向枚举。\n * 在行驶引导子项中使用。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.DirectionType.EAST;\n *\n * <\/script>\n * // ES6 Import\n * import { DirectionType } from \'{npm}\';\n *\n * const result = DirectionType.EAST;\n * ```\n */\nvar DirectionType = {\n    /** 东。 */\n    EAST: "EAST",\n    /** 无方向。 */\n    NONE: "NONE",\n    /** 北。 */\n    NORTH: "NORTH",\n    /** 南。 */\n    SOURTH: "SOURTH",\n    /** 西。 */\n    WEST: "WEST"\n};\n\n/**\n * @enum SideType\n * @description  行驶位置枚举。\n * 表示在行驶在路的左边、右边或者路上的枚举,该类用在行驶导引子项类中。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.SideType.LEFT;\n *\n * <\/script>\n * // ES6 Import\n * import { SideType } from \'{npm}\';\n *\n * const result = SideType.LEFT;\n * ```\n */\nvar SideType = {\n    /** 路的左侧。 */\n    LEFT: "LEFT",\n    /** 在路上（即路的中间）。 */\n    MIDDLE: "MIDDLE",\n    /** 无效值。 */\n    NONE: "NONE",\n    /** 路的右侧。 */\n    RIGHT: "RIGHT"\n};\n\n/**\n * @enum SupplyCenterType\n * @description  资源供给中心类型枚举。\n * 该枚举定义了网络分析中资源中心点的类型，主要用于资源分配和选址分区。\n * 资源供给中心点的类型包括非中心，固定中心和可选中心。固定中心用于资源分配分析； 固定中心和可选中心用于选址分析；非中心在两种网络分析时都不予考虑。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.SupplyCenterType.FIXEDCENTER;\n *\n * <\/script>\n * // ES6 Import\n * import { SupplyCenterType } from \'{npm}\';\n *\n * const result = SupplyCenterType.FIXEDCENTER;\n * ```\n */\nvar SupplyCenterType = {\n    /** 固定中心点。 */\n    FIXEDCENTER: "FIXEDCENTER",\n    /** 非中心点。 */\n    NULL: "NULL",\n    /** 可选中心点。 */\n    OPTIONALCENTER: "OPTIONALCENTER"\n};\n\n/**\n * @enum TurnType\n * @description  转弯方向枚举。\n * 用在行驶引导子项类中，表示转弯的方向。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.TurnType.AHEAD;\n *\n * <\/script>\n * // ES6 Import\n * import { TurnType } from \'{npm}\';\n *\n * const result = TurnType.AHEAD;\n * ```\n */\nvar TurnType = {\n    /** 向前直行。 */\n    AHEAD: "AHEAD",\n    /** 掉头。 */\n    BACK: "BACK",\n    /** 终点，不拐弯。 */\n    END: "END",\n    /** 左转弯。 */\n    LEFT: "LEFT",\n    /** 无效值。 */\n    NONE: "NONE",\n    /** 右转弯。 */\n    RIGHT: "RIGHT"\n};\n\n/**\n * @enum BufferEndType\n * @description  缓冲区分析BufferEnd类型。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.BufferEndType.FLAT;\n *\n * <\/script>\n * // ES6 Import\n * import { BufferEndType } from \'{npm}\';\n *\n * const result = BufferEndType.FLAT;\n * ```\n */\nvar BufferEndType = {\n    /** FLAT */\n    FLAT: "FLAT",\n    /** ROUND */\n    ROUND: "ROUND"\n};\n/**\n * @enum OverlayOperationType\n * @description  叠加分析类型枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.OverlayOperationType.CLIP;\n *\n * <\/script>\n * // ES6 Import\n * import { OverlayOperationType } from \'{npm}\';\n *\n * const result = OverlayOperationType.CLIP;\n * ```\n */\n var OverlayOperationType = {\n    /** 操作数据集（几何对象）裁剪被操作数据集（几何对象）。 */\n    CLIP: "CLIP",\n    /** 在被操作数据集（几何对象）上擦除掉与操作数据集（几何对象）相重合的部分。 */\n    ERASE: "ERASE",\n    /**对被操作数据集（几何对象）进行同一操作，即操作执行后，被操作数据集（几何对象）包含来自操作数据集（几何对象）的几何形状。 */\n    IDENTITY: "IDENTITY",\n    /** 对两个数据集（几何对象）求交，返回两个数据集（几何对象）的交集。 */\n    INTERSECT: "INTERSECT",\n    /** 对两个面数据集（几何对象）进行合并操作。 */\n    UNION: "UNION",\n    /** 对两个面数据集（几何对象）进行更新操作。 */\n    UPDATE: "UPDATE",\n    /** 对两个面数据集（几何对象）进行对称差操作。 */\n    XOR: "XOR"\n};\n\n/**\n * @enum OutputType\n * @description  分布式分析输出类型枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.OutputType.INDEXEDHDFS;\n *\n * <\/script>\n * // ES6 Import\n * import { OutputType } from \'{npm}\';\n *\n * const result = OutputType.INDEXEDHDFS;\n * ```\n */\nvar OutputType =  {\n    /** INDEXEDHDFS */\n    INDEXEDHDFS: "INDEXEDHDFS",\n    /** UDB */\n    UDB: "UDB",\n    /** MONGODB */\n    MONGODB: "MONGODB",\n    /** PG */\n    PG: "PG"\n};\n\n/**\n * @enum SmoothMethod\n * @description  光滑方法枚举。\n * 用于从Grid 或DEM数据生成等值线或等值面时对等值线或者等值面的边界线进行平滑处理的方法。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.SmoothMethod.BSPLINE;\n *\n * <\/script>\n * // ES6 Import\n * import { SmoothMethod } from \'{npm}\';\n *\n * const result = SmoothMethod.BSPLINE;\n * ```\n */\n var SmoothMethod = {\n    /** B 样条法。 */\n    BSPLINE: "BSPLINE",\n    /** 磨角法。 */\n    POLISH: "POLISH"\n};\n\n/**\n * @enum SurfaceAnalystMethod\n * @description  表面分析方法枚举。\n * 通过对数据进行表面分析，能够挖掘原始数据所包含的信息，使某些细节明显化，易于分析。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.SurfaceAnalystMethod.ISOLINE;\n *\n * <\/script>\n * // ES6 Import\n * import { SurfaceAnalystMethod } from \'{npm}\';\n *\n * const result = SurfaceAnalystMethod.ISOLINE;\n * ```\n */\nvar SurfaceAnalystMethod = {\n    /** 等值线提取。 */\n    ISOLINE: "ISOLINE",\n    /** 等值面提取。 */\n    ISOREGION: "ISOREGION"\n};\n\n/**\n * @enum DataReturnMode\n * @description  数据返回模式枚举。\n * 该枚举用于指定空间分析返回结果模式,包含返回数据集标识和记录集、只返回数据集标识(数据集名称@数据源名称)及只返回记录集三种模式。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.DataReturnMode.DATASET_AND_RECORDSET;\n *\n * <\/script>\n * // ES6 Import\n * import { DataReturnMode } from \'{npm}\';\n *\n * const result = DataReturnMode.DATASET_AND_RECORDSET;\n * ```\n */\nvar DataReturnMode = {\n    /** 返回结果数据集标识(数据集名称@数据源名称)和记录集（RecordSet）。 */\n    DATASET_AND_RECORDSET: "DATASET_AND_RECORDSET",\n    /** 只返回数据集标识（数据集名称@数据源名称）。 */\n    DATASET_ONLY: "DATASET_ONLY",\n    /** 只返回记录集（RecordSet）。 */\n    RECORDSET_ONLY: "RECORDSET_ONLY"\n};\n\n/**\n * @enum EditType\n * @description  要素集更新模式枚举。\n * 该枚举用于指定数据服务中要素集更新模式,包含添加要素集、更新要素集和删除要素集。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.EditType.ADD;\n *\n * <\/script>\n * // ES6 Import\n * import { EditType } from \'{npm}\';\n *\n * const result = {namespace}.EditType.ADD;\n * ```\n */\nvar EditType = {\n    /** 增加操作。 */\n    ADD: "add",\n    /** 修改操作。 */\n    UPDATE: "update",\n    /** 删除操作。 */\n    DELETE: "delete"\n};\n\n/**\n * @enum TransferTactic\n * @description  公交换乘策略枚举。\n * 该枚举用于指定公交服务中要素集更新模式,包含添加要素集、更新要素集和删除要素集。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.TransferTactic.LESS_TIME;\n *\n * <\/script>\n * // ES6 Import\n * import { TransferTactic } from \'{npm}\';\n *\n * const result = TransferTactic.LESS_TIME;\n * ```\n */\nvar TransferTactic = {\n    /** 时间短。 */\n    LESS_TIME: "LESS_TIME",\n    /** 少换乘。 */\n    LESS_TRANSFER: "LESS_TRANSFER",\n    /** 少步行。 */\n    LESS_WALK: "LESS_WALK",\n    /** 距离最短。 */\n    MIN_DISTANCE: "MIN_DISTANCE"\n};\n\n/**\n * @enum TransferPreference\n * @description  公交换乘策略枚举。\n * 该枚举用于指定交通换乘服务中设置地铁优先、公交优先、不乘地铁、无偏好等偏好设置。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.TransferPreference.BUS;\n *\n * <\/script>\n * // ES6 Import\n * import { TransferPreference } from \'{npm}\';\n *\n * const result = TransferPreference.BUS;\n * ```\n */\nvar TransferPreference = {\n    /** 公交汽车优先。 */\n    BUS: "BUS",\n    /** 地铁优先。 */\n    SUBWAY: "SUBWAY",\n    /** 不乘坐地铁。 */\n    NO_SUBWAY: "NO_SUBWAY",\n    /** 无乘车偏好。 */\n    NONE: "NONE"\n};\n\n/**\n * @enum GridType\n * @description  地图背景格网类型枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.GridType.CROSS;\n *\n * <\/script>\n * // ES6 Import\n * import { GridType } from \'{npm}\';\n *\n * const result = GridType.CROSS;\n * ```\n */\nvar GridType =  {\n    /** 十字叉丝。 */\n    CROSS: "CROSS",\n    /** 网格线。 */\n    GRID: "GRID",\n    /** 点。 */\n    POINT: "POINT"\n};\n\n/**\n * @enum ColorSpaceType\n * @description  色彩空间枚举。\n * 由于成色原理的不同，决定了显示器、投影仪这类靠色光直接合成颜色的颜色设备和打印机、\n * 印刷机这类靠使用颜料的印刷设备在生成颜色方式上的区别。\n * 针对上述不同成色方式，SuperMap 提供两种色彩空间，\n * 分别为 RGB 和 CMYK。RGB 主要用于显示系统中，CMYK 主要用于印刷系统中。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.ColorSpaceType.CMYK;\n *\n * <\/script>\n * // ES6 Import\n * import { ColorSpaceType } from \'{npm}\';\n *\n * const result = ColorSpaceType.CMYK;\n * ```\n */\nvar ColorSpaceType = {\n    /** 该类型主要在印刷系统使用。 */\n    CMYK: "CMYK",\n    /** 该类型主要在显示系统中使用。 */\n    RGB: "RGB"\n};\n\n/**\n * @enum LayerType\n * @description  图层类型。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.LayerType.UGC;\n *\n * <\/script>\n * // ES6 Import\n * import { LayerType } from \'{npm}\';\n *\n * const result = LayerType.UGC;\n * ```\n */\nvar LayerType = {\n    /** SuperMap UGC 类型图层。如矢量图层、栅格(Grid)图层、影像图层。 */\n    UGC: "UGC",\n    /** WMS 图层。 */\n    WMS: "WMS",\n    /** WFS 图层。 */\n    WFS: "WFS",\n    /** 自定义图层。 */\n    CUSTOM: "CUSTOM"\n};\n\n/**\n * @enum UGCLayerType\n * @description  SuperMap 图层类型。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.UGCLayerType.THEME;\n *\n * <\/script>\n * // ES6 Import\n * import { UGCLayerType } from \'{npm}\';\n *\n * const result = UGCLayerType.THEME;\n * ```\n */\nvar UGCLayerType = {\n    /** 专题图层。 */\n    THEME: "THEME",\n    /** 矢量图层。 */\n    VECTOR: "VECTOR",\n    /** 栅格图层。。 */\n    GRID: "GRID",\n    /** 影像图层。 */\n    IMAGE: "IMAGE"\n};\n\n/**\n * @enum StatisticMode\n * @description  字段统计方法类型。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.StatisticMode.AVERAGE;\n *\n * <\/script>\n * // ES6 Import\n * import { StatisticMode } from \'{npm}\';\n *\n * const result = StatisticMode.AVERAGE;\n * ```\n */\nvar StatisticMode = {\n    /** 统计所选字段的平均值。 */\n    AVERAGE: "AVERAGE",\n    /** 统计所选字段的最大值。 */\n    MAX: "MAX",\n    /** 统计所选字段的最小值。 */\n    MIN: "MIN",\n    /** 统计所选字段的标准差 */\n    STDDEVIATION: "STDDEVIATION",\n    /** 统计所选字段的总和。 */\n    SUM: "SUM",\n    /** 统计所选字段的方差。 */\n    VARIANCE: "VARIANCE"\n};\n\n/**\n * @enum PixelFormat\n * @description  栅格与影像数据存储的像素格式枚举。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.PixelFormat.BIT16;\n *\n * <\/script>\n * // ES6 Import\n * import { PixelFormat } from \'{npm}\';\n *\n * const result = PixelFormat.BIT16;\n * ```\n */\nvar PixelFormat = {\n    /** 每个像元用16个比特(即2个字节)表示。 */\n    BIT16: "BIT16",\n    /** 每个像元用32个比特(即4个字节)表示。 */\n    BIT32: "BIT32",\n    /** 每个像元用64个比特(即8个字节)表示，只提供给栅格数据集使用。 */\n    BIT64: "BIT64",\n    /** 每个像元用4个字节来表示，只提供给栅格数据集使用。 */\n    SINGLE: "SINGLE",\n    /** 每个像元用8个字节来表示，只提供给栅格数据集使用。 */\n    DOUBLE: "DOUBLE",\n    /** 每个像元用1个比特表示。 */\n    UBIT1: "UBIT1",\n    /** 每个像元用4个比特来表示。 */\n    UBIT4: "UBIT4",\n    /** 每个像元用8个比特(即1个字节)来表示。 */\n    UBIT8: "UBIT8",\n    /** 每个像元用24个比特(即3个字节)来表示。 */\n    UBIT24: "UBIT24",\n    /** 每个像元用32个比特(即4个字节)来表示。 */\n    UBIT32: "UBIT32"\n};\n\n/**\n * @enum SearchMode\n * @description  内插时使用的样本点的查找方式枚举\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.SearchMode.KDTREE_FIXED_COUNT;\n *\n * <\/script>\n * // ES6 Import\n * import { SearchMode } from \'{npm}\';\n *\n * const result = SearchMode.KDTREE_FIXED_COUNT;\n * ```\n */\nvar SearchMode = {\n    /** 使用 KDTREE 的固定点数方式查找参与内插分析的点。 */\n    KDTREE_FIXED_COUNT: "KDTREE_FIXED_COUNT",\n    /** 使用 KDTREE 的定长方式查找参与内插分析的点。 */\n    KDTREE_FIXED_RADIUS: "KDTREE_FIXED_RADIUS",\n    /** 不进行查找，使用所有的输入点进行内插分析。 */\n    NONE: "NONE",\n    /** 使用 QUADTREE 方式查找参与内插分析的点，仅对样条（RBF）插值和普通克吕金（Kriging）有用。 */\n    QUADTREE: "QUADTREE"\n};\n\n/**\n * @enum InterpolationAlgorithmType\n * @description  插值分析的算法的类型\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.InterpolationAlgorithmType.KRIGING;\n *\n * <\/script>\n * // ES6 Import\n * import { InterpolationAlgorithmType } from \'{npm}\';\n *\n * const result = InterpolationAlgorithmType.KRIGING;\n * ```\n */\nvar InterpolationAlgorithmType = {\n    /** 普通克吕金插值法。 */\n    KRIGING: "KRIGING",\n    /** 简单克吕金插值法。 */\n    SimpleKriging: "SimpleKriging",\n    /** 泛克吕金插值法。 */\n    UniversalKriging: "UniversalKriging"\n};\n\n/**\n * @enum VariogramMode\n * @description  克吕金（Kriging）插值时的半变函数类型枚举\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.VariogramMode.EXPONENTIAL;\n *\n * <\/script>\n * // ES6 Import\n * import { VariogramMode } from \'{npm}\';\n *\n * const result = VariogramMode.EXPONENTIAL;\n * ```\n */\nvar VariogramMode = {\n    /** 指数函数。 */\n    EXPONENTIAL: "EXPONENTIAL",\n    /** 高斯函数。 */\n    GAUSSIAN: "GAUSSIAN",\n    /** 球型函数。 */\n    SPHERICAL: "SPHERICAL"\n};\n\n/**\n * @enum Exponent\n * @description  定义了泛克吕金（UniversalKriging）插值时样点数据中趋势面方程的阶数\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.Exponent.EXP1;\n *\n * <\/script>\n * // ES6 Import\n * import { Exponent } from \'{npm}\';\n *\n * const result = Exponent.EXP1;\n * ```\n */\nvar Exponent = {\n    /** 阶数为1。 */\n    EXP1: "EXP1",\n    /** 阶数为2。 */\n    EXP2: "EXP2"\n};\n\n/**\n * @enum ClientType\n * @description token申请的客户端标识类型\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.ClientType.IP;\n *\n * <\/script>\n * // ES6 Import\n * import { ClientType } from \'{npm}\';\n *\n * const result = ClientType.IP;\n * ```\n */\nvar ClientType = {\n    /** 指定的 IP 地址。 */\n    IP: "IP",\n    /** 指定的 URL。 */\n    REFERER: "Referer",\n    /** 发送申请令牌请求的客户端 IP。 */\n    REQUESTIP: "RequestIP",\n    /** 不做任何验证。 */\n    NONE: "NONE",\n    /** SERVER。 */\n    SERVER: "SERVER",\n    /** WEB。 */\n    WEB: "WEB"\n};\n\n/**\n * @enum ChartType\n * @description 客户端专题图图表类型\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.ChartType.BAR;\n *\n * <\/script>\n * // ES6 Import\n * import { ChartType } from \'{npm}\';\n *\n * const result = ChartType.BAR;\n * ```\n */\nvar ChartType = {\n    /** 柱状图。 */\n    BAR: "Bar",\n    /** 三维柱状图。 */\n    BAR3D: "Bar3D",\n    /** 圆形图。 */\n    CIRCLE: "Circle",\n    /** 饼图。 */\n    PIE: "Pie",\n    /** 散点图。 */\n    POINT: "Point",\n    /** 折线图。 */\n    LINE: "Line",\n    /** 环状图。 */\n    RING: "Ring"\n};\n\n/**\n * @enum ClipAnalystMode\n * @description  裁剪分析模式\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.ClipAnalystMode.CLIP;\n *\n * <\/script>\n * // ES6 Import\n * import { ClipAnalystMode } from \'{npm}\';\n *\n * const result = ClipAnalystMode.CLIP;\n * ```\n */\nvar ClipAnalystMode = {\n    /** CLIP。 */\n    CLIP: "clip",\n    /** INTERSECT。 */\n    INTERSECT: "intersect"\n};\n\n/**\n * @enum AnalystAreaUnit\n * @description 分布式分析面积单位\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.AnalystAreaUnit.SQUAREMETER;\n *\n * <\/script>\n * // ES6 Import\n * import { AnalystAreaUnit } from \'{npm}\';\n *\n * const result = AnalystAreaUnit.SQUAREMETER;\n * ```\n */\nvar AnalystAreaUnit = {\n    /** 平方米。 */\n    "SQUAREMETER": "SquareMeter",\n    /** 平方千米。 */\n    "SQUAREKILOMETER": "SquareKiloMeter",\n    /** 公顷。 */\n    "HECTARE": "Hectare",\n    /** 公亩。 */\n    "ARE": "Are",\n    /** 英亩。 */\n    "ACRE": "Acre",\n    /** 平方英尺。 */\n    "SQUAREFOOT": "SquareFoot",\n    /** 平方码。 */\n    "SQUAREYARD": "SquareYard",\n    /** 平方英里。 */\n    "SQUAREMILE": "SquareMile"\n};\n\n/**\n * @enum AnalystSizeUnit\n * @description 分布式分析单位\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.AnalystSizeUnit.METER;\n *\n * <\/script>\n * // ES6 Import\n * import { AnalystSizeUnit } from \'{npm}\';\n *\n * const result = AnalystSizeUnit.METER;\n * ```\n */\nvar AnalystSizeUnit = {\n    /** 米。 */\n    "METER": "Meter",\n    /** 千米。 */\n    "KILOMETER": "Kilometer",\n    /** 码。 */\n    "YARD": "Yard",\n    /** 英尺。 */\n    "FOOT": "Foot",\n    /** 英里。 */\n    "MILE": "Mile"\n};\n\n/**\n * @enum StatisticAnalystMode\n * @description 分布式分析统计模式\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.StatisticAnalystMode.MAX;\n *\n * <\/script>\n * // ES6 Import\n * import { StatisticAnalystMode } from \'{npm}\';\n *\n * const result = StatisticAnalystMode.MAX;\n * ```\n */\nvar StatisticAnalystMode = {\n    /** 统计所选字段的最大值。 */\n    "MAX": "max",\n    /** 统计所选字段的最小值。 */\n    "MIN": "min",\n    /** 统计所选字段的平均值。 */\n    "AVERAGE": "average",\n    /** 统计所选字段的总和。 */\n    "SUM": "sum",\n    /** 统计所选字段的方差。 */\n    "VARIANCE": "variance",\n    /** 统计所选字段的标准差 */\n    "STDDEVIATION": "stdDeviation"\n};\n\n/**\n * @enum SummaryType\n * @description 分布式分析聚合类型\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.SummaryType.SUMMARYMESH;\n *\n * <\/script>\n * // ES6 Import\n * import { SummaryType } from \'{npm}\';\n *\n * const result = SummaryType.SUMMARYMESH;\n * ```\n */\nvar SummaryType = {\n    /** 格网聚合。 */\n    "SUMMARYMESH": "SUMMARYMESH",\n    /** 多边形聚合。 */\n    "SUMMARYREGION": "SUMMARYREGION"\n};\n\n/**\n * @enum TopologyValidatorRule\n * @description  拓扑检查模式枚举。该类定义了拓扑检查操作模式常量。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.TopologyValidatorRule.REGIONNOOVERLAP;\n *\n * <\/script>\n * // ES6 Import\n * import { TopologyValidatorRule } from \'{npm}\';\n *\n * const result = TopologyValidatorRule.REGIONNOOVERLAP;\n * ```\n */\nvar TopologyValidatorRule = {\n    /** 面内无重叠，用于对面数据进行拓扑检查。 */\n    REGIONNOOVERLAP: "REGIONNOOVERLAP",\n    /** 面与面无重叠，用于对面数据进行拓扑检查。 */\n    REGIONNOOVERLAPWITH: "REGIONNOOVERLAPWITH",\n    /** 面被面包含，用于对面数据进行拓扑检查。 */\n    REGIONCONTAINEDBYREGION: "REGIONCONTAINEDBYREGION",\n    /** 面被面覆盖，用于对面数据进行拓扑检查。 */\n    REGIONCOVEREDBYREGION: "REGIONCOVEREDBYREGION",\n    /** 线与线无重叠，用于对线数据进行拓扑检查。 */\n    LINENOOVERLAP: "LINENOOVERLAP",\n    /** 线内无重叠，用于对线数据进行拓扑检查。 */\n    LINENOOVERLAPWITH: "LINENOOVERLAPWITH",\n    /** 点不相同，用于对点数据进行拓扑检查。 */\n    POINTNOIDENTICAL: "POINTNOIDENTICAL"\n};\n\n/**\n * @enum BucketAggType\n * @description  格网聚合查询枚举类，该类定义了Elasticsearch数据服务中聚合查询模式常量\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.BucketAggType.GEOHASH_GRID;\n *\n * <\/script>\n * // ES6 Import\n * import { BucketAggType } from \'{npm}\';\n *\n * const result = BucketAggType.GEOHASH_GRID;\n * ```\n */\nvar BucketAggType = {\n    /** 格网聚合类型 */\n    GEOHASH_GRID: "geohash_grid"\n};\n\n/**\n * @enum MetricsAggType\n * @description  指标聚合类型枚举类，该类定义了Elasticsearch数据服务中聚合查询模式常量\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.MetricsAggType.AVG;\n *\n * <\/script>\n * // ES6 Import\n * import { MetricsAggType } from \'{npm}\';\n *\n * const result = MetricsAggType.AVG;\n * ```\n */\nvar MetricsAggType = {\n  /** 平均值聚合类型 */\n  AVG:\'avg\',\n  /** 最大值聚合类型 */\n  MAX:\'max\',\n  /** 最小值聚合类型 */\n  MIN:\'min\',\n  /** 求和聚合类型 */\n  SUM:\'sum\'\n};\n\n/**\n * @enum GetFeatureMode\n * @description feature 查询方式。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.GetFeatureMode.BOUNDS;\n *\n * <\/script>\n * // ES6 Import\n * import { GetFeatureMode } from \'{npm}\';\n *\n * const result = GetFeatureMode.BOUNDS;\n * ```\n */\nvar GetFeatureMode = {\n    /** 通过范围查询来获取要素。 */\n    BOUNDS: "BOUNDS",\n    /** 通过几何对象的缓冲区来获取要素。 */\n    BUFFER: "BUFFER",\n    /** 通过 ID 来获取要素。 */\n    ID: "ID",\n    /** 通过空间查询模式来获取要素。 */\n    SPATIAL: "SPATIAL",\n    /** 通过 SQL 查询来获取要素。 */\n    SQL: \'SQL\'\n}\n\n/**\n * @enum RasterFunctionType\n * @description 栅格分析方法。\n * @category BaseTypes Constant\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.GetFeatureMode.NDVI;\n *\n * <\/script>\n * // ES6 Import\n * import { GetFeatureMode } from \'{npm}\';\n *\n * const result = GetFeatureMode.NDVI;\n * ```\n */\nvar RasterFunctionType = {\n    /** 归一化植被指数。 */\n    NDVI: "NDVI",\n    /** 阴影面分析。 */\n    HILLSHADE: "HILLSHADE"\n}\n\n/**\n * @enum ResourceType\n * @description iportal资源类型。\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.GetFeatureMode.MAP;\n *\n * <\/script>\n * // ES6 Import\n * import { GetFeatureMode } from \'{npm}\';\n *\n * const result = GetFeatureMode.MAP;\n * ```\n */\nvar ResourceType = {\n    /** 地图。 */\n    MAP: "MAP",\n    /** 服务。 */\n    SERVICE: "SERVICE",\n    /** 场景。 */\n    SCENE: "SCENE",\n    /** 数据。 */\n    DATA: "DATA",\n    /** 洞察。 */\n    INSIGHTS_WORKSPACE: "INSIGHTS_WORKSPACE",\n    /** 大屏。 */\n    MAP_DASHBOARD: "MAP_DASHBOARD"\n}\n\n/**\n * @enum OrderBy\n * @description iportal资源排序字段。\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.OrderBy.UPDATETIME;\n *\n * <\/script>\n * // ES6 Import\n * import { OrderBy } from \'{npm}\';\n *\n * const result = OrderBy.UPDATETIME;\n * ```\n */\nvar OrderBy = {\n    /** 按更新时间排序 */\n    UPDATETIME: "UPDATETIME",\n    /** 按热度(可能是访问量、下载量)排序 */\n    HEATLEVEL: "HEATLEVEL",\n    /** 按相关性排序 */\n    RELEVANCE: "RELEVANCE"\n}\n\n/**\n * @enum OrderType\n * @description iportal资源升序还是降序过滤\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.OrderType.ASC;\n *\n * <\/script>\n * // ES6 Import\n * import { OrderType } from \'{npm}\';\n *\n * const result = OrderType.ASC;\n * ```\n */\nvar OrderType = {\n    /** 升序 */\n    ASC: "ASC",\n    /** 降序 */\n    DESC: "DESC"\n}\n\n/**\n * @enum SearchType\n * @description iportal资源查询的范围进行过滤\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.SearchType.PUBLIC;\n *\n * <\/script>\n * // ES6 Import\n * import { SearchType } from \'{npm}\';\n *\n * const result = SearchType.PUBLIC;\n * ```\n */\nvar SearchType = {\n    /** 公开资源。 */\n    PUBLIC: "PUBLIC",\n    /** 我的资源。 */\n    MY_RES: "MY_RES",\n    /** 我的群组资源。 */\n    MYGROUP_RES: "MYGROUP_RES",\n    /** 我的部门资源。 */\n    MYDEPARTMENT_RES: "MYDEPARTMENT_RES",\n    /** 分享给我的资源。 */\n    SHARETOME_RES: "SHARETOME_RES"\n}\n\n/**\n * @enum AggregationTypes\n * @description iportal资源聚合查询的类型\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.AggregationTypes.TAG;\n *\n * <\/script>\n * // ES6 Import\n * import { AggregationTypes } from \'{npm}\';\n *\n * const result = AggregationTypes.TAG;\n * ```\n */\nvar AggregationTypes = {\n    /** 标签 */\n    TAG: "TAG",\n    /** 资源类型 */\n    TYPE: "TYPE"\n}\n\n/**\n * @enum PermissionType\n * @description iportal资源权限类型。\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.PermissionType.SEARCH;\n *\n * <\/script>\n * // ES6 Import\n * import { PermissionType } from \'{npm}\';\n *\n * const result = PermissionType.SEARCH;\n * ```\n */\nvar PermissionType = {\n    /** 可检索 */\n    SEARCH:"SEARCH",\n    /** 可查看 */\n    READ: "READ",\n    /** 可编辑 */\n    READWRITE: "READWRITE",\n    /** 可删除 */\n    DELETE: "DELETE",\n    /** 可下载，包括可读、可检索 */\n    DOWNLOAD:"DOWNLOAD"\n}\n\n/**\n * @enum EntityType\n * @description iportal资源实体类型。\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.EntityType.DEPARTMENT;\n *\n * <\/script>\n * // ES6 Import\n * import { EntityType } from \'{npm}\';\n *\n * const result = EntityType.DEPARTMENT;\n * ```\n */\nvar EntityType = {\n    /** 部门 */\n    DEPARTMENT: "DEPARTMENT",\n    /** 用户组 */\n    GROUP: "GROUP",\n    /** 群组 */\n    IPORTALGROUP: "IPORTALGROUP",\n    /** 角色 */\n    ROLE: "ROLE",\n    /** 用户 */\n    USER: "USER"\n}\n\n/**\n * @enum DataItemType\n * @description iportal数据类型。\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.DataItemType.GEOJSON;\n *\n * <\/script>\n * // ES6 Import\n * import { DataItemType } from \'{npm}\';\n *\n * const result = DataItemType.GEOJSON;\n * ```\n */\nvar DataItemType = {\n    /** geojson数据。 */\n    GEOJSON: "GEOJSON",\n    /** UGCV5_MVT  */\n    UGCV5_MVT: "UGCV5_MVT",\n    /** json数据  */\n    JSON: "JSON",\n    /** AUDIO */\n    AUDIO: "AUDIO",\n    /** COLOR */\n    COLOR: "COLOR",\n    /** COLORSCHEME */\n    COLORSCHEME: "COLORSCHEME",\n    /** CSV */\n    CSV: "CSV",\n    /** EXCEL */\n    EXCEL: "EXCEL",\n    /** FILLSYMBOL */\n    FILLSYMBOL: "FILLSYMBOL",\n    /** IMAGE */\n    IMAGE: "IMAGE",\n    /** LAYERTEMPLATE */\n    LAYERTEMPLATE: "LAYERTEMPLATE",\n    /** LAYOUTTEMPLATE */\n    LAYOUTTEMPLATE: "LAYOUTTEMPLATE",\n    /** LINESYMBOL */\n    LINESYMBOL: "LINESYMBOL",\n    /** MAPTEMPLATE */\n    MAPTEMPLATE: "MAPTEMPLATE",\n    /** MARKERSYMBOL */\n    MARKERSYMBOL: "MARKERSYMBOL",\n    /** MBTILES */\n    MBTILES: "MBTILES",\n    /** PHOTOS */\n    PHOTOS: "PHOTOS",\n    /** SHP */\n    SHP: "SHP",\n    /** SMTILES */\n    SMTILES: "SMTILES",\n    /** SVTILES */\n    SVTILES: "SVTILES",\n    /** THEMETEMPLATE */\n    THEMETEMPLATE: "THEMETEMPLATE",\n    /** TPK */\n    TPK: "TPK",\n    /** UDB */\n    UDB: "UDB",\n    /** UGCV5 */\n    UGCV5: "UGCV5",\n    /** UNKNOWN */\n    UNKNOWN: "UNKNOWN",\n    /** VIDEO */\n    VIDEO: "VIDEO",\n    /** WORKENVIRONMENT */\n    WORKENVIRONMENT: "WORKENVIRONMENT",\n    /** WORKSPACE */\n    WORKSPACE: "WORKSPACE"\n}\n\n/**\n * @enum WebExportFormatType\n * @description Web 打印输出的格式。\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.WebExportFormatType.PNG;\n *\n * <\/script>\n * // ES6 Import\n * import { WebExportFormatType } from \'{npm}\';\n *\n * const result = WebExportFormatType.PNG;\n * ```\n */\nvar WebExportFormatType = {\n    /** png */\n    PNG: "PNG",\n    /** pdf */\n    PDF: "PDF"\n}\n\n/**\n * @enum WebScaleOrientationType\n * @description Web 比例尺的方位样式。\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.WebScaleOrientationType.HORIZONTALLABELSBELOW;\n *\n * <\/script>\n * // ES6 Import\n * import { WebScaleOrientationType } from \'{npm}\';\n *\n * const result = WebScaleOrientationType.HORIZONTALLABELSBELOW;\n * ```\n */\nvar WebScaleOrientationType = {\n    /** horizontal labels below */\n    HORIZONTALLABELSBELOW: "HORIZONTALLABELSBELOW",\n    /** horizontal labels above */\n    HORIZONTALLABELSABOVE: "HORIZONTALLABELSABOVE",\n    /** vertical labels left */\n    VERTICALLABELSLEFT: "VERTICALLABELSLEFT",\n    /** vertical labels right */\n    VERTICALLABELSRIGHT: "VERTICALLABELSRIGHT"\n}\n\n/**\n * @enum WebScaleType\n * @description Web 比例尺的样式。\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.WebScaleType.LINE;\n *\n * <\/script>\n * // ES6 Import\n * import { WebScaleType } from \'{npm}\';\n *\n * const result = WebScaleType.LINE;\n * ```\n */\nvar WebScaleType = {\n    /** line */\n    LINE: "LINE",\n    /** bar */\n    BAR: "BAR",\n    /** bar sub */\n    BAR_SUB: "BAR_SUB"\n}\n\n/**\n * @enum WebScaleUnit\n * @description Web 比例尺的单位制。\n * @category BaseTypes Constant\n * @version 10.0.1\n * @type {string}\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.WebScaleUnit.METER;\n *\n * <\/script>\n * // ES6 Import\n * import { WebScaleUnit } from \'{npm}\';\n *\n * const result = WebScaleUnit.METER;\n * ```\n */\nvar WebScaleUnit = {\n    /** 米 */\n    METER: "METER",\n    /** 英尺 */\n    FOOT: "FOOT",\n    /** 度 */\n    DEGREES: "DEGREES"\n}\n\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/iServer/ServerGeometry.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @class ServerGeometry\n * @deprecatedclass SuperMap.ServerGeometry\n * @category  iServer Data Feature\n * @classdesc 服务端几何对象类。该类描述几何对象（矢量）的特征数据（坐标点对、几何对象的类型等）。基于服务端的空间分析、空间关系运算、查询等 GIS 服务功能使用服务端几何对象。\n * @param {Object} options - 参数。\n * @param {string} options.id - 服务端几何对象唯一标识符。\n * @param {Array.<number>} options.parts - 服务端几何对象中各个子对象所包含的节点个数。\n * @param {Array.<GeometryPoint>} options.points - 组成几何对象的节点的坐标对数组。\n * @param {GeometryType} options.type - 几何对象的类型。\n * @param {ServerStyle} [options.style] - 服务端几何对象的风格。\n * @usage\n */\nclass ServerGeometry_ServerGeometry {\n    constructor(options) {\n        /**\n         * @member {string} ServerGeometry.prototype.id\n         * @description 服务端几何对象唯一标识符。\n         */\n        this.id = 0;\n\n        /**\n         * @member {ServerStyle} [ServerGeometry.prototype.style]\n         * @description 服务端几何对象的风格（ServerStyle）。\n         */\n        this.style = null;\n\n        /**\n         * @member {Array.<number>} ServerGeometry.prototype.parts\n         * @description 服务端几何对象中各个子对象所包含的节点个数。<br>\n         * 1.几何对象从结构上可以分为简单几何对象和复杂几何对象。\n         * 简单几何对象与复杂几何对象的区别：简单的几何对象一般为单一对象，\n         * 而复杂的几何对象由多个简单对象组成或经过一定的空间运算之后产生，\n         * 如：矩形为简单的区域对象，而中空的矩形为复杂的区域对象。<br>\n         * 2.通常情况，一个简单几何对象的子对象就是它本身，\n         * 因此对于简单对象来说的该字段为长度为1的整型数组，\n         * 该字段的值就是这个简单对象节点的个数。\n         * 如果一个几何对象是由几个简单对象组合而成的，\n         * 例如，一个岛状几何对象由 3 个简单的多边形组成而成，\n         * 那么这个岛状的几何对象的 Parts 字段值就是一个长度为 3 的整型数组，\n         * 数组中每个成员的值分别代表这三个多边形所包含的节点个数。\n         */\n        this.parts = null;\n\n        /**\n         * @member {Array.<GeometryPoint>} ServerGeometry.prototype.points\n         * @description 组成几何对象的节点的坐标对数组。<br>\n         * 1.所有几何对象（点、线、面）都是由一些简单的点坐标组成的，\n         * 该字段存放了组成几何对象的点坐标的数组。\n         * 对于简单的面对象，他的起点和终点的坐标点相同。<br>\n         * 2.对于复杂的几何对象，根据 Parts 属性来确定每一个组成复杂几何对象的简单对象所对应的节点的个数，\n         * 从而确定 Points 字段中坐标对的分配归属问题。\n         */\n        this.points = null;\n\n        /**\n         * @member {GeometryType} ServerGeometry.prototype.type\n         * @description 几何对象的类型（GeometryType）。\n         */\n        this.type = null;\n\n        /**\n         * @member {Object} ServerGeometry.prototype.prjCoordSys\n         * @description 投影坐标参数，现仅在缓冲区分析中有效。\n         */\n        this.prjCoordSys = null;\n        if (options) {\n            Util.extend(this, options);\n        }\n\n        this.CLASS_NAME = \'SuperMap.ServerGeometry\';\n    }\n\n    /**\n     * @function ServerGeometry.prototype.destroy\n     * @description 释放资源，将引用资源的属性置空。\n     */\n    destroy() {\n        var me = this;\n        me.id = null;\n        me.style = null;\n        me.parts = null;\n        me.partTopo = null;\n        me.points = null;\n        me.type = null;\n        me.prjCoordSys = null;\n    }\n\n    /**\n     * @function ServerGeometry.prototype.toGeometry\n     * @description 将服务端几何对象 ServerGeometry 转换为客户端几何对象 Geometry。\n     * @returns {Geometry} 转换后的客户端几何对象。\n     */\n    toGeometry() {\n        var me = this,\n            geoType = me.type;\n        switch (geoType.toUpperCase()) {\n            case GeometryType.POINT:\n                return me.toGeoPoint();\n            case GeometryType.LINE:\n                return me.toGeoLine();\n            case GeometryType.LINEM:\n                return me.toGeoLinem();\n            case GeometryType.REGION:\n                return me.toGeoRegion();\n            case GeometryType.POINTEPS:\n                return me.toGeoPoint();\n            case GeometryType.LINEEPS:\n                return me.toGeoLineEPS();\n            case GeometryType.REGIONEPS:\n                return me.toGeoRegionEPS();\n            case GeometryType.GEOCOMPOUND:\n                return me.transformGeoCompound();\n        }\n    }\n\n    /**\n     * @function ServerGeometry.prototype.toGeoPoint\n     * @description 将服务端的点几何对象转换为客户端几何对象。包括 Point、MultiPoint。\n     * @returns {Geometry} 转换后的客户端几何对象。\n     */\n    toGeoPoint() {\n        var me = this,\n            geoParts = me.parts || [],\n            geoPoints = me.points || [],\n            len = geoParts.length;\n        if (len > 0) {\n            if (len === 1) {\n                return new geometry_Point_Point(geoPoints[0].x, geoPoints[0].y);\n            } else {\n                var pointList = [];\n                for (let i = 0; i < len; i++) {\n                    pointList.push(new geometry_Point_Point(geoPoints[i].x, geoPoints[i].y));\n                }\n                return new MultiPoint_MultiPoint(pointList);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @function ServerGeometry.prototype.toGeoLine\n     * @description 将服务端的线几何对象转换为客户端几何对象。包括 GeometryLinearRing、GeometryLineString、GeometryMultiLineString。\n     * @returns {Geometry} 转换后的客户端几何对象。\n     */\n    toGeoLine() {\n        var me = this,\n            geoParts = me.parts || [],\n            geoPoints = me.points || [],\n            len = geoParts.length;\n        if (len > 0) {\n            if (len === 1) {\n                let pointList = [];\n                for (let i = 0; i < geoParts[0]; i++) {\n                    pointList.push(new geometry_Point_Point(geoPoints[i].x, geoPoints[i].y));\n                }\n                //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString\n                if (pointList[0].equals(pointList[geoParts[0] - 1])) {\n                    return new LinearRing_LinearRing(pointList);\n                } else {\n                    return new LineString_LineString(pointList);\n                }\n            } else {\n                let lineList = [];\n                for (let i = 0; i < len; i++) {\n                    let pointList = [];\n                    for (let j = 0; j < geoParts[i]; j++) {\n                        pointList.push(new geometry_Point_Point(geoPoints[j].x, geoPoints[j].y));\n                    }\n                    lineList.push(new LineString_LineString(pointList));\n                    geoPoints.splice(0, geoParts[i]);\n                }\n                return new MultiLineString_MultiLineString(lineList);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @function ServerGeometry.prototype.toGeoLineEPS\n     * @description 将服务端的线几何对象转换为客户端几何对象。包括 GeometryLinearRing、GeometryLineString、GeometryMultiLineString。\n     * @returns {Geometry} 转换后的客户端几何对象。\n     */\n    toGeoLineEPS() {\n        var me = this,\n            geoParts = me.parts || [],\n            geoPoints = me.points || [],\n            i,\n            j,\n            pointList,\n            lineList,\n            lineEPS,\n            len = geoParts.length;\n        if (len > 0) {\n            if (len === 1) {\n                for (i = 0, pointList = []; i < geoParts[0]; i++) {\n                    pointList.push(new geometry_Point_Point(geoPoints[i].x, geoPoints[i].y, geoPoints[i].type));\n                }\n                //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString\n                if (pointList[0].equals(pointList[geoParts[0] - 1])) {\n                    lineEPS = LineString_LineString.createLineEPS(pointList);\n                    return new LinearRing_LinearRing(lineEPS);\n                } else {\n                    lineEPS = LineString_LineString.createLineEPS(pointList);\n                    return new LineString_LineString(lineEPS);\n                }\n            } else {\n                for (i = 0, lineList = []; i < len; i++) {\n                    for (j = 0, pointList = []; j < geoParts[i]; j++) {\n                        pointList.push(new geometry_Point_Point(geoPoints[j].x, geoPoints[j].y));\n                    }\n                    lineEPS = LineString_LineString.createLineEPS(pointList);\n                    lineList.push(new LineString_LineString(lineEPS));\n                    geoPoints.splice(0, geoParts[i]);\n                }\n                return new MultiLineString_MultiLineString(lineList);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @function ServerGeometry.prototype.toGeoLinem\n     * @description 将服务端的路由线几何对象转换为客户端几何对象。包括 LinearRing、LineString、MultiLineString。\n     * @returns {Geometry} 转换后的客户端几何对象。\n     */\n    toGeoLinem() {\n        var me = this;\n        return Route_Route.fromJson(me);\n    }\n\n    /**\n     * @function ServerGeometry.prototype.toGeoRegion\n     * @description 将服务端的面几何对象转换为客户端几何对象。类型为 GeometryPolygon。\n     * @returns {Geometry} 转换后的客户端几何对象。\n     */\n    toGeoRegion() {\n        var me = this,\n            geoParts = me.parts || [],\n            geoTopo = me.partTopo || [],\n            geoPoints = me.points || [],\n            len = geoParts.length;\n        if (len <= 0) {\n            return null;\n        }\n        var polygonArray = [];\n        var pointList = [];\n        if (len == 1) {\n            for (let i = 0; i < geoPoints.length; i++) {\n                pointList.push(new geometry_Point_Point(geoPoints[i].x, geoPoints[i].y));\n            }\n            polygonArray.push(new Polygon_Polygon([new LinearRing_LinearRing(pointList)]));\n            return new MultiPolygon_MultiPolygon(polygonArray);\n        }\n        //处理复杂面\n        var CCWArray = [];\n        var areaArray = [];\n        var polygonArrayTemp = [];\n        var polygonBounds = [];\n        //polyon岛洞标识数组，初始都是岛。\n        var CCWIdent = [];\n        for (let i = 0, pointIndex = 0; i < len; i++) {\n            for (let j = 0; j < geoParts[i]; j++) {\n                pointList.push(new geometry_Point_Point(geoPoints[pointIndex + j].x, geoPoints[pointIndex + j].y));\n            }\n            pointIndex += geoParts[i];\n            var polygon = new Polygon_Polygon([new LinearRing_LinearRing(pointList)]);\n            pointList = [];\n            polygonArrayTemp.push(polygon);\n            if (geoTopo.length === 0) {\n                polygonBounds.push(polygon.getBounds());\n            }\n            CCWIdent.push(1);\n            areaArray.push(polygon.getArea());\n        }\n        //iServer 9D新增字段\n        if (geoTopo.length === 0) {\n            //根据面积排序\n            ServerGeometry_ServerGeometry.bubbleSort(areaArray, polygonArrayTemp, geoTopo, polygonBounds);\n            //岛洞底层判断原则：将所有的子对象按照面积排序，面积最大的直接判定为岛（1），从面积次大的开始处理，\n            // 如果发现该对象在某个面积大于它的对象之中（即被包含），则根据包含它的对象的标识（1 or -1），指定其标识（-1 or 1），\n            // 依次处理完所有对象，就得到了一个标识数组，1表示岛，-1表示洞\n            //目标polygon索引列表 -1标示没有被任何polygon包含，\n            var targetArray = [];\n            for (let i = 1; i < polygonArrayTemp.length; i++) {\n                for (let j = i - 1; j >= 0; j--) {\n                    targetArray[i] = -1;\n                    if (polygonBounds[j].containsBounds(polygonBounds[i])) {\n                        CCWIdent[i] = CCWIdent[j] * -1;\n                        if (CCWIdent[i] < 0) {\n                            targetArray[i] = j;\n                        }\n                        break;\n                    }\n                }\n            }\n            for (let i = 0; i < polygonArrayTemp.length; i++) {\n                if (CCWIdent[i] > 0) {\n                    polygonArray.push(polygonArrayTemp[i]);\n                } else {\n                    polygonArray[targetArray[i]].components = polygonArray[targetArray[i]].components.concat(\n                        polygonArrayTemp[i].components\n                    );\n                    //占位\n                    polygonArray.push(\'\');\n                }\n            }\n        } else {\n            polygonArray = new Array();\n            for (let i = 0; i < polygonArrayTemp.length; i++) {\n                if (geoTopo[i] && geoTopo[i] == -1) {\n                    CCWArray = CCWArray.concat(polygonArrayTemp[i].components);\n                } else {\n                    if (CCWArray.length > 0 && polygonArray.length > 0) {\n                        polygonArray[polygonArray.length - 1].components =\n                            polygonArray[polygonArray.length - 1].components.concat(CCWArray);\n                        CCWArray = [];\n                    }\n                    polygonArray.push(polygonArrayTemp[i]);\n                }\n                if (i == len - 1) {\n                    var polyLength = polygonArray.length;\n                    if (polyLength) {\n                        polygonArray[polyLength - 1].components =\n                            polygonArray[polyLength - 1].components.concat(CCWArray);\n                    } else {\n                        for (let k = 0, length = CCWArray.length; k < length; k++) {\n                            polygonArray.push(new Polygon_Polygon(CCWArray));\n                        }\n                    }\n                }\n            }\n        }\n        return new MultiPolygon_MultiPolygon(polygonArray);\n    }\n\n    /**\n     * @function ServerGeometry.prototype.toGeoRegionEPS\n     * @description 将服务端的面几何对象转换为客户端几何对象。类型为 Polygon。\n     * @returns {Geometry} 转换后的客户端几何对象。\n     */\n    toGeoRegionEPS() {\n        var me = this,\n            geoParts = me.parts || [],\n            geoTopo = me.partTopo || [],\n            geoPoints = me.points || [],\n            len = geoParts.length;\n\n        if (len <= 0) {\n            return null;\n        }\n        var polygonArray = [];\n        var pointList = [];\n        var lineEPS;\n        if (len == 1) {\n            for (var i = 0; i < geoPoints.length; i++) {\n                pointList.push(new geometry_Point_Point(geoPoints[i].x, geoPoints[i].y));\n            }\n\n            lineEPS = LineString_LineString.createLineEPS(pointList);\n            polygonArray.push(new Polygon_Polygon([new LinearRing_LinearRing(lineEPS)]));\n            return new MultiPolygon_MultiPolygon(polygonArray);\n        }\n        //处理复杂面\n        var CCWArray = [];\n        var areaArray = [];\n        var polygonArrayTemp = [];\n        var polygonBounds = [];\n        //polyon岛洞标识数组，初始都是岛。\n        var CCWIdent = [];\n        for (let i = 0, pointIndex = 0; i < len; i++) {\n            for (let j = 0; j < geoParts[i]; j++) {\n                pointList.push(new geometry_Point_Point(geoPoints[pointIndex + j].x, geoPoints[pointIndex + j].y));\n            }\n            pointIndex += geoParts[i];\n\n            lineEPS = LineString_LineString.createLineEPS(pointList);\n            var polygon = new Polygon_Polygon([new LinearRing_LinearRing(lineEPS)]);\n            pointList = [];\n            polygonArrayTemp.push(polygon);\n            if (geoTopo.length === 0) {\n                polygonBounds.push(polygon.getBounds());\n            }\n            CCWIdent.push(1);\n            areaArray.push(polygon.getArea());\n        }\n        //iServer 9D新增字段\n        if (geoTopo.length === 0) {\n            //根据面积排序\n            ServerGeometry_ServerGeometry.bubbleSort(areaArray, polygonArrayTemp, geoTopo, polygonBounds);\n            //岛洞底层判断原则：将所有的子对象按照面积排序，面积最大的直接判定为岛（1），从面积次大的开始处理，\n            // 如果发现该对象在某个面积大于它的对象之中（即被包含），则根据包含它的对象的标识（1 or -1），指定其标识（-1 or 1），\n            // 依次处理完所有对象，就得到了一个标识数组，1表示岛，-1表示洞\n            //目标polygon索引列表 -1标示没有被任何polygon包含，\n            var targetArray = [];\n            for (let i = 1; i < polygonArrayTemp.length; i++) {\n                for (let j = i - 1; j >= 0; j--) {\n                    targetArray[i] = -1;\n                    if (polygonBounds[j].containsBounds(polygonBounds[i])) {\n                        CCWIdent[i] = CCWIdent[j] * -1;\n                        if (CCWIdent[i] < 0) {\n                            targetArray[i] = j;\n                        }\n                        break;\n                    }\n                }\n            }\n            for (let i = 0; i < polygonArrayTemp.length; i++) {\n                if (CCWIdent[i] > 0) {\n                    polygonArray.push(polygonArrayTemp[i]);\n                } else {\n                    polygonArray[targetArray[i]].components = polygonArray[targetArray[i]].components.concat(\n                        polygonArrayTemp[i].components\n                    );\n                    //占位\n                    polygonArray.push(\'\');\n                }\n            }\n        } else {\n            polygonArray = new Array();\n            for (let i = 0; i < polygonArrayTemp.length; i++) {\n                if (geoTopo[i] && geoTopo[i] == -1) {\n                    CCWArray = CCWArray.concat(polygonArrayTemp[i].components);\n                } else {\n                    if (CCWArray.length > 0 && polygonArray.length > 0) {\n                        polygonArray[polygonArray.length - 1].components =\n                            polygonArray[polygonArray.length - 1].components.concat(CCWArray);\n                        CCWArray = [];\n                    }\n                    polygonArray.push(polygonArrayTemp[i]);\n                }\n                if (i == len - 1) {\n                    var polyLength = polygonArray.length;\n                    if (polyLength) {\n                        polygonArray[polyLength - 1].components =\n                            polygonArray[polyLength - 1].components.concat(CCWArray);\n                    } else {\n                        for (let k = 0, length = CCWArray.length; k < length; k++) {\n                            polygonArray.push(new Polygon_Polygon(CCWArray));\n                        }\n                    }\n                }\n            }\n        }\n        return new MultiPolygon_MultiPolygon(polygonArray);\n    }\n    transformGeoCompound() {\n        const me = this,\n            geoParts = me.geoParts || [],\n            len = geoParts.length;\n        if (len <= 0) {\n            return null;\n        }\n        const geometryList = [];\n        for (let index = 0; index < len; index++) {\n            const geometry = geoParts[index];\n            geometryList.push(new ServerGeometry_ServerGeometry(geometry).toGeometry());\n        }\n        return new Collection_Collection(geometryList);\n    }\n\n    /**\n     * @function ServerGeometry.prototype.fromJson\n     * @description 将 JSON 对象表示服务端几何对象转换为 ServerGeometry。\n     * @param {Object} jsonObject - 要转换的 JSON 对象。\n     * @returns {ServerGeometry} 转换后的 ServerGeometry 对象。\n     */\n    static fromJson(jsonObject) {\n        if (!jsonObject) {\n            return;\n        }\n        return new ServerGeometry_ServerGeometry({\n            id: jsonObject.id,\n            style: ServerStyle_ServerStyle.fromJson(jsonObject.style),\n            parts: jsonObject.parts,\n            partTopo: jsonObject.partTopo,\n            points: jsonObject.points,\n            center: jsonObject.center,\n            length: jsonObject.length,\n            maxM: jsonObject.maxM,\n            minM: jsonObject.minM,\n            type: jsonObject.type\n        });\n    }\n\n    /**\n     * @function ServerGeometry.prototype.fromGeometry\n     * @description 将客户端 Geometry 转换成服务端 ServerGeometry。\n     * @param {Geometry} geometry - 要转换的客户端 Geometry 对象。\n     * @returns {ServerGeometry} 转换后的 ServerGeometry 对象。\n     */\n    static fromGeometry(geometry) {\n        if (!geometry) {\n            return;\n        }\n        var id = 0,\n            parts = [],\n            points = [],\n            type = null,\n            icomponents = geometry.components,\n            className = geometry.CLASS_NAME,\n            prjCoordSys = { epsgCode: geometry.SRID };\n\n        if (!isNaN(geometry.id)) {\n            id = geometry.id;\n        }\n        //坑爹的改法，没法，为了支持态势标绘，有时间就得全改\n        if (\n            className != \'SuperMap.Geometry.LinearRing\' &&\n            className != \'SuperMap.Geometry.LineString\' &&\n            (geometry instanceof MultiPoint_MultiPoint || geometry instanceof MultiLineString_MultiLineString)\n        ) {\n            let ilen = icomponents.length;\n            for (let i = 0; i < ilen; i++) {\n                const vertices = icomponents[i].getVertices();\n                let partPointsCount = vertices.length;\n                parts.push(partPointsCount);\n                for (let j = 0; j < partPointsCount; j++) {\n                    points.push(new geometry_Point_Point(vertices[j].x, vertices[j].y));\n                }\n            }\n            //这里className不是多点就全部是算线\n            type = className == \'SuperMap.Geometry.MultiPoint\' ? GeometryType.POINT : GeometryType.LINE;\n        } else if (geometry instanceof MultiPolygon_MultiPolygon) {\n            let ilen = icomponents.length;\n            for (let i = 0; i < ilen; i++) {\n                let polygon = icomponents[i],\n                    linearRingOfPolygon = polygon.components,\n                    linearRingOfPolygonLen = linearRingOfPolygon.length;\n                for (let j = 0; j < linearRingOfPolygonLen; j++) {\n                    const vertices = linearRingOfPolygon[j].getVertices();\n                    const partPointsCount = vertices.length + 1;\n                    parts.push(partPointsCount);\n                    for (let k = 0; k < partPointsCount - 1; k++) {\n                        points.push(new geometry_Point_Point(vertices[k].x, vertices[k].y));\n                    }\n                    points.push(\n                        new geometry_Point_Point(vertices[0].x, vertices[0].y)\n                    );\n                }\n            }\n            type = GeometryType.REGION;\n        } else if (geometry instanceof Polygon_Polygon) {\n            let ilen = icomponents.length;\n            for (let i = 0; i < ilen; i++) {\n                const vertices = icomponents[i].getVertices();\n                let partPointsCount = vertices.length + 1;\n                parts.push(partPointsCount);\n                for (let j = 0; j < partPointsCount - 1; j++) {\n                  points.push(new geometry_Point_Point(vertices[j].x, vertices[j].y));\n                }\n                points.push(new geometry_Point_Point(vertices[0].x, vertices[0].y));\n            }\n            type = GeometryType.REGION;\n        } else {\n            const vertices = geometry.getVertices();\n            let geometryVerticesCount = vertices.length;\n            for (let j = 0; j < geometryVerticesCount; j++) {\n                points.push(new geometry_Point_Point(vertices[j].x, vertices[j].y));\n            }\n            if (geometry instanceof LinearRing_LinearRing) {\n                points.push(new geometry_Point_Point(vertices[0].x, vertices[0].y));\n                geometryVerticesCount++;\n            }\n            parts.push(geometryVerticesCount);\n            type = geometry instanceof geometry_Point_Point ? GeometryType.POINT : GeometryType.LINE;\n        }\n\n        return new ServerGeometry_ServerGeometry({\n            id: id,\n            style: null,\n            parts: parts,\n            points: points,\n            type: type,\n            prjCoordSys: prjCoordSys\n        });\n    }\n\n    /**\n     * @function ServerGeometry.prototype.IsClockWise\n     * @description 判断 linearRing 中的点的顺序。返回值大于 0，逆时针；小于 0，顺时针。\n     * @param {Geometry} geometry - 要转换的客户端 Geometry 对象。\n     * @returns {number} 返回值大于 0，逆时针；小于 0，顺时针。\n     */\n    static IsClockWise(points) {\n        var length = points.length;\n        if (length < 3) {\n            return 0.0;\n        }\n        var s = points[0].y * (points[length - 1].x - points[1].x);\n        points.push(points[0]);\n        for (var i = 1; i < length; i++) {\n            s += points[i].y * (points[i - 1].x - points[i + 1].x);\n        }\n        return s * 0.5;\n    }\n\n    static bubbleSort(areaArray, pointList, geoTopo, polygonBounds) {\n        for (var i = 0; i < areaArray.length; i++) {\n            for (var j = 0; j < areaArray.length; j++) {\n                if (areaArray[i] > areaArray[j]) {\n                    var d = areaArray[j];\n                    areaArray[j] = areaArray[i];\n                    areaArray[i] = d;\n                    var b = pointList[j];\n                    pointList[j] = pointList[i];\n                    pointList[i] = b;\n                    if (geoTopo && geoTopo.length > 0) {\n                        var c = geoTopo[j];\n                        geoTopo[j] = geoTopo[i];\n                        geoTopo[i] = c;\n                    }\n                    if (polygonBounds && polygonBounds.length > 0) {\n                        var f = polygonBounds[j];\n                        polygonBounds[j] = polygonBounds[i];\n                        polygonBounds[i] = f;\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/Feature.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n/**\n * @class Feature\n * @deprecatedclass SuperMap.Feature\n * @category BaseTypes Geometry\n * @classdesc 要素类组合了地理和属性，Feature 类同时具有 marker 和 lonlat 属性。\n * @param {SuperMap.Layer} layer - 图层。\n * @param {LonLat} lonlat - 经纬度。\n * @param {Object} data - 数据对象。\n * @usage\n */\nclass Feature_Feature {\n\n\n    constructor(layer, lonlat, data) {\n        this.CLASS_NAME = "SuperMap.Feature";\n        /**\n         * @deprecated\n         * @member {SuperMap.Layer} Feature.prototype.layer\n         * @description 图层。\n         */\n        this.layer = layer;\n\n        /**\n         * @member {string} Feature.prototype.id\n         * @description 要素 ID。\n         */\n        this.id = Util.createUniqueID(this.CLASS_NAME + "_");\n\n        /**\n         * @member {LonLat} Feature.prototype.lonlat\n         * @description 经纬度。\n         *\n         */\n        this.lonlat = lonlat;\n\n        /**\n         * @member {Object} Feature.prototype.data\n         * @description 数据对象。\n         */\n        this.data = (data != null) ? data : {};\n\n    }\n\n    /**\n     * @function Feature.prototype.destroy\n     * @description 释放相关资源。\n     */\n    destroy() {\n        this.id = null;\n        this.lonlat = null;\n        this.data = null;\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/commontypes/Vector.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n/**\n * @class FeatureVector\n * @aliasclass Feature.Vector\n * @deprecatedclass SuperMap.Feature.Vector\n * @category BaseTypes Geometry\n * @classdesc 矢量要素类。该类具有 Geometry 属性存放几何信息，\n * attributes 属性存放非几何信息，另外还包含了 style 属性，用来定义矢量要素的样式，\n * 其中，默认的样式在 {@link FeatureVector.style} 类中定义，如果没有特别的指定将使用默认的样式。\n * @extends {Feature}\n * @param {Geometry} geometry - 要素的几何信息。\n * @param {Object} [attributes] - 描述要素的任意的可序列化属性，将要映射到 attributes 属性中的对象。\n * @param {Object} [style] - 样式对象。\n * @example\n * var geometry = new GeometryPoint(-115,10);\n *  var style = {\n     *      strokeColor:"#339933",\n     *      strokeOpacity:1,\n     *      strokeWidth:3,\n     *      pointRadius:6\n     *  }\n *  var pointFeature = new FeatureVector(geometry,null,style);\n *  vectorLayer.addFeatures(pointFeature);\n * @usage\n */\n// TRASH THIS\nconst State = {\n  /** states */\n  UNKNOWN: \'Unknown\',\n  INSERT: \'Insert\',\n  UPDATE: \'Update\',\n  DELETE: \'Delete\'\n};\nclass Vector_Vector extends Feature_Feature {\n\n\n    constructor(geometry, attributes, style) {\n        super(null, null, attributes);\n        /**\n         * @member {string} FeatureVector.prototype.fid\n         * @description fid\n         */\n        this.fid = null;\n\n        /**\n         * @member {Geometry} FeatureVector.prototype.geometry\n         * @description 存放几何信息。\n         */\n        this.geometry = geometry ? geometry : null;\n\n        /**\n         * @member {Object} FeatureVector.prototype.attributes\n         * @description 描述要素的任意的可序列化属性。\n         */\n        this.attributes = {};\n\n        if (attributes) {\n            this.attributes = Util.extend(this.attributes, attributes);\n        }\n\n        /**\n         * @member {Bounds} FeatureVector.prototype.bounds\n         * @description 限制要素几何的边界。\n         */\n        this.bounds = null;\n\n        /**\n         * @member {string} FeatureVector.prototype.state\n         * @description state\n         */\n        this.state = null;\n\n        /**\n         * @member {Object} FeatureVector.prototype.style\n         * @description 要素的样式属性，地图查询返回的 feature 的 style，8C 变为null。\n         */\n        this.style = style ? style : null;\n\n        /**\n         * @member {string} FeatureVector.prototype.url\n         * @description 如果设置了这个属性，在更新或者删除要素时需要考虑 {@link HTTP} 。\n         */\n        this.url = null;\n\n        this.lonlat = null;\n\n        this.CLASS_NAME = "SuperMap.Feature.Vector";\n\n        Vector_Vector.style = {\n            \'default\': {\n                fillColor: "#ee9900",\n                fillOpacity: 0.4,\n                hoverFillColor: "white",\n                hoverFillOpacity: 0.8,\n                strokeColor: "#ee9900",\n                strokeOpacity: 1,\n                strokeWidth: 1,\n                strokeLinecap: "round",\n                strokeDashstyle: "solid",\n                hoverStrokeColor: "red",\n                hoverStrokeOpacity: 1,\n                hoverStrokeWidth: 0.2,\n                pointRadius: 6,\n                hoverPointRadius: 1,\n                hoverPointUnit: "%",\n                pointerEvents: "visiblePainted",\n                cursor: "inherit",\n                fontColor: "#000000",\n                labelAlign: "cm",\n                labelOutlineColor: "white",\n                labelOutlineWidth: 3\n            },\n            \'select\': {\n                fillColor: "blue",\n                fillOpacity: 0.4,\n                hoverFillColor: "white",\n                hoverFillOpacity: 0.8,\n                strokeColor: "blue",\n                strokeOpacity: 1,\n                strokeWidth: 2,\n                strokeLinecap: "round",\n                strokeDashstyle: "solid",\n                hoverStrokeColor: "red",\n                hoverStrokeOpacity: 1,\n                hoverStrokeWidth: 0.2,\n                pointRadius: 6,\n                hoverPointRadius: 1,\n                hoverPointUnit: "%",\n                pointerEvents: "visiblePainted",\n                cursor: "pointer",\n                fontColor: "#000000",\n                labelAlign: "cm",\n                labelOutlineColor: "white",\n                labelOutlineWidth: 3\n\n            },\n            \'temporary\': {\n                fillColor: "#66cccc",\n                fillOpacity: 0.2,\n                hoverFillColor: "white",\n                hoverFillOpacity: 0.8,\n                strokeColor: "#66cccc",\n                strokeOpacity: 1,\n                strokeLinecap: "round",\n                strokeWidth: 2,\n                strokeDashstyle: "solid",\n                hoverStrokeColor: "red",\n                hoverStrokeOpacity: 1,\n                hoverStrokeWidth: 0.2,\n                pointRadius: 6,\n                hoverPointRadius: 1,\n                hoverPointUnit: "%",\n                pointerEvents: "visiblePainted",\n                //cursor:"inherit",\n                cursor: "default",\n                fontColor: "#000000",\n                labelAlign: "cm",\n                labelOutlineColor: "white",\n                labelOutlineWidth: 3\n\n            },\n            \'delete\': {\n                display: "none"\n            }\n        };\n    }\n\n    /**\n     * @function FeatureVector.prototype.destroy\n     * @description 释放资源，将引用资源的属性置空。\n     */\n    destroy() {\n        if (this.layer) {\n            this.layer.removeFeatures(this);\n            this.layer = null;\n        }\n\n        this.geometry = null;\n        super.destroy();\n    }\n\n    /**\n     * @function FeatureVector.prototype.clone\n     * @description 复制矢量要素，并返回复制后的新对象。\n     * @returns {FeatureVector} 相同要素的新的矢量要素。\n     */\n    clone() {\n        return new Vector_Vector(\n            this.geometry ? this.geometry.clone() : null,\n            this.attributes,\n            this.style);\n    }\n\n    /**\n     * @function FeatureVector.prototype.toState\n     * @description 设置新状态。\n     * @param {string} state - 状态。\n     */\n    toState(state) {\n        if (state === State.UPDATE) {\n            switch (this.state) {\n                case State.UNKNOWN:\n                case State.DELETE:\n                    this.state = state;\n                    break;\n                case State.UPDATE:\n                case State.INSERT:\n                    break;\n            }\n        } else if (state === State.INSERT) {\n            switch (this.state) {\n                case State.UNKNOWN:\n                    break;\n                default:\n                    this.state = state;\n                    break;\n            }\n        } else if (state === State.DELETE) {\n            switch (this.state) {\n                case State.INSERT:\n                    // the feature should be destroyed\n                    break;\n                case State.DELETE:\n                    break;\n                case State.UNKNOWN:\n                case State.UPDATE:\n                    this.state = state;\n                    break;\n            }\n        } else if (state === State.UNKNOWN) {\n            this.state = state;\n        }\n    }\n}\n/**\n *\n * @typedef {Object} FeatureVector.style\n * @description Feature 有大量的样式属性，如果没有特别的指定将使用默认的样式，\n * 大部分样式通过 SVG 标准定义属性。\n * - fill properties 资料介绍：{@link http://www.w3.org/TR/SVG/painting.html#FillProperties}\n * - stroke properties 资料介绍：{@link http://www.w3.org/TR/SVG/painting.html#StrokeProperties}\n * @property {boolean} [fill] - 不需要填充则设置为 false。\n * @property {string} [fillColor=\'#ee9900\'] - 十六进制填充颜色。\n * @property {number} [fillOpacity=0.4] - 填充不透明度。\n * @property {boolean} [stroke] - 不需要描边则设为 false。\n * @property {string} [strokeColor=\'#ee9900\'] - 十六进制描边颜色。\n * @property {number} [strokeOpacity=0.4] - 描边的不透明度(0-1)。\n * @property {number} [strokeWidth=1] - 像素描边宽度。\n * @property {string} [strokeLinecap=\'round\'] - strokeLinecap 有三种类型 butt，round，square。\n * @property {string} [strokeDashstyle=\'solid\'] - 有 dot，dash，dashdot，longdash，longdashdot，solid 几种样式。\n * @property {boolean} [graphic] - 不需要则设置为 false。\n * @property {number} [pointRadius=6] - 像素点半径。\n * @property {string} [pointerEvents=\'visiblePainted\'] - pointerEvents。\n * @property {string} [cursor] - cursor。\n * @property {boolean} [allowRotate=\'false\'] - 是否允许图标随着运行方向旋转。用于时空数据图层。\n * @property {string} [externalGraphic] - 连接到用来渲染点的外部的图形。\n * @property {number} [graphicWidth] - 外部图表的像素宽度。\n * @property {number} [graphicHeight] - 外部图表的高宽度。\n * @property {number} [graphicOpacity] - 外部图表的不透明度(0-1)。\n * @property {number} [graphicXOffset] - 外部图表沿着x方向的偏移量。\n * @property {number} [graphicYOffset] - 外部图表沿着y方向的偏移量 Pixel。\n * @property {number} [rotation] - 一个图表沿着其中心点（或者偏移中心指定点）在顺时针方向旋转。\n * @property {number} [graphicZIndex] - 渲染时使用的索引值。\n * @property {string} [graphicName=\'circle\'] - 渲染点时图标使用的名字。支持"circle" , "square", "star", "x", "cross", "triangle"。\n * @property {string} [graphicTitle] - 外部图表的提示框。\n * @property {string} [backgroundGraphic] - 外部图表的背景。\n * @property {number} [backgroundGraphicZIndex] - 背景图渲染时使用的索引值。\n * @property {number} [backgroundXOffset] - 背景图在 x 轴的偏移量。\n * @property {number} [backgroundYOffset] - 背景图在 y 轴的偏移量。\n * @property {number} [backgroundHeight] - 背景图的高度。如果没有设置，将用 graphicHeight。\n * @property {number} [backgroundWidth] - 背景图的宽度。如果没有设置，将用 graphicWidth。\n * @property {boolean} [isUnicode=false] - 这个属性要配合 label 属性来用，当为 true时，label 就可以使用 unicode 编码，\n * 比如 "a" 的 unicode 十六进制编码为 61，则 label 属性可以为 "&#x61;",其中 "&#" 为前缀，标志这个为 unicode 编码，\n * "x" 是指 16 进制,这时页面显示的是 "a"；当此值为 false 的时候，label 的内容会被直接输出，\n * 比如，label 为 "&#x61;"，这时页面显示的也是 "&#x61;"。\n * @property {string} [label] - 可选的标签文本。\n * @property {string} [labelAlign=\'cm\'] - 标签对齐，是由两个字符组成的字符串，如："lt", "cm", "rb"，\n * 其中第一个字符代表水平方向上的对齐，"l"=left, "c"=center, "r"=right；\n * 第二个字符代表垂直方向上的对齐，"t"=top, "m"=middle, "b"=bottom。\n * @property {number} [labelXOffset] - 标签在 x 轴方向的偏移量。\n * @property {number} [labelYOffset] - 标签在 y 轴方向的偏移量。\n * @property {boolean} [labelSelect=false] - 如果设为 true，标签可以选用 SelectFeature 或者 similar 控件。\n * @property {string} [fontColor=\'#000000\'] - 标签字体颜色。\n * @property {number} [fontOpacity] - 标签透明度 (0-1)。\n * @property {string} [fontFamily] - 标签的字体类型。\n * @property {string} [fontSize] - 标签的字体大小。\n * @property {string} [fontStyle] - 标签的字体样式。\n * @property {string} [fontWeight] - 标签的字体粗细。\n * @property {string} [display] - 如果 display 属性设置为 “none”，符号将没有任何效果。\n * @example\n *  // label的用法如下：\n *  function addGeoTest(){\n *  var geometry = new GeometryPoint(105, 35);\n *  var pointFeature = new FeatureVector(geometry);\n *  var styleTest = {\n *        label:"supermap",\n *        fontColor:"#0000ff",\n *        fontOpacity:"0.5",\n *        fontFamily:"隶书",\n *        fontSize:"8em",\n *        fontWeight:"bold",\n *        fontStyle:"italic",\n *        labelSelect:"true",\n *     }\n *           pointFeature.style = styleTest;\n *          vectorLayer.addFeatures([pointFeature]);\n * }\n     */\n\n\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/format/Format.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n/**\n * @class Format\n * @deprecatedclass SuperMap.Format\n * @classdesc 读写各种格式的格式类基类。其子类应该包含并实现 read 和 write 方法。\n * @category BaseTypes Format\n * @param {Object} options - 可选参数。\n * @param {boolean} [options.keepData=false] - 如果设置为 true， data 属性会指向被解析的对象（例如 JSON 或 xml 数据对象）。\n * @param {Object} [options.data] - 当 keepData 属性设置为 true，这是传递给 read 操作的要被解析的字符串。\n * @usage\n */\nclass Format_Format {\n\n\n    constructor(options) {\n        /**\n         * @member {Object} Format.prototype.data\n         * @description 当 keepData 属性设置为 true，这是传递给 read 操作的要被解析的字符串。\n         */\n        this.data = null;\n\n        /**\n         * @member {Object} [Format.prototype.keepData=false]\n         * @description 保持最近读到的数据的引用（通过 data 属性）。\n         */\n        this.keepData = false;\n\n        Util.extend(this, options);\n        this.options = options;\n\n        this.CLASS_NAME = "SuperMap.Format";\n    }\n\n    /**\n     * @function Format.prototype.destroy\n     * @description 销毁该格式类，释放相关资源。\n     */\n    destroy() {\n        //用来销毁该格式类，释放相关资源\n    }\n\n    /**\n     * @function Format.prototype.read\n     * @description 来从字符串中读取数据。\n     * @param {string} data - 读取的数据。\n     */\n    read(data) { // eslint-disable-line no-unused-vars\n        //用来从字符串中读取数据\n    }\n\n    /**\n     * @function Format.prototype.write\n     * @description 将对象写成字符串。\n     * @param {Object} object - 可序列化的对象。\n     * @returns {string} 对象转化后的字符串。\n     */\n    write(object) { // eslint-disable-line no-unused-vars\n        //用来写字符串\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/format/JSON.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n/**\n * @class JSONFormat\n * @aliasclass Format.JSON\n * @deprecatedclass SuperMap.Format.JSON\n * @classdesc 安全的读写 JSON 的解析类。使用 {@link JSONFormat} 构造函数创建新实例。\n * @category BaseTypes Format\n * @param {Object} [options] - 可选参数。\n * @param {string} [options.indent="    "] - 用于格式化输出，indent 字符串会在每次缩进的时候使用一次。\n * @param {string} [options.space=" "] - 用于格式化输出，space 字符串会在名值对的 ":" 后边添加。\n * @param {string} [options.newline="\\n"] - 用于格式化输出, newline 字符串会用在每一个名值对或数组项末尾。\n * @param {number} [options.level=0] - 用于格式化输出, 表示的是缩进级别。\n * @param {boolean} [options.pretty=false] - 是否在序列化的时候使用额外的空格控制结构。在 write 方法中使用。\n * @param {boolean} [options.nativeJSON] - 需要被注册的监听器对象。\n * @extends {Format}\n * @usage\n */\nclass JSON_JSONFormat extends Format_Format {\n\n    constructor(options) {\n        super(options);\n        /**\n         * @member {string} [JSONFormat.prototype.indent="    "]\n         * @description 用于格式化输出，indent 字符串会在每次缩进的时候使用一次。\n         */\n        this.indent = "    ";\n\n        /**\n         * @member {string} [JSONFormat.prototype.space=" "]\n         * @description 用于格式化输出，space 字符串会在名值对的 ":" 后边添加。\n         */\n        this.space = " ";\n\n        /**\n         * @member {string} [JSONFormat.prototype.newline="\\n"]\n         * @description 用于格式化输出, newline 字符串会用在每一个名值对或数组项末尾。\n         */\n        this.newline = "\\n";\n\n        /**\n         * @member {number} [JSONFormat.prototype.level=0]\n         * @description 用于格式化输出, 表示的是缩进级别。\n         */\n        this.level = 0;\n\n        /**\n         * @member {boolean} [JSONFormat.prototype.pretty=false]\n         * @description 是否在序列化的时候使用额外的空格控制结构。在 write 方法中使用。\n         */\n        this.pretty = false;\n\n        /**\n         * @member {boolean} JSONFormat.prototype.nativeJSON\n         * @description 判断浏览器是否原生支持 JSON 格式数据。\n         */\n        this.nativeJSON = (function () {\n            return !!(window.JSON && typeof JSON.parse === "function" && typeof JSON.stringify === "function");\n        })();\n\n        this.CLASS_NAME = "SuperMap.Format.JSON";\n        /**\n         * @member JSONFormat.prototype.serialize\n         * @description 提供一些类型对象转 JSON 字符串的方法。\n         */\n        this.serialize = {\n            /**\n             * @function JSONFormat.serialize.object\n             * @description 把对象转换为 JSON 字符串。\n             * @param {Object} object - 可序列化的对象。\n             * @returns {string} JSON 字符串。\n             */\n            \'object\': function (object) {\n                // three special objects that we want to treat differently\n                if (object == null) {\n                    return "null";\n                }\n                if (object.constructor === Date) {\n                    return this.serialize.date.apply(this, [object]);\n                }\n                if (object.constructor === Array) {\n                    return this.serialize.array.apply(this, [object]);\n                }\n                var pieces = [\'{\'];\n                this.level += 1;\n                var key, keyJSON, valueJSON;\n\n                var addComma = false;\n                for (key in object) {\n                    if (object.hasOwnProperty(key)) {\n                        // recursive calls need to allow for sub-classing\n                        keyJSON = this.write.apply(this,\n                            [key, this.pretty]);\n                        valueJSON = this.write.apply(this,\n                            [object[key], this.pretty]);\n                        if (keyJSON != null && valueJSON != null) {\n                            if (addComma) {\n                                pieces.push(\',\');\n                            }\n                            pieces.push(this.writeNewline(), this.writeIndent(),\n                                keyJSON, \':\', this.writeSpace(), valueJSON);\n                            addComma = true;\n                        }\n                    }\n                }\n\n                this.level -= 1;\n                pieces.push(this.writeNewline(), this.writeIndent(), \'}\');\n                return pieces.join(\'\');\n            },\n\n            /**\n             * @function JSONFormat.serialize.array\n             * @description 把数组转换成 JSON 字符串。\n             * @param {Array} array - 可序列化的数组。\n             * @returns {string} JSON 字符串。\n             */\n            \'array\': function (array) {\n                var json;\n                var pieces = [\'[\'];\n                this.level += 1;\n\n                for (var i = 0, len = array.length; i < len; ++i) {\n                    // recursive calls need to allow for sub-classing\n                    json = this.write.apply(this,\n                        [array[i], this.pretty]);\n                    if (json != null) {\n                        if (i > 0) {\n                            pieces.push(\',\');\n                        }\n                        pieces.push(this.writeNewline(), this.writeIndent(), json);\n                    }\n                }\n\n                this.level -= 1;\n                pieces.push(this.writeNewline(), this.writeIndent(), \']\');\n                return pieces.join(\'\');\n            },\n\n            /**\n             * @function JSONFormat.serialize.string\n             * @description 把字符串转换成 JSON 字符串。\n             * @param {string} string - 可序列化的字符串。\n             * @returns {string} JSON 字符串。\n             */\n            \'string\': function (string) {\n                // If the string contains no control characters, no quote characters, and no\n                // backslash characters, then we can simply slap some quotes around it.\n                // Otherwise we must also replace the offending characters with safe\n                // sequences.\n                var m = {\n                    \'\\b\': \'\\\\b\',\n                    \'\\t\': \'\\\\t\',\n                    \'\\n\': \'\\\\n\',\n                    \'\\f\': \'\\\\f\',\n                    \'\\r\': \'\\\\r\',\n                    \'"\': \'\\\\"\',\n                    \'\\\\\': \'\\\\\\\\\'\n                };\n                /*eslint-disable no-control-regex*/\n                if (/["\\\\\\x00-\\x1f]/.test(string)) {\n                    return \'"\' + string.replace(/([\\x00-\\x1f\\\\"])/g, function (a, b) {\n                        var c = m[b];\n                        if (c) {\n                            return c;\n                        }\n                        c = b.charCodeAt();\n                        return \'\\\\u00\' +\n                            Math.floor(c / 16).toString(16) +\n                            (c % 16).toString(16);\n                    }) + \'"\';\n                }\n                return \'"\' + string + \'"\';\n            },\n\n            /**\n             * @function JSONFormat.serialize.number\n             * @description 把数字转换成 JSON 字符串。\n             * @param {number} number - 可序列化的数字。\n             * @returns {string} JSON 字符串。\n             */\n            \'number\': function (number) {\n                return isFinite(number) ? String(number) : "null";\n            },\n\n            /**\n             * @function JSONFormat.serialize.boolean\n             * @description Transform a boolean into a JSON string.\n             * @param {boolean} bool - The boolean to be serialized.\n             * @returns {string} A JSON string representing the boolean.\n             */\n            \'boolean\': function (bool) {\n                return String(bool);\n            },\n\n            /**\n             * @function JSONFormat.serialize.object\n             * @description 将日期对象转换成 JSON 字符串。\n             * @param {Date} date - 可序列化的日期对象。\n             * @returns {string} JSON 字符串。\n             */\n            \'date\': function (date) {\n                function format(number) {\n                    // Format integers to have at least two digits.\n                    return (number < 10) ? \'0\' + number : number;\n                }\n\n                return \'"\' + date.getFullYear() + \'-\' +\n                    format(date.getMonth() + 1) + \'-\' +\n                    format(date.getDate()) + \'T\' +\n                    format(date.getHours()) + \':\' +\n                    format(date.getMinutes()) + \':\' +\n                    format(date.getSeconds()) + \'"\';\n            }\n        };\n    }\n\n    /**\n     * @function JSONFormat.prototype.read\n     * @description 将一个符合 JSON 结构的字符串进行解析。\n     * @param {string} json - 符合 JSON 结构的字符串。\n     * @param {function} filter - 过滤方法，最终结果的每一个键值对都会调用该过滤方法，并在对应的值的位置替换成该方法返回的值。\n     * @returns {(Object|string|Array|number|boolean)} 对象，数组，字符串或数字。\n     */\n    read(json, filter) {\n        var object;\n        if (this.nativeJSON) {\n            try {\n                object = JSON.parse(json, filter);\n            } catch (e) {\n                // Fall through if the regexp test fails.\n            }\n        }\n\n        if (this.keepData) {\n            this.data = object;\n        }\n\n        return object;\n    }\n\n    /**\n     * @function JSONFormat.prototype.write\n     * @description 序列化一个对象到一个符合 JSON 格式的字符串。\n     * @param {Object|string|Array|number|boolean} value - 需要被序列化的对象，数组，字符串，数字，布尔值。\n     * @param {boolean} [pretty=false] - 是否在序列化的时候使用额外的空格控制结构。在 write 方法中使用。\n     * @returns {string} 符合 JSON 格式的字符串。\n     *\n     */\n    write(value, pretty) {\n        this.pretty = !!pretty;\n        var json = null;\n        var type = typeof value;\n        if (this.serialize[type]) {\n            try {\n                json = (!this.pretty && this.nativeJSON) ?\n                    JSON.stringify(value) :\n                    this.serialize[type].apply(this, [value]);\n            } catch (err) {\n                //console.error("Trouble serializing: " + err);\n            }\n        }\n        return json;\n    }\n\n    /**\n     * @function JSONFormat.prototype.writeIndent\n     * @description 根据缩进级别输出一个缩进字符串。\n     * @private\n     * @returns {string} 一个适当的缩进字符串。\n     */\n    writeIndent() {\n        var pieces = [];\n        if (this.pretty) {\n            for (var i = 0; i < this.level; ++i) {\n                pieces.push(this.indent);\n            }\n        }\n        return pieces.join(\'\');\n    }\n\n    /**\n     * @function JSONFormat.prototype.writeNewline\n     * @description 在格式化输出模式情况下输出代表新一行的字符串。\n     * @private\n     * @returns {string} 代表新的一行的字符串。\n     */\n    writeNewline() {\n        return (this.pretty) ? this.newline : \'\';\n    }\n\n    /**\n     * @function JSONFormat.prototype.writeSpace\n     * @private\n     * @description 在格式化输出模式情况下输出一个代表空格的字符串。\n     * @returns {string} 空格字符串。\n     */\n    writeSpace() {\n        return (this.pretty) ? this.space : \'\';\n    }\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/format/GeoJSON.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\n * This program are made available under the terms of the Apache License, Version 2.0\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @class GeoJSONFormat\n * @aliasclass Format.GeoJSON\n * @deprecatedclass SuperMap.Format.GeoJSON\n * @classdesc  GeoJSON 的读和写。使用 {@link GeoJSONObject} 构造器创建一个 GeoJSON 解析器。\n * @category BaseTypes Format\n * @param {Object} [options] - 可选参数。\n * @param {string} [options.indent="    "] - 用于格式化输出，indent 字符串会在每次缩进的时候使用一次。\n * @param {string} [options.space=" "] - 用于格式化输出，space 字符串会在名值对的 ":" 后边添加。\n * @param {string} [options.newline="\\n"] - 用于格式化输出, newline 字符串会用在每一个名值对或数组项末尾。\n * @param {number} [options.level=0] - 用于格式化输出, 表示的是缩进级别。\n * @param {boolean} [options.pretty=false] - 是否在序列化的时候使用额外的空格控制结构。在 write 方法中使用。\n * @param {boolean} [options.nativeJSON] - 需要被注册的监听器对象。\n * @param {boolean} [options.ignoreExtraDims=true] - 忽略维度超过 2 的几何要素。\n * @extends {JSONFormat}\n * @usage\n */\nclass GeoJSON_GeoJSON extends JSON_JSONFormat {\n\n\n    constructor(options) {\n        super(options);\n        /**\n         * @member {boolean} [GeoJSONFormat.prototype.ignoreExtraDims=true]\n         * @description 忽略维度超过 2 的几何要素。\n         */\n        this.ignoreExtraDims = true;\n\n        this.CLASS_NAME = "SuperMap.Format.GeoJSON";\n        /**\n         * @member {Object} GeoJSONFormat.prototype.parseCoords\n         * @private\n         * @description 一个属性名对应着 GeoJSON 对象的几何类型的对象。每个属性其实都是一个实际上做解析用的方法。\n         */\n        this.parseCoords = {\n            /**\n             * @function GeoJSONFormat.parseCoords.point\n             * @description 将一组坐标转成一个 {@link Geometry} 对象。\n             * @param {Object} array - GeoJSON 片段中的一组坐标。\n             * @returns {Geometry} 一个几何对象。\n             */\n            "point": function (array) {\n                if (this.ignoreExtraDims === false &&\n                    array.length != 2) {\n                    throw "Only 2D points are supported: " + array;\n                }\n                return new geometry_Point_Point(array[0], array[1]);\n            },\n\n            /**\n             * @function GeoJSONFormat.parseCoords.multipoint\n             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。\n             * @param {Object} array - GeoJSON 片段中的坐标组数组。\n             * @returns {Geometry} 一个几何对象。\n             */\n            "multipoint": function (array) {\n                var points = [];\n                var p = null;\n                for (var i = 0, len = array.length; i < len; ++i) {\n                    try {\n                        p = this.parseCoords["point"].apply(this, [array[i]]);\n                    } catch (err) {\n                        throw err;\n                    }\n                    points.push(p);\n                }\n                return new MultiPoint_MultiPoint(points);\n            },\n\n            /**\n             * @function GeoJSONFormat.parseCoords.linestring\n             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。\n             * @param {Object} array - GeoJSON 片段中的坐标组数组。\n             * @returns {Geometry} 一个几何对象。\n             */\n            "linestring": function (array) {\n                var points = [];\n                var p = null;\n                for (var i = 0, len = array.length; i < len; ++i) {\n                    try {\n                        p = this.parseCoords["point"].apply(this, [array[i]]);\n                    } catch (err) {\n                        throw err;\n                    }\n                    points.push(p);\n                }\n                return new LineString_LineString(points);\n            },\n\n            /**\n             * @function GeoJSONFormat.parseCoords.multilinestring\n             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。\n             * @param {Object} array - GeoJSON 片段中的坐标组数组。\n             * @returns {Geometry} 一个几何对象。\n             */\n            "multilinestring": function (array) {\n                var lines = [];\n                var l = null;\n                for (var i = 0, len = array.length; i < len; ++i) {\n                    try {\n                        l = this.parseCoords["linestring"].apply(this, [array[i]]);\n                    } catch (err) {\n                        throw err;\n                    }\n                    lines.push(l);\n                }\n                return new MultiLineString_MultiLineString(lines);\n            },\n\n            /**\n             * @function GeoJSONFormat.parseCoords.polygon\n             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。\n             * @returns {Geometry} 一个几何对象。\n             */\n            "polygon": function (array) {\n                var rings = [];\n                var r, l;\n                for (var i = 0, len = array.length; i < len; ++i) {\n                    try {\n                        l = this.parseCoords["linestring"].apply(this, [array[i]]);\n                    } catch (err) {\n                        throw err;\n                    }\n                    r = new LinearRing_LinearRing(l.components);\n                    rings.push(r);\n                }\n                return new Polygon_Polygon(rings);\n            },\n\n            /**\n             * @function GeoJSONFormat.parseCoords.multipolygon\n             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。\n             * @param {Object} array - GeoJSON 片段中的坐标组数组。\n             * @returns {Geometry} 一个几何对象。\n             */\n            "multipolygon": function (array) {\n                var polys = [];\n                var p = null;\n                for (var i = 0, len = array.length; i < len; ++i) {\n                    try {\n                        p = this.parseCoords["polygon"].apply(this, [array[i]]);\n                    } catch (err) {\n                        throw err;\n                    }\n                    polys.push(p);\n                }\n                return new MultiPolygon_MultiPolygon(polys);\n            },\n\n            /**\n             * @function GeoJSONFormat.parseCoords.box\n             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。\n             * @param {Array} array - GeoJSON 片段中的坐标组数组。\n             * @returns {Geometry} 一个几何对象。\n             */\n            "box": function (array) {\n                if (array.length != 2) {\n                    throw "GeoJSON box coordinates must have 2 elements";\n                }\n                return new Polygon_Polygon([\n                    new LinearRing_LinearRing([\n                        new geometry_Point_Point(array[0][0], array[0][1]),\n                        new geometry_Point_Point(array[1][0], array[0][1]),\n                        new geometry_Point_Point(array[1][0], array[1][1]),\n                        new geometry_Point_Point(array[0][0], array[1][1]),\n                        new geometry_Point_Point(array[0][0], array[0][1])\n                    ])\n                ]);\n            }\n\n        };\n        /**\n         * @member {Object} GeoJSONFormat.prototype.extract\n         * @private\n         * @description 一个属性名对应着GeoJSON类型的对象。其值为相应的实际的解析方法。\n         */\n        this.extract = {\n            /**\n             * @function GeoJSONFormat.extract.feature\n             * @description 返回一个表示单个要素对象的 GeoJSON 的一部分。\n             * @param {SuperMap.ServerFeature} feature - iServer 要素对象。\n             * @returns {Object} 一个表示点的对象。\n             */\n            \'feature\': function (feature) {\n                var geom = this.extract.geometry.apply(this, [feature.geometry]);\n                var json = {\n                    "type": "Feature",\n                    "properties": this.createAttributes(feature),\n                    "geometry": geom\n                };\n\n                if (feature.geometry && feature.geometry.type === \'TEXT\') {\n                    json.properties.texts = feature.geometry.texts;\n                    json.properties.textStyle = feature.geometry.textStyle;\n                }\n                if (feature.fid) {\n                    json.id = feature.fid;\n                }\n                if (feature.ID) {\n                    json.id = feature.ID;\n                }\n                return json;\n            },\n\n\n            /**\n             * @function GeoJSONFormat.extract.geometry\n             * @description 返回一个表示单个几何对象的 GeoJSON 的一部分。\n             * @param {Object} geometry - iServer 几何对象。\n             * @returns {Object} 一个表示几何体的对象。\n             */\n            \'geometry\': function (geometry) {\n                if (geometry == null) {\n                    return null;\n                }\n                if (!geometry.parts && geometry.points) {\n                    geometry.parts = [geometry.points.length];\n                }\n                var geo = geometry.hasOwnProperty(\'geometryType\')\n                    ? geometry\n                    : new ServerGeometry_ServerGeometry(geometry).toGeometry() || geometry;\n                var geometryType = geo.geometryType || geo.type;\n                var data;\n                if (geometryType === "LinearRing") {\n                    geometryType = "LineString";\n                }\n                if (geometryType === "LINEM") {\n                    geometryType = "MultiLineString";\n                }\n                data = this.extract[geometryType.toLowerCase()].apply(this, [geo]);\n                geometryType = geometryType === \'TEXT\' ? \'Point\' : geometryType;\n                var json;\n                if (geometryType === "Collection") {\n                    json = {\n                        "type": "GeometryCollection",\n                        "geometries": data\n                    };\n                } else {\n                    json = {\n                        "type": geometryType,\n                        "coordinates": data\n                    };\n                }\n                return json;\n            },\n\n\n            /**\n             * @function GeoJSONFormat.extract.point\n             * @description 从一个点对象中返回一个坐标组。\n             * @param {GeometryPoint} point - 一个点对象。\n             * @returns {Array} 一个表示一个点的坐标组。\n             */\n            \'point\': function (point) {\n                var p = [point.x, point.y];\n                for (var name in point) {\n                    if (name !== "x" && name !== "y" && point[name] !== null && !isNaN(point[name])) {\n                        p.push(point[name]);\n                    }\n                }\n                return p;\n            },\n\n            /**\n             * @function GeoJSONFormat.extract.point\n             * @description 从一个文本对象中返回一个坐标组。\n             * @param {Object} geo - 一个文本对象。\n             * @returns {Array} 一个表示一个点的坐标组。\n             */\n            \'text\': function (geo) {\n                return [geo.points[0].x, geo.points[0].y];\n            },\n\n            /**\n             * @function GeoJSONFormat.extract.multipoint\n             * @description 从一个多点对象中返一个坐标组数组。\n             * @param {GeometryMultiPoint} multipoint - 多点对象。\n             * @returns {Array} 一个表示多点的坐标组数组。\n             */\n            \'multipoint\': function (multipoint) {\n                var array = [];\n                for (var i = 0, len = multipoint.components.length; i < len; ++i) {\n                    array.push(this.extract.point.apply(this, [multipoint.components[i]]));\n                }\n                return array;\n            },\n\n            /**\n             * @function GeoJSONFormat.extract.linestring\n             * @description 从一个线对象中返回一个坐标组数组。\n             * @param {Linestring} linestring - 线对象。\n             * @returns {Array} 一个表示线对象的坐标组数组。\n             */\n            \'linestring\': function (linestring) {\n                var array = [];\n                for (var i = 0, len = linestring.components.length; i < len; ++i) {\n                    array.push(this.extract.point.apply(this, [linestring.components[i]]));\n                }\n                return array;\n            },\n\n            /**\n             * @function GeoJSONFormat.extract.multilinestring\n             * @description 从一个多线对象中返回一个线数组。\n             * @param {GeometryMultiLineString} multilinestring - 多线对象。\n             *\n             * @returns {Array} 一个表示多线的线数组。\n             */\n            \'multilinestring\': function (multilinestring) {\n                var array = [];\n                for (var i = 0, len = multilinestring.components.length; i < len; ++i) {\n                    array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));\n                }\n                return array;\n            },\n\n            /**\n             * @function GeoJSONFormat.extract.polygon\n             * @description 从一个面对象中返回一组线环。\n             * @param {GeometryPolygon} polygon - 面对象。\n             * @returns {Array} 一组表示面的线环。\n             */\n            \'polygon\': function (polygon) {\n                var array = [];\n                for (var i = 0, len = polygon.components.length; i < len; ++i) {\n                    array.push(this.extract.linestring.apply(this, [polygon.components[i]]));\n                }\n                return array;\n            },\n\n            /**\n             * @function GeoJSONFormat.extract.multipolygon\n             * @description 从一个多面对象中返回一组面。\n             * @param {GeometryMultiPolygon} multipolygon - 多面对象。\n             * @returns {Array} 一组表示多面的面。\n             */\n            \'multipolygon\': function (multipolygon) {\n                var array = [];\n                for (var i = 0, len = multipolygon.components.length; i < len; ++i) {\n                    array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));\n                }\n                return array;\n            },\n\n            /**\n             * @function GeoJSONFormat.extract.collection\n             * @description 从一个几何要素集合中一组几何要素数组。\n             * @param {GeometryCollection} collection - 几何要素集合。\n             * @returns {Array} 一组表示几何要素集合的几何要素数组。\n             */\n            \'collection\': function (collection) {\n                var len = collection.components.length;\n                var array = new Array(len);\n                for (var i = 0; i < len; ++i) {\n                    array[i] = this.extract.geometry.apply(this, [collection.components[i]]);\n                }\n                return array;\n            }\n        };\n    }\n\n    /**\n     * @function GeoJSONFormat.prototype.read\n     * @description 将 GeoJSON 对象或者GeoJSON 对象字符串转换为 SuperMap Feature 对象。\n     * @param {GeoJSONObject} json - GeoJSON 对象。\n     * @param {string} [type=\'FeaureCollection\'] - 可选的字符串，它决定了输出的格式。支持的值有："Geometry","Feature"，和 "FeatureCollection"，如果此值为null。\n     * @param {function} filter - 对象中每个层次每个键值对都会调用此函数得出一个结果。每个值都会被 filter 函数的结果所替换掉。这个函数可被用来将某些对象转化成某个类相应的对象，或者将日期字符串转化成Date对象。\n     * @returns {Object}  返回值依赖于 type 参数的值。\n     *     -如果 type 等于 "FeatureCollection"，返回值将会是 {@link FeatureVector} 数组。\n     *     -如果 type 为 "Geometry",输入的 JSON 对象必须表示一个唯一的几何体，然后返回值就会是 {@link Geometry}。\n     *     -如果 type 为 "Feature"，输入的 JSON 对象也必须表示的一个要素，这样返回值才会是 {@link FeatureVector}。\n     */\n\n    read(json, type, filter) {\n        type = (type) ? type : "FeatureCollection";\n        var results = null;\n        var obj = null;\n        if (typeof json == "string") {\n            obj = super.read(json, filter);\n        } else {\n            obj = json;\n        }\n        if (!obj) {\n            //console.error("Bad JSON: " + json);\n        } else if (typeof (obj.type) != "string") {\n            //console.error("Bad GeoJSON - no type: " + json);\n        } else if (this.isValidType(obj, type)) {\n            switch (type) {\n                case "Geometry":\n                    try {\n                        results = this.parseGeometry(obj);\n                    } catch (err) {\n                        //console.error(err);\n                    }\n                    break;\n                case "Feature":\n                    try {\n                        results = this.parseFeature(obj);\n                        results.type = "Feature";\n                    } catch (err) {\n                        //console.error(err);\n                    }\n                    break;\n                case "FeatureCollection":\n                    // for type FeatureCollection, we allow input to be any type\n                    results = [];\n                    switch (obj.type) {\n                        case "Feature":\n                            try {\n                                results.push(this.parseFeature(obj));\n                            } catch (err) {\n                                results = null;\n                                //console.error(err);\n                            }\n                            break;\n                        case "FeatureCollection":\n                            for (var i = 0, len = obj.features.length; i < len; ++i) {\n                                try {\n                                    results.push(this.parseFeature(obj.features[i]));\n                                } catch (err) {\n                                    results = null;\n                                    // console.error(err);\n                                }\n                            }\n                            break;\n                        default:\n                            try {\n                                var geom = this.parseGeometry(obj);\n                                results.push(new Vector_Vector(geom));\n                            } catch (err) {\n                                results = null;\n                                //console.error(err);\n                            }\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        return results;\n    }\n\n    /**\n     * @function GeoJSONFormat.prototype.write\n     * @description iServer Geometry JSON 对象 转 GeoJSON对象字符串。\n     * @param {Object} obj - iServer Geometry JSON 对象。\n     * @param {boolean} [pretty=false] - 是否使用换行和缩进来控制输出。\n     * @returns {GeoJSONObject} 一个 GeoJSON 字符串，它表示了输入的几何对象，要素对象，或者要素对象数组。\n     */\n    write(obj, pretty) {\n        return super.write(this.toGeoJSON(obj), pretty);\n    }\n    /**\n     * @function GeoJSONFormat.prototype.fromGeoJSON\n     * @version 9.1.1\n     * @description 将 GeoJSON 对象或者GeoJSON 对象字符串转换为iServer Feature JSON。\n     * @param {GeoJSONObject} json - GeoJSON 对象。\n     * @param {string} [type=\'FeaureCollection\'] - 可选的字符串，它决定了输出的格式。支持的值有："Geometry","Feature"，和 "FeatureCollection"，如果此值为null。\n     * @param {function} filter - 对象中每个层次每个键值对都会调用此函数得出一个结果。每个值都会被 filter 函数的结果所替换掉。这个函数可被用来将某些对象转化成某个类相应的对象，或者将日期字符串转化成Date对象。\n     * @returns {Object}  iServer Feature JSON。\n     */\n    fromGeoJSON(json, type, filter) {\n        let feature = this.read(json, type, filter);\n        if (!Util.isArray(feature)) {\n            return this._toiSevrerFeature(feature);\n        }\n        return feature.map((element) => {\n            return this._toiSevrerFeature(element);\n        })\n    }\n\n    /**\n     * @function GeoJSONFormat.prototype.toGeoJSON\n     * @version 9.1.1\n     * @description 将 iServer Feature JSON 对象转换为 GeoJSON 对象。\n     * @param {Object} obj - iServer Feature JSON。\n     * @returns {GeoJSONObject}  GeoJSON 对象。\n     */\n    toGeoJSON(obj) {\n        var geojson = {\n            "type": null\n        };\n        if (Util.isArray(obj)) {\n            geojson.type = "FeatureCollection";\n            var numFeatures = obj.length;\n            geojson.features = new Array(numFeatures);\n            for (var i = 0; i < numFeatures; ++i) {\n                var element = obj[i];\n                if (isGeometry(element)) {\n                    let feature = {};\n                    feature.geometry = element;\n                    geojson.features[i] = this.extract.feature.apply(this, [feature]);\n                } else {\n                    geojson.features[i] = this.extract.feature.apply(this, [element]);\n                }\n            }\n        } else if (isGeometry(obj)) {\n            let feature = {};\n            feature.geometry = obj;\n            geojson = this.extract.feature.apply(this, [feature]);\n        } else {\n            geojson = this.extract.feature.apply(this, [obj]);\n        }\n\n        function isGeometry(input) {\n            return (input.hasOwnProperty("parts") && input.hasOwnProperty("points")) || input.hasOwnProperty("geoParts");\n        }\n\n        return geojson;\n\n    }\n    /**\n     *  @function GeoJSONFormat.prototype.isValidType\n     *  @description 检查一个 GeoJSON 对象是否和给定的类型相符的合法的对象。\n     *  @returns {boolean} GeoJSON 是否是给定类型的合法对象。\n     *  @private\n     */\n    isValidType(obj, type) {\n        var valid = false;\n        switch (type) {\n            case "Geometry":\n                if (Util.indexOf(\n                    ["Point", "MultiPoint", "LineString", "MultiLineString",\n                        "Polygon", "MultiPolygon", "Box", "GeometryCollection"\n                    ],\n                    obj.type) == -1) {\n                    // unsupported geometry type\n                    //console.error("Unsupported geometry type: " +\n                    // obj.type);\n                } else {\n                    valid = true;\n                }\n                break;\n            case "FeatureCollection":\n                // allow for any type to be converted to a feature collection\n                valid = true;\n                break;\n            default:\n                // for Feature types must match\n                if (obj.type == type) {\n                    valid = true;\n                } else {\n                    //console.error("Cannot convert types from " +\n                    //obj.type + " to " + type);\n                }\n        }\n        return valid;\n    }\n\n    /**\n     * @function GeoJSONFormat.prototype.parseFeature\n     * @description 将一个 GeoJSON 中的 feature 转化成 {@link FeatureVector}> 对象。\n     * @private\n     * @param {GeoJSONObject} obj - 从 GeoJSON 对象中创建一个对象。\n     * @returns {FeatureVector} 一个要素。\n     */\n    parseFeature(obj) {\n        var feature, geometry, attributes, bbox;\n        attributes = (obj.properties) ? obj.properties : {};\n        bbox = (obj.geometry && obj.geometry.bbox) || obj.bbox;\n        try {\n            geometry = this.parseGeometry(obj.geometry);\n        } catch (err) {\n            // deal with bad geometries\n            throw err;\n        }\n        feature = new Vector_Vector(geometry, attributes);\n        if (bbox) {\n            feature.bounds = Bounds_Bounds.fromArray(bbox);\n        }\n        if (obj.id) {\n            feature.fid = obj.id;\n        }\n        return feature;\n    }\n\n\n    /**\n     * @function GeoJSONFormat.prototype.parseGeometry\n     * @description 将一个 GeoJSON 中的几何要素转化成 {@link Geometry} 对象。\n     * @param {GeoJSONObject} obj - 从 GeoJSON 对象中创建一个对象。\n     * @returns {Geometry} 一个几何要素。\n     * @private\n     */\n    parseGeometry(obj) {\n        if (obj == null) {\n            return null;\n        }\n        var geometry;\n        if (obj.type == "GeometryCollection") {\n            if (!(Util.isArray(obj.geometries))) {\n                throw "GeometryCollection must have geometries array: " + obj;\n            }\n            var numGeom = obj.geometries.length;\n            var components = new Array(numGeom);\n            for (var i = 0; i < numGeom; ++i) {\n                components[i] = this.parseGeometry.apply(\n                    this, [obj.geometries[i]]\n                );\n            }\n            geometry = new Collection_Collection(components);\n        } else {\n            if (!(Util.isArray(obj.coordinates))) {\n                throw "Geometry must have coordinates array: " + obj;\n            }\n            if (!this.parseCoords[obj.type.toLowerCase()]) {\n                throw "Unsupported geometry type: " + obj.type;\n            }\n            try {\n                geometry = this.parseCoords[obj.type.toLowerCase()].apply(\n                    this, [obj.coordinates]\n                );\n            } catch (err) {\n                // deal with bad coordinates\n                throw err;\n            }\n        }\n        return geometry;\n    }\n\n\n    /**\n     * @function GeoJSONFormat.prototype.createCRSObject\n     * @description 从一个要素对象中创建一个坐标参考系对象。\n     * @param {FeatureVector} object - 要素对象。\n     * @private\n     * @returns {GeoJSONObject} 一个可作为 GeoJSON 对象的 CRS 属性使用的对象。\n     */\n    createCRSObject(object) {\n        var proj = object.layer.projection.toString();\n        var crs = {};\n        if (proj.match(/epsg:/i)) {\n            var code = parseInt(proj.substring(proj.indexOf(":") + 1));\n            if (code == 4326) {\n                crs = {\n                    "type": "name",\n                    "properties": {\n                        "name": "urn:ogc:def:crs:OGC:1.3:CRS84"\n                    }\n                };\n            } else {\n                crs = {\n                    "type": "name",\n                    "properties": {\n                        "name": "EPSG:" + code\n                    }\n                };\n            }\n        }\n        return crs;\n    }\n    _toiSevrerFeature(feature) {\n        const attributes = feature.attributes;\n        const attrNames = [];\n        const attrValues = [];\n        for (var attr in attributes) {\n            attrNames.push(attr);\n            attrValues.push(attributes[attr]);\n        }\n        const newFeature = {\n            fieldNames: attrNames,\n            fieldValues: attrValues,\n            geometry: ServerGeometry_ServerGeometry.fromGeometry(feature.geometry)\n        };\n        newFeature.geometry.id = feature.fid;\n        return newFeature;\n    }\n    createAttributes(feature) {\n        if (!feature) {\n            return null;\n        }\n        var attr = {};\n        processFieldsAttributes(feature, attr);\n        var exceptKeys = ["fieldNames", "fieldValues", "geometry", "stringID", "ID"];\n        for (var key in feature) {\n            if (exceptKeys.indexOf(key) > -1) {\n                continue;\n            }\n            attr[key] = feature[key];\n        }\n\n        function processFieldsAttributes(feature, attributes) {\n            if (!(feature.hasOwnProperty("fieldNames") && feature.hasOwnProperty("fieldValues"))) {\n                return;\n            }\n            var names = feature.fieldNames,\n                values = feature.fieldValues;\n            for (var i in names) {\n                attributes[names[i]] = values[i];\n            }\n        }\n\n        return attr;\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-common/util/MapCalculateUtil.js\n\n\n/**\n * @function getMeterPerMapUnit\n * @description 单位换算，把米|度|千米|英寸|英尺换成米。\n * @category BaseTypes Util\n * @param {string} mapUnit 地图单位。\n * @returns {number} 返回地图的距离单位。\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.getMeterPerMapUnit(mapUnit);\n *\n * <\/script>\n *\n * // ES6 Import\n * import { getMeterPerMapUnit } from \'{npm}\';\n *\n * const result = getMeterPerMapUnit(mapUnit);\n * ```\n */\nvar getMeterPerMapUnit = function(mapUnit) {\n    var earchRadiusInMeters = 6378137;\n    var meterPerMapUnit;\n    if (mapUnit === Unit.METER) {\n        meterPerMapUnit = 1;\n    } else if (mapUnit === Unit.DEGREE) {\n        // 每度表示多少米。\n        meterPerMapUnit = (Math.PI * 2 * earchRadiusInMeters) / 360;\n    } else if (mapUnit === Unit.KILOMETER) {\n        meterPerMapUnit = 1.0e-3;\n    } else if (mapUnit === Unit.INCH) {\n        meterPerMapUnit = 1 / 2.5399999918e-2;\n    } else if (mapUnit === Unit.FOOT) {\n        meterPerMapUnit = 0.3048;\n    } else {\n        return meterPerMapUnit;\n    }\n    return meterPerMapUnit;\n};\n\n/**\n * @function getWrapNum\n * @description 获取该坐标系的经纬度范围的经度或纬度。\n * @category BaseTypes Util\n * @param {number} x 经度或纬度。\n * @param {boolean} includeMax 是否获取经度或纬度的最大值。\n * @param {boolean} includeMin 是否获取经度或纬度的最小值。\n * @param {number} range 坐标系的经纬度范围。\n * @returns {number} 返回经度或纬度的值。\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.getWrapNum(x, includeMax, includeMin, range);\n *\n * <\/script>\n *\n * // ES6 Import\n * import { getWrapNum } from \'{npm}\';\n *\n * const result = getWrapNum(x, includeMax, includeMin, range);\n * ```\n */\nfunction getWrapNum(x, includeMax = true, includeMin = true, range = [-180, 180]) {\n    var max = range[1],\n        min = range[0],\n        d = max - min;\n    if (x === max && includeMax) {\n        return x;\n    }\n    if (x === min && includeMin) {\n        return x;\n    }\n    var tmp = (((x - min) % d) + d) % d;\n    if (tmp === 0 && includeMax) {\n        return max;\n    }\n    return ((((x - min) % d) + d) % d) + min;\n}\n\n/**\n * @function conversionDegree\n * @description 转换经纬度。\n * @category BaseTypes Util\n * @param {number} degrees 经度或纬度。\n * @returns {string} 返回度分秒。\n * @usage\n * ```\n * // 浏览器\n * <script type="text/javascript" src="{cdn}"><\/script>\n * <script>\n *   const result = {namespace}.conversionDegree(degrees);\n *\n * <\/script>\n *\n * // ES6 Import\n * import { conversionDegree } from \'{npm}\';\n *\n * const result = conversionDegree(degrees);\n * ```\n */\nfunction conversionDegree(degrees) {\n    const degree = parseInt(degrees);\n    let fraction = parseInt((degrees - degree) * 60);\n    let second = parseInt(((degrees - degree) * 60 - fraction) * 60);\n    fraction = parseInt(fraction / 10) === 0 ? `0${fraction}` : fraction;\n    second = parseInt(second / 10) === 0 ? `0${second}` : second;\n    return `${degree}°${fraction}\'${second}`;\n}\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-leaflet/core/Util.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\r\n * This program are made available under the terms of the Apache License, Version 2.0\r\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\r\n \r\n \r\n \r\n \r\n /**\r\n * @function toGeoJSON\r\n * @category BaseTypes Util\r\n * @description 将传入对象转为 GeoJSON 格式。\r\n * @param {Object} feature - 待转参数。\r\n * @usage\r\n * ```\r\n * // 浏览器\r\n * <script type="text/javascript" src="{cdn}"><\/script>\r\n * <script>\r\n *   const result = {namespace}.Util.toGeoJSON(feature);\r\n *\r\n * <\/script>\r\n *\r\n * // ES6 Import\r\n * import { toGeoJSON } from \'{npm}\';\r\n *\r\n * const result = toGeoJSON(feature);\r\n * ```\r\n */\r\n var toGeoJSON = function(feature) {\r\n    if (!feature) {\r\n        return feature;\r\n    }\r\n    return new GeoJSON_GeoJSON().toGeoJSON(feature);\r\n};\r\n\r\n /**\r\n * @function toSuperMapGeometry\r\n * @category BaseTypes Util\r\n * @description 将 GeoJSON 对象转为 SuperMap 几何图形。\r\n * @param {GeoJSONObject} geometry - GeoJSON 对象。\r\n * @usage\r\n * ```\r\n * // 浏览器\r\n * <script type="text/javascript" src="{cdn}"><\/script>\r\n * <script>\r\n *   const result = {namespace}.Util.toSuperMapGeometry(geometry);\r\n *\r\n * <\/script>\r\n *\r\n * // ES6 Import\r\n * import { toSuperMapGeometry } from \'{npm}\';\r\n *\r\n * const result = toSuperMapGeometry(geometry);\r\n * ```\r\n */\r\nvar toSuperMapGeometry = function(geometry) {\r\n    if (!geometry) {\r\n        return geometry;\r\n    }\r\n    var result,\r\n        format = new GeoJSON_GeoJSON();\r\n    if ([\'FeatureCollection\', \'Feature\', \'Geometry\'].indexOf(geometry.type) != -1) {\r\n        result = format.read(geometry, geometry.type);\r\n    } else if (typeof geometry.toGeoJSON === \'function\') {\r\n        var geojson = geometry.toGeoJSON();\r\n        result = geojson ? format.read(geojson, geojson.type) : geometry;\r\n    }\r\n\r\n    var serverResult = result || geometry;\r\n    if (leaflet_src_default.a.Util.isArray(result)) {\r\n        if (result.length === 1) {\r\n            serverResult = result[0];\r\n        } else if (result.length > 1) {\r\n            serverResult = [];\r\n            result.map(function(item) {\r\n                serverResult.push(item.geometry);\r\n                return item;\r\n            });\r\n        }\r\n    }\r\n\r\n    return serverResult && serverResult.geometry ? serverResult.geometry : serverResult;\r\n};\r\nvar Util_getMeterPerMapUnit = getMeterPerMapUnit;\r\n\r\n\r\n /**\r\n * @function resolutionToScale\r\n * @category BaseTypes Util\r\n * @description 通过分辨率计算比例尺。\r\n * @param {number} resolution - 分辨率。\r\n * @param {number} dpi - 屏幕分辨率。\r\n * @param {string} mapUnit - 地图单位。\r\n * @returns {number} 比例尺。\r\n * @usage\r\n * ```\r\n * // 浏览器\r\n * <script type="text/javascript" src="{cdn}"><\/script>\r\n * <script>\r\n *   const result = {namespace}.Util.resolutionToScale(resolution, dpi, mapUnit);\r\n *\r\n * <\/script>\r\n *\r\n * // ES6 Import\r\n * import { resolutionToScale } from \'{npm}\';\r\n *\r\n * const result = resolutionToScale(resolution, dpi, mapUnit);\r\n * ```\r\n */\r\nvar resolutionToScale = function(resolution, dpi, mapUnit) {\r\n    var inchPerMeter = 1 / 0.0254;\r\n    // 地球半径。\r\n    var meterPerMapUnit = Util_getMeterPerMapUnit(mapUnit);\r\n    var scale = resolution * dpi * inchPerMeter * meterPerMapUnit;\r\n    scale = 1 / scale;\r\n    return scale;\r\n};\r\n\r\n /**\r\n * @function scaleToResolution\r\n * @category BaseTypes Util\r\n * @description 通过比例尺计算分辨率。\r\n * @param {number} scale - 比例尺。\r\n * @param {number} dpi - 屏幕分辨率。\r\n * @param {string} mapUnit - 地图单位。\r\n * @returns {number} 分辨率。\r\n * @usage\r\n * ```\r\n * // 浏览器\r\n * <script type="text/javascript" src="{cdn}"><\/script>\r\n * <script>\r\n *   const result = {namespace}.Util.scaleToResolution(scale, dpi, mapUnit);\r\n *\r\n * <\/script>\r\n *\r\n * // ES6 Import\r\n * import { scaleToResolution } from \'{npm}\';\r\n *\r\n * const result = scaleToResolution(scale, dpi, mapUnit);\r\n * ```\r\n */\r\nvar scaleToResolution = function(scale, dpi, mapUnit) {\r\n    var inchPerMeter = 1 / 0.0254;\r\n    var meterPerMapUnitValue = Util_getMeterPerMapUnit(mapUnit);\r\n    var resolution = scale * dpi * inchPerMeter * meterPerMapUnitValue;\r\n    resolution = 1 / resolution;\r\n    return resolution;\r\n};\r\n\r\n /**\r\n * @function normalizeScale\r\n * @category BaseTypes Util\r\n * @description 转换比例尺。\r\n * @param {number} scale - 比例尺。\r\n * @returns {number} 正常的 scale 值。\r\n * @usage\r\n * ```\r\n * // 浏览器\r\n * <script type="text/javascript" src="{cdn}"><\/script>\r\n * <script>\r\n *   const result = {namespace}.Util.normalizeScale(scale);\r\n *\r\n *  // 弃用的写法\r\n *   const result = L.supermap.Util.NormalizeScale(scale);\r\n *   const result = L.Util.NormalizeScale(scale);\r\n * <\/script>\r\n *\r\n * // ES6 Import\r\n * import { normalizeScale } from \'{npm}\';\r\n *\r\n * const result = normalizeScale(scale);\r\n * ```\r\n */\r\nvar normalizeScale = function(scale) {\r\n  return scale > 1.0 ? 1.0 / scale : scale;\r\n};\r\n\r\n /**\r\n * @function getResolutionFromScaleDpi\r\n * @category BaseTypes Util\r\n * @description 根据比例尺和 dpi 计算屏幕分辨率。\r\n * @param {number} scale - 比例尺。\r\n * @param {number} dpi - 图像分辨率，表示每英寸内的像素个数。\r\n * @param {string} [coordUnit] - 投影坐标系统的地图单位。\r\n * @param {number} [datumAxis=6378137] - 地理坐标系统椭球体长半轴。用户自定义地图的 Options 时，若未指定该参数的值，则 DPI 默认按照 WGS84 参考系的椭球体长半轴 6378137 来计算。\r\n * @returns {number} 当前比例尺下的屏幕分辨率。\r\n * @usage\r\n * ```\r\n * // 浏览器\r\n * <script type="text/javascript" src="{cdn}"><\/script>\r\n * <script>\r\n *   const result = {namespace}.Util.getResolutionFromScaleDpi(scale, dpi, coordUnit, datumAxis);\r\n * \r\n *   // 弃用的写法\r\n *   const result = L.supermap.Util.GetResolutionFromScaleDpi(scale, dpi, coordUnit, datumAxis);\r\n *   const result = L.Util.GetResolutionFromScaleDpi(scale, dpi, coordUnit, datumAxis);\r\n * <\/script>\r\n *\r\n * // ES6 Import\r\n * import { getResolutionFromScaleDpi } from \'{npm}\';\r\n *\r\n * const result = getResolutionFromScaleDpi(scale, dpi, coordUnit, datumAxis);\r\n * ```\r\n */\r\nvar getResolutionFromScaleDpi = function(scale, dpi, coordUnit, datumAxis) {\r\n    var resolution = null,\r\n        ratio = 10000;\r\n    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。\r\n    datumAxis = datumAxis || 6378137;\r\n    coordUnit = coordUnit || \'\';\r\n    if (scale > 0 && dpi > 0) {\r\n        scale = normalizeScale(scale);\r\n        if (\r\n            coordUnit.toLowerCase() === \'degree\' ||\r\n            coordUnit.toLowerCase() === \'degrees\' ||\r\n            coordUnit.toLowerCase() === \'dd\'\r\n        ) {\r\n            //scale = CommonUtil.normalizeScale(scale);\r\n            resolution = (0.0254 * ratio) / dpi / scale / ((Math.PI * 2 * datumAxis) / 360) / ratio;\r\n            return resolution;\r\n        } else {\r\n            resolution = (0.0254 * ratio) / dpi / scale / ratio;\r\n            return resolution;\r\n        }\r\n    }\r\n    return -1;\r\n};\r\n\r\n\n// CONCATENATED MODULE: ./node_modules/@supermap/iclient-leaflet/mapping/TiledMapLayer.js\n/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.\r\n * This program are made available under the terms of the Apache License, Version 2.0\r\n * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n\r\n/**\r\n * @class TiledMapLayer\r\n * @deprecatedclassinstance L.supermap.tiledMapLayer\r\n * @classdesc SuperMap iServer 的 REST 地图服务的图层(SuperMap iServer Java 6R 及以上分块动态 REST 图层)。使用 TileImage 资源出图。\r\n * @category iServer Map Tile\r\n * @extends {L.TileLayer}\r\n * @example\r\n *      new TiledMapLayer(url).addTo(map);\r\n * @param {string} url - 服务地址，例如: http://{ip}:{port}/iserver/services/map-world/rest/maps/World。\r\n * @param {Object} options - 参数。\r\n * @param {string} [options.layersID] - 获取进行切片的地图图层 ID，即指定进行地图切片的图层，可以是临时图层集，也可以是当前地图中图层的组合\r\n * @param {boolean} [options.redirect=false] - 是否重定向，如果为 true，则将请求重定向到瓦片的真实地址；如果为 false，则响应体中是瓦片的字节流。\r\n * @param {boolean} [options.transparent=true] - 是否背景透明。\r\n * @param {boolean} [options.cacheEnabled=true] - 启用缓存。\r\n * @param {boolean} [options.clipRegionEnabled=false] - 是否启用地图裁剪。\r\n * @param {L.Path} [options.clipRegion] - 地图显示裁剪的区域。是一个面对象，当 clipRegionEnabled = true 时有效，即地图只显示该区域覆盖的部分。\r\n * @param {Object} [options.prjCoordSys] - 请求的地图的坐标参考系统。 如：prjCoordSys={"epsgCode":3857}。\r\n * @param {boolean} [options.overlapDisplayed=false] - 地图对象在同一范围内时，是否重叠显示。\r\n * @param {string} [options.overlapDisplayedOptions] - 避免地图对象压盖显示的过滤选项。\r\n * @param {string} [options.tileversion] - 切片版本名称，cacheEnabled 为 true 时有效。如果没有设置 tileversion 参数，而且当前地图的切片集中存在多个版本，则默认使用最后一个更新版本。\r\n * @param {CRS} [options.crs] - 坐标系统类。\r\n * @param {string} [options.tileProxy] - 服务代理地址。\r\n * @param {string} [options.format=\'png\'] - 瓦片表述类型，支持 "png" 、"webp"、"bmp" 、"jpg"、 "gif" 等图片格式。\r\n * @param {(number|L.Point)} [options.tileSize=256] - 瓦片大小。\r\n * @param {(NDVIParameter|HillshadeParameter)} [options.rasterfunction] - 栅格分析参数。\r\n * @param {string} [options.attribution=\'Map Data <span>© <a href=\'http://support.supermap.com.cn/product/iServer.aspx\' title=\'SuperMap iServer\' target=\'_blank\'>SuperMap iServer</a></span>\'] - 版权信息。\r\n * @param {Array.<number>} [options.subdomains] - 子域名数组。\r\n * @fires TiledMapLayer#tilesetsinfoloaded\r\n * @fires TiledMapLayer#tileversionschanged\r\n * @usage\r\n */\r\nvar TiledMapLayer = leaflet_src_default.a.TileLayer.extend({\r\n\r\n    options: {\r\n        //如果有layersID，则是在使用专题图\r\n        layersID: null,\r\n        //如果为 true，则将请求重定向到瓦片的真实地址；如果为 false，则响应体中是瓦片的字节流\r\n        redirect: false,\r\n        transparent: true,\r\n        cacheEnabled: true,\r\n        clipRegionEnabled: false,\r\n        //地图显示裁剪的区域\r\n        clipRegion: null,\r\n        //请求的地图的坐标参考系统。 如：prjCoordSys={"epsgCode":3857}\r\n        prjCoordSys: null,\r\n        //地图对象在同一范围内时，是否重叠显示\r\n        overlapDisplayed: false,\r\n        //避免地图对象压盖显示的过滤选项\r\n        overlapDisplayedOptions: null,\r\n        //切片版本名称，cacheEnabled 为 true 时有效。\r\n        tileversion: null,\r\n        crs: null,\r\n        format: \'png\',\r\n        //启用托管地址。\r\n        tileProxy:null,\r\n        attribution: core_Attributions.Common.attribution,\r\n        subdomains: null\r\n    },\r\n\r\n    initialize: function (url, options) {\r\n        this._url = url;\r\n        leaflet_src_default.a.TileLayer.prototype.initialize.apply(this, arguments);\r\n        leaflet_src_default.a.setOptions(this, options);\r\n        leaflet_src_default.a.stamp(this);\r\n\r\n        //当前切片在切片集中的index\r\n        this.tileSetsIndex = -1;\r\n        this.tempIndex = -1;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @function TiledMapLayer.prototype.onAdd\r\n     * @description 添加地图。\r\n     * @param {L.Map} map - Leaflet Map 对象。\r\n     */\r\n    onAdd: function (map) {\r\n        this._crs = this.options.crs || map.options.crs;\r\n        leaflet_src_default.a.TileLayer.prototype.onAdd.call(this, map);\r\n    },\r\n\r\n    /**\r\n     * @function TiledMapLayer.prototype.getTileUrl\r\n     * @description 根据行列号获取瓦片地址。\r\n     * @param {Object} coords - 行列号。\r\n     * @returns {string} 瓦片地址。\r\n     */\r\n    getTileUrl: function (coords) {\r\n        var scale = this.getScaleFromCoords(coords);\r\n        var layerUrl = this._getLayerUrl();\r\n        var tileUrl = layerUrl + "&scale=" + scale + "&x=" + coords.x + "&y=" + coords.y;\r\n        //支持代理\r\n        if (this.options.tileProxy) {\r\n            tileUrl = this.options.tileProxy + encodeURIComponent(tileUrl);\r\n        }\r\n        if (!this.options.cacheEnabled) {\r\n            tileUrl += "&_t=" + new Date().getTime();\r\n        }\r\n        if (this.options.subdomains) {\r\n            tileUrl = leaflet_src_default.a.Util.template(tileUrl, {s: this._getSubdomain(coords)});\r\n        }\r\n        return tileUrl;\r\n    },\r\n\r\n    /**\r\n     * @function TiledMapLayer.prototype.getScale\r\n     * @description 根据缩放级别获取比例尺。\r\n     * @param {number} zoom - 缩放级别。\r\n     * @returns {number} 比例尺。\r\n     */\r\n    getScale: function (zoom) {\r\n        var me = this;\r\n        //返回当前比例尺\r\n        var z = zoom || me._map.getZoom();\r\n        return me.scales[z];\r\n    },\r\n\r\n    /**\r\n     * @function TiledMapLayer.prototype.getScaleFromCoords\r\n     * @description 通过行列号获取比例尺。\r\n     * @param {Object} coords - 行列号。\r\n     * @returns {number} 比例尺。\r\n     */\r\n    getScaleFromCoords: function (coords) {\r\n        var me = this,\r\n            scale;\r\n        if (me.scales && me.scales[coords.z]) {\r\n            return me.scales[coords.z];\r\n        }\r\n        me.scales = me.scales || {};\r\n        scale = me.getDefaultScale(coords);\r\n        me.scales[coords.z] = scale;\r\n        return scale;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @function TiledMapLayer.prototype.getDefaultScale\r\n     * @description 获取默认比例尺信息。\r\n     * @param {Object} coords - 坐标对象参数。\r\n     */\r\n    getDefaultScale: function (coords) {\r\n        var me = this,\r\n            crs = me._crs;\r\n        if (crs.scales) {\r\n            return crs.scales[coords.z];\r\n        } else {\r\n            var tileBounds = me._tileCoordsToBounds(coords);\r\n            var ne = crs.project(tileBounds.getNorthEast());\r\n            var sw = crs.project(tileBounds.getSouthWest());\r\n            var tileSize = me.options.tileSize;\r\n            var resolution = Math.max(\r\n                Math.abs(ne.x - sw.x) / tileSize,\r\n                Math.abs(ne.y - sw.y) / tileSize\r\n            );\r\n            var mapUnit = Unit.METER;\r\n            if (crs.code) {\r\n                var array = crs.code.split(\':\');\r\n                if (array && array.length > 1) {\r\n                    var code = parseInt(array[1]);\r\n                    mapUnit = code && code >= 4000 && code <= 5000 ? Unit.DEGREE : Unit.METER;\r\n                }\r\n            }\r\n            return resolutionToScale(resolution, 96, mapUnit);\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * @function TiledMapLayer.prototype.setTileSetsInfo\r\n     * @description 设置瓦片集信息。\r\n     * @param {Object} tileSets - 瓦片对象集。\r\n     */\r\n    setTileSetsInfo: function (tileSets) {\r\n        this.tileSets = tileSets;\r\n        if (leaflet_src_default.a.Util.isArray(this.tileSets)) {\r\n            this.tileSets = this.tileSets[0];\r\n        }\r\n        if (!this.tileSets) {\r\n            return;\r\n        }\r\n        /**\r\n         * @event TiledMapLayer#tilesetsinfoloaded\r\n         * @description 瓦片集信息设置完成后触发。\r\n         * @property {Array.<Object>} tileVersions  - 瓦片集信息。\r\n         */\r\n        this.fire(\'tilesetsinfoloaded\', {\r\n            tileVersions: this.tileSets.tileVersions\r\n        });\r\n        this.changeTilesVersion();\r\n    },\r\n\r\n    /**\r\n     * @function TiledMapLayer.prototype.lastTilesVersion\r\n     * @description 请求上一个版本切片，并重新绘制。\r\n     */\r\n    lastTilesVersion: function () {\r\n        this.tempIndex = this.tileSetsIndex - 1;\r\n        this.changeTilesVersion();\r\n    },\r\n\r\n    /**\r\n     * @function TiledMapLayer.prototype.nextTilesVersion\r\n     * @description 请求下一个版本切片，并重新绘制。\r\n     */\r\n    nextTilesVersion: function () {\r\n        this.tempIndex = this.tileSetsIndex + 1;\r\n        this.changeTilesVersion();\r\n    },\r\n\r\n    /**\r\n     * @function TiledMapLayer.prototype.changeTilesVersion\r\n     * @description 切换到某一版本的切片，并重绘。通过 this.tempIndex 保存需要切换的版本索引\r\n     */\r\n    changeTilesVersion: function () {\r\n        var me = this;\r\n        //切片版本集信息是否存在\r\n        if (me.tileSets == null) {\r\n            //版本信息为空，重新查询，查询成功继续跳转到相应的版本\r\n            //me.getTileSetsInfo();\r\n            return;\r\n        }\r\n        if (me.tempIndex === me.tileSetsIndex || this.tempIndex < 0) {\r\n            return;\r\n        }\r\n        //检测index是否可用\r\n        var tileVersions = me.tileSets.tileVersions;\r\n        if (tileVersions && me.tempIndex < tileVersions.length && me.tempIndex >= 0) {\r\n            var name = tileVersions[me.tempIndex].name;\r\n            var result = me.mergeTileVersionParam(name);\r\n            if (result) {\r\n                me.tileSetsIndex = me.tempIndex;\r\n                /**\r\n                 * @event TiledMapLayer#tileversionschanged\r\n                 * @description 切片的版本切换和重绘成功之后触发。\r\n                 * @property {Object} tileVersion  - 该版本的切片。\r\n                 */\r\n                me.fire(\'tileversionschanged\', {\r\n                    tileVersion: tileVersions[me.tempIndex]\r\n                });\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @function TiledMapLayer.prototype.updateCurrentTileSetsIndex\r\n     * @description 手动设置当前切片集索引，目前主要提供给控件使用。\r\n     * @param {number} index - 索引值。\r\n     */\r\n    updateCurrentTileSetsIndex: function (index) {\r\n        this.tempIndex = index;\r\n    },\r\n\r\n    /**\r\n     * @function TiledMapLayer.prototype.mergeTileVersionParam\r\n     * @description 更改URL请求参数中的切片版本号，并重绘。\r\n     * @param {string} version - 切片版本号。\r\n     * @returns {boolean} 是否成功。\r\n     */\r\n    mergeTileVersionParam: function (version) {\r\n        if (version) {\r\n            this.requestParams["tileversion"] = version;\r\n            this._paramsChanged = true;\r\n            this.redraw();\r\n            this._paramsChanged = false;\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n\r\n    _getLayerUrl: function () {\r\n        if (this._paramsChanged) {\r\n            this._layerUrl = this._createLayerUrl();\r\n        }\r\n        return this._layerUrl || this._createLayerUrl();\r\n    },\r\n\r\n    _createLayerUrl: function () {\r\n        let layerUrl = Util.urlPathAppend(this._url, `tileImage.${this.options.format}`);\r\n        this.requestParams = this.requestParams || this._getAllRequestParams();\r\n        layerUrl = Util.urlAppend(layerUrl, leaflet_src["Util"].getParamString(this.requestParams));\r\n        layerUrl = SecurityManager_SecurityManager.appendCredential(layerUrl);\r\n        this._layerUrl = layerUrl;\r\n        return layerUrl;\r\n    },\r\n\r\n    _getAllRequestParams: function () {\r\n        var me = this,\r\n            options = me.options || {},\r\n            params = {};\r\n\r\n        var tileSize = this.options.tileSize;\r\n        if (!(tileSize instanceof leaflet_src_default.a.Point)) {\r\n            tileSize = leaflet_src_default.a.point(tileSize, tileSize);\r\n        }\r\n        params["width"] = tileSize.x;\r\n        params["height"] = tileSize.y;\r\n\r\n        params["redirect"] = options.redirect === true;\r\n        params["transparent"] = options.transparent === true;\r\n        params["cacheEnabled"] = !(options.cacheEnabled === false);\r\n\r\n        if (options.prjCoordSys) {\r\n            params["prjCoordSys"] = JSON.stringify(options.prjCoordSys);\r\n        }\r\n\r\n        if (options.layersID) {\r\n            params["layersID"] = options.layersID.toString();\r\n        }\r\n\r\n        if (options.clipRegionEnabled && options.clipRegion) {\r\n            options.clipRegion = ServerGeometry_ServerGeometry.fromGeometry(toSuperMapGeometry(options.clipRegion));\r\n            params["clipRegionEnabled"] = options.clipRegionEnabled;\r\n            params["clipRegion"] = JSON.stringify(options.clipRegion);\r\n        }\r\n\r\n        //切片的起始参考点，默认为地图范围的左上角。\r\n        var crs = me._crs;\r\n        if (crs.options && crs.options.origin) {\r\n            params["origin"] = JSON.stringify({\r\n                x: crs.options.origin[0],\r\n                y: crs.options.origin[1]\r\n            });\r\n        } else if (crs.projection && crs.projection.bounds) {\r\n            var bounds = crs.projection.bounds;\r\n            var tileOrigin = leaflet_src_default.a.point(bounds.min.x, bounds.max.y);\r\n            params["origin"] = JSON.stringify({\r\n                x: tileOrigin.x,\r\n                y: tileOrigin.y\r\n            });\r\n        }\r\n\r\n        if (options.overlapDisplayed === false) {\r\n            params["overlapDisplayed"] = false;\r\n            if (options.overlapDisplayedOptions) {\r\n                params["overlapDisplayedOptions"] = me.overlapDisplayedOptions.toString();\r\n            }\r\n        } else {\r\n            params["overlapDisplayed"] = true;\r\n        }\r\n\r\n        if (params.cacheEnabled === true && options.tileversion) {\r\n            params["tileversion"] = options.tileversion.toString();\r\n        }\r\n        if (options.rasterfunction) {\r\n            params["rasterfunction"] = JSON.stringify(options.rasterfunction);\r\n        }\r\n\r\n        return params;\r\n    }\r\n});\r\n\r\nvar tiledMapLayer = function (url, options) {\r\n    return new TiledMapLayer(url, options);\r\n};\r\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/wleaflet/ui/Map/index.vue?vue&type=script&lang=js&\n\n\n\n/* harmony default export */ var Mapvue_type_script_lang_js_ = ({\n  components: {},\n  props: {\n    customClass: {\n      type: String,\n      "default": \'wcx-custom-map\'\n    },\n    el: {\n      type: String,\n      "default": \'map\'\n    },\n    options: {\n      type: Object,\n      "default": function _default() {\n        return {\n          center: [34.759197, 113.778584],\n          zoom: 10,\n          minZoom: 4,\n          maxZoom: 16\n        };\n      }\n    }\n  },\n  data: function data() {\n    return {\n      map: null\n    };\n  },\n  computed: {},\n  created: function created() {},\n  mounted: function mounted() {\n    this.initMap();\n  },\n  methods: {\n    initMap: function initMap() {\n      var China = new TiledMapLayer(\'https://iserver.supermap.io/iserver/services/map-china400/rest/maps/China\', {\n        noWrap: true\n      });\n      var ChinaDark = new TiledMapLayer(\'https://iserver.supermap.io/iserver/services/map-china400/rest/maps/ChinaDark\', {\n        noWrap: true\n      });\n      var arcgis = leaflet_src_default.a.tileLayer(\'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\');\n      var labelTextCollision = new leaflet_src_default.a.LabelTextCollision({\n        collisionFlg: true\n      });\n      window.map = this.map = leaflet_src_default.a.map(this.el, _objectSpread2(_objectSpread2({}, this.options), {}, {\n        layers: [China],\n        renderer: labelTextCollision\n      }));\n      var baseMaps = {\n        China: China,\n        ChinaDark: ChinaDark,\n        arcgis: arcgis\n      };\n      leaflet_src_default.a.control.layers(baseMaps).addTo(this.map);\n      this.$emit(\'mapComplete\', this.map);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/wleaflet/ui/Map/index.vue?vue&type=script&lang=js&\n /* harmony default export */ var ui_Mapvue_type_script_lang_js_ = (Mapvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/wleaflet/ui/Map/index.vue?vue&type=style&index=0&id=fad4bd8e&prod&scoped=true&lang=less&\nvar Mapvue_type_style_index_0_id_fad4bd8e_prod_scoped_true_lang_less_ = __webpack_require__("dead");\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent(\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */,\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options =\n    typeof scriptExports === \'function\' ? scriptExports.options : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = \'data-v-\' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) {\n    // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== \'undefined\') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n          injectStyles.call(\n            this,\n            (options.functional ? this.parent : this).$root.$options.shadowRoot\n          )\n        }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn\'t\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n// CONCATENATED MODULE: ./src/wleaflet/ui/Map/index.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar Map_component = normalizeComponent(\n  ui_Mapvue_type_script_lang_js_,\n  Mapvue_type_template_id_fad4bd8e_scoped_true_render,\n  Mapvue_type_template_id_fad4bd8e_scoped_true_staticRenderFns,\n  false,\n  null,\n  "fad4bd8e",\n  null\n  \n)\n\n/* harmony default export */ var Map = (Map_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5f48ba14-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Table/index.vue?vue&type=template&id=2de3a101&scoped=true&\nvar Tablevue_type_template_id_2de3a101_scoped_true_render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\'div\', {\n    staticClass: "wcx-table-container"\n  }, [_c(\'div\', {\n    staticClass: "wcx-table-fold",\n    on: {\n      "click": _vm.handdleFold\n    }\n  }, [_c(\'img\', {\n    "class": _vm.isOpen ? \'open\' : \'\',\n    attrs: {\n      "src": __webpack_require__("eb10"),\n      "alt": ""\n    }\n  })]), _c(\'div\', {\n    staticClass: "wcx-table-content",\n    "class": [_vm.isOpen ? \'open\' : \'\']\n  }, [_c(\'el-table\', {\n    directives: [{\n      name: "loading",\n      rawName: "v-loading",\n      value: _vm.loading,\n      expression: "loading"\n    }],\n    staticStyle: {\n      "width": "100%"\n    },\n    attrs: {\n      "data": _vm.tableList\n    },\n    on: {\n      "row-click": _vm.rowClick\n    }\n  }, [_c(\'el-table-column\', {\n    attrs: {\n      "type": "设置类型",\n      "prop": "name",\n      "label": "名称"\n    }\n  }), _c(\'el-table-column\', {\n    attrs: {\n      "type": "设置类型",\n      "prop": "province",\n      "label": "所属省份"\n    }\n  }), _c(\'el-table-column\', {\n    attrs: {\n      "type": "设置类型",\n      "label": "编码",\n      "prop": "code"\n    }\n  }), _c(\'el-table-column\', {\n    attrs: {\n      "type": "设置类型",\n      "label": "经度",\n      "prop": "lat"\n    }\n  }), _c(\'el-table-column\', {\n    attrs: {\n      "type": "设置类型",\n      "label": "纬度",\n      "prop": "lng"\n    }\n  }), _c(\'el-table-column\', {\n    attrs: {\n      "type": "设置类型",\n      "label": "海拔",\n      "prop": "height"\n    }\n  })], 1), _c(\'el-pagination\', {\n    attrs: {\n      "page-size": _vm.params.size,\n      "current-page": _vm.params.pageNumber,\n      "layout": "prev, pager, next",\n      "total": _vm.params.total\n    },\n    on: {\n      "current-change": _vm.currentChange\n    }\n  })], 1)]);\n};\n\nvar Tablevue_type_template_id_2de3a101_scoped_true_staticRenderFns = [];\n\n// CONCATENATED MODULE: ./src/components/Table/index.vue?vue&type=template&id=2de3a101&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Table/index.vue?vue&type=script&lang=js&\n/* harmony default export */ var Tablevue_type_script_lang_js_ = ({\n  props: {\n    params: {\n      type: Object,\n      "default": function _default() {\n        return {\n          pageSize: 10,\n          pageNumber: 1,\n          total: 10\n        };\n      }\n    },\n    tableList: {\n      type: Array,\n      "default": function _default() {\n        return [];\n      }\n    },\n    loading: {\n      type: Boolean,\n      "default": true\n    }\n  },\n  components: {},\n  data: function data() {\n    return {\n      isOpen: true\n    };\n  },\n  computed: {},\n  created: function created() {},\n  mounted: function mounted() {},\n  methods: {\n    currentChange: function currentChange(val) {\n      this.$emit(\'currentChange\', val);\n    },\n    handdleFold: function handdleFold() {\n      this.isOpen = !this.isOpen;\n    },\n    rowClick: function rowClick(row, column, event) {\n      this.$emit(\'rowClick\', row, column, event);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/Table/index.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_Tablevue_type_script_lang_js_ = (Tablevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/Table/index.vue?vue&type=style&index=0&id=2de3a101&prod&scoped=true&lang=less&\nvar Tablevue_type_style_index_0_id_2de3a101_prod_scoped_true_lang_less_ = __webpack_require__("222c");\n\n// CONCATENATED MODULE: ./src/components/Table/index.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar Table_component = normalizeComponent(\n  components_Tablevue_type_script_lang_js_,\n  Tablevue_type_template_id_2de3a101_scoped_true_render,\n  Tablevue_type_template_id_2de3a101_scoped_true_staticRenderFns,\n  false,\n  null,\n  "2de3a101",\n  null\n  \n)\n\n/* harmony default export */ var Table = (Table_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5f48ba14-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/wleaflet/ui/DrawTool/index.vue?vue&type=template&id=03dbae72&\nvar DrawToolvue_type_template_id_03dbae72_render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\'div\');\n};\n\nvar DrawToolvue_type_template_id_03dbae72_staticRenderFns = [];\n\n// CONCATENATED MODULE: ./src/wleaflet/ui/DrawTool/index.vue?vue&type=template&id=03dbae72&\n\n// EXTERNAL MODULE: ./node_modules/@geoman-io/leaflet-geoman-free/dist/leaflet-geoman.min.js\nvar leaflet_geoman_min = __webpack_require__("845a");\n\n// EXTERNAL MODULE: ./node_modules/@geoman-io/leaflet-geoman-free/dist/leaflet-geoman.css\nvar leaflet_geoman = __webpack_require__("a94e");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/wleaflet/ui/DrawTool/index.vue?vue&type=script&lang=js&\n\n\n/* harmony default export */ var DrawToolvue_type_script_lang_js_ = ({\n  name: \'DrawTool\',\n  props: {\n    map: {\n      type: Object,\n      "default": function _default() {\n        return null;\n      }\n    }\n  },\n  data: function data() {\n    return {};\n  },\n  mounted: function mounted() {\n    this.map.pm.addControls({\n      position: \'topleft\',\n      drawPolygon: true,\n      // 添加绘制多边形\n      drawMarker: true,\n      //添加按钮以绘制标记\n      drawCircleMarker: true,\n      //添加按钮以绘制圆形标记\n      drawPolyline: true,\n      //添加按钮绘制线条\n      drawRectangle: true,\n      //添加按钮绘制矩形\n      drawCircle: true,\n      //  添加按钮绘制圆圈\n      editMode: true,\n      //  添加按钮编辑多边形\n      dragMode: true,\n      //   添加按钮拖动多边形\n      cutPolygon: true,\n      // 添加一个按钮以删除图层里面的部分内容\n      removalMode: true // 清除图层\n\n    }); // 设置绘制后的线条颜色等\n\n    this.map.pm.setPathOptions({\n      color: \'blue\',\n      fillColor: \'pink\',\n      fillOpacity: 0.4\n    });\n    this.map.pm.setLang(\'zh\'); //设置语言\n\n    this.map.on(\'pm:drawstart\', function (e) {\n      //绘制开始时事件\n      console.log(e, \'first\');\n    });\n    this.map.on(\'pm:create\', function (e) {\n      console.log(e, \'绘制完成时调用\');\n      console.log(JSON.stringify(e.layer._latlngs)); //获取绘制的坐标           绘制线段时不能显示第一个点坐标\n    });\n  },\n  components: {},\n  methods: {}\n});\n// CONCATENATED MODULE: ./src/wleaflet/ui/DrawTool/index.vue?vue&type=script&lang=js&\n /* harmony default export */ var ui_DrawToolvue_type_script_lang_js_ = (DrawToolvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/wleaflet/ui/DrawTool/index.vue\n\n\n\n\n\n/* normalize component */\n\nvar DrawTool_component = normalizeComponent(\n  ui_DrawToolvue_type_script_lang_js_,\n  DrawToolvue_type_template_id_03dbae72_render,\n  DrawToolvue_type_template_id_03dbae72_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var DrawTool = (DrawTool_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5f48ba14-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/vector.vue?vue&type=template&id=e51daf18&scoped=true&\nvar vectorvue_type_template_id_e51daf18_scoped_true_render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\'el-button\', {\n    staticClass: "add-button",\n    attrs: {\n      "type": "primary",\n      "size": "mini"\n    },\n    on: {\n      "click": _vm.handleClick\n    }\n  }, [_vm._v(_vm._s(_vm.text))]);\n};\n\nvar vectorvue_type_template_id_e51daf18_scoped_true_staticRenderFns = [];\n\n// CONCATENATED MODULE: ./src/views/vector.vue?vue&type=template&id=e51daf18&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/leaflet.motion/dist/leaflet.motion.js\nvar leaflet_motion = __webpack_require__("4138");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/vector.vue?vue&type=script&lang=js&\n\n\nvar featureGroup = null;\nvar route = null;\n/* harmony default export */ var vectorvue_type_script_lang_js_ = ({\n  components: {},\n  data: function data() {\n    return {\n      text: \'显示线和面\',\n      has: false\n    };\n  },\n  computed: {},\n  created: function created() {},\n  mounted: function mounted() {\n    featureGroup = leaflet_src_default.a.featureGroup();\n  },\n  methods: {\n    handleClick: function handleClick() {\n      if (this.has) {\n        console.log(111);\n        this.removeVectorLayer();\n      } else {\n        this.addVectorLayer();\n        console.log(22);\n      }\n    },\n    addVectorLayer: function addVectorLayer() {\n      var _this = this;\n\n      fetch(\'./data/vector.json\').then(function (response) {\n        return response.json();\n      }).then(function (result) {\n        console.log(result);\n        var polygon = leaflet_src_default.a.polygon(result.polygon, {\n          color: \'red\'\n        });\n        var polyline = leaflet_src_default.a.polyline(result.polyline, {\n          color: \'red\'\n        });\n        route = result.polyline;\n        featureGroup.addLayer(polygon);\n        featureGroup.addLayer(polyline);\n        featureGroup.addTo(map);\n        map.fitBounds(featureGroup.getBounds());\n        _this.text = \'清除点和面\';\n        _this.has = true;\n\n        _this.move();\n      });\n    },\n    removeVectorLayer: function removeVectorLayer() {\n      this.text = \'显示点和面\';\n      featureGroup && featureGroup.clearLayers();\n      this.has = false;\n    },\n    move: function move() {\n      var seqGroup = leaflet_src_default.a.motion.seq([leaflet_src_default.a.motion.polyline(route, {\n        color: \'orangered\'\n      }, {\n        easing: leaflet_src_default.a.Motion.Ease.easeInOutQuad\n      }, {\n        removeOnEnd: true,\n        icon: leaflet_src_default.a.divIcon({\n          html: "<i class=\'icon\' style=\'fontSize:24px\'>✈</i>",\n          iconSize: leaflet_src_default.a.point(36, 36)\n        })\n      }).motionDuration(18000)]).addTo(map);\n      seqGroup.motionStart();\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/views/vector.vue?vue&type=script&lang=js&\n /* harmony default export */ var views_vectorvue_type_script_lang_js_ = (vectorvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/views/vector.vue?vue&type=style&index=0&id=e51daf18&prod&scoped=true&lang=less&\nvar vectorvue_type_style_index_0_id_e51daf18_prod_scoped_true_lang_less_ = __webpack_require__("71b9");\n\n// CONCATENATED MODULE: ./src/views/vector.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar vector_component = normalizeComponent(\n  views_vectorvue_type_script_lang_js_,\n  vectorvue_type_template_id_e51daf18_scoped_true_render,\n  vectorvue_type_template_id_e51daf18_scoped_true_staticRenderFns,\n  false,\n  null,\n  "e51daf18",\n  null\n  \n)\n\n/* harmony default export */ var vector = (vector_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5f48ba14-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/huge.vue?vue&type=template&id=1e90d133&scoped=true&\nvar hugevue_type_template_id_1e90d133_scoped_true_render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\'el-button\', {\n    staticClass: "add-button",\n    attrs: {\n      "type": "primary",\n      "size": "mini"\n    },\n    on: {\n      "click": _vm.handleClick\n    }\n  }, [_vm._v("加载10000点")]);\n};\n\nvar hugevue_type_template_id_1e90d133_scoped_true_staticRenderFns = [];\n\n// CONCATENATED MODULE: ./src/views/huge.vue?vue&type=template&id=1e90d133&scoped=true&\n\n// EXTERNAL MODULE: ./src/wleaflet/lib/leaflet.canvas-markers.js\nvar leaflet_canvas_markers = __webpack_require__("6664");\n\n// CONCATENATED MODULE: ./src/wleaflet/core/marker.js\n\n\n/*\r\n * @Author: zulezhe\r\n * @Date: 2022-08-23 10:08:29\r\n * @LastEditors: zulezhe\r\n * @LastEditTime: 2022-08-24 12:52:13\r\n * @Path: https://gitee.com/zulezhe/\r\n * @Description:\r\n */\n\n\nvar popup = null;\nvar marker_featureGroup = null;\n/**\r\n * 添加点\r\n */\n\nfunction addMarker(item) {\n  var marker = leaflet_src_default.a.marker([Number(item.lat), Number(item.lng)], {\n    code: \'marker-\' + item.code,\n    icon: leaflet_src_default.a.icon({\n      iconUrl: item.icon.iconUrl,\n      iconSize: item.icon.iconSize,\n      iconAnchor: [0, 0],\n      popupAnchor: [5, 0],\n      className: \'leaflet-custom-icon\'\n    }),\n    customData: _objectSpread2({}, item)\n  });\n  marker.bindTooltip(item.name, {\n    direction: \'top\',\n    offset: leaflet_src_default.a.point(15, 0)\n  }).openTooltip();\n  marker.on(\'click\', onClick);\n  return marker;\n} // export function addMarker(item) {\n//   let marker = L.marker([Number(item.lat), Number(item.lng)], {\n//     code: \'marker-\' + item.code,\n//     icon: L.divIcon({\n//       html: `\n//       <div class="custom-div-icon-container">\n//         <img src="${item.icon.iconUrl}" alt="">\n//       </div>\n//       `,\n//       iconSize: L.point(27.5, 24)\n//     }),\n//     customData: { ...item }\n//   });\n//   marker\n//     .bindTooltip(item.name, {\n//       direction: \'top\',\n//       offset: L.point(15, 0)\n//     })\n//     .openTooltip();\n//   marker.on(\'click\', onClick);\n//   return marker;\n// }\n\n/**\r\n * 添加多点\r\n * @param {*} list\r\n */\n\nfunction addMarkers(list, options) {\n  marker_featureGroup = leaflet_src_default.a.featureGroup();\n  list.map(function (item) {\n    marker_featureGroup.addLayer(addMarker(_objectSpread2(_objectSpread2({}, item), options)));\n  });\n  marker_featureGroup.addTo(map);\n  map.fitBounds(marker_featureGroup.getBounds());\n  return marker_featureGroup;\n}\n/**\r\n * 添加海量点\r\n */\n\nfunction addHugeMarkers(list, options) {\n  var ciLayer = leaflet_src_default.a.canvasIconLayer({}).addTo(map);\n  list.map(function (item) {\n    var marker = addMarker(_objectSpread2(_objectSpread2({}, item), options));\n    ciLayer.addLayer(marker);\n  });\n  console.log(ciLayer);\n}\n/**\r\n * 删除点\r\n */\n\nfunction removeMarker() {}\n/**\r\n * 清空要素组\r\n */\n\nfunction clearGroup(group) {\n  group.clearLayers();\n}\n/**\r\n * 查找点\r\n */\n\nfunction findMarker() {}\n/**\r\n * 更新点\r\n */\n\nfunction updateMarker() {}\n/**\r\n * 移入点\r\n */\n\nfunction onMouseover(e) {\n  console.log(\'鼠标移入\', e);\n  var target = e.target;\n  var customData = target.options.customData;\n  e.target.bindTooltip(customData.name, {\n    direction: \'top\'\n  }).openTooltip();\n}\n/**\r\n * 移出点\r\n */\n\nfunction onMouseout(e) {\n  console.log(\'鼠标移出\', e);\n  e.target.closeTooltip();\n}\n/**\r\n * 点击点\r\n */\n\nfunction onClick(e) {\n  var target = e.target;\n  console.log(\'点击点\', e, target);\n  var layers = marker_featureGroup.getLayers();\n  layers.map(function (layer) {\n    if (layer.options.code === target.options.code) {\n      target.setIcon(leaflet_src_default.a.icon({\n        iconUrl: __webpack_require__("2e8a"),\n        className: \'leaflet-custom-icon blinking\'\n      }));\n    } else {\n      layer.setIcon(leaflet_src_default.a.icon({\n        iconUrl: __webpack_require__("c1c5"),\n        className: \'leaflet-custom-icon\'\n      }));\n    }\n  });\n  console.log(\'获取featureGroup上的所有图层===>\', layers); // L.DomUtil.addClass(target, \'active\');\n\n  popup = leaflet_src_default.a.popup({\n    offset: leaflet_src_default.a.point(10, 0)\n  }).setLatLng([e.latlng.lat, e.latlng.lng]).setContent("\\n      <div class=\\"custom-popup-container\\" style=\\"width:300px;height:240px;\\">\\n        <div class=\\"row\\">\\n            <span class=\\"title\\">\\u540D\\u79F0:</span>\\n            <span class=\\"value\\">".concat(target.options.customData.name, "</span>\\n        </div>\\n        <div class=\\"row\\">\\n            <span class=\\"title\\">\\u6240\\u5C5E\\u7701\\u4EFD:</span>\\n            <span class=\\"value\\">").concat(target.options.customData.province, "</span>\\n        </div>\\n        <div class=\\"row\\">\\n            <span class=\\"title\\">\\u7F16\\u7801:</span>\\n            <span class=\\"value\\">").concat(target.options.customData.code, "</span>\\n        </div>\\n        <div class=\\"row\\">\\n            <span class=\\"title\\">\\u4F4D\\u7F6E:</span>\\n            <span class=\\"value\\">").concat(target.options.customData.lng, ",").concat(target.options.customData.lat, "</span>\\n        </div>\\n        <div class=\\"row\\">\\n            <span class=\\"title\\">\\u6D77\\u62D4:</span>\\n            <span class=\\"value\\">").concat(target.options.customData.height, "m</span>\\n        </div>\\n      </div>\\n    "));\n  popup.openOn(map);\n}\nfunction closePopup() {\n  console.log(popup);\n  popup && popup._close();\n}\n/**\r\n * 聚焦到多点\r\n * @param {*} markers\r\n */\n\nfunction setViewMarkers(markers) {\n  var markerBounds = leaflet_src_default.a.latLngBounds([]);\n  markers.forEach(function (marker) {\n    markerBounds.extend([marker.lat, marker.lng]);\n  });\n  map.fitBounds(markerBounds);\n}\n/**\r\n * 飞行到点\r\n * @param {*} map\r\n * @param {*} position\r\n * @param {*} zoom\r\n */\n\nfunction flyTo(position) {\n  var zoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 13;\n  map.flyTo(position, zoom);\n}\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/huge.vue?vue&type=script&lang=js&\n\n/* harmony default export */ var hugevue_type_script_lang_js_ = ({\n  components: {},\n  data: function data() {\n    return {};\n  },\n  computed: {},\n  created: function created() {},\n  mounted: function mounted() {},\n  methods: {\n    handleClick: function handleClick() {\n      var list = [];\n\n      for (var i = 0; i < 10000; i++) {\n        var lat = 34.759197 + (Math.random() - Math.random()) * 3;\n        var lng = 113.778584 + (Math.random() - Math.random()) * 3;\n        list.push({\n          lat: lat,\n          lng: lng,\n          name: \'第\' + i + \'个\'\n        });\n      }\n\n      addHugeMarkers(list, {\n        icon: {\n          iconUrl: __webpack_require__("0f91"),\n          iconSize: [30, 30]\n        }\n      });\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/views/huge.vue?vue&type=script&lang=js&\n /* harmony default export */ var views_hugevue_type_script_lang_js_ = (hugevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/views/huge.vue?vue&type=style&index=0&id=1e90d133&prod&scoped=true&lang=less&\nvar hugevue_type_style_index_0_id_1e90d133_prod_scoped_true_lang_less_ = __webpack_require__("8330");\n\n// CONCATENATED MODULE: ./src/views/huge.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar huge_component = normalizeComponent(\n  views_hugevue_type_script_lang_js_,\n  hugevue_type_template_id_1e90d133_scoped_true_render,\n  hugevue_type_template_id_1e90d133_scoped_true_staticRenderFns,\n  false,\n  null,\n  "1e90d133",\n  null\n  \n)\n\n/* harmony default export */ var huge = (huge_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5f48ba14-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/avoid.vue?vue&type=template&id=54c9288a&scoped=true&\nvar avoidvue_type_template_id_54c9288a_scoped_true_render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\'el-button\', {\n    staticClass: "add-button",\n    attrs: {\n      "type": "primary",\n      "size": "mini"\n    },\n    on: {\n      "click": _vm.handleClick\n    }\n  }, [_vm._v("5000标签避让")]);\n};\n\nvar avoidvue_type_template_id_54c9288a_scoped_true_staticRenderFns = [];\n\n// CONCATENATED MODULE: ./src/views/avoid.vue?vue&type=template&id=54c9288a&scoped=true&\n\n// EXTERNAL MODULE: ./src/wleaflet/lib/L.LabelTextCollision.js\nvar L_LabelTextCollision = __webpack_require__("2b6d");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/avoid.vue?vue&type=script&lang=js&\n\n/* harmony default export */ var avoidvue_type_script_lang_js_ = ({\n  components: {},\n  data: function data() {\n    return {};\n  },\n  computed: {},\n  created: function created() {},\n  mounted: function mounted() {},\n  methods: {\n    handleClick: function handleClick() {\n      var layers = L.featureGroup().addTo(map);\n\n      for (var i = 0; i < 5000; i++) {\n        var lat = 34.759197 + (Math.random() - Math.random()) * 3;\n        var lng = 113.778584 + (Math.random() - Math.random()) * 3;\n        var latlng = L.latLng(lat, lng);\n        var marker = L.circleMarker(latlng, {\n          radius: 0,\n          text: \'我是第\' + i + \'个标签\',\n          textStyle: {\n            stroke: true,\n            width: 80,\n            hieght: 40,\n            color: \'blue\',\n            font: "15px \'Microsoft Yahei\'",\n            offsetX: -70,\n            offsetY: -10\n          }\n        });\n        layers.addLayer(marker);\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/views/avoid.vue?vue&type=script&lang=js&\n /* harmony default export */ var views_avoidvue_type_script_lang_js_ = (avoidvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/views/avoid.vue?vue&type=style&index=0&id=54c9288a&prod&scoped=true&lang=less&\nvar avoidvue_type_style_index_0_id_54c9288a_prod_scoped_true_lang_less_ = __webpack_require__("664f");\n\n// CONCATENATED MODULE: ./src/views/avoid.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar avoid_component = normalizeComponent(\n  views_avoidvue_type_script_lang_js_,\n  avoidvue_type_template_id_54c9288a_scoped_true_render,\n  avoidvue_type_template_id_54c9288a_scoped_true_staticRenderFns,\n  false,\n  null,\n  "54c9288a",\n  null\n  \n)\n\n/* harmony default export */ var avoid = (avoid_component.exports);\n// CONCATENATED MODULE: ./src/api/index.js\n/*\n * @Author: wangchaoxu\n * @Date: 2021-04-21 19:13:36\n * @LastEditors: zulezhe\n * @LastEditTime: 2022-08-23 00:31:26\n * @Path: https://gitee.com/wangchaoxu/\n * @Description:\n */\nfunction api_getData(params) {\n  return new Promise(function (resolve, reject) {\n    fetch(\'./data/test.json\').then(function (response) {\n      return response.json();\n    }).then(function (res) {\n      resolve({\n        data: res.slice((params.pageNumber - 1) * params.pageSize, params.pageNumber * params.pageSize),\n        total: res.length\n      });\n    })["catch"](function (err) {\n      reject(err);\n    });\n  });\n}\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/index.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n\n\n/* harmony default export */ var viewsvue_type_script_lang_js_ = ({\n  components: {\n    WMap: Map,\n    WTable: Table,\n    WDrawTool: DrawTool,\n    WVector: vector,\n    WHuge: huge,\n    WAvoid: avoid\n  },\n  data: function data() {\n    return {\n      tableList: [],\n      loading: true,\n      map: null,\n      featureGroup: null,\n      params: {\n        pageNumber: 1,\n        pageSize: 5,\n        total: 10\n      }\n    };\n  },\n  computed: {},\n  created: function created() {},\n  mounted: function mounted() {\n    this.getData();\n  },\n  methods: {\n    mapComplete: function mapComplete(map) {\n      this.map = map;\n      console.log(\'地图加载完成\', map);\n    },\n    getData: function getData() {\n      var _this = this;\n\n      this.loading = true;\n      api_getData(this.params).then(function (res) {\n        _this.tableList = res.data;\n        _this.params.total = res.total;\n        _this.featureGroup && clearGroup(_this.featureGroup);\n        _this.featureGroup = addMarkers(_this.tableList, {\n          icon: {\n            iconUrl: __webpack_require__("c1c5"),\n            iconSize: [32, 48]\n          }\n        });\n      })["finally"](function () {\n        setTimeout(function () {\n          _this.loading = false;\n        }, 1000);\n      });\n    },\n    currentChange: function currentChange(val) {\n      this.params.pageNumber = val;\n      closePopup();\n      this.getData();\n    },\n    rowClick: function rowClick(row, column, event) {\n      console.log(\'点击当前行===>\', row, column, event);\n      flyTo([Number(row.lat), Number(row.lng)], 13);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/views/index.vue?vue&type=script&lang=js&\n /* harmony default export */ var src_viewsvue_type_script_lang_js_ = (viewsvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/views/index.vue?vue&type=style&index=0&id=23ec8df8&prod&scoped=true&lang=less&\nvar viewsvue_type_style_index_0_id_23ec8df8_prod_scoped_true_lang_less_ = __webpack_require__("acd2");\n\n// CONCATENATED MODULE: ./src/views/index.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar views_component = normalizeComponent(\n  src_viewsvue_type_script_lang_js_,\n  viewsvue_type_template_id_23ec8df8_scoped_true_render,\n  viewsvue_type_template_id_23ec8df8_scoped_true_staticRenderFns,\n  false,\n  null,\n  "23ec8df8",\n  null\n  \n)\n\n/* harmony default export */ var views = (views_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=script&lang=js&\n\n/* harmony default export */ var Appvue_type_script_lang_js_ = ({\n  components: {\n    Home: views\n  },\n  data: function data() {\n    return {};\n  }\n});\n// CONCATENATED MODULE: ./src/App.vue?vue&type=script&lang=js&\n /* harmony default export */ var src_Appvue_type_script_lang_js_ = (Appvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/App.vue?vue&type=style&index=0&id=f8a82e40&prod&lang=less&scoped=true&\nvar Appvue_type_style_index_0_id_f8a82e40_prod_lang_less_scoped_true_ = __webpack_require__("9874");\n\n// CONCATENATED MODULE: ./src/App.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar App_component = normalizeComponent(\n  src_Appvue_type_script_lang_js_,\n  Appvue_type_template_id_f8a82e40_scoped_true_render,\n  staticRenderFns,\n  false,\n  null,\n  "f8a82e40",\n  null\n  \n)\n\n/* harmony default export */ var App = (App_component.exports);\n// EXTERNAL MODULE: ./src/assets/styles/include.less\nvar include = __webpack_require__("c293");\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/theme-chalk/message.css\nvar message = __webpack_require__("0fb7");\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/theme-chalk/base.css\nvar base = __webpack_require__("450d");\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/message.js\nvar lib_message = __webpack_require__("f529");\nvar lib_message_default = /*#__PURE__*/__webpack_require__.n(lib_message);\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/theme-chalk/loading.css\nvar loading = __webpack_require__("be4f");\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/loading.js\nvar lib_loading = __webpack_require__("896a");\nvar lib_loading_default = /*#__PURE__*/__webpack_require__.n(lib_loading);\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/theme-chalk/pagination.css\nvar pagination = __webpack_require__("672e");\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/pagination.js\nvar lib_pagination = __webpack_require__("101e");\nvar lib_pagination_default = /*#__PURE__*/__webpack_require__.n(lib_pagination);\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/theme-chalk/table-column.css\nvar table_column = __webpack_require__("5466");\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/table-column.js\nvar lib_table_column = __webpack_require__("ecdf");\nvar lib_table_column_default = /*#__PURE__*/__webpack_require__.n(lib_table_column);\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/theme-chalk/table.css\nvar table = __webpack_require__("38a0");\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/table.js\nvar lib_table = __webpack_require__("ad41");\nvar lib_table_default = /*#__PURE__*/__webpack_require__.n(lib_table);\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/theme-chalk/button.css\nvar theme_chalk_button = __webpack_require__("1951");\n\n// EXTERNAL MODULE: ./node_modules/element-ui/lib/button.js\nvar lib_button = __webpack_require__("eedf");\nvar lib_button_default = /*#__PURE__*/__webpack_require__.n(lib_button);\n\n// CONCATENATED MODULE: ./src/plugins/element-ui.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n * @Author: your name\n * @Date: 2020-10-25 14:45:14\n * @LastEditTime: 2022-08-24 13:09:19\n * @LastEditors: zulezhe\n * @Description: In User Settings Edit\n * @FilePath: \\moafly-spa2\\src\\plugins\\element-ui.js\n */\n\nvue_runtime_esm["default"].use(lib_button_default.a);\nvue_runtime_esm["default"].use(lib_table_default.a);\nvue_runtime_esm["default"].use(lib_table_column_default.a);\nvue_runtime_esm["default"].use(lib_pagination_default.a);\nvue_runtime_esm["default"].use(lib_loading_default.a.directive);\nvue_runtime_esm["default"].prototype.$message = lib_message_default.a;\nvue_runtime_esm["default"].prototype.$loading = {\n  loading: null,\n  open: function open() {\n    var _this = this;\n\n    this.loading = lib_loading_default.a.service({\n      // 声明一个loading对象\n      lock: true,\n      // 是否锁屏\n      text: \'正在加载...\',\n      // 加载动画的文字\n      spinner: \'el-icon-loading\',\n      // 引入的loading图标\n      background: \'rgba(0, 0, 0, 0.5)\',\n      // 背景颜色\n      target: \'.sub-main\',\n      // 需要遮罩的区域\n      body: true,\n      customClass: \'mask\' // 遮罩层新增类名\n\n    });\n    setTimeout(function () {\n      // 设定定时器，超时5S后自动关闭遮罩层，避免请求失败时，遮罩层一直存在的问题\n      _this.loading.close(); // 关闭遮罩层\n\n    }, 5000);\n  },\n  close: function close() {\n    this.loading.close();\n  }\n};\n// CONCATENATED MODULE: ./src/main.js\n/*\n * @Author: zulezhe\n * @Date: 2022-08-22 17:58:57\n * @LastEditors: zulezhe\n * @LastEditTime: 2022-08-24 13:17:59\n * @Path: https://gitee.com/zulezhe/\n * @Description:\n */\n\n\n\n\nvue_runtime_esm["default"].config.productionTip = false;\nnew vue_runtime_esm["default"]({\n  render: function render(h) {\n    return h(App);\n  }\n}).$mount(\'#app\');\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT8zZGZkIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9pbmRleC52dWU/MWU0YiIsIndlYnBhY2s6Ly8vLi9zcmMvd2xlYWZsZXQvdWkvTWFwL2luZGV4LnZ1ZT8yYjk4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcz9hZGUzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyLmpzPzU1MzAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9nbG9iYWwuanM/NGY5MCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy92YWx1ZXMuanM/YjZmNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy9QcmltZU1lcmlkaWFuLmpzPzNmZWUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb25zdGFudHMvdW5pdHMuanM/ZTU2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL21hdGNoLmpzPzc5NzQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qU3RyaW5nLmpzPzUzOWIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3drdC1wYXJzZXIvcGFyc2VyLmpzP2E0Y2QiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3drdC1wYXJzZXIvcHJvY2Vzcy5qcz84MzQ2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93a3QtcGFyc2VyL2luZGV4LmpzP2M0MWIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kZWZzLmpzPzgxNjIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wYXJzZUNvZGUuanM/YTc2YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2V4dGVuZC5qcz8wYjk3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL21zZm56LmpzP2NiNWEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vc2lnbi5qcz9lMDFlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2FkanVzdF9sb24uanM/NzJiMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi90c2Zuei5qcz8xM2ZkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL3BoaTJ6LmpzP2ZmYWMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9tZXJjLmpzPzc2OTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9sb25nbGF0LmpzPzY3NDEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy5qcz9hMDg0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29uc3RhbnRzL0VsbGlwc29pZC5qcz9jMjdkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvZGVyaXZlQ29uc3RhbnRzLmpzPzBjZjMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb25zdGFudHMvRGF0dW0uanM/ODU3MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2RhdHVtLmpzPzEwNGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9uYWRncmlkLmpzPzQ4MDIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9Qcm9qLmpzPzU1OWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kYXR1bVV0aWxzLmpzPzEzOTYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kYXR1bV90cmFuc2Zvcm0uanM/Yzk5NCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2FkanVzdF9heGlzLmpzPzI0YjEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vdG9Qb2ludC5qcz85ZDljIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY2hlY2tTYW5pdHkuanM/ZGIyYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3RyYW5zZm9ybS5qcz81OTIyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29yZS5qcz85MDcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZ3JzL21ncnMuanM/OTEwYSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL1BvaW50LmpzP2NiODYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vcGpfZW5mbi5qcz8yMTc2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL3BqX21sZm4uanM/NzNlYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9wal9pbnZfbWxmbi5qcz9jOTRiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvdG1lcmMuanM/Y2E0YiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9zaW5oLmpzPzJjMjEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vaHlwb3QuanM/OGU4YiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9sb2cxcHkuanM/OTQ2ZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9hc2luaHkuanM/ZmRiMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9nYXRnLmpzP2M0MWIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vY2xlbnMuanM/MGVjNCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9jb3NoLmpzPzZiMDkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vY2xlbnNfY21wbHguanM/YTExZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2V0bWVyYy5qcz9lODc5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2FkanVzdF96b25lLmpzP2FkMTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy91dG0uanM/Y2RjYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9zcmF0LmpzPzRjYmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9nYXVzcy5qcz9lYWRkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvc3RlcmVhLmpzPzk2NjUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zdGVyZS5qcz8yNmM3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvc29tZXJjLmpzPzUyY2UiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9vbWVyYy5qcz9mM2JmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbGNjLmpzPzg4NTQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9rcm92YWsuanM/ZjBmNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9tbGZuLmpzPzEwOGEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vZTBmbi5qcz81MzE3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2UxZm4uanM/YTQ1OSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9lMmZuLmpzP2M2MDYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vZTNmbi5qcz80NTc5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2dOLmpzPzA2YjYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vYWRqdXN0X2xhdC5qcz9hYjBkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2ltbGZuLmpzPzI5MjAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9jYXNzLmpzPzJjMTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vcXNmbnouanM/YTdiNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2xhZWEuanM/YTgxMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9hc2luei5qcz9iNDA3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvYWVhLmpzP2RiNDMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9nbm9tLmpzPzhjM2MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vaXFzZm56LmpzPzdjNTIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9jZWEuanM/ZDYxNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2VxYy5qcz8wZjhiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvcG9seS5qcz84YTk1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbnptZy5qcz8zODIwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbWlsbC5qcz85YWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvc2ludS5qcz8wZTUwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbW9sbC5qcz8yNTA1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvZXFkYy5qcz80NTc1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvdmFuZGcuanM/YWZiNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2FlcWQuanM/YTI0MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL29ydGhvLmpzP2QzY2IiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9xc2MuanM/NDcxOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL3JvYmluLmpzP2MwZDciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9nZW9jZW50LmpzPzQ1Y2UiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy90cGVycy5qcz81MmI1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvZ2Vvcy5qcz85NWI2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9wcm9qcy5qcz81N2FhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvaW5kZXguanM/YTc5ZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVybWFwL2ljbGllbnQtbGVhZmxldC9jb3JlL1Byb2o0TGVhZmxldC5qcz81MDI4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1sZWFmbGV0L2NvcmUvQXR0cmlidXRpb25zLmpzP2VlODIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWxlYWZsZXQvY29yZS9CYXNlLmpzP2E1MTEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9jb21tb250eXBlcy9CYXNlVHlwZXMuanM/ZDMzNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVybWFwL2ljbGllbnQtY29tbW9uL2NvbW1vbnR5cGVzL0dlb21ldHJ5LmpzP2RjOWYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9jb21tb250eXBlcy9VdGlsLmpzP2RlZjkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi91dGlsL0ZldGNoUmVxdWVzdC5qcz81N2FkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vY29tbW9udHlwZXMvQ3JlZGVudGlhbC5qcz85NDY4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vc2VjdXJpdHkvU2VjdXJpdHlNYW5hZ2VyLmpzPzVjOWEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9jb21tb250eXBlcy9TaXplLmpzPzcxYjMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9jb21tb250eXBlcy9QaXhlbC5qcz8zY2IzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vY29tbW9udHlwZXMvTG9uTGF0LmpzPzg1Y2UiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9jb21tb250eXBlcy9Cb3VuZHMuanM/MDkzMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVybWFwL2ljbGllbnQtY29tbW9uL2NvbW1vbnR5cGVzL2dlb21ldHJ5L1BvaW50LmpzPzM3MTQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9jb21tb250eXBlcy9nZW9tZXRyeS9Db2xsZWN0aW9uLmpzPzM4ODMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9jb21tb250eXBlcy9nZW9tZXRyeS9NdWx0aVBvaW50LmpzP2Q4ZjQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9jb21tb250eXBlcy9nZW9tZXRyeS9DdXJ2ZS5qcz8zYTVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vY29tbW9udHlwZXMvZ2VvbWV0cnkvTGluZVN0cmluZy5qcz8yYjcwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vY29tbW9udHlwZXMvZ2VvbWV0cnkvTGluZWFyUmluZy5qcz84YjdmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vY29tbW9udHlwZXMvZ2VvbWV0cnkvTXVsdGlMaW5lU3RyaW5nLmpzP2FhYmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9jb21tb250eXBlcy9nZW9tZXRyeS9Qb2x5Z29uLmpzPzE5ODYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9jb21tb250eXBlcy9nZW9tZXRyeS9NdWx0aVBvbHlnb24uanM/ZmNiMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVybWFwL2ljbGllbnQtY29tbW9uL2lTZXJ2ZXIvU2VydmVyQ29sb3IuanM/NDAzZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVybWFwL2ljbGllbnQtY29tbW9uL2lTZXJ2ZXIvU2VydmVyU3R5bGUuanM/NjFhMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVybWFwL2ljbGllbnQtY29tbW9uL2lTZXJ2ZXIvUG9pbnRXaXRoTWVhc3VyZS5qcz9kYjQ1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vaVNlcnZlci9Sb3V0ZS5qcz9mMjUzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vUkVTVC5qcz82ZjljIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vaVNlcnZlci9TZXJ2ZXJHZW9tZXRyeS5qcz9hYTg1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vY29tbW9udHlwZXMvRmVhdHVyZS5qcz84MmQwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vY29tbW9udHlwZXMvVmVjdG9yLmpzPzgwZTciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9mb3JtYXQvRm9ybWF0LmpzPzU4MzkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9mb3JtYXQvSlNPTi5qcz81MWE4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1jb21tb24vZm9ybWF0L0dlb0pTT04uanM/ODdmZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVybWFwL2ljbGllbnQtY29tbW9uL3V0aWwvTWFwQ2FsY3VsYXRlVXRpbC5qcz9lMjM1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1sZWFmbGV0L2NvcmUvVXRpbC5qcz85ZWI3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJtYXAvaWNsaWVudC1sZWFmbGV0L21hcHBpbmcvVGlsZWRNYXBMYXllci5qcz9iMmU1Iiwid2VicGFjazovLy9zcmMvd2xlYWZsZXQvdWkvTWFwL2luZGV4LnZ1ZT8yYTM4Iiwid2VicGFjazovLy8uL3NyYy93bGVhZmxldC91aS9NYXAvaW5kZXgudnVlPzQ3ZTgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcz8yODc3Iiwid2VicGFjazovLy8uL3NyYy93bGVhZmxldC91aS9NYXAvaW5kZXgudnVlP2NiNDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvVGFibGUvaW5kZXgudnVlP2Y0ZjciLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1RhYmxlL2luZGV4LnZ1ZT9lMzY3Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1RhYmxlL2luZGV4LnZ1ZT82MjFkIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1RhYmxlL2luZGV4LnZ1ZT8wY2ExIiwid2VicGFjazovLy8uL3NyYy93bGVhZmxldC91aS9EcmF3VG9vbC9pbmRleC52dWU/YzkwOCIsIndlYnBhY2s6Ly8vc3JjL3dsZWFmbGV0L3VpL0RyYXdUb29sL2luZGV4LnZ1ZT9iODUxIiwid2VicGFjazovLy8uL3NyYy93bGVhZmxldC91aS9EcmF3VG9vbC9pbmRleC52dWU/NGI5MiIsIndlYnBhY2s6Ly8vLi9zcmMvd2xlYWZsZXQvdWkvRHJhd1Rvb2wvaW5kZXgudnVlPzMwZDciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3ZlY3Rvci52dWU/NTYwYyIsIndlYnBhY2s6Ly8vc3JjL3ZpZXdzL3ZlY3Rvci52dWU/NjFiNSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvdmVjdG9yLnZ1ZT83ZjY4Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy92ZWN0b3IudnVlPzk5MDciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2h1Z2UudnVlPzljODciLCJ3ZWJwYWNrOi8vLy4vc3JjL3dsZWFmbGV0L2NvcmUvbWFya2VyLmpzPzk5MDgiLCJ3ZWJwYWNrOi8vL3NyYy92aWV3cy9odWdlLnZ1ZT81M2NlIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9odWdlLnZ1ZT8yNjg0Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9odWdlLnZ1ZT85MzIyIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9hdm9pZC52dWU/NjYwOCIsIndlYnBhY2s6Ly8vc3JjL3ZpZXdzL2F2b2lkLnZ1ZT9lODVlIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9hdm9pZC52dWU/ZmQyMyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYXZvaWQudnVlPzIwZjAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9pbmRleC5qcz8zNjVjIiwid2VicGFjazovLy9zcmMvdmlld3MvaW5kZXgudnVlPzJkOGYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2luZGV4LnZ1ZT82MjE0Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9pbmRleC52dWU/NmVhMyIsIndlYnBhY2s6Ly8vc3JjL0FwcC52dWU/YzY1ZCIsIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT82MGQwIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlPzMxNWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvZWxlbWVudC11aS5qcz9iNzAzIiwid2VicGFjazovLy8uL3NyYy9tYWluLmpzPzU2ZDciXSwibmFtZXMiOlsicmVuZGVyIiwiX3ZtIiwiX2MiLCJfc2VsZiIsImF0dHJzIiwic3RhdGljUmVuZGVyRm5zIiwic3RhdGljQ2xhc3MiLCJvbiIsIm1hcENvbXBsZXRlIiwibWFwIiwidGFibGVMaXN0IiwibG9hZGluZyIsInBhcmFtcyIsImN1cnJlbnRDaGFuZ2UiLCJyb3dDbGljayIsImN1c3RvbUNsYXNzIiwiZWwiLCJfdCIsIl9lIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29tcG9uZW50cyIsInByb3BzIiwidHlwZSIsIm9wdGlvbnMiLCJjZW50ZXIiLCJ6b29tIiwibWluWm9vbSIsIm1heFpvb20iLCJkYXRhIiwiY29tcHV0ZWQiLCJjcmVhdGVkIiwibW91bnRlZCIsIm1ldGhvZHMiLCJpbml0TWFwIiwibm9XcmFwIiwiY29sbGlzaW9uRmxnIiwid2luZG93IiwibGF5ZXJzIiwicmVuZGVyZXIiLCJDaGluYSIsIkNoaW5hRGFyayIsImFyY2dpcyIsIkwiLCJoYW5kZGxlRm9sZCIsImlzT3BlbiIsInJlcXVpcmUiLCJkaXJlY3RpdmVzIiwibmFtZSIsInJhd05hbWUiLCJleHByZXNzaW9uIiwic3RhdGljU3R5bGUiLCJzaXplIiwicGFnZU51bWJlciIsInRvdGFsIiwicGFnZVNpemUiLCJ2YWwiLCJyb3ciLCJjb2x1bW4iLCJldmVudCIsInBvc2l0aW9uIiwiZHJhd1BvbHlnb24iLCJkcmF3TWFya2VyIiwiZHJhd0NpcmNsZU1hcmtlciIsImRyYXdQb2x5bGluZSIsImRyYXdSZWN0YW5nbGUiLCJkcmF3Q2lyY2xlIiwiZWRpdE1vZGUiLCJkcmFnTW9kZSIsImN1dFBvbHlnb24iLCJyZW1vdmFsTW9kZSIsImNvbG9yIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJjb25zb2xlIiwiaGFuZGxlQ2xpY2siLCJfdiIsIl9zIiwidGV4dCIsImhhcyIsImZlYXR1cmVHcm91cCIsImFkZFZlY3RvckxheWVyIiwiZmV0Y2giLCJ0aGVuIiwicm91dGUiLCJyZW1vdmVWZWN0b3JMYXllciIsIm1vdmUiLCJzZXEiLCJwb2x5bGluZSIsImVhc2luZyIsInJlbW92ZU9uRW5kIiwiaWNvbiIsImh0bWwiLCJpY29uU2l6ZSIsIm1vdGlvbkR1cmF0aW9uIiwiYWRkVG8iLCJzZXFHcm91cCIsInBvcHVwIiwiYWRkTWFya2VyIiwiaXRlbSIsIm1hcmtlciIsIk51bWJlciIsImxhdCIsImxuZyIsImNvZGUiLCJpY29uVXJsIiwiaWNvbkFuY2hvciIsInBvcHVwQW5jaG9yIiwiY2xhc3NOYW1lIiwiY3VzdG9tRGF0YSIsImJpbmRUb29sdGlwIiwiZGlyZWN0aW9uIiwib2Zmc2V0IiwicG9pbnQiLCJvcGVuVG9vbHRpcCIsIm9uQ2xpY2siLCJhZGRNYXJrZXJzIiwibGlzdCIsImFkZExheWVyIiwiZml0Qm91bmRzIiwiZ2V0Qm91bmRzIiwiYWRkSHVnZU1hcmtlcnMiLCJjaUxheWVyIiwiY2FudmFzSWNvbkxheWVyIiwibG9nIiwicmVtb3ZlTWFya2VyIiwiY2xlYXJHcm91cCIsImdyb3VwIiwiY2xlYXJMYXllcnMiLCJmaW5kTWFya2VyIiwidXBkYXRlTWFya2VyIiwib25Nb3VzZW92ZXIiLCJlIiwib25Nb3VzZW91dCIsImNsb3NlVG9vbHRpcCIsImdldExheWVycyIsImxheWVyIiwic2V0SWNvbiIsInNldExhdExuZyIsImxhdGxuZyIsInNldENvbnRlbnQiLCJwcm92aW5jZSIsImhlaWdodCIsIm9wZW5PbiIsImNsb3NlUG9wdXAiLCJfY2xvc2UiLCJzZXRWaWV3TWFya2VycyIsIm1hcmtlcnMiLCJtYXJrZXJCb3VuZHMiLCJsYXRMbmdCb3VuZHMiLCJleHRlbmQiLCJmbHlUbyIsInJhZGl1cyIsInRleHRTdHlsZSIsInN0cm9rZSIsIndpZHRoIiwiaGllZ2h0IiwiZm9udCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZ2V0RGF0YSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJqc29uIiwicmVzIiwic2xpY2UiLCJlcnIiLCJXTWFwIiwiV1RhYmxlIiwiV0RyYXdUb29sIiwiV1ZlY3RvciIsIldIdWdlIiwiV0F2b2lkIiwiYXBpIiwic2V0VGltZW91dCIsIkhvbWUiLCJWdWUiLCJ1c2UiLCJkaXJlY3RpdmUiLCJwcm90b3R5cGUiLCIkbWVzc2FnZSIsIiRsb2FkaW5nIiwib3BlbiIsInNlcnZpY2UiLCJsb2NrIiwic3Bpbm5lciIsImJhY2tncm91bmQiLCJib2R5IiwiY2xvc2UiLCJjb25maWciLCJwcm9kdWN0aW9uVGlwIiwiaCIsIkFwcCIsIiRtb3VudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQUlBLG1EQUFNLEdBQUcs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QUs7QUFDTDtBQUNBLGVBQWUsS0FBSyxDQUFDLHFCQUFhO0FBQ2xDLHdEQUF3RCxHQUFHO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUM1SWMsc0RBQVcsRUFBQzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEhBLElBQUksY0FBRztBQUN1QjtBQUNFOzs7O0FBSWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGNBQUc7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZixhQUFh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O0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sWUFBWSxpQkFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7QUNsUTBEO0FBQ1E7QUFDdEM7O0FBRXJCO0FBQ1AsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixLQUFLLFNBQVMsR0FBRyxRQUFRLEdBQUc7QUFDL0M7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0I7QUFDdEI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBUyxzQkFBTTtBQUN0QixXQUFXO0FBQ1gsa0JBQWtCLEtBQUssQ0FBQyxpQkFBUztBQUNqQztBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9DQSxJQUFJLGFBQU87QUFDaUI7QUFDNUIsYUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7O0FDdEc2Rzs7QUFFN0c7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDLEdBQUc7QUFDSCxxQkFBcUIsU0FBUztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQywrQkFBK0IsVUFBVTtBQUN6QywrQkFBK0IsVUFBVTtBQUN6QywrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxtREFBSyxFQUFDOzs7QUN0Q3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsZ0ZBQWdGO0FBQ2pIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0lvQztBQUNOO0FBQ1U7QUFDK0M7QUFDakQ7QUFDVjtBQUNBO0FBQ1U7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLLENBQUMsYUFBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDLGdCQUFnQixzQkFBUztBQUN6QixZQUFZLFlBQWU7QUFDM0IsaUJBQWlCLFdBQVc7QUFDNUIsK0JBQStCLFNBQUs7QUFDcEM7O0FBRUEsRUFBRSxNQUFNLGFBQWE7QUFDckIsRUFBRSxNQUFNLGdCQUFnQjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ2UsbURBQVUsRUFBQzs7O0FDekViO0FBQ3NEO0FBQzVEO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDLFVBQVU7QUFDN0M7QUFDQSxHQUFHLGdDQUFnQyxVQUFVO0FBQzdDO0FBQ0EsR0FBRztBQUNILGdCQUFnQjtBQUNoQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCLFNBQVM7QUFDVCxjQUFjO0FBQ2QsZUFBZTtBQUNmLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPLHdCQUF3QixPQUFPO0FBQ3hELGdCQUFnQixPQUFPO0FBQ3ZCLEdBQUcscUJBQXFCLE9BQU8sdUJBQXVCLE9BQU87QUFDN0QsZUFBZSxPQUFPO0FBQ3RCLEdBQUcsc0JBQXNCLE9BQU87QUFDaEM7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHLHFCQUFxQixPQUFPO0FBQy9CO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVE7QUFDUixTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFlBQVk7QUFDWixZQUFZO0FBQ1osV0FBVztBQUNYLFdBQVc7QUFDWCxZQUFZO0FBQ1osV0FBVzs7QUFFWDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVAscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlCQUF5QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUCxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHLHlCQUF5QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUM1TzRCOztBQUVtRztBQUNsRjtBQUM3QztBQUNBLG1CQUFtQixVQUFVLGFBQWEsVUFBVTtBQUNwRDs7QUFFZTtBQUNmO0FBQ0EsTUFBTSxhQUFhO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsV0FBVyx3QkFBd0IsV0FBVztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZ0JBQWdCLGtCQUFrQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QyxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLG1CQUFtQjtBQUNoQyxjQUFjLGtCQUFrQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSxVQUFVLG9CQUFvQjs7QUFFOUIsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IscUJBQXFCLFlBQVk7QUFDakMsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTLFVBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsY0FBYztBQUNkLGNBQWM7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9MZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQzVEYztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOztBQ1plO0FBQ2Y7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkb0U7QUFDcEI7QUFDUjtBQUNkO0FBQ2E7QUFDQzs7QUFFeEM7QUFDQSx1Q0FBdUMsVUFBVSxnQ0FBZ0MsVUFBVSxnRUFBZ0UsVUFBVSw4QkFBOEIsVUFBVTtBQUM3TTs7QUFFZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxFQUFFLFdBQVc7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLG1CQUFtQixHQUFHO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixtQkFBbUIsR0FBRztBQUN0QjtBQUNBO0FBQ0EsR0FBRyxPQUFPO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7O0FBRUE7QUFDQTs7O0FDM0YwQjtBQUNVO0FBQ3BDLElBQUksVUFBSyxHQUFHLElBQUk7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiOztBQUVBLFNBQVMsVUFBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQUs7QUFDcEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWUsVUFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLG1EQUFLLEU7Ozs7O0FDbEZwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxJQUFJLE1BQUMsTUFBTTtBQUNYLFdBQVc7QUFDWCxXQUFXO0FBQ1gsSUFBSSxNQUFDLE1BQU07QUFDWCxJQUFJLE1BQUMsTUFBTTtBQUNJO0FBQ2YsV0FBVyxZQUFPO0FBQ2xCLFdBQVcsWUFBTztBQUNsQixXQUFXLFlBQU87QUFDbEIsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDTyxTQUFTLFlBQU87QUFDdkIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNPLFNBQVMsWUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sU0FBUyxZQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsTUFBQztBQUNoQixzQkFBc0IsTUFBQyxHQUFHLE1BQUM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE1BQUM7QUFDaEIsc0JBQXNCLE1BQUMsR0FBRyxNQUFDO0FBQzNCOztBQUVBLGVBQWUsTUFBQztBQUNoQixzQkFBc0IsTUFBQyxHQUFHLE1BQUM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE1BQUM7QUFDaEIsc0JBQXNCLE1BQUMsR0FBRyxNQUFDO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQUM7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFDO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFDO0FBQ2xCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsZUFBZSxNQUFDO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUN6dUJzQzs7QUFFdEMsU0FBUyxXQUFLO0FBQ2Qsd0JBQXdCLFdBQUs7QUFDN0IsZUFBZSxXQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFLO0FBQ0wsYUFBYSxXQUFLLENBQUMsWUFBTztBQUMxQjtBQUNBLFdBQUs7QUFDTCxTQUFTLFlBQU87QUFDaEI7QUFDZSx5REFBSyxFQUFDOzs7QUNqQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FDdkJlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsQzs7QUNKZ0M7QUFDVTs7QUFFMUM7O0FBRWU7QUFDZjtBQUNBO0FBQ0Esd0JBQXdCLEdBQUcsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUNyQkQ7QUFDQTs7QUFFd0M7QUFDQTtBQUNRO0FBQ0Y7O0FBRUs7QUFDakI7O0FBRTNCLFNBQVMsVUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsYUFBTztBQUN2QjtBQUNBOztBQUVBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsYUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFVBQVUsV0FBVzs7QUFFckIsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU8sR0FBRyxJQUFJO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU8sSUFBSSxXQUFLO0FBQ0Q7QUFDZixRQUFRLFVBQUk7QUFDWixXQUFXLGFBQU87QUFDbEIsV0FBVyxhQUFPO0FBQ2xCLFNBQVMsV0FBSztBQUNkLENBQUMsRUFBQzs7O0FDNUthO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsQzs7QUNKZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FDUGM7QUFDZjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FDTDJCO0FBQ0U7O0FBRWY7QUFDZjtBQUNBLE1BQU0sTUFBTSxlQUFlLEtBQUs7O0FBRWhDO0FBQ0EsQ0FBQzs7O0FDUmM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUNkYztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQ2RjO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsQzs7QUNKMEI7QUFDQTs7QUFFWDtBQUNmO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSTtBQUN2QixtQkFBbUIsSUFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FDL0JEO0FBQ0E7O0FBRXlDO0FBQ1A7QUFDRTtBQUNFO0FBQ0o7QUFDRTtBQUNZO0FBQ0Y7O0FBRXZDLFNBQVMsV0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFLO0FBQ1QsbUJBQW1CLEtBQUs7QUFDeEIsbUJBQW1CLEtBQUs7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxJQUFJO0FBQ2QsNEJBQTRCLEtBQUs7QUFDakM7O0FBRU8sU0FBUyxjQUFPO0FBQ3ZCLFdBQVcsVUFBVTtBQUNyQjs7QUFFQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDLE9BQU8sTUFBTTs7QUFFYixZQUFZLFdBQVc7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTyxTQUFTLGNBQU87QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFdBQVc7O0FBRXpCO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSTs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLEtBQUs7QUFDMUM7O0FBRUEsVUFBVSxVQUFVO0FBQ3BCLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVPLElBQUksWUFBSztBQUNEO0FBQ2YsUUFBUSxXQUFJO0FBQ1osV0FBVyxjQUFPO0FBQ2xCLFdBQVcsY0FBTztBQUNsQixTQUFTLFlBQUs7QUFDZCxDQUFDLEVBQUM7OztBQzNLb0M7O0FBRXZCO0FBQ2Y7QUFDQSx1QkFBdUIsVUFBVTs7QUFFakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQ2IrQztBQUNsQjtBQUN2QjtBQUNpQzs7O0FBR2pDLFNBQVMsUUFBSTtBQUNwQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsR0FBRztBQUNsRDtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxNQUFNO0FBQ1IsaUJBQWlCLE1BQU07QUFDdkIsaUJBQWlCLE1BQU07QUFDdkI7O0FBRU8sSUFBSSxTQUFLO0FBQ0Q7QUFDZixRQUFRLFFBQUk7QUFDWixTQUFTLFNBQUs7QUFDZDtBQUNBLENBQUMsRUFBQzs7O0FDM0JhO0FBQ2Y7QUFDQSxDOztBQ0ZrQztBQUNsQyxJQUFJLGNBQVE7QUFDd0M7O0FBRTdDLFNBQVMsVUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNLHlDQUF5QyxNQUFNLGFBQWEsSUFBSTtBQUM3Rzs7QUFFTyxTQUFTLGFBQU87QUFDdkI7QUFDQTs7QUFFQSw2REFBNkQsTUFBTSxhQUFhLElBQUkseUNBQXlDLE9BQU87QUFDcEk7QUFDQTtBQUNBOztBQUVPLFNBQVMsYUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRCxlQUFlLGNBQVEsQ0FBQyxPQUFPO0FBQy9CLDhCQUE4QixJQUFJLDRDQUE0QyxPQUFPO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLElBQUksV0FBSztBQUNEO0FBQ2YsUUFBUSxVQUFJO0FBQ1osV0FBVyxhQUFPO0FBQ2xCLFdBQVcsYUFBTztBQUNsQixTQUFTLFdBQUs7QUFDZCxDQUFDLEVBQUM7OztBQ25EMEI7QUFDa0I7O0FBRXZDLFNBQVMsV0FBSTtBQUNwQixFQUFFLEtBQUs7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxTQUFTLGNBQU87QUFDdkI7QUFDQSxRQUFRLFVBQVU7QUFDbEIsRUFBRSxLQUFLO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sU0FBUyxjQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxLQUFLO0FBQ1AsUUFBUSxVQUFVO0FBQ2xCO0FBQ0E7O0FBRU8sSUFBSSxZQUFLO0FBQ0Q7QUFDZixRQUFRLFdBQUk7QUFDWixXQUFXLGNBQU87QUFDbEIsV0FBVyxjQUFPO0FBQ2xCLFNBQVMsWUFBSztBQUNkLENBQUMsRUFBQzs7O0FDL0RpRDs7QUFFakI7QUFDRTtBQUNBO0FBQ0E7QUFDVTs7QUFFdkM7QUFDUDtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDOztBQUVPLFNBQVMsVUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsS0FBSztBQUMvRSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsS0FBSztBQUMvRSxrQ0FBa0MsS0FBSyx5REFBeUQsS0FBSztBQUNyRztBQUNBLGVBQWUsS0FBSztBQUNwQiwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLFNBQVMsYUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVOztBQUV2Qix3REFBd0QsS0FBSyxpQ0FBaUMsS0FBSztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLFNBQVMsYUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QyxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQSxpQkFBaUIsS0FBSyx5QkFBeUIsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVPLElBQUksV0FBSztBQUNEO0FBQ2YsUUFBUSxVQUFJO0FBQ1osV0FBVyxhQUFPO0FBQ2xCLFdBQVcsYUFBTztBQUNsQixTQUFTLFdBQUs7QUFDZDtBQUNBLENBQUMsRUFBQzs7O0FDN0tGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLFNBQVMsV0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxTQUFTLGNBQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLFNBQVMsY0FBTztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLElBQUksWUFBSztBQUNEO0FBQ2YsUUFBUSxXQUFJO0FBQ1osV0FBVyxjQUFPO0FBQ2xCLFdBQVcsY0FBTztBQUNsQixTQUFTLFlBQUs7QUFDZCxDQUFDLEVBQUM7OztBQ3JGa0M7QUFDVTtBQUNWO0FBQ3NDOztBQUUxRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNPLFNBQVMsVUFBSSxJO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLEdBQUc7QUFDNUM7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixPQUFPLDJDQUEyQyxPQUFPO0FBQ2hGLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsS0FBSztBQUN0QixpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLEtBQUs7QUFDTCxjQUFjLE1BQU07QUFDcEI7O0FBRUEsZ0JBQWdCLFVBQVU7QUFDMUIsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxLO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRCwrQ0FBK0MsTUFBTTtBQUNyRDs7O0FBR0E7QUFDQTtBQUNPLFNBQVMsYUFBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLE9BQU8sSUFBSSxLQUFLO0FBQy9DLDBCQUEwQixLQUFLOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTyxTQUFTLGFBQU87QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBLHlCQUF5QixPQUFPLEdBQUcsT0FBTztBQUMxQyxHQUFHO0FBQ0g7QUFDQSxlQUFlLEtBQUs7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRU8sSUFBSSxXQUFLO0FBQ0Q7QUFDZixRQUFRLFVBQUk7QUFDWixXQUFXLGFBQU87QUFDbEIsV0FBVyxhQUFPO0FBQ2xCLFNBQVMsV0FBSztBQUNkLENBQUMsRUFBQzs7O0FDaFBrQztBQUNBO0FBQ0Y7QUFDWTtBQUNWO0FBQ2U7QUFDNUMsU0FBUyxRQUFJOztBQUVwQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsdUJBQXVCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLOztBQUVqQjtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSzs7QUFFakIsWUFBWSxLQUFLOztBQUVqQix3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTyxTQUFTLFdBQU87O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRCxVQUFVLElBQUksU0FBUyxPQUFPLE9BQU8sS0FBSztBQUMxQzs7QUFFQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBLFlBQVksS0FBSztBQUNqQixTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLFNBQVMsV0FBTzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxJQUFJLFNBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmLFFBQVEsUUFBSTtBQUNaLFdBQVcsV0FBTztBQUNsQixXQUFXLFdBQU87QUFDbEIsU0FBUyxTQUFLO0FBQ2QsQ0FBQyxFQUFDOzs7QUNySjRDOztBQUV2QyxTQUFTLFdBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ08sU0FBUyxjQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLFNBQVMsY0FBTztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU8sSUFBSSxZQUFLO0FBQ0Q7QUFDZixRQUFRLFdBQUk7QUFDWixXQUFXLGNBQU87QUFDbEIsV0FBVyxjQUFPO0FBQ2xCLFNBQVMsWUFBSztBQUNkLENBQUMsRUFBQzs7O0FDekdhO0FBQ2Y7QUFDQSxDOztBQ0ZlO0FBQ2Y7QUFDQSxDOztBQ0ZlO0FBQ2Y7QUFDQSxDOztBQ0ZlO0FBQ2Y7QUFDQSxDOztBQ0ZlO0FBQ2Y7QUFDQSxDOztBQ0ZlO0FBQ2Y7QUFDQTtBQUNBLEM7O0FDSDRDO0FBQ2xCOztBQUVYO0FBQ2Ysd0JBQXdCLE9BQU8sY0FBYyxJQUFJO0FBQ2pELENBQUM7OztBQ0xjO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7QUNma0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNKO0FBQ2dCO0FBQ0E7QUFDVjtBQUNlOztBQUU1QyxTQUFTLFNBQUk7QUFDcEI7QUFDQSxjQUFjLElBQUk7QUFDbEIsY0FBYyxJQUFJO0FBQ2xCLGNBQWMsSUFBSTtBQUNsQixjQUFjLElBQUk7QUFDbEIsd0JBQXdCLElBQUk7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ08sU0FBUyxZQUFPOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSTs7QUFFMUI7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLFNBQVMsWUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsa0NBQWtDLE9BQU8sS0FBSyxLQUFLO0FBQ25EO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLFVBQVU7QUFDbEIsUUFBUSxVQUFVO0FBQ2xCOztBQUVBOztBQUVPLElBQUksVUFBSztBQUNEO0FBQ2YsUUFBUSxTQUFJO0FBQ1osV0FBVyxZQUFPO0FBQ2xCLFdBQVcsWUFBTztBQUNsQixTQUFTLFVBQUs7QUFDZCxDQUFDLEVBQUM7OztBQzNHYTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7QUNSMkQ7O0FBRXZCO0FBQ1U7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7QUFDQTtBQUNBOztBQUVQO0FBQ0E7QUFDTyxTQUFTLFNBQUk7QUFDcEI7QUFDQSxtQkFBbUIsT0FBTyxJQUFJLEtBQUs7QUFDbkM7QUFDQTtBQUNBLHlCQUF5QixLQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTyxTQUFTLFlBQU87O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxVQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLFNBQVMsWUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsVUFBVTtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLElBQUksVUFBSztBQUNEO0FBQ2YsUUFBUSxTQUFJO0FBQ1osV0FBVyxZQUFPO0FBQ2xCLFdBQVcsWUFBTztBQUNsQixTQUFTLFVBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7O0FDelNhO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOztBQ0xvQztBQUNBO0FBQ1U7QUFDVjtBQUNNOztBQUVuQyxTQUFTLFFBQUk7O0FBRXBCLHdDQUF3QyxLQUFLO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxLQUFLOztBQUVsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxLQUFLOztBQUVsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7O0FBRWxCLHdDQUF3QyxLQUFLO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLFNBQVMsV0FBTzs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsS0FBSztBQUNoQjtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sU0FBUyxXQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsVUFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLGVBQWUsS0FBSztBQUNwQjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLElBQUksU0FBSztBQUNEO0FBQ2YsUUFBUSxRQUFJO0FBQ1osV0FBVyxXQUFPO0FBQ2xCLFdBQVcsV0FBTztBQUNsQixTQUFTLFNBQUs7QUFDZDtBQUNBLENBQUMsRUFBQzs7O0FDaEk0QztBQUNWO0FBQ007O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsU0FBSTs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ08sU0FBUyxZQUFPO0FBQ3ZCLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1gsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxTQUFTLFlBQU87QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsS0FBSztBQUNmO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sSUFBSSxVQUFLO0FBQ0Q7QUFDZixRQUFRLFNBQUk7QUFDWixXQUFXLFlBQU87QUFDbEIsV0FBVyxZQUFPO0FBQ2xCLFNBQVMsVUFBSztBQUNkLENBQUMsRUFBQzs7O0FDdkcwQzs7QUFFN0I7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQy9CNkM7QUFDVjtBQUNBO0FBQ0U7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsUUFBSTtBQUNwQjtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLFNBQVMsV0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTyxTQUFTLFdBQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLFVBQVU7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sSUFBSSxTQUFLO0FBQ0Q7QUFDZixRQUFRLFFBQUk7QUFDWixXQUFXLFdBQU87QUFDbEIsV0FBVyxXQUFPO0FBQ2xCLFNBQVMsU0FBSztBQUNkLENBQUMsRUFBQzs7O0FDckU0QztBQUNBOztBQUV2QyxTQUFTLFFBQUk7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDTyxTQUFTLFdBQU87O0FBRXZCO0FBQ0E7O0FBRUEsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ08sU0FBUyxXQUFPOztBQUV2QjtBQUNBOztBQUVBLFFBQVEsVUFBVTtBQUNsQixRQUFRLFVBQVU7QUFDbEI7QUFDQTs7QUFFTyxJQUFJLFNBQUs7QUFDRDtBQUNmLFFBQVEsUUFBSTtBQUNaLFdBQVcsV0FBTztBQUNsQixXQUFXLFdBQU87QUFDbEIsU0FBUyxTQUFLO0FBQ2QsQ0FBQyxFQUFDOzs7QUMvQ2dDO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDQTtBQUNaO0FBQ1E7O0FBRVo7QUFDOUIsSUFBSSxhQUFROztBQUVMLFNBQVMsU0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxZQUFZLElBQUk7QUFDaEIsWUFBWSxJQUFJO0FBQ2hCLFlBQVksSUFBSTtBQUNoQixZQUFZLElBQUk7QUFDaEIsc0JBQXNCLElBQUksZ0RBQWdEO0FBQzFFOztBQUVBO0FBQ0E7QUFDTyxTQUFTLFlBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakI7QUFDQSxtQkFBbUIsSUFBSTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTyxTQUFTLFlBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pELFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBUSxDQUFDLEdBQUc7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFRLENBQUMsR0FBRztBQUMzQjtBQUNBO0FBQ0EsdUJBQXVCLElBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sSUFBSSxVQUFLO0FBQ0Q7QUFDZixRQUFRLFNBQUk7QUFDWixXQUFXLFlBQU87QUFDbEIsV0FBVyxZQUFPO0FBQ2xCLFNBQVMsVUFBSztBQUNkLENBQUMsRUFBQzs7O0FDdEk2Qzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRUEsU0FBUyxTQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTLFlBQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsWUFBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVPLElBQUksVUFBSztBQUNEO0FBQ2YsUUFBUSxTQUFJO0FBQ1osV0FBVyxZQUFPO0FBQ2xCLFdBQVcsWUFBTztBQUNsQixTQUFTLFVBQUs7QUFDZCxDQUFDLEVBQUM7OztBQ2pPNEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDTyxTQUFTLFNBQUk7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ08sU0FBUyxZQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLFNBQVMsWUFBTztBQUN2QjtBQUNBOztBQUVBLFlBQVksVUFBVTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxJQUFJLFVBQUs7QUFDRDtBQUNmLFFBQVEsU0FBSTtBQUNaLFdBQVcsWUFBTztBQUNsQixXQUFXLFlBQU87QUFDbEIsU0FBUyxVQUFLO0FBQ2QsQ0FBQyxFQUFDOzs7QUNuRDRDO0FBQ0E7QUFDTjtBQUN4QyxJQUFJLGFBQVE7QUFDNEI7QUFDUTtBQUNHOztBQUVmOzs7QUFHN0IsU0FBUyxTQUFJO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNPLFNBQVMsWUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBUSxDQUFDLEdBQUc7QUFDL0I7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLFNBQVMsWUFBTztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBLGtCQUFrQixLQUFLLElBQUksT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxJQUFJLFVBQUs7QUFDRDtBQUNmLFFBQVEsU0FBSTtBQUNaLFdBQVcsWUFBTztBQUNsQixXQUFXLFlBQU87QUFDbEIsU0FBUyxVQUFLO0FBQ2QsQ0FBQyxFQUFDOzs7QUNsSDRDO0FBQ3ZDLFNBQVMsU0FBSTtBQUNzQjtBQUMxQztBQUNBO0FBQ08sU0FBUyxZQUFPOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxTQUFTLFlBQU87QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sSUFBSSxVQUFLO0FBQ0Q7QUFDZixRQUFRLFNBQUk7QUFDWixXQUFXLFlBQU87QUFDbEIsV0FBVyxZQUFPO0FBQ2xCLFNBQVMsVUFBSztBQUNkLENBQUMsRUFBQzs7O0FDbEZnQztBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDWTtBQUNBO0FBQ1Y7QUFDTTs7QUFFbkMsU0FBUyxTQUFJOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUk7QUFDaEIsWUFBWSxJQUFJO0FBQ2hCLFlBQVksSUFBSTtBQUNoQixZQUFZLElBQUk7O0FBRWhCO0FBQ0E7O0FBRUEsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsSUFBSTs7QUFFakIsd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLFNBQVMsWUFBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLFNBQVMsWUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFVBQVU7QUFDcEIsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTyxJQUFJLFVBQUs7QUFDRDtBQUNmLFFBQVEsU0FBSTtBQUNaLFdBQVcsWUFBTztBQUNsQixXQUFXLFlBQU87QUFDbEIsU0FBUyxVQUFLO0FBQ2QsQ0FBQyxFQUFDOzs7QUNwSDRDOztBQUVLOztBQUVmOztBQUVwQztBQUNBO0FBQ08sU0FBUyxVQUFJO0FBQ3BCLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVPLFNBQVMsYUFBTzs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQix5QkFBeUIsS0FBSywrQkFBK0IsT0FBTyxLQUFLLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTyxTQUFTLGFBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxJQUFJLFdBQUs7QUFDRDtBQUNmLFFBQVEsVUFBSTtBQUNaLFdBQVcsYUFBTztBQUNsQixXQUFXLGFBQU87QUFDbEIsU0FBUyxXQUFLO0FBQ2QsQ0FBQyxFQUFDOzs7QUNoSTRDO0FBQ0s7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSjtBQUNNO0FBQ0E7Ozs7QUFJN0IsU0FBUyxTQUFJO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFTyxTQUFTLFlBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkMsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hEO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkMsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYixTQUFTLElBQUk7QUFDYixTQUFTLElBQUk7QUFDYixTQUFTLElBQUk7QUFDYixzQ0FBc0MsS0FBSztBQUMzQztBQUNBLHFCQUFxQixJQUFJLGlCQUFpQixPQUFPO0FBQ2pELG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQSxxQkFBcUIsSUFBSSxpQkFBaUIsT0FBTztBQUNqRCxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksRUFBRTtBQUNkLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRU8sU0FBUyxZQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixrQ0FBa0MsT0FBTztBQUN6QywyQkFBMkIsS0FBSztBQUNoQztBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxjQUFjLFVBQVU7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2IsU0FBUyxJQUFJO0FBQ2IsU0FBUyxJQUFJO0FBQ2IsU0FBUyxJQUFJO0FBQ2Isc0NBQXNDLEtBQUs7QUFDM0M7QUFDQSxxQkFBcUIsSUFBSSxpQkFBaUIsT0FBTztBQUNqRDtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hEO0FBQ0EscUJBQXFCLElBQUksaUJBQWlCLE9BQU87QUFDakQ7QUFDQTs7QUFFQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPLElBQUksVUFBSztBQUNEO0FBQ2YsUUFBUSxTQUFJO0FBQ1osV0FBVyxZQUFPO0FBQ2xCLFdBQVcsWUFBTztBQUNsQixTQUFTLFVBQUs7QUFDZCxDQUFDLEVBQUM7OztBQy9NNEM7QUFDVjtBQUNlOztBQUU1QyxTQUFTLFVBQUk7QUFDcEIsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTyxTQUFTLGFBQU87QUFDdkIscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWCxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sU0FBUyxhQUFPO0FBQ3ZCLFNBQVM7QUFDVCxRQUFRO0FBQ1IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLOztBQUVYO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLO0FBQ2IsOEJBQThCLE9BQU87QUFDckMsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxVQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVPLElBQUksV0FBSztBQUNEO0FBQ2YsUUFBUSxVQUFJO0FBQ1osV0FBVyxhQUFPO0FBQ2xCLFdBQVcsYUFBTztBQUNsQixTQUFTLFdBQUs7QUFDZCxDQUFDLEVBQUM7OztBQzFGRjtBQUNBOztBQUV3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxTQUFTLFFBQUk7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPLEdBQUcsTUFBTTtBQUNuQztBQUNBLEdBQUcseUJBQXlCLE9BQU8sR0FBRyxNQUFNO0FBQzVDO0FBQ0EsR0FBRyxrQ0FBa0MsTUFBTTtBQUMzQztBQUNBLEdBQUcsa0NBQWtDLE9BQU8sR0FBRyxNQUFNO0FBQ3JEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLFNBQVMsV0FBTztBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLGVBQWUsTUFBTSxXQUFXLE9BQU8sR0FBRyxNQUFNO0FBQ2hEO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IsS0FBSyxnQkFBZ0IsT0FBTyxHQUFHLE1BQU0sYUFBYSxPQUFPLEdBQUcsTUFBTTtBQUNsRTtBQUNBLGlDQUFpQyxHQUFHLFNBQVMsR0FBRztBQUNoRCxLQUFLLGtCQUFrQixPQUFPLEdBQUcsTUFBTSxhQUFhLE1BQU07QUFDMUQ7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVUsT0FBTztBQUNqQixlQUFlLE1BQU0sV0FBVyxPQUFPLEdBQUcsTUFBTTtBQUNoRDtBQUNBLHFCQUFxQixPQUFPO0FBQzVCLEtBQUssZ0JBQWdCLE1BQU0sWUFBWSxNQUFNO0FBQzdDO0FBQ0E7QUFDQSxLQUFLLGlCQUFpQixNQUFNLGFBQWEsT0FBTyxHQUFHLE1BQU07QUFDekQ7QUFDQSxxQkFBcUIsT0FBTztBQUM1QixLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsR0FBRyxVQUFVLEdBQUc7QUFDbEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUMsS0FBSztBQUNMLHVDQUF1QyxHQUFHO0FBQzFDLEtBQUs7QUFDTCx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixHQUFHLGtEQUFrRCxNQUFNLEtBQUssT0FBTztBQUM5Rjs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLEdBQUc7QUFDSCxVQUFVLEdBQUc7QUFDYixHQUFHO0FBQ0gsZ0JBQWdCLEdBQUc7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ08sU0FBUyxXQUFPO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxVQUFVLE9BQU87QUFDakIsR0FBRztBQUNIO0FBQ0EsMEJBQTBCLEdBQUcsUUFBUSxHQUFHO0FBQ3hDLEdBQUc7QUFDSDtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSx1QkFBdUIsT0FBTztBQUM5QixLQUFLO0FBQ0wsc0NBQXNDLEdBQUcsV0FBVyxHQUFHO0FBQ3ZELEtBQUs7QUFDTCx1QkFBdUIsT0FBTztBQUM5QixLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixPQUFPO0FBQy9CLEtBQUs7QUFDTCx1Q0FBdUMsR0FBRyxZQUFZLEdBQUc7QUFDekQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BELEtBQUs7QUFDTCw2Q0FBNkMsR0FBRztBQUNoRCxLQUFLO0FBQ0wsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBLEtBQUssa0JBQWtCLE1BQU0sYUFBYSxPQUFPLEdBQUcsTUFBTTtBQUMxRDtBQUNBLGVBQWUsT0FBTztBQUN0QixLQUFLLGtCQUFrQixPQUFPLEdBQUcsTUFBTSxlQUFlLE9BQU8sR0FBRyxNQUFNO0FBQ3RFO0FBQ0Esc0NBQXNDLEdBQUcsV0FBVyxHQUFHO0FBQ3ZELEtBQUs7QUFDTDtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakIsWUFBWSxNQUFNO0FBQ2xCLEdBQUcsa0JBQWtCLEdBQUc7QUFDeEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFTyxJQUFJLFNBQUs7QUFDRDtBQUNmLFFBQVEsUUFBSTtBQUNaLFdBQVcsV0FBTztBQUNsQixXQUFXLFdBQU87QUFDbEIsU0FBUyxTQUFLO0FBQ2QsQ0FBQyxFQUFDOzs7O0FDOVdGO0FBQ0E7QUFDQTs7QUFFNkQ7QUFDZjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLEdBQUc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLFNBQVMsVUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sU0FBUyxhQUFPO0FBQ3ZCLGNBQWMsVUFBVTs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLFNBQVMsYUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQSwyQkFBMkIsT0FBTyxHQUFHLE9BQU87QUFDNUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUssS0FBSzs7QUFFbkI7QUFDQSw2QkFBNkIsR0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFTyxJQUFJLFdBQUs7QUFDRDtBQUNmLFFBQVEsVUFBSTtBQUNaLFdBQVcsYUFBTztBQUNsQixXQUFXLGFBQU87QUFDbEIsU0FBUyxXQUFLO0FBQ2QsQ0FBQyxFQUFDOzs7QUM3SnFCOztBQUVoQixTQUFTLFlBQUk7QUFDcEI7O0FBRUE7O0FBRU8sU0FBUyxlQUFPO0FBQ3ZCLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTs7QUFFTyxTQUFTLGVBQU87QUFDdkIsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBOztBQUVPLElBQUksYUFBSztBQUNEO0FBQ2YsVUFBVSxZQUFJO0FBQ2QsYUFBYSxlQUFPO0FBQ3BCLGFBQWEsZUFBTztBQUNwQixXQUFXLGFBQUs7QUFDaEIsQ0FBQyxFOzs7QUN6QkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwRDtBQUN0Qjs7QUFFcEMsSUFBSSxZQUFNO0FBQ1YsVUFBVSx5QkFBeUI7QUFDbkMsVUFBVSxtQ0FBbUM7QUFDN0MsVUFBVSxtQ0FBbUM7QUFDN0MsVUFBVSxvQkFBb0I7QUFDOUIsVUFBVSxvQkFBb0I7QUFDOUI7O0FBRU8sU0FBUyxVQUFJO0FBQ3BCLGNBQWMsWUFBTTtBQUNwQjtBQUNBLGdCQUFnQixZQUFNO0FBQ3RCLEtBQUssVUFBVSxZQUFNO0FBQ3JCO0FBQ0EsS0FBSyxVQUFVLFlBQU07QUFDckI7QUFDQTtBQUNBLFFBQVEsWUFBTTtBQUNkLDBCQUEwQixHQUFHO0FBQzdCO0FBQ0EsR0FBRzs7QUFFSCxzQ0FBc0MsT0FBTyxLQUFLLEtBQUs7QUFDdkQ7QUFDQSxHQUFHLGdDQUFnQyxLQUFLO0FBQ3hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sU0FBUyxhQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxTQUFTLGFBQU87QUFDdkI7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxLQUFLO0FBQ2hCLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sSUFBSSxXQUFLO0FBQ0Q7QUFDZixRQUFRLFVBQUk7QUFDWixXQUFXLGFBQU87QUFDbEIsV0FBVyxhQUFPO0FBQ2xCLFNBQVMsV0FBSztBQUNkLENBQUMsRUFBQzs7O0FDeEtrQzs7QUFFN0IsU0FBUyxTQUFJO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFlBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxLQUFLOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxZQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQsU0FBUztBQUNUO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxJQUFJLFVBQUs7QUFDRDtBQUNmLFVBQVUsU0FBSTtBQUNkLGFBQWEsWUFBTztBQUNwQixhQUFhLFlBQU87QUFDcEIsV0FBVyxVQUFLO0FBQ2hCLENBQUMsRUFBQzs7OztBQzdKMEM7QUFDRTtBQUNOO0FBQ007QUFDRjtBQUNFO0FBQ0Y7QUFDSjtBQUNNO0FBQ0o7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0o7QUFDSTtBQUNJO0FBQ0o7QUFDRjtBQUMzQjtBQUNmLDZCQUE2QixLQUFLO0FBQ2xDLDZCQUE2QixNQUFNO0FBQ25DLDZCQUE2QixHQUFHO0FBQ2hDLDZCQUE2QixNQUFNO0FBQ25DLDZCQUE2QixLQUFLO0FBQ2xDLDZCQUE2QixNQUFNO0FBQ25DLDZCQUE2QixLQUFLO0FBQ2xDLDZCQUE2QixHQUFHO0FBQ2hDLDZCQUE2QixNQUFNO0FBQ25DLDZCQUE2QixJQUFJO0FBQ2pDLDZCQUE2QixJQUFJO0FBQ2pDLDZCQUE2QixHQUFHO0FBQ2hDLDZCQUE2QixJQUFJO0FBQ2pDLDZCQUE2QixHQUFHO0FBQ2hDLDZCQUE2QixHQUFHO0FBQ2hDLDZCQUE2QixJQUFJO0FBQ2pDLDZCQUE2QixJQUFJO0FBQ2pDLDZCQUE2QixJQUFJO0FBQ2pDLDZCQUE2QixJQUFJO0FBQ2pDLDZCQUE2QixJQUFJO0FBQ2pDLDZCQUE2QixJQUFJO0FBQ2pDLDZCQUE2QixLQUFLO0FBQ2xDLDZCQUE2QixJQUFJO0FBQ2pDLDZCQUE2QixLQUFLO0FBQ2xDLDZCQUE2QixHQUFHO0FBQ2hDLDZCQUE2QixLQUFLO0FBQ2xDLDZCQUE2QixPQUFPO0FBQ3BDLDZCQUE2QixLQUFLO0FBQ2xDLDZCQUE2QixJQUFJO0FBQ2pDLEM7O0FDM0QyQjtBQUNEO0FBQ0U7QUFDVTtBQUNaO0FBQ007QUFDSTtBQUNaO0FBQ21COztBQUUzQyxJQUFLLHdCQUF3QjtBQUM3QixJQUFLLFFBQVEsSUFBSTtBQUNqQixJQUFLLGFBQWEsSUFBSztBQUN2QixJQUFLLFNBQVMsU0FBSztBQUNuQixJQUFLLFdBQVcsT0FBTTtBQUN0QixJQUFLLFFBQVEsUUFBSTtBQUNqQixJQUFLLFdBQVcsT0FBTztBQUN2QixJQUFLLGFBQWEsU0FBUztBQUMzQixJQUFLLFFBQVEsSUFBSTtBQUNqQixJQUFLO0FBQ0wsV0FBbUIsQ0FBQyxJQUFLO0FBQ1YsNENBQUssRUFBQzs7O0FDckJyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0I7QUFDRTs7QUFFMUIsZUFBZSxHQUFLO0FBQ3BCLGlCQUFpQixHQUFLO0FBQ3RCLHFCQUFDLFFBQVEscUJBQUM7O0FBRVYscUJBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTyxxQkFBcUIsV0FBVztBQUNsRCxXQUFXLFNBQVM7QUFDcEI7QUFDQSxxQkFBQyxtQkFBbUIscUJBQUM7QUFDckI7QUFDQSxtQkFBbUIscUJBQUM7QUFDcEI7QUFDQTtBQUNBLFlBQVkscUJBQUM7QUFDYiwyQkFBMkIscUJBQUM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQUM7QUFDcEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQUM7QUFDcEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsWUFBWSxHQUFLO0FBQ2pCLFNBQVMsVUFBVSxHQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEdBQUs7QUFDckI7QUFDQTtBQUNBOztBQUVBLGVBQWUsR0FBSztBQUNwQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPLCtCQUErQjtBQUNqRCxXQUFXLHlCQUF5QjtBQUNwQyxXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ08sVUFBVSxxQkFBQztBQUNsQixjQUFjLHFCQUFDOztBQUVmO0FBQ0EsNEJBQTRCLHFCQUFDO0FBQzdCLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxZQUFZLHFCQUFDO0FBQ2I7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxxQkFBQztBQUNuQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFDO0FBQ25DOztBQUVBLFFBQVEscUJBQUM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFCQUFDO0FBQ2hEO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkJBQTJCLDJDQUEyQztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2REFBNkQsUUFBUTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsY0FBYyxxQkFBQzs7QUFFZixPQUFPLHFCQUFDOztBQUVSO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ00sSUFBSSxnQkFBRztBQUNkO0FBQ0E7Ozs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhIQUE4SCxXQUFXLFVBQVU7QUFDbko7QUFDQTs7QUFFZSxrRTs7QUNoRGY7QUFDQTtBQUNBO0FBQ3dCO0FBQ0E7QUFDa0I7O0FBRTFDLHFCQUFDO0FBQ0Q7QUFDQTtBQUNBLGdCQUFnQixpQkFBWTtBQUM1QjtBQUNBLENBQUM7QUFDRCxxQkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBQztBQUMzQztBQUNBLGVBQWUscUJBQUM7QUFDaEI7QUFDQSxDQUFDO0FBQ0QsZUFBZSxxQkFBQyxXQUFXLHFCQUFDLFVBQVUscUJBQUMsU0FBUyxxQkFBQyxlQUFlLHFCQUFDLFNBQVMscUJBQUM7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTCxDOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQSxDQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMsMEJBQTBCLFFBQVEsb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDLDBCQUEwQixRQUFRLG9CQUFvQjtBQUN0RDtBQUNBLG9CQUFvQixHQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCLDBCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7QUFDQSxlQUFlLE9BQU8sMkNBQTJDLE1BQU07QUFDdkUsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsT0FBTztBQUN2Qix1REFBdUQsV0FBVztBQUNsRTtBQUNBLG1CQUFtQixFQUFFLElBQUksTUFBTSxJQUFJLElBQUksSUFBSTtBQUMzQztBQUNBLHFCQUFxQixXQUFXOztBQUVoQztBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUNsZEE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxPQUFPO0FBQ1U7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSxpQkFBUTs7O0FBR3JCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJOztBQUV0QjtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFRO0FBQzNCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Qsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNLQTtBQUNBO0FBQ0E7QUFDd0M7QUFDRjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVSxRQUFRLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWEsUUFBUSxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTLEVBQUUsUUFBUSxFQUFFLHVCQUF1QixTQUFTLE9BQU87QUFDNUU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qyx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLFdBQVc7QUFDWCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxjQUFjO0FBQzNCLGFBQWEsY0FBYztBQUMzQixhQUFhLGNBQWM7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixpQkFBUTtBQUNyQyxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsU0FBUztBQUNULHNDQUFzQztBQUN0QztBQUNBLE9BQU87QUFDUCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU8sc0JBQXNCLE1BQU07QUFDaEQsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVvRjs7Ozs7Ozs7Ozs7OztBQzlzQ3BGO0FBQ0E7QUFDQTtBQUN3QztBQUNyQjtBQUNrQjtBQUNNOztBQUUzQyxJQUFJLGtCQUFLO0FBQ0Y7QUFDUCxJQUFJLGtCQUFLO0FBQ1Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBVTtBQUN4QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQSxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVUsUUFBUSxJQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUyxRQUFRLElBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBLEtBQUssVUFBVTs7QUFFZjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVSxvQkFBb0IsUUFBUSxJQUFJOztBQUUxQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBLEtBQUssVUFBVTs7QUFFZjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVSxvQkFBb0IsUUFBUSxJQUFJOztBQUUxQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWUsUUFBUSxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUkscURBQXFEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSSxxREFBcUQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlLGtCQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLHFCQUFVO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7O0FDcmtCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQzdGQTtBQUNBO0FBQ0E7QUFDMkM7QUFDUztBQUNHOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hELE9BQU8sa0NBQWtDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNPLE1BQU0sK0JBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsc0JBQXNCO0FBQ3JDLGlCQUFpQixRQUFRO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxJQUFJO0FBQ2xCLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQWU7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUSxnQkFBZ0I7QUFDekM7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQWU7QUFDZiwrQkFBZTtBQUNmLCtCQUFlO0FBQ2YsK0JBQWU7OztBQ2xZZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU0sV0FBVyxZQUFZO0FBQzFDLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdLQTtBQUNBO0FBQ0E7QUFDNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSxhQUFNOzs7QUFHbkI7QUFDQSxZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0EseUJBQXlCLElBQUk7O0FBRTdCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLG1CQUFtQixhQUFNO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQU0sWUFBWSxJQUFJO0FBQ3pDLHVCQUF1QixJQUFJO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTyxFQUFFLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQU07QUFDekI7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDLGVBQWUsZUFBZTtBQUM5QixpQkFBaUIsT0FBTyxFQUFFLGFBQWE7QUFDdkM7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQSxtQkFBbUIsYUFBTTtBQUN6Qjs7O0FBR0E7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQzRCO0FBQ0U7QUFDRTtBQUNKOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNPLE1BQU0sYUFBTTs7O0FBR25CO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTs7QUFFdkM7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7O0FBRTNDO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLHFDQUFxQyxJQUFJOztBQUV6QztBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTs7QUFFckM7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxtQkFBbUIsYUFBTTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixhQUFNO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQU07QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQU07QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRyw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNkJBQTZCO0FBQ3pGLGFBQWE7QUFDYjtBQUNBLDREQUE0RCw2QkFBNkI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBTTtBQUN0QixnQkFBZ0IsYUFBTTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxtQkFBbUIsYUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDcUM7QUFDSjtBQUNKOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSxvQkFBSyxTQUFTLGlCQUFROzs7QUFHbkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBSztBQUMzQjs7QUFFQTtBQUNBLFFBQVEsSUFBSTs7QUFFWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBTTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQzdJQTtBQUNBO0FBQ0E7QUFDaUM7QUFDSTtBQUNSOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0scUJBQVUsU0FBUyxpQkFBUTs7O0FBR3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0EsMkJBQTJCLHFCQUFVO0FBQ3JDLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQUk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBTTtBQUMvQjtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxRQUFRLElBQUk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RCxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZLElBQUk7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVCx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUNwUEE7QUFDQTtBQUNBO0FBQ3dDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0scUJBQVUsU0FBUyxxQkFBVTs7O0FBRzFDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIseURBQXlEO0FBQ3RGLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw2QkFBNkIsNERBQTREO0FBQ3pGLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSxXQUFLLFNBQVMscUJBQVU7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7OztBQ25DQTtBQUNBO0FBQ0E7QUFDOEI7QUFDQTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLHFCQUFVLFNBQVMsV0FBSzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQSw4QkFBOEIscUJBQVU7QUFDeEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixxQkFBVTtBQUN6QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEJBQTRCLHFCQUFVO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0JBQStCLHFCQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBVTtBQUNsQyxTQUFTO0FBQ1Qsd0JBQXdCLHFCQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pVQTtBQUNBO0FBQ0E7QUFDd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLHFCQUFVLFNBQVMscUJBQVU7OztBQUcxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsYUFBYTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDd0M7QUFDbEI7OztBQUd0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0sK0JBQWUsU0FBUyxxQkFBVTs7O0FBRy9DO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FDeENBO0FBQ0E7QUFDQTtBQUN3QztBQUN2QjtBQUNLO0FBQ0E7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLGVBQU8sU0FBUyxxQkFBVTs7O0FBR3ZDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FDMURBO0FBQ0E7QUFDQTtBQUN3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0seUJBQVksU0FBUyxxQkFBVTs7O0FBRzVDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FDMUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDTzs7QUFFUDs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDeUM7QUFDQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDTyxNQUFNLHVCQUFXOztBQUV4QjtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBLGlDQUFpQyxXQUFXOztBQUU1QztBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVzs7QUFFNUM7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBLDZCQUE2QixXQUFXOztBQUV4QztBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBVztBQUM5QiwyQkFBMkIsV0FBVztBQUN0QztBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7Ozs7O0FDak5BO0FBQ0E7QUFDQTtBQUN5QztBQUNXOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ08sTUFBTSxpQ0FBZ0IsU0FBUyxvQkFBSzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksSUFBSTtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RCxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ3FCO0FBQ0E7QUFDVjtBQUNVOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ08sTUFBTSxXQUFLLFNBQVMscUJBQVU7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksSUFBSTtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRSw0RUFBNEUsVUFBVTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsU0FBUztBQUNwRSwrQkFBK0IsaUJBQWlCO0FBQ2hELG1DQUFtQyxpQ0FBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQVU7QUFDaEQsaUJBQWlCO0FBQ2pCLHNDQUFzQyxxQkFBVTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUEsbUJBQW1CLFdBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7O0FDdk9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYSxRQUFRLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWEsUUFBUSxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZSxRQUFRLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYyxRQUFRLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVcsUUFBUSxJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUIsUUFBUSxJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0IsUUFBUSxJQUFJO0FBQzdDO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYyxRQUFRLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyxRQUFRLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CLFFBQVEsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElB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O0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlLFFBQVEsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0IsUUFBUSxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYyxRQUFRLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYSxRQUFRLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCLFFBQVEsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixRQUFRLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXLFFBQVEsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYSxRQUFRLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZLFFBQVEsSUFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0IsUUFBUSxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0IsUUFBUSxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0IsUUFBUSxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUIsUUFBUSxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFD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QUFwQnNCLENBQXpCLEM7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBWiwwQkFBRyxDQUFDYSxNQUFKLENBQVdDLGFBQVgsR0FBMkIsS0FBM0I7QUFDQSxJQUFJZCwwQkFBSixDQUFRO0VBQ043TSxNQUFNLEVBQUUsZ0JBQUE0TixDQUFDO0lBQUEsT0FBSUEsQ0FBQyxDQUFDQyxHQUFELENBQUw7RUFBQTtBQURILENBQVIsRUFFR0MsTUFGSCxDQUVVLE1BRlYiLCJmaWxlIjoiNTZkNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKXt2YXIgX3ZtPXRoaXMsX2M9X3ZtLl9zZWxmLl9jO3JldHVybiBfYygnZGl2Jyx7YXR0cnM6e1wiaWRcIjpcImFwcFwifX0sW19jKCdIb21lJyldLDEpXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKXt2YXIgX3ZtPXRoaXMsX2M9X3ZtLl9zZWxmLl9jO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJob21lLWNvbnRhaW5lclwifSxbX2MoJ1dNYXAnLHtvbjp7XCJtYXBDb21wbGV0ZVwiOl92bS5tYXBDb21wbGV0ZX19LFtfYygnV0RyYXdUb29sJyx7YXR0cnM6e1wibWFwXCI6X3ZtLm1hcH19KV0sMSksX2MoJ1dUYWJsZScse2F0dHJzOntcInRhYmxlTGlzdFwiOl92bS50YWJsZUxpc3QsXCJsb2FkaW5nXCI6X3ZtLmxvYWRpbmcsXCJwYXJhbXNcIjpfdm0ucGFyYW1zfSxvbjp7XCJjdXJyZW50Q2hhbmdlXCI6X3ZtLmN1cnJlbnRDaGFuZ2UsXCJyb3dDbGlja1wiOl92bS5yb3dDbGlja319KSxfYygnV1ZlY3RvcicpLF9jKCdXSHVnZScpLF9jKCdXQXZvaWQnKV0sMSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpe3ZhciBfdm09dGhpcyxfYz1fdm0uX3NlbGYuX2M7cmV0dXJuIF9jKCdkaXYnLHtjbGFzczpbJ3djeC1tYXAtY29udGFpbmVyJywgX3ZtLmN1c3RvbUNsYXNzXSxhdHRyczp7XCJpZFwiOl92bS5lbH19LFsoX3ZtLm1hcCk/W192bS5fdChcImRlZmF1bHRcIixudWxsLHtcIm1hcFwiOl92bS5tYXB9KV06X3ZtLl9lKCldLDIpXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSIsImltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tIFwiLi9kZWZpbmVQcm9wZXJ0eS5qc1wiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWZzKSB7XG4gIGRlZnMoJ0VQU0c6NDMyNicsIFwiK3RpdGxlPVdHUyA4NCAobG9uZy9sYXQpICtwcm9qPWxvbmdsYXQgK2VsbHBzPVdHUzg0ICtkYXR1bT1XR1M4NCArdW5pdHM9ZGVncmVlc1wiKTtcbiAgZGVmcygnRVBTRzo0MjY5JywgXCIrdGl0bGU9TkFEODMgKGxvbmcvbGF0KSArcHJvaj1sb25nbGF0ICthPTYzNzgxMzcuMCArYj02MzU2NzUyLjMxNDE0MDM2ICtlbGxwcz1HUlM4MCArZGF0dW09TkFEODMgK3VuaXRzPWRlZ3JlZXNcIik7XG4gIGRlZnMoJ0VQU0c6Mzg1NycsIFwiK3RpdGxlPVdHUyA4NCAvIFBzZXVkby1NZXJjYXRvciArcHJvaj1tZXJjICthPTYzNzgxMzcgK2I9NjM3ODEzNyArbGF0X3RzPTAuMCArbG9uXzA9MC4wICt4XzA9MC4wICt5XzA9MCAraz0xLjAgK3VuaXRzPW0gK25hZGdyaWRzPUBudWxsICtub19kZWZzXCIpO1xuXG4gIGRlZnMuV0dTODQgPSBkZWZzWydFUFNHOjQzMjYnXTtcbiAgZGVmc1snRVBTRzozNzg1J10gPSBkZWZzWydFUFNHOjM4NTcnXTsgLy8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0LCBvZmZpY2lhbCBjb2RlIGlzIDM4NTdcbiAgZGVmcy5HT09HTEUgPSBkZWZzWydFUFNHOjM4NTcnXTtcbiAgZGVmc1snRVBTRzo5MDA5MTMnXSA9IGRlZnNbJ0VQU0c6Mzg1NyddO1xuICBkZWZzWydFUFNHOjEwMjExMyddID0gZGVmc1snRVBTRzozODU3J107XG59XG4iLCJleHBvcnQgdmFyIFBKRF8zUEFSQU0gPSAxO1xuZXhwb3J0IHZhciBQSkRfN1BBUkFNID0gMjtcbmV4cG9ydCB2YXIgUEpEX0dSSURTSElGVCA9IDM7XG5leHBvcnQgdmFyIFBKRF9XR1M4NCA9IDQ7IC8vIFdHUzg0IG9yIGVxdWl2YWxlbnRcbmV4cG9ydCB2YXIgUEpEX05PREFUVU0gPSA1OyAvLyBXR1M4NCBvciBlcXVpdmFsZW50XG5leHBvcnQgdmFyIFNSU19XR1M4NF9TRU1JTUFKT1IgPSA2Mzc4MTM3LjA7ICAvLyBvbmx5IHVzZWQgaW4gZ3JpZCBzaGlmdCB0cmFuc2Zvcm1zXG5leHBvcnQgdmFyIFNSU19XR1M4NF9TRU1JTUlOT1IgPSA2MzU2NzUyLjMxNDsgIC8vIG9ubHkgdXNlZCBpbiBncmlkIHNoaWZ0IHRyYW5zZm9ybXNcbmV4cG9ydCB2YXIgU1JTX1dHUzg0X0VTUVVBUkVEID0gMC4wMDY2OTQzNzk5OTAxNDEzMTY1OyAvLyBvbmx5IHVzZWQgaW4gZ3JpZCBzaGlmdCB0cmFuc2Zvcm1zXG5leHBvcnQgdmFyIFNFQ19UT19SQUQgPSA0Ljg0ODEzNjgxMTA5NTM1OTkzNTg5OTE0MTAyMzU3ZS02O1xuZXhwb3J0IHZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xuLy8gZWxsaXBvaWQgcGpfc2V0X2VsbC5jXG5leHBvcnQgdmFyIFNJWFRIID0gMC4xNjY2NjY2NjY2NjY2NjY2NjY3O1xuLyogMS82ICovXG5leHBvcnQgdmFyIFJBNCA9IDAuMDQ3MjIyMjIyMjIyMjIyMjIyMjI7XG4vKiAxNy8zNjAgKi9cbmV4cG9ydCB2YXIgUkE2ID0gMC4wMjIxNTYwODQ2NTYwODQ2NTYwODtcbmV4cG9ydCB2YXIgRVBTTE4gPSAxLjBlLTEwO1xuLy8geW91J2QgdGhpbmsgeW91IGNvdWxkIHVzZSBOdW1iZXIuRVBTSUxPTiBhYm92ZSBidXQgdGhhdCBtYWtlc1xuLy8gTW9sbHdlaWRlIGdldCBpbnRvIGFuIGluZmluYXRlIGxvb3AuXG5cbmV4cG9ydCB2YXIgRDJSID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbmV4cG9ydCB2YXIgUjJEID0gNTcuMjk1Nzc5NTEzMDgyMzIwODg7XG5leHBvcnQgdmFyIEZPUlRQSSA9IE1hdGguUEkvNDtcbmV4cG9ydCB2YXIgVFdPX1BJID0gTWF0aC5QSSAqIDI7XG4vLyBTUEkgaXMgc2xpZ2h0bHkgZ3JlYXRlciB0aGFuIE1hdGguUEksIHNvIHZhbHVlcyB0aGF0IGV4Y2VlZCB0aGUgLTE4MC4uMTgwXG4vLyBkZWdyZWUgcmFuZ2UgYnkgYSB0aW55IGFtb3VudCBkb24ndCBnZXQgd3JhcHBlZC4gVGhpcyBwcmV2ZW50cyBwb2ludHMgdGhhdFxuLy8gaGF2ZSBkcmlmdGVkIGZyb20gdGhlaXIgb3JpZ2luYWwgbG9jYXRpb24gYWxvbmcgdGhlIDE4MHRoIG1lcmlkaWFuIChkdWUgdG9cbi8vIGZsb2F0aW5nIHBvaW50IGVycm9yKSBmcm9tIGNoYW5naW5nIHRoZWlyIHNpZ24uXG5leHBvcnQgdmFyIFNQSSA9IDMuMTQxNTkyNjUzNTk7XG4iLCJ2YXIgZXhwb3J0cyA9IHt9O1xuZXhwb3J0IHtleHBvcnRzIGFzIGRlZmF1bHR9O1xuXG5leHBvcnRzLmdyZWVud2ljaCA9IDAuMDsgLy9cIjBkRVwiLFxuZXhwb3J0cy5saXNib24gPSAtOS4xMzE5MDYxMTExMTE7IC8vXCI5ZDA3JzU0Ljg2MlxcXCJXXCIsXG5leHBvcnRzLnBhcmlzID0gMi4zMzcyMjkxNjY2Njc7IC8vXCIyZDIwJzE0LjAyNVxcXCJFXCIsXG5leHBvcnRzLmJvZ290YSA9IC03NC4wODA5MTY2NjY2Njc7IC8vXCI3NGQwNCc1MS4zXFxcIldcIixcbmV4cG9ydHMubWFkcmlkID0gLTMuNjg3OTM4ODg4ODg5OyAvL1wiM2Q0MScxNi41OFxcXCJXXCIsXG5leHBvcnRzLnJvbWUgPSAxMi40NTIzMzMzMzMzMzM7IC8vXCIxMmQyNyc4LjRcXFwiRVwiLFxuZXhwb3J0cy5iZXJuID0gNy40Mzk1ODMzMzMzMzM7IC8vXCI3ZDI2JzIyLjVcXFwiRVwiLFxuZXhwb3J0cy5qYWthcnRhID0gMTA2LjgwNzcxOTQ0NDQ0NDsgLy9cIjEwNmQ0OCcyNy43OVxcXCJFXCIsXG5leHBvcnRzLmZlcnJvID0gLTE3LjY2NjY2NjY2NjY2NzsgLy9cIjE3ZDQwJ1dcIixcbmV4cG9ydHMuYnJ1c3NlbHMgPSA0LjM2Nzk3NTsgLy9cIjRkMjInNC43MVxcXCJFXCIsXG5leHBvcnRzLnN0b2NraG9sbSA9IDE4LjA1ODI3Nzc3Nzc3ODsgLy9cIjE4ZDMnMjkuOFxcXCJFXCIsXG5leHBvcnRzLmF0aGVucyA9IDIzLjcxNjMzNzU7IC8vXCIyM2Q0Mic1OC44MTVcXFwiRVwiLFxuZXhwb3J0cy5vc2xvID0gMTAuNzIyOTE2NjY2NjY3OyAvL1wiMTBkNDMnMjIuNVxcXCJFXCJcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZnQ6IHt0b19tZXRlcjogMC4zMDQ4fSxcbiAgJ3VzLWZ0Jzoge3RvX21ldGVyOiAxMjAwIC8gMzkzN31cbn07XG4iLCJ2YXIgaWdub3JlZENoYXIgPSAvW1xcc19cXC1cXC9cXChcXCldL2c7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXRjaChvYmosIGtleSkge1xuICBpZiAob2JqW2tleV0pIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICB2YXIgbGtleSA9IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoaWdub3JlZENoYXIsICcnKTtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHRlc3RrZXksIHByb2Nlc3NlZEtleTtcbiAgd2hpbGUgKCsraSA8IGtleXMubGVuZ3RoKSB7XG4gICAgdGVzdGtleSA9IGtleXNbaV07XG4gICAgcHJvY2Vzc2VkS2V5ID0gdGVzdGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoaWdub3JlZENoYXIsICcnKTtcbiAgICBpZiAocHJvY2Vzc2VkS2V5ID09PSBsa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW3Rlc3RrZXldO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtEMlJ9IGZyb20gJy4vY29uc3RhbnRzL3ZhbHVlcyc7XG5pbXBvcnQgUHJpbWVNZXJpZGlhbiBmcm9tICcuL2NvbnN0YW50cy9QcmltZU1lcmlkaWFuJztcbmltcG9ydCB1bml0cyBmcm9tICcuL2NvbnN0YW50cy91bml0cyc7XG5pbXBvcnQgbWF0Y2ggZnJvbSAnLi9tYXRjaCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlZkRhdGEpIHtcbiAgdmFyIHNlbGYgPSB7fTtcbiAgdmFyIHBhcmFtT2JqID0gZGVmRGF0YS5zcGxpdCgnKycpLm1hcChmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYudHJpbSgpO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBhO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24ocCwgYSkge1xuICAgIHZhciBzcGxpdCA9IGEuc3BsaXQoJz0nKTtcbiAgICBzcGxpdC5wdXNoKHRydWUpO1xuICAgIHBbc3BsaXRbMF0udG9Mb3dlckNhc2UoKV0gPSBzcGxpdFsxXTtcbiAgICByZXR1cm4gcDtcbiAgfSwge30pO1xuICB2YXIgcGFyYW1OYW1lLCBwYXJhbVZhbCwgcGFyYW1PdXRuYW1lO1xuICB2YXIgcGFyYW1zID0ge1xuICAgIHByb2o6ICdwcm9qTmFtZScsXG4gICAgZGF0dW06ICdkYXR1bUNvZGUnLFxuICAgIHJmOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnJmID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGxhdF8wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxhdDAgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbGF0XzE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubGF0MSA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsYXRfMjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sYXQyID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxhdF90czogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sYXRfdHMgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbG9uXzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZzAgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbG9uXzE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZzEgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbG9uXzI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZzIgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgYWxwaGE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuYWxwaGEgPSBwYXJzZUZsb2F0KHYpICogRDJSO1xuICAgIH0sXG4gICAgZ2FtbWE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYucmVjdGlmaWVkX2dyaWRfYW5nbGUgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgbG9uYzogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sb25nYyA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICB4XzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYueDAgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgeV8wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnkwID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGtfMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5rMCA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBrOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmswID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuYSA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBiOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmIgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgcl9hOiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuUl9BID0gdHJ1ZTtcbiAgICB9LFxuICAgIHpvbmU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuem9uZSA9IHBhcnNlSW50KHYsIDEwKTtcbiAgICB9LFxuICAgIHNvdXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYudXRtU291dGggPSB0cnVlO1xuICAgIH0sXG4gICAgdG93Z3M4NDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5kYXR1bV9wYXJhbXMgPSB2LnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdG9fbWV0ZXI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYudG9fbWV0ZXIgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgdW5pdHM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYudW5pdHMgPSB2O1xuICAgICAgdmFyIHVuaXQgPSBtYXRjaCh1bml0cywgdik7XG4gICAgICBpZiAodW5pdCkge1xuICAgICAgICBzZWxmLnRvX21ldGVyID0gdW5pdC50b19tZXRlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZyb21fZ3JlZW53aWNoOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmZyb21fZ3JlZW53aWNoID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIHBtOiBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgcG0gPSBtYXRjaChQcmltZU1lcmlkaWFuLCB2KTtcbiAgICAgIHNlbGYuZnJvbV9ncmVlbndpY2ggPSAocG0gPyBwbSA6IHBhcnNlRmxvYXQodikpICogRDJSO1xuICAgIH0sXG4gICAgbmFkZ3JpZHM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICh2ID09PSAnQG51bGwnKSB7XG4gICAgICAgIHNlbGYuZGF0dW1Db2RlID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYubmFkZ3JpZHMgPSB2O1xuICAgICAgfVxuICAgIH0sXG4gICAgYXhpczogZnVuY3Rpb24odikge1xuICAgICAgdmFyIGxlZ2FsQXhpcyA9IFwiZXduc3VkXCI7XG4gICAgICBpZiAodi5sZW5ndGggPT09IDMgJiYgbGVnYWxBeGlzLmluZGV4T2Yodi5zdWJzdHIoMCwgMSkpICE9PSAtMSAmJiBsZWdhbEF4aXMuaW5kZXhPZih2LnN1YnN0cigxLCAxKSkgIT09IC0xICYmIGxlZ2FsQXhpcy5pbmRleE9mKHYuc3Vic3RyKDIsIDEpKSAhPT0gLTEpIHtcbiAgICAgICAgc2VsZi5heGlzID0gdjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFwcHJveDogZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmFwcHJveCA9IHRydWU7XG4gICAgfVxuICB9O1xuICBmb3IgKHBhcmFtTmFtZSBpbiBwYXJhbU9iaikge1xuICAgIHBhcmFtVmFsID0gcGFyYW1PYmpbcGFyYW1OYW1lXTtcbiAgICBpZiAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgcGFyYW1PdXRuYW1lID0gcGFyYW1zW3BhcmFtTmFtZV07XG4gICAgICBpZiAodHlwZW9mIHBhcmFtT3V0bmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwYXJhbU91dG5hbWUocGFyYW1WYWwpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGZbcGFyYW1PdXRuYW1lXSA9IHBhcmFtVmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNlbGZbcGFyYW1OYW1lXSA9IHBhcmFtVmFsO1xuICAgIH1cbiAgfVxuICBpZih0eXBlb2Ygc2VsZi5kYXR1bUNvZGUgPT09ICdzdHJpbmcnICYmIHNlbGYuZGF0dW1Db2RlICE9PSBcIldHUzg0XCIpe1xuICAgIHNlbGYuZGF0dW1Db2RlID0gc2VsZi5kYXR1bUNvZGUudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHBhcnNlU3RyaW5nO1xuXG52YXIgTkVVVFJBTCA9IDE7XG52YXIgS0VZV09SRCA9IDI7XG52YXIgTlVNQkVSID0gMztcbnZhciBRVU9URUQgPSA0O1xudmFyIEFGVEVSUVVPVEUgPSA1O1xudmFyIEVOREVEID0gLTE7XG52YXIgd2hpdGVzcGFjZSA9IC9cXHMvO1xudmFyIGxhdGluID0gL1tBLVphLXpdLztcbnZhciBrZXl3b3JkID0gL1tBLVphLXo4NF9dLztcbnZhciBlbmRUaGluZ3MgPSAvWyxcXF1dLztcbnZhciBkaWdldHMgPSAvW1xcZFxcLkVcXC1cXCtdLztcbi8vIGNvbnN0IGlnbm9yZWRDaGFyID0gL1tcXHNfXFwtXFwvXFwoXFwpXS9nO1xuZnVuY3Rpb24gUGFyc2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGEgc3RyaW5nJyk7XG4gIH1cbiAgdGhpcy50ZXh0ID0gdGV4dC50cmltKCk7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLnBsYWNlID0gMDtcbiAgdGhpcy5yb290ID0gbnVsbDtcbiAgdGhpcy5zdGFjayA9IFtdO1xuICB0aGlzLmN1cnJlbnRPYmplY3QgPSBudWxsO1xuICB0aGlzLnN0YXRlID0gTkVVVFJBTDtcbn1cblBhcnNlci5wcm90b3R5cGUucmVhZENoYXJpY3RlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2hhciA9IHRoaXMudGV4dFt0aGlzLnBsYWNlKytdO1xuICBpZiAodGhpcy5zdGF0ZSAhPT0gUVVPVEVEKSB7XG4gICAgd2hpbGUgKHdoaXRlc3BhY2UudGVzdChjaGFyKSkge1xuICAgICAgaWYgKHRoaXMucGxhY2UgPj0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjaGFyID0gdGhpcy50ZXh0W3RoaXMucGxhY2UrK107XG4gICAgfVxuICB9XG4gIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgIGNhc2UgTkVVVFJBTDpcbiAgICAgIHJldHVybiB0aGlzLm5ldXRyYWwoY2hhcik7XG4gICAgY2FzZSBLRVlXT1JEOlxuICAgICAgcmV0dXJuIHRoaXMua2V5d29yZChjaGFyKVxuICAgIGNhc2UgUVVPVEVEOlxuICAgICAgcmV0dXJuIHRoaXMucXVvdGVkKGNoYXIpO1xuICAgIGNhc2UgQUZURVJRVU9URTpcbiAgICAgIHJldHVybiB0aGlzLmFmdGVycXVvdGUoY2hhcik7XG4gICAgY2FzZSBOVU1CRVI6XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXIoY2hhcik7XG4gICAgY2FzZSBFTkRFRDpcbiAgICAgIHJldHVybjtcbiAgfVxufTtcblBhcnNlci5wcm90b3R5cGUuYWZ0ZXJxdW90ZSA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICB0aGlzLndvcmQgKz0gJ1wiJztcbiAgICB0aGlzLnN0YXRlID0gUVVPVEVEO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZW5kVGhpbmdzLnRlc3QoY2hhcikpIHtcbiAgICB0aGlzLndvcmQgPSB0aGlzLndvcmQudHJpbSgpO1xuICAgIHRoaXMuYWZ0ZXJJdGVtKGNoYXIpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ2hhdm5cXCd0IGhhbmRsZWQgXCInICtjaGFyICsgJ1wiIGluIGFmdGVycXVvdGUgeWV0LCBpbmRleCAnICsgdGhpcy5wbGFjZSk7XG59O1xuUGFyc2VyLnByb3RvdHlwZS5hZnRlckl0ZW0gPSBmdW5jdGlvbihjaGFyKSB7XG4gIGlmIChjaGFyID09PSAnLCcpIHtcbiAgICBpZiAodGhpcy53b3JkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmN1cnJlbnRPYmplY3QucHVzaCh0aGlzLndvcmQpO1xuICAgIH1cbiAgICB0aGlzLndvcmQgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBORVVUUkFMO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY2hhciA9PT0gJ10nKSB7XG4gICAgdGhpcy5sZXZlbC0tO1xuICAgIGlmICh0aGlzLndvcmQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY3VycmVudE9iamVjdC5wdXNoKHRoaXMud29yZCk7XG4gICAgICB0aGlzLndvcmQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gTkVVVFJBTDtcbiAgICB0aGlzLmN1cnJlbnRPYmplY3QgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIGlmICghdGhpcy5jdXJyZW50T2JqZWN0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gRU5ERUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG59O1xuUGFyc2VyLnByb3RvdHlwZS5udW1iZXIgPSBmdW5jdGlvbihjaGFyKSB7XG4gIGlmIChkaWdldHMudGVzdChjaGFyKSkge1xuICAgIHRoaXMud29yZCArPSBjaGFyO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZW5kVGhpbmdzLnRlc3QoY2hhcikpIHtcbiAgICB0aGlzLndvcmQgPSBwYXJzZUZsb2F0KHRoaXMud29yZCk7XG4gICAgdGhpcy5hZnRlckl0ZW0oY2hhcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignaGF2blxcJ3QgaGFuZGxlZCBcIicgK2NoYXIgKyAnXCIgaW4gbnVtYmVyIHlldCwgaW5kZXggJyArIHRoaXMucGxhY2UpO1xufTtcblBhcnNlci5wcm90b3R5cGUucXVvdGVkID0gZnVuY3Rpb24oY2hhcikge1xuICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgIHRoaXMuc3RhdGUgPSBBRlRFUlFVT1RFO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLndvcmQgKz0gY2hhcjtcbiAgcmV0dXJuO1xufTtcblBhcnNlci5wcm90b3R5cGUua2V5d29yZCA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgaWYgKGtleXdvcmQudGVzdChjaGFyKSkge1xuICAgIHRoaXMud29yZCArPSBjaGFyO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY2hhciA9PT0gJ1snKSB7XG4gICAgdmFyIG5ld09iamVjdHMgPSBbXTtcbiAgICBuZXdPYmplY3RzLnB1c2godGhpcy53b3JkKTtcbiAgICB0aGlzLmxldmVsKys7XG4gICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5yb290ID0gbmV3T2JqZWN0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50T2JqZWN0LnB1c2gobmV3T2JqZWN0cyk7XG4gICAgfVxuICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmN1cnJlbnRPYmplY3QpO1xuICAgIHRoaXMuY3VycmVudE9iamVjdCA9IG5ld09iamVjdHM7XG4gICAgdGhpcy5zdGF0ZSA9IE5FVVRSQUw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbmRUaGluZ3MudGVzdChjaGFyKSkge1xuICAgIHRoaXMuYWZ0ZXJJdGVtKGNoYXIpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ2hhdm5cXCd0IGhhbmRsZWQgXCInICtjaGFyICsgJ1wiIGluIGtleXdvcmQgeWV0LCBpbmRleCAnICsgdGhpcy5wbGFjZSk7XG59O1xuUGFyc2VyLnByb3RvdHlwZS5uZXV0cmFsID0gZnVuY3Rpb24oY2hhcikge1xuICBpZiAobGF0aW4udGVzdChjaGFyKSkge1xuICAgIHRoaXMud29yZCA9IGNoYXI7XG4gICAgdGhpcy5zdGF0ZSA9IEtFWVdPUkQ7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgdGhpcy53b3JkID0gJyc7XG4gICAgdGhpcy5zdGF0ZSA9IFFVT1RFRDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGRpZ2V0cy50ZXN0KGNoYXIpKSB7XG4gICAgdGhpcy53b3JkID0gY2hhcjtcbiAgICB0aGlzLnN0YXRlID0gTlVNQkVSO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZW5kVGhpbmdzLnRlc3QoY2hhcikpIHtcbiAgICB0aGlzLmFmdGVySXRlbShjaGFyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdoYXZuXFwndCBoYW5kbGVkIFwiJyArY2hhciArICdcIiBpbiBuZXV0cmFsIHlldCwgaW5kZXggJyArIHRoaXMucGxhY2UpO1xufTtcblBhcnNlci5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLnBsYWNlIDwgdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgIHRoaXMucmVhZENoYXJpY3RlcigpO1xuICB9XG4gIGlmICh0aGlzLnN0YXRlID09PSBFTkRFRCkge1xuICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gcGFyc2Ugc3RyaW5nIFwiJyArdGhpcy50ZXh0ICsgJ1wiLiBTdGF0ZSBpcyAnICsgdGhpcy5zdGF0ZSk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyh0eHQpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIodHh0KTtcbiAgcmV0dXJuIHBhcnNlci5vdXRwdXQoKTtcbn1cbiIsIlxuXG5mdW5jdGlvbiBtYXBpdChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgIHZhbHVlLnVuc2hpZnQoa2V5KTtcbiAgICBrZXkgPSBudWxsO1xuICB9XG4gIHZhciB0aGluZyA9IGtleSA/IHt9IDogb2JqO1xuXG4gIHZhciBvdXQgPSB2YWx1ZS5yZWR1Y2UoZnVuY3Rpb24obmV3T2JqLCBpdGVtKSB7XG4gICAgc0V4cHIoaXRlbSwgbmV3T2JqKTtcbiAgICByZXR1cm4gbmV3T2JqXG4gIH0sIHRoaW5nKTtcbiAgaWYgKGtleSkge1xuICAgIG9ialtrZXldID0gb3V0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzRXhwcih2LCBvYmopIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgb2JqW3ZdID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGtleSA9IHYuc2hpZnQoKTtcbiAgaWYgKGtleSA9PT0gJ1BBUkFNRVRFUicpIHtcbiAgICBrZXkgPSB2LnNoaWZ0KCk7XG4gIH1cbiAgaWYgKHYubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodlswXSkpIHtcbiAgICAgIG9ialtrZXldID0ge307XG4gICAgICBzRXhwcih2WzBdLCBvYmpba2V5XSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9ialtrZXldID0gdlswXTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF2Lmxlbmd0aCkge1xuICAgIG9ialtrZXldID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGtleSA9PT0gJ1RPV0dTODQnKSB7XG4gICAgb2JqW2tleV0gPSB2O1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5ID09PSAnQVhJUycpIHtcbiAgICBpZiAoIShrZXkgaW4gb2JqKSkge1xuICAgICAgb2JqW2tleV0gPSBbXTtcbiAgICB9XG4gICAgb2JqW2tleV0ucHVzaCh2KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICBvYmpba2V5XSA9IHt9O1xuICB9XG5cbiAgdmFyIGk7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAnVU5JVCc6XG4gICAgY2FzZSAnUFJJTUVNJzpcbiAgICBjYXNlICdWRVJUX0RBVFVNJzpcbiAgICAgIG9ialtrZXldID0ge1xuICAgICAgICBuYW1lOiB2WzBdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGNvbnZlcnQ6IHZbMV1cbiAgICAgIH07XG4gICAgICBpZiAodi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgc0V4cHIodlsyXSwgb2JqW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ1NQSEVST0lEJzpcbiAgICBjYXNlICdFTExJUFNPSUQnOlxuICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgIG5hbWU6IHZbMF0sXG4gICAgICAgIGE6IHZbMV0sXG4gICAgICAgIHJmOiB2WzJdXG4gICAgICB9O1xuICAgICAgaWYgKHYubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHNFeHByKHZbM10sIG9ialtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdQUk9KRUNURURDUlMnOlxuICAgIGNhc2UgJ1BST0pDUlMnOlxuICAgIGNhc2UgJ0dFT0dDUyc6XG4gICAgY2FzZSAnR0VPQ0NTJzpcbiAgICBjYXNlICdQUk9KQ1MnOlxuICAgIGNhc2UgJ0xPQ0FMX0NTJzpcbiAgICBjYXNlICdHRU9EQ1JTJzpcbiAgICBjYXNlICdHRU9ERVRJQ0NSUyc6XG4gICAgY2FzZSAnR0VPREVUSUNEQVRVTSc6XG4gICAgY2FzZSAnRURBVFVNJzpcbiAgICBjYXNlICdFTkdJTkVFUklOR0RBVFVNJzpcbiAgICBjYXNlICdWRVJUX0NTJzpcbiAgICBjYXNlICdWRVJUQ1JTJzpcbiAgICBjYXNlICdWRVJUSUNBTENSUyc6XG4gICAgY2FzZSAnQ09NUERfQ1MnOlxuICAgIGNhc2UgJ0NPTVBPVU5EQ1JTJzpcbiAgICBjYXNlICdFTkdJTkVFUklOR0NSUyc6XG4gICAgY2FzZSAnRU5HQ1JTJzpcbiAgICBjYXNlICdGSVRURURfQ1MnOlxuICAgIGNhc2UgJ0xPQ0FMX0RBVFVNJzpcbiAgICBjYXNlICdEQVRVTSc6XG4gICAgICB2WzBdID0gWyduYW1lJywgdlswXV07XG4gICAgICBtYXBpdChvYmosIGtleSwgdik7XG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCB2Lmxlbmd0aCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gc0V4cHIodiwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwaXQob2JqLCBrZXksIHYpO1xuICB9XG59XG4iLCJ2YXIgRDJSID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbmltcG9ydCBwYXJzZXIgZnJvbSAnLi9wYXJzZXInO1xuaW1wb3J0IHtzRXhwcn0gZnJvbSAnLi9wcm9jZXNzJztcblxuXG5cbmZ1bmN0aW9uIHJlbmFtZShvYmosIHBhcmFtcykge1xuICB2YXIgb3V0TmFtZSA9IHBhcmFtc1swXTtcbiAgdmFyIGluTmFtZSA9IHBhcmFtc1sxXTtcbiAgaWYgKCEob3V0TmFtZSBpbiBvYmopICYmIChpbk5hbWUgaW4gb2JqKSkge1xuICAgIG9ialtvdXROYW1lXSA9IG9ialtpbk5hbWVdO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBvYmpbb3V0TmFtZV0gPSBwYXJhbXNbMl0ob2JqW291dE5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZDJyKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCAqIEQyUjtcbn1cblxuZnVuY3Rpb24gY2xlYW5XS1Qod2t0KSB7XG4gIGlmICh3a3QudHlwZSA9PT0gJ0dFT0dDUycpIHtcbiAgICB3a3QucHJvak5hbWUgPSAnbG9uZ2xhdCc7XG4gIH0gZWxzZSBpZiAod2t0LnR5cGUgPT09ICdMT0NBTF9DUycpIHtcbiAgICB3a3QucHJvak5hbWUgPSAnaWRlbnRpdHknO1xuICAgIHdrdC5sb2NhbCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiB3a3QuUFJPSkVDVElPTiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHdrdC5wcm9qTmFtZSA9IE9iamVjdC5rZXlzKHdrdC5QUk9KRUNUSU9OKVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2t0LnByb2pOYW1lID0gd2t0LlBST0pFQ1RJT047XG4gICAgfVxuICB9XG4gIGlmICh3a3QuQVhJUykge1xuICAgIHZhciBheGlzT3JkZXIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB3a3QuQVhJUy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgYXhpcyA9IFt3a3QuQVhJU1tpXVswXS50b0xvd2VyQ2FzZSgpLCB3a3QuQVhJU1tpXVsxXS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmIChheGlzWzBdLmluZGV4T2YoJ25vcnRoJykgIT09IC0xIHx8ICgoYXhpc1swXSA9PT0gJ3knIHx8IGF4aXNbMF0gPT09ICdsYXQnKSAmJiBheGlzWzFdID09PSAnbm9ydGgnKSkge1xuICAgICAgICBheGlzT3JkZXIgKz0gJ24nO1xuICAgICAgfSBlbHNlIGlmIChheGlzWzBdLmluZGV4T2YoJ3NvdXRoJykgIT09IC0xIHx8ICgoYXhpc1swXSA9PT0gJ3knIHx8IGF4aXNbMF0gPT09ICdsYXQnKSAmJiBheGlzWzFdID09PSAnc291dGgnKSkge1xuICAgICAgICBheGlzT3JkZXIgKz0gJ3MnO1xuICAgICAgfSBlbHNlIGlmIChheGlzWzBdLmluZGV4T2YoJ2Vhc3QnKSAhPT0gLTEgfHwgKChheGlzWzBdID09PSAneCcgfHwgYXhpc1swXSA9PT0gJ2xvbicpICYmIGF4aXNbMV0gPT09ICdlYXN0JykpIHtcbiAgICAgICAgYXhpc09yZGVyICs9ICdlJztcbiAgICAgIH0gZWxzZSBpZiAoYXhpc1swXS5pbmRleE9mKCd3ZXN0JykgIT09IC0xIHx8ICgoYXhpc1swXSA9PT0gJ3gnIHx8IGF4aXNbMF0gPT09ICdsb24nKSAmJiBheGlzWzFdID09PSAnd2VzdCcpKSB7XG4gICAgICAgIGF4aXNPcmRlciArPSAndyc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChheGlzT3JkZXIubGVuZ3RoID09PSAyKSB7XG4gICAgICBheGlzT3JkZXIgKz0gJ3UnO1xuICAgIH1cbiAgICBpZiAoYXhpc09yZGVyLmxlbmd0aCA9PT0gMykge1xuICAgICAgd2t0LmF4aXMgPSBheGlzT3JkZXI7XG4gICAgfVxuICB9XG4gIGlmICh3a3QuVU5JVCkge1xuICAgIHdrdC51bml0cyA9IHdrdC5VTklULm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAod2t0LnVuaXRzID09PSAnbWV0cmUnKSB7XG4gICAgICB3a3QudW5pdHMgPSAnbWV0ZXInO1xuICAgIH1cbiAgICBpZiAod2t0LlVOSVQuY29udmVydCkge1xuICAgICAgaWYgKHdrdC50eXBlID09PSAnR0VPR0NTJykge1xuICAgICAgICBpZiAod2t0LkRBVFVNICYmIHdrdC5EQVRVTS5TUEhFUk9JRCkge1xuICAgICAgICAgIHdrdC50b19tZXRlciA9IHdrdC5VTklULmNvbnZlcnQqd2t0LkRBVFVNLlNQSEVST0lELmE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdrdC50b19tZXRlciA9IHdrdC5VTklULmNvbnZlcnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBnZW9nY3MgPSB3a3QuR0VPR0NTO1xuICBpZiAod2t0LnR5cGUgPT09ICdHRU9HQ1MnKSB7XG4gICAgZ2VvZ2NzID0gd2t0O1xuICB9XG4gIGlmIChnZW9nY3MpIHtcbiAgICAvL2lmKHdrdC5HRU9HQ1MuUFJJTUVNJiZ3a3QuR0VPR0NTLlBSSU1FTS5jb252ZXJ0KXtcbiAgICAvLyAgd2t0LmZyb21fZ3JlZW53aWNoPXdrdC5HRU9HQ1MuUFJJTUVNLmNvbnZlcnQqRDJSO1xuICAgIC8vfVxuICAgIGlmIChnZW9nY3MuREFUVU0pIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSBnZW9nY3MuREFUVU0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gZ2VvZ2NzLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUuc2xpY2UoMCwgMikgPT09ICdkXycpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuZGF0dW1Db2RlLnNsaWNlKDIpO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZSA9PT0gJ25ld196ZWFsYW5kX2dlb2RldGljX2RhdHVtXzE5NDknIHx8IHdrdC5kYXR1bUNvZGUgPT09ICduZXdfemVhbGFuZF8xOTQ5Jykge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9ICduemdkNDknO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZSA9PT0gJ3dnc18xOTg0JyB8fCB3a3QuZGF0dW1Db2RlID09PSAnd29ybGRfZ2VvZGV0aWNfc3lzdGVtXzE5ODQnKSB7XG4gICAgICBpZiAod2t0LlBST0pFQ1RJT04gPT09ICdNZXJjYXRvcl9BdXhpbGlhcnlfU3BoZXJlJykge1xuICAgICAgICB3a3Quc3BoZXJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdrdC5kYXR1bUNvZGUgPSAnd2dzODQnO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZS5zbGljZSgtNikgPT09ICdfZmVycm8nKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LmRhdHVtQ29kZS5zbGljZSgwLCAtIDYpO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZS5zbGljZSgtOCkgPT09ICdfamFrYXJ0YScpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuZGF0dW1Db2RlLnNsaWNlKDAsIC0gOCk7XG4gICAgfVxuICAgIGlmICh+d2t0LmRhdHVtQ29kZS5pbmRleE9mKCdiZWxnZScpKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gJ3JuYjcyJztcbiAgICB9XG4gICAgaWYgKGdlb2djcy5EQVRVTSAmJiBnZW9nY3MuREFUVU0uU1BIRVJPSUQpIHtcbiAgICAgIHdrdC5lbGxwcyA9IGdlb2djcy5EQVRVTS5TUEhFUk9JRC5uYW1lLnJlcGxhY2UoJ18xOScsICcnKS5yZXBsYWNlKC9bQ2NdbGFya2VcXF8xOC8sICdjbHJrJyk7XG4gICAgICBpZiAod2t0LmVsbHBzLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgMTMpID09PSAnaW50ZXJuYXRpb25hbCcpIHtcbiAgICAgICAgd2t0LmVsbHBzID0gJ2ludGwnO1xuICAgICAgfVxuXG4gICAgICB3a3QuYSA9IGdlb2djcy5EQVRVTS5TUEhFUk9JRC5hO1xuICAgICAgd2t0LnJmID0gcGFyc2VGbG9hdChnZW9nY3MuREFUVU0uU1BIRVJPSUQucmYsIDEwKTtcbiAgICB9XG5cbiAgICBpZiAoZ2VvZ2NzLkRBVFVNICYmIGdlb2djcy5EQVRVTS5UT1dHUzg0KSB7XG4gICAgICB3a3QuZGF0dW1fcGFyYW1zID0gZ2VvZ2NzLkRBVFVNLlRPV0dTODQ7XG4gICAgfVxuICAgIGlmICh+d2t0LmRhdHVtQ29kZS5pbmRleE9mKCdvc2diXzE5MzYnKSkge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9ICdvc2diMzYnO1xuICAgIH1cbiAgICBpZiAofndrdC5kYXR1bUNvZGUuaW5kZXhPZignb3NuaV8xOTUyJykpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSAnb3NuaTUyJztcbiAgICB9XG4gICAgaWYgKH53a3QuZGF0dW1Db2RlLmluZGV4T2YoJ3RtNjUnKVxuICAgICAgfHwgfndrdC5kYXR1bUNvZGUuaW5kZXhPZignZ2VvZGV0aWNfZGF0dW1fb2ZfMTk2NScpKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gJ2lyZTY1JztcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUgPT09ICdjaDE5MDMrJykge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9ICdjaDE5MDMnO1xuICAgIH1cbiAgICBpZiAofndrdC5kYXR1bUNvZGUuaW5kZXhPZignaXNyYWVsJykpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSAnaXNyOTMnO1xuICAgIH1cbiAgfVxuICBpZiAod2t0LmIgJiYgIWlzRmluaXRlKHdrdC5iKSkge1xuICAgIHdrdC5iID0gd2t0LmE7XG4gIH1cblxuICBmdW5jdGlvbiB0b01ldGVyKGlucHV0KSB7XG4gICAgdmFyIHJhdGlvID0gd2t0LnRvX21ldGVyIHx8IDE7XG4gICAgcmV0dXJuIGlucHV0ICogcmF0aW87XG4gIH1cbiAgdmFyIHJlbmFtZXIgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHJlbmFtZSh3a3QsIGEpO1xuICB9O1xuICB2YXIgbGlzdCA9IFtcbiAgICBbJ3N0YW5kYXJkX3BhcmFsbGVsXzEnLCAnU3RhbmRhcmRfUGFyYWxsZWxfMSddLFxuICAgIFsnc3RhbmRhcmRfcGFyYWxsZWxfMScsICdMYXRpdHVkZSBvZiAxc3Qgc3RhbmRhcmQgcGFyYWxsZWwnXSxcbiAgICBbJ3N0YW5kYXJkX3BhcmFsbGVsXzInLCAnU3RhbmRhcmRfUGFyYWxsZWxfMiddLFxuICAgIFsnc3RhbmRhcmRfcGFyYWxsZWxfMicsICdMYXRpdHVkZSBvZiAybmQgc3RhbmRhcmQgcGFyYWxsZWwnXSxcbiAgICBbJ2ZhbHNlX2Vhc3RpbmcnLCAnRmFsc2VfRWFzdGluZyddLFxuICAgIFsnZmFsc2VfZWFzdGluZycsICdGYWxzZSBlYXN0aW5nJ10sXG4gICAgWydmYWxzZS1lYXN0aW5nJywgJ0Vhc3RpbmcgYXQgZmFsc2Ugb3JpZ2luJ10sXG4gICAgWydmYWxzZV9ub3J0aGluZycsICdGYWxzZV9Ob3J0aGluZyddLFxuICAgIFsnZmFsc2Vfbm9ydGhpbmcnLCAnRmFsc2Ugbm9ydGhpbmcnXSxcbiAgICBbJ2ZhbHNlX25vcnRoaW5nJywgJ05vcnRoaW5nIGF0IGZhbHNlIG9yaWdpbiddLFxuICAgIFsnY2VudHJhbF9tZXJpZGlhbicsICdDZW50cmFsX01lcmlkaWFuJ10sXG4gICAgWydjZW50cmFsX21lcmlkaWFuJywgJ0xvbmdpdHVkZSBvZiBuYXR1cmFsIG9yaWdpbiddLFxuICAgIFsnY2VudHJhbF9tZXJpZGlhbicsICdMb25naXR1ZGUgb2YgZmFsc2Ugb3JpZ2luJ10sXG4gICAgWydsYXRpdHVkZV9vZl9vcmlnaW4nLCAnTGF0aXR1ZGVfT2ZfT3JpZ2luJ10sXG4gICAgWydsYXRpdHVkZV9vZl9vcmlnaW4nLCAnQ2VudHJhbF9QYXJhbGxlbCddLFxuICAgIFsnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgJ0xhdGl0dWRlIG9mIG5hdHVyYWwgb3JpZ2luJ10sXG4gICAgWydsYXRpdHVkZV9vZl9vcmlnaW4nLCAnTGF0aXR1ZGUgb2YgZmFsc2Ugb3JpZ2luJ10sXG4gICAgWydzY2FsZV9mYWN0b3InLCAnU2NhbGVfRmFjdG9yJ10sXG4gICAgWydrMCcsICdzY2FsZV9mYWN0b3InXSxcbiAgICBbJ2xhdGl0dWRlX29mX2NlbnRlcicsICdMYXRpdHVkZV9PZl9DZW50ZXInXSxcbiAgICBbJ2xhdGl0dWRlX29mX2NlbnRlcicsICdMYXRpdHVkZV9vZl9jZW50ZXInXSxcbiAgICBbJ2xhdDAnLCAnbGF0aXR1ZGVfb2ZfY2VudGVyJywgZDJyXSxcbiAgICBbJ2xvbmdpdHVkZV9vZl9jZW50ZXInLCAnTG9uZ2l0dWRlX09mX0NlbnRlciddLFxuICAgIFsnbG9uZ2l0dWRlX29mX2NlbnRlcicsICdMb25naXR1ZGVfb2ZfY2VudGVyJ10sXG4gICAgWydsb25nYycsICdsb25naXR1ZGVfb2ZfY2VudGVyJywgZDJyXSxcbiAgICBbJ3gwJywgJ2ZhbHNlX2Vhc3RpbmcnLCB0b01ldGVyXSxcbiAgICBbJ3kwJywgJ2ZhbHNlX25vcnRoaW5nJywgdG9NZXRlcl0sXG4gICAgWydsb25nMCcsICdjZW50cmFsX21lcmlkaWFuJywgZDJyXSxcbiAgICBbJ2xhdDAnLCAnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgZDJyXSxcbiAgICBbJ2xhdDAnLCAnc3RhbmRhcmRfcGFyYWxsZWxfMScsIGQycl0sXG4gICAgWydsYXQxJywgJ3N0YW5kYXJkX3BhcmFsbGVsXzEnLCBkMnJdLFxuICAgIFsnbGF0MicsICdzdGFuZGFyZF9wYXJhbGxlbF8yJywgZDJyXSxcbiAgICBbJ2F6aW11dGgnLCAnQXppbXV0aCddLFxuICAgIFsnYWxwaGEnLCAnYXppbXV0aCcsIGQycl0sXG4gICAgWydzcnNDb2RlJywgJ25hbWUnXVxuICBdO1xuICBsaXN0LmZvckVhY2gocmVuYW1lcik7XG4gIGlmICghd2t0LmxvbmcwICYmIHdrdC5sb25nYyAmJiAod2t0LnByb2pOYW1lID09PSAnQWxiZXJzX0NvbmljX0VxdWFsX0FyZWEnIHx8IHdrdC5wcm9qTmFtZSA9PT0gJ0xhbWJlcnRfQXppbXV0aGFsX0VxdWFsX0FyZWEnKSkge1xuICAgIHdrdC5sb25nMCA9IHdrdC5sb25nYztcbiAgfVxuICBpZiAoIXdrdC5sYXRfdHMgJiYgd2t0LmxhdDEgJiYgKHdrdC5wcm9qTmFtZSA9PT0gJ1N0ZXJlb2dyYXBoaWNfU291dGhfUG9sZScgfHwgd2t0LnByb2pOYW1lID09PSAnUG9sYXIgU3RlcmVvZ3JhcGhpYyAodmFyaWFudCBCKScpKSB7XG4gICAgd2t0LmxhdDAgPSBkMnIod2t0LmxhdDEgPiAwID8gOTAgOiAtOTApO1xuICAgIHdrdC5sYXRfdHMgPSB3a3QubGF0MTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24od2t0KSB7XG4gIHZhciBsaXNwID0gcGFyc2VyKHdrdCk7XG4gIHZhciB0eXBlID0gbGlzcC5zaGlmdCgpO1xuICB2YXIgbmFtZSA9IGxpc3Auc2hpZnQoKTtcbiAgbGlzcC51bnNoaWZ0KFsnbmFtZScsIG5hbWVdKTtcbiAgbGlzcC51bnNoaWZ0KFsndHlwZScsIHR5cGVdKTtcbiAgdmFyIG9iaiA9IHt9O1xuICBzRXhwcihsaXNwLCBvYmopO1xuICBjbGVhbldLVChvYmopO1xuICByZXR1cm4gb2JqO1xufVxuIiwiaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi9nbG9iYWwnO1xuaW1wb3J0IHBhcnNlUHJvaiBmcm9tICcuL3Byb2pTdHJpbmcnO1xuaW1wb3J0IHdrdCBmcm9tICd3a3QtcGFyc2VyJztcblxuZnVuY3Rpb24gZGVmcyhuYW1lKSB7XG4gIC8qZ2xvYmFsIGNvbnNvbGUqL1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGRlZiA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChkZWYuY2hhckF0KDApID09PSAnKycpIHtcbiAgICAgICAgZGVmc1tuYW1lXSA9IHBhcnNlUHJvaihhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlZnNbbmFtZV0gPSB3a3QoYXJndW1lbnRzWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmc1tuYW1lXSA9IGRlZjtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gbmFtZS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIGRlZnMuYXBwbHkodGhhdCwgdik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVmcyh2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG5hbWUgaW4gZGVmcykge1xuICAgICAgICByZXR1cm4gZGVmc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoJ0VQU0cnIGluIG5hbWUpIHtcbiAgICAgIGRlZnNbJ0VQU0c6JyArIG5hbWUuRVBTR10gPSBuYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmICgnRVNSSScgaW4gbmFtZSkge1xuICAgICAgZGVmc1snRVNSSTonICsgbmFtZS5FU1JJXSA9IG5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdJQVUyMDAwJyBpbiBuYW1lKSB7XG4gICAgICBkZWZzWydJQVUyMDAwOicgKyBuYW1lLklBVTIwMDBdID0gbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cblxufVxuZ2xvYmFscyhkZWZzKTtcbmV4cG9ydCBkZWZhdWx0IGRlZnM7XG4iLCJpbXBvcnQgZGVmcyBmcm9tICcuL2RlZnMnO1xuaW1wb3J0IHdrdCBmcm9tICd3a3QtcGFyc2VyJztcbmltcG9ydCBwcm9qU3RyIGZyb20gJy4vcHJvalN0cmluZyc7XG5pbXBvcnQgbWF0Y2ggZnJvbSAnLi9tYXRjaCc7XG5mdW5jdGlvbiB0ZXN0T2JqKGNvZGUpe1xuICByZXR1cm4gdHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnO1xufVxuZnVuY3Rpb24gdGVzdERlZihjb2RlKXtcbiAgcmV0dXJuIGNvZGUgaW4gZGVmcztcbn1cbnZhciBjb2RlV29yZHMgPSBbJ1BST0pFQ1RFRENSUycsICdQUk9KQ1JTJywgJ0dFT0dDUycsJ0dFT0NDUycsJ1BST0pDUycsJ0xPQ0FMX0NTJywgJ0dFT0RDUlMnLCAnR0VPREVUSUNDUlMnLCAnR0VPREVUSUNEQVRVTScsICdFTkdDUlMnLCAnRU5HSU5FRVJJTkdDUlMnXTtcbmZ1bmN0aW9uIHRlc3RXS1QoY29kZSl7XG4gIHJldHVybiBjb2RlV29yZHMuc29tZShmdW5jdGlvbiAod29yZCkge1xuICAgIHJldHVybiBjb2RlLmluZGV4T2Yod29yZCkgPiAtMTtcbiAgfSk7XG59XG52YXIgY29kZXMgPSBbJzM4NTcnLCAnOTAwOTEzJywgJzM3ODUnLCAnMTAyMTEzJ107XG5mdW5jdGlvbiBjaGVja01lcmNhdG9yKGl0ZW0pIHtcbiAgdmFyIGF1dGggPSBtYXRjaChpdGVtLCAnYXV0aG9yaXR5Jyk7XG4gIGlmICghYXV0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY29kZSA9IG1hdGNoKGF1dGgsICdlcHNnJyk7XG4gIHJldHVybiBjb2RlICYmIGNvZGVzLmluZGV4T2YoY29kZSkgPiAtMTtcbn1cbmZ1bmN0aW9uIGNoZWNrUHJvalN0cihpdGVtKSB7XG4gIHZhciBleHQgPSBtYXRjaChpdGVtLCAnZXh0ZW5zaW9uJyk7XG4gIGlmICghZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBtYXRjaChleHQsICdwcm9qNCcpO1xufVxuZnVuY3Rpb24gdGVzdFByb2ooY29kZSl7XG4gIHJldHVybiBjb2RlWzBdID09PSAnKyc7XG59XG5mdW5jdGlvbiBwYXJzZShjb2RlKXtcbiAgaWYgKHRlc3RPYmooY29kZSkpIHtcbiAgICAvL2NoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIGEgV0tUIHN0cmluZ1xuICAgIGlmICh0ZXN0RGVmKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZGVmc1tjb2RlXTtcbiAgICB9XG4gICAgaWYgKHRlc3RXS1QoY29kZSkpIHtcbiAgICAgIHZhciBvdXQgPSB3a3QoY29kZSk7XG4gICAgICAvLyB0ZXN0IG9mIHNwZXRpYWwgY2FzZSwgZHVlIHRvIHRoaXMgYmVpbmcgYSB2ZXJ5IGNvbW1vbiBhbmQgb2Z0ZW4gbWFsZm9ybWVkXG4gICAgICBpZiAoY2hlY2tNZXJjYXRvcihvdXQpKSB7XG4gICAgICAgIHJldHVybiBkZWZzWydFUFNHOjM4NTcnXTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXliZVByb2pTdHIgPSBjaGVja1Byb2pTdHIob3V0KTtcbiAgICAgIGlmIChtYXliZVByb2pTdHIpIHtcbiAgICAgICAgcmV0dXJuIHByb2pTdHIobWF5YmVQcm9qU3RyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGlmICh0ZXN0UHJvaihjb2RlKSkge1xuICAgICAgcmV0dXJuIHByb2pTdHIoY29kZSk7XG4gICAgfVxuICB9ZWxzZXtcbiAgICByZXR1cm4gY29kZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbiB8fCB7fTtcbiAgdmFyIHZhbHVlLCBwcm9wZXJ0eTtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG4gIH1cbiAgZm9yIChwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdGluYXRpb247XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlY2NlbnQsIHNpbnBoaSwgY29zcGhpKSB7XG4gIHZhciBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gIHJldHVybiBjb3NwaGkgLyAoTWF0aC5zcXJ0KDEgLSBjb24gKiBjb24pKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4PDAgPyAtMSA6IDE7XG59IiwiXG5pbXBvcnQge1RXT19QSSwgU1BJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcbmltcG9ydCBzaWduIGZyb20gJy4vc2lnbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChNYXRoLmFicyh4KSA8PSBTUEkpID8geCA6ICh4IC0gKHNpZ24oeCkgKiBUV09fUEkpKTtcbn1cbiIsImltcG9ydCB7SEFMRl9QSX0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGVjY2VudCwgcGhpLCBzaW5waGkpIHtcbiAgdmFyIGNvbiA9IGVjY2VudCAqIHNpbnBoaTtcbiAgdmFyIGNvbSA9IDAuNSAqIGVjY2VudDtcbiAgY29uID0gTWF0aC5wb3coKCgxIC0gY29uKSAvICgxICsgY29uKSksIGNvbSk7XG4gIHJldHVybiAoTWF0aC50YW4oMC41ICogKEhBTEZfUEkgLSBwaGkpKSAvIGNvbik7XG59XG4iLCJpbXBvcnQge0hBTEZfUEl9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlY2NlbnQsIHRzKSB7XG4gIHZhciBlY2NudGggPSAwLjUgKiBlY2NlbnQ7XG4gIHZhciBjb24sIGRwaGk7XG4gIHZhciBwaGkgPSBIQUxGX1BJIC0gMiAqIE1hdGguYXRhbih0cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IDE1OyBpKyspIHtcbiAgICBjb24gPSBlY2NlbnQgKiBNYXRoLnNpbihwaGkpO1xuICAgIGRwaGkgPSBIQUxGX1BJIC0gMiAqIE1hdGguYXRhbih0cyAqIChNYXRoLnBvdygoKDEgLSBjb24pIC8gKDEgKyBjb24pKSwgZWNjbnRoKSkpIC0gcGhpO1xuICAgIHBoaSArPSBkcGhpO1xuICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSAwLjAwMDAwMDAwMDEpIHtcbiAgICAgIHJldHVybiBwaGk7XG4gICAgfVxuICB9XG4gIC8vY29uc29sZS5sb2coXCJwaGkyeiBoYXMgTm9Db252ZXJnZW5jZVwiKTtcbiAgcmV0dXJuIC05OTk5O1xufVxuIiwiaW1wb3J0IG1zZm56IGZyb20gJy4uL2NvbW1vbi9tc2Zueic7XG5cbmltcG9ydCBhZGp1c3RfbG9uIGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbG9uJztcbmltcG9ydCB0c2ZueiBmcm9tICcuLi9jb21tb24vdHNmbnonO1xuaW1wb3J0IHBoaTJ6IGZyb20gJy4uL2NvbW1vbi9waGkyeic7XG5pbXBvcnQge0ZPUlRQSSwgUjJELCBFUFNMTiwgSEFMRl9QSX0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgdmFyIGNvbiA9IHRoaXMuYiAvIHRoaXMuYTtcbiAgdGhpcy5lcyA9IDEgLSBjb24gKiBjb247XG4gIGlmKCEoJ3gwJyBpbiB0aGlzKSl7XG4gICAgdGhpcy54MCA9IDA7XG4gIH1cbiAgaWYoISgneTAnIGluIHRoaXMpKXtcbiAgICB0aGlzLnkwID0gMDtcbiAgfVxuICB0aGlzLmUgPSBNYXRoLnNxcnQodGhpcy5lcyk7XG4gIGlmICh0aGlzLmxhdF90cykge1xuICAgIGlmICh0aGlzLnNwaGVyZSkge1xuICAgICAgdGhpcy5rMCA9IE1hdGguY29zKHRoaXMubGF0X3RzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmswID0gbXNmbnoodGhpcy5lLCBNYXRoLnNpbih0aGlzLmxhdF90cyksIE1hdGguY29zKHRoaXMubGF0X3RzKSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmICghdGhpcy5rMCkge1xuICAgICAgaWYgKHRoaXMuaykge1xuICAgICAgICB0aGlzLmswID0gdGhpcy5rO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuazAgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiBNZXJjYXRvciBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIC8vIGNvbnZlcnQgdG8gcmFkaWFuc1xuICBpZiAobGF0ICogUjJEID4gOTAgJiYgbGF0ICogUjJEIDwgLTkwICYmIGxvbiAqIFIyRCA+IDE4MCAmJiBsb24gKiBSMkQgPCAtMTgwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgeCwgeTtcbiAgaWYgKE1hdGguYWJzKE1hdGguYWJzKGxhdCkgLSBIQUxGX1BJKSA8PSBFUFNMTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0aGlzLnNwaGVyZSkge1xuICAgICAgeCA9IHRoaXMueDAgKyB0aGlzLmEgKiB0aGlzLmswICogYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICogdGhpcy5rMCAqIE1hdGgubG9nKE1hdGgudGFuKEZPUlRQSSArIDAuNSAqIGxhdCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaW5waGkgPSBNYXRoLnNpbihsYXQpO1xuICAgICAgdmFyIHRzID0gdHNmbnoodGhpcy5lLCBsYXQsIHNpbnBoaSk7XG4gICAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIHRoaXMuazAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICAgICAgeSA9IHRoaXMueTAgLSB0aGlzLmEgKiB0aGlzLmswICogTWF0aC5sb2codHMpO1xuICAgIH1cbiAgICBwLnggPSB4O1xuICAgIHAueSA9IHk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbn1cblxuLyogTWVyY2F0b3IgaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcblxuICB2YXIgeCA9IHAueCAtIHRoaXMueDA7XG4gIHZhciB5ID0gcC55IC0gdGhpcy55MDtcbiAgdmFyIGxvbiwgbGF0O1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGxhdCA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKE1hdGguZXhwKC15IC8gKHRoaXMuYSAqIHRoaXMuazApKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHRzID0gTWF0aC5leHAoLXkgLyAodGhpcy5hICogdGhpcy5rMCkpO1xuICAgIGxhdCA9IHBoaTJ6KHRoaXMuZSwgdHMpO1xuICAgIGlmIChsYXQgPT09IC05OTk5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgeCAvICh0aGlzLmEgKiB0aGlzLmswKSk7XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiTWVyY2F0b3JcIiwgXCJQb3B1bGFyIFZpc3VhbGlzYXRpb24gUHNldWRvIE1lcmNhdG9yXCIsIFwiTWVyY2F0b3JfMVNQXCIsIFwiTWVyY2F0b3JfQXV4aWxpYXJ5X1NwaGVyZVwiLCBcIm1lcmNcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICAvL25vLW9wIGZvciBsb25nbGF0XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHB0KSB7XG4gIHJldHVybiBwdDtcbn1cbmV4cG9ydCB7aWRlbnRpdHkgYXMgZm9yd2FyZH07XG5leHBvcnQge2lkZW50aXR5IGFzIGludmVyc2V9O1xuZXhwb3J0IHZhciBuYW1lcyA9IFtcImxvbmdsYXRcIiwgXCJpZGVudGl0eVwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogaWRlbnRpdHksXG4gIGludmVyc2U6IGlkZW50aXR5LFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgbWVyYyBmcm9tIFwiLi9wcm9qZWN0aW9ucy9tZXJjXCI7XG5pbXBvcnQgbG9uZ2xhdCBmcm9tIFwiLi9wcm9qZWN0aW9ucy9sb25nbGF0XCI7XG52YXIgcHJvanMgPSBbbWVyYywgbG9uZ2xhdF07XG52YXIgbmFtZXMgPSB7fTtcbnZhciBwcm9qU3RvcmUgPSBbXTtcblxuZnVuY3Rpb24gYWRkKHByb2osIGkpIHtcbiAgdmFyIGxlbiA9IHByb2pTdG9yZS5sZW5ndGg7XG4gIGlmICghcHJvai5uYW1lcykge1xuICAgIGNvbnNvbGUubG9nKGkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHByb2pTdG9yZVtsZW5dID0gcHJvajtcbiAgcHJvai5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICBuYW1lc1tuLnRvTG93ZXJDYXNlKCldID0gbGVuO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCB7YWRkfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbiA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHR5cGVvZiBuYW1lc1tuXSAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvalN0b3JlW25hbWVzW25dXSkge1xuICAgIHJldHVybiBwcm9qU3RvcmVbbmFtZXNbbl1dO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydCgpIHtcbiAgcHJvanMuZm9yRWFjaChhZGQpO1xufVxuZXhwb3J0IGRlZmF1bHQge1xuICBzdGFydDogc3RhcnQsXG4gIGFkZDogYWRkLFxuICBnZXQ6IGdldFxufTtcbiIsInZhciBleHBvcnRzID0ge307XG5leHBvcnQge2V4cG9ydHMgYXMgZGVmYXVsdH07XG5leHBvcnRzLk1FUklUID0ge1xuICBhOiA2Mzc4MTM3LjAsXG4gIHJmOiAyOTguMjU3LFxuICBlbGxpcHNlTmFtZTogXCJNRVJJVCAxOTgzXCJcbn07XG5cbmV4cG9ydHMuU0dTODUgPSB7XG4gIGE6IDYzNzgxMzYuMCxcbiAgcmY6IDI5OC4yNTcsXG4gIGVsbGlwc2VOYW1lOiBcIlNvdmlldCBHZW9kZXRpYyBTeXN0ZW0gODVcIlxufTtcblxuZXhwb3J0cy5HUlM4MCA9IHtcbiAgYTogNjM3ODEzNy4wLFxuICByZjogMjk4LjI1NzIyMjEwMSxcbiAgZWxsaXBzZU5hbWU6IFwiR1JTIDE5ODAoSVVHRywgMTk4MClcIlxufTtcblxuZXhwb3J0cy5JQVU3NiA9IHtcbiAgYTogNjM3ODE0MC4wLFxuICByZjogMjk4LjI1NyxcbiAgZWxsaXBzZU5hbWU6IFwiSUFVIDE5NzZcIlxufTtcblxuZXhwb3J0cy5haXJ5ID0ge1xuICBhOiA2Mzc3NTYzLjM5NixcbiAgYjogNjM1NjI1Ni45MTAsXG4gIGVsbGlwc2VOYW1lOiBcIkFpcnkgMTgzMFwiXG59O1xuXG5leHBvcnRzLkFQTDQgPSB7XG4gIGE6IDYzNzgxMzcsXG4gIHJmOiAyOTguMjUsXG4gIGVsbGlwc2VOYW1lOiBcIkFwcGwuIFBoeXNpY3MuIDE5NjVcIlxufTtcblxuZXhwb3J0cy5OV0w5RCA9IHtcbiAgYTogNjM3ODE0NS4wLFxuICByZjogMjk4LjI1LFxuICBlbGxpcHNlTmFtZTogXCJOYXZhbCBXZWFwb25zIExhYi4sIDE5NjVcIlxufTtcblxuZXhwb3J0cy5tb2RfYWlyeSA9IHtcbiAgYTogNjM3NzM0MC4xODksXG4gIGI6IDYzNTYwMzQuNDQ2LFxuICBlbGxpcHNlTmFtZTogXCJNb2RpZmllZCBBaXJ5XCJcbn07XG5cbmV4cG9ydHMuYW5kcmFlID0ge1xuICBhOiA2Mzc3MTA0LjQzLFxuICByZjogMzAwLjAsXG4gIGVsbGlwc2VOYW1lOiBcIkFuZHJhZSAxODc2IChEZW4uLCBJY2xuZC4pXCJcbn07XG5cbmV4cG9ydHMuYXVzdF9TQSA9IHtcbiAgYTogNjM3ODE2MC4wLFxuICByZjogMjk4LjI1LFxuICBlbGxpcHNlTmFtZTogXCJBdXN0cmFsaWFuIE5hdGwgJiBTLiBBbWVyLiAxOTY5XCJcbn07XG5cbmV4cG9ydHMuR1JTNjcgPSB7XG4gIGE6IDYzNzgxNjAuMCxcbiAgcmY6IDI5OC4yNDcxNjc0MjcwLFxuICBlbGxpcHNlTmFtZTogXCJHUlMgNjcoSVVHRyAxOTY3KVwiXG59O1xuXG5leHBvcnRzLmJlc3NlbCA9IHtcbiAgYTogNjM3NzM5Ny4xNTUsXG4gIHJmOiAyOTkuMTUyODEyOCxcbiAgZWxsaXBzZU5hbWU6IFwiQmVzc2VsIDE4NDFcIlxufTtcblxuZXhwb3J0cy5iZXNzX25hbSA9IHtcbiAgYTogNjM3NzQ4My44NjUsXG4gIHJmOiAyOTkuMTUyODEyOCxcbiAgZWxsaXBzZU5hbWU6IFwiQmVzc2VsIDE4NDEgKE5hbWliaWEpXCJcbn07XG5cbmV4cG9ydHMuY2xyazY2ID0ge1xuICBhOiA2Mzc4MjA2LjQsXG4gIGI6IDYzNTY1ODMuOCxcbiAgZWxsaXBzZU5hbWU6IFwiQ2xhcmtlIDE4NjZcIlxufTtcblxuZXhwb3J0cy5jbHJrODAgPSB7XG4gIGE6IDYzNzgyNDkuMTQ1LFxuICByZjogMjkzLjQ2NjMsXG4gIGVsbGlwc2VOYW1lOiBcIkNsYXJrZSAxODgwIG1vZC5cIlxufTtcblxuZXhwb3J0cy5jbHJrNTggPSB7XG4gIGE6IDYzNzgyOTMuNjQ1MjA4NzU5LFxuICByZjogMjk0LjI2MDY3NjM2OTI2NTQsXG4gIGVsbGlwc2VOYW1lOiBcIkNsYXJrZSAxODU4XCJcbn07XG5cbmV4cG9ydHMuQ1BNID0ge1xuICBhOiA2Mzc1NzM4LjcsXG4gIHJmOiAzMzQuMjksXG4gIGVsbGlwc2VOYW1lOiBcIkNvbW0uIGRlcyBQb2lkcyBldCBNZXN1cmVzIDE3OTlcIlxufTtcblxuZXhwb3J0cy5kZWxtYnIgPSB7XG4gIGE6IDYzNzY0MjguMCxcbiAgcmY6IDMxMS41LFxuICBlbGxpcHNlTmFtZTogXCJEZWxhbWJyZSAxODEwIChCZWxnaXVtKVwiXG59O1xuXG5leHBvcnRzLmVuZ2VsaXMgPSB7XG4gIGE6IDYzNzgxMzYuMDUsXG4gIHJmOiAyOTguMjU2NixcbiAgZWxsaXBzZU5hbWU6IFwiRW5nZWxpcyAxOTg1XCJcbn07XG5cbmV4cG9ydHMuZXZyc3QzMCA9IHtcbiAgYTogNjM3NzI3Ni4zNDUsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAxODMwXCJcbn07XG5cbmV4cG9ydHMuZXZyc3Q0OCA9IHtcbiAgYTogNjM3NzMwNC4wNjMsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAxOTQ4XCJcbn07XG5cbmV4cG9ydHMuZXZyc3Q1NiA9IHtcbiAgYTogNjM3NzMwMS4yNDMsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAxOTU2XCJcbn07XG5cbmV4cG9ydHMuZXZyc3Q2OSA9IHtcbiAgYTogNjM3NzI5NS42NjQsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAxOTY5XCJcbn07XG5cbmV4cG9ydHMuZXZyc3RTUyA9IHtcbiAgYTogNjM3NzI5OC41NTYsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAoU2FiYWggJiBTYXJhd2FrKVwiXG59O1xuXG5leHBvcnRzLmZzY2hyNjAgPSB7XG4gIGE6IDYzNzgxNjYuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJGaXNjaGVyIChNZXJjdXJ5IERhdHVtKSAxOTYwXCJcbn07XG5cbmV4cG9ydHMuZnNjaHI2MG0gPSB7XG4gIGE6IDYzNzgxNTUuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJGaXNjaGVyIDE5NjBcIlxufTtcblxuZXhwb3J0cy5mc2NocjY4ID0ge1xuICBhOiA2Mzc4MTUwLjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiRmlzY2hlciAxOTY4XCJcbn07XG5cbmV4cG9ydHMuaGVsbWVydCA9IHtcbiAgYTogNjM3ODIwMC4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIkhlbG1lcnQgMTkwNlwiXG59O1xuXG5leHBvcnRzLmhvdWdoID0ge1xuICBhOiA2Mzc4MjcwLjAsXG4gIHJmOiAyOTcuMCxcbiAgZWxsaXBzZU5hbWU6IFwiSG91Z2hcIlxufTtcblxuZXhwb3J0cy5pbnRsID0ge1xuICBhOiA2Mzc4Mzg4LjAsXG4gIHJmOiAyOTcuMCxcbiAgZWxsaXBzZU5hbWU6IFwiSW50ZXJuYXRpb25hbCAxOTA5IChIYXlmb3JkKVwiXG59O1xuXG5leHBvcnRzLmthdWxhID0ge1xuICBhOiA2Mzc4MTYzLjAsXG4gIHJmOiAyOTguMjQsXG4gIGVsbGlwc2VOYW1lOiBcIkthdWxhIDE5NjFcIlxufTtcblxuZXhwb3J0cy5sZXJjaCA9IHtcbiAgYTogNjM3ODEzOS4wLFxuICByZjogMjk4LjI1NyxcbiAgZWxsaXBzZU5hbWU6IFwiTGVyY2ggMTk3OVwiXG59O1xuXG5leHBvcnRzLm1wcnRzID0ge1xuICBhOiA2Mzk3MzAwLjAsXG4gIHJmOiAxOTEuMCxcbiAgZWxsaXBzZU5hbWU6IFwiTWF1cGVydGl1cyAxNzM4XCJcbn07XG5cbmV4cG9ydHMubmV3X2ludGwgPSB7XG4gIGE6IDYzNzgxNTcuNSxcbiAgYjogNjM1Njc3Mi4yLFxuICBlbGxpcHNlTmFtZTogXCJOZXcgSW50ZXJuYXRpb25hbCAxOTY3XCJcbn07XG5cbmV4cG9ydHMucGxlc3NpcyA9IHtcbiAgYTogNjM3NjUyMy4wLFxuICByZjogNjM1NTg2My4wLFxuICBlbGxpcHNlTmFtZTogXCJQbGVzc2lzIDE4MTcgKEZyYW5jZSlcIlxufTtcblxuZXhwb3J0cy5rcmFzcyA9IHtcbiAgYTogNjM3ODI0NS4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIktyYXNzb3Zza3ksIDE5NDJcIlxufTtcblxuZXhwb3J0cy5TRWFzaWEgPSB7XG4gIGE6IDYzNzgxNTUuMCxcbiAgYjogNjM1Njc3My4zMjA1LFxuICBlbGxpcHNlTmFtZTogXCJTb3V0aGVhc3QgQXNpYVwiXG59O1xuXG5leHBvcnRzLndhbGJlY2sgPSB7XG4gIGE6IDYzNzY4OTYuMCxcbiAgYjogNjM1NTgzNC44NDY3LFxuICBlbGxpcHNlTmFtZTogXCJXYWxiZWNrXCJcbn07XG5cbmV4cG9ydHMuV0dTNjAgPSB7XG4gIGE6IDYzNzgxNjUuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJXR1MgNjBcIlxufTtcblxuZXhwb3J0cy5XR1M2NiA9IHtcbiAgYTogNjM3ODE0NS4wLFxuICByZjogMjk4LjI1LFxuICBlbGxpcHNlTmFtZTogXCJXR1MgNjZcIlxufTtcblxuZXhwb3J0cy5XR1M3ID0ge1xuICBhOiA2Mzc4MTM1LjAsXG4gIHJmOiAyOTguMjYsXG4gIGVsbGlwc2VOYW1lOiBcIldHUyA3MlwiXG59O1xuXG5leHBvcnQgdmFyIFdHUzg0ID0gZXhwb3J0cy5XR1M4NCA9IHtcbiAgYTogNjM3ODEzNy4wLFxuICByZjogMjk4LjI1NzIyMzU2MyxcbiAgZWxsaXBzZU5hbWU6IFwiV0dTIDg0XCJcbn07XG5cbmV4cG9ydHMuc3BoZXJlID0ge1xuICBhOiA2MzcwOTk3LjAsXG4gIGI6IDYzNzA5OTcuMCxcbiAgZWxsaXBzZU5hbWU6IFwiTm9ybWFsIFNwaGVyZSAocj02MzcwOTk3KVwiXG59O1xuIiwiaW1wb3J0IHtTSVhUSCwgUkE0LCBSQTYsIEVQU0xOfSBmcm9tICcuL2NvbnN0YW50cy92YWx1ZXMnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIEVsbGlwc29pZCwgV0dTODR9IGZyb20gJy4vY29uc3RhbnRzL0VsbGlwc29pZCc7XG5pbXBvcnQgbWF0Y2ggZnJvbSAnLi9tYXRjaCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBlY2NlbnRyaWNpdHkoYSwgYiwgcmYsIFJfQSkge1xuICB2YXIgYTIgPSBhICogYTsgLy8gdXNlZCBpbiBnZW9jZW50cmljXG4gIHZhciBiMiA9IGIgKiBiOyAvLyB1c2VkIGluIGdlb2NlbnRyaWNcbiAgdmFyIGVzID0gKGEyIC0gYjIpIC8gYTI7IC8vIGUgXiAyXG4gIHZhciBlID0gMDtcbiAgaWYgKFJfQSkge1xuICAgIGEgKj0gMSAtIGVzICogKFNJWFRIICsgZXMgKiAoUkE0ICsgZXMgKiBSQTYpKTtcbiAgICBhMiA9IGEgKiBhO1xuICAgIGVzID0gMDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5zcXJ0KGVzKTsgLy8gZWNjZW50cmljaXR5XG4gIH1cbiAgdmFyIGVwMiA9IChhMiAtIGIyKSAvIGIyOyAvLyB1c2VkIGluIGdlb2NlbnRyaWNcbiAgcmV0dXJuIHtcbiAgICBlczogZXMsXG4gICAgZTogZSxcbiAgICBlcDI6IGVwMlxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwaGVyZShhLCBiLCByZiwgZWxscHMsIHNwaGVyZSkge1xuICBpZiAoIWEpIHsgLy8gZG8gd2UgaGF2ZSBhbiBlbGxpcHNvaWQ/XG4gICAgdmFyIGVsbGlwc2UgPSBtYXRjaChFbGxpcHNvaWQsIGVsbHBzKTtcbiAgICBpZiAoIWVsbGlwc2UpIHtcbiAgICAgIGVsbGlwc2UgPSBXR1M4NDtcbiAgICB9XG4gICAgYSA9IGVsbGlwc2UuYTtcbiAgICBiID0gZWxsaXBzZS5iO1xuICAgIHJmID0gZWxsaXBzZS5yZjtcbiAgfVxuXG4gIGlmIChyZiAmJiAhYikge1xuICAgIGIgPSAoMS4wIC0gMS4wIC8gcmYpICogYTtcbiAgfVxuICBpZiAocmYgPT09IDAgfHwgTWF0aC5hYnMoYSAtIGIpIDwgRVBTTE4pIHtcbiAgICBzcGhlcmUgPSB0cnVlO1xuICAgIGIgPSBhO1xuICB9XG4gIHJldHVybiB7XG4gICAgYTogYSxcbiAgICBiOiBiLFxuICAgIHJmOiByZixcbiAgICBzcGhlcmU6IHNwaGVyZVxuICB9O1xufVxuIiwidmFyIGV4cG9ydHMgPSB7fTtcbmV4cG9ydCB7ZXhwb3J0cyBhcyBkZWZhdWx0fTtcbmV4cG9ydHMud2dzODQgPSB7XG4gIHRvd2dzODQ6IFwiMCwwLDBcIixcbiAgZWxsaXBzZTogXCJXR1M4NFwiLFxuICBkYXR1bU5hbWU6IFwiV0dTODRcIlxufTtcblxuZXhwb3J0cy5jaDE5MDMgPSB7XG4gIHRvd2dzODQ6IFwiNjc0LjM3NCwxNS4wNTYsNDA1LjM0NlwiLFxuICBlbGxpcHNlOiBcImJlc3NlbFwiLFxuICBkYXR1bU5hbWU6IFwic3dpc3NcIlxufTtcblxuZXhwb3J0cy5nZ3JzODcgPSB7XG4gIHRvd2dzODQ6IFwiLTE5OS44Nyw3NC43OSwyNDYuNjJcIixcbiAgZWxsaXBzZTogXCJHUlM4MFwiLFxuICBkYXR1bU5hbWU6IFwiR3JlZWtfR2VvZGV0aWNfUmVmZXJlbmNlX1N5c3RlbV8xOTg3XCJcbn07XG5cbmV4cG9ydHMubmFkODMgPSB7XG4gIHRvd2dzODQ6IFwiMCwwLDBcIixcbiAgZWxsaXBzZTogXCJHUlM4MFwiLFxuICBkYXR1bU5hbWU6IFwiTm9ydGhfQW1lcmljYW5fRGF0dW1fMTk4M1wiXG59O1xuXG5leHBvcnRzLm5hZDI3ID0ge1xuICBuYWRncmlkczogXCJAY29udXMsQGFsYXNrYSxAbnR2Ml8wLmdzYixAbnR2MV9jYW4uZGF0XCIsXG4gIGVsbGlwc2U6IFwiY2xyazY2XCIsXG4gIGRhdHVtTmFtZTogXCJOb3J0aF9BbWVyaWNhbl9EYXR1bV8xOTI3XCJcbn07XG5cbmV4cG9ydHMucG90c2RhbSA9IHtcbiAgdG93Z3M4NDogXCI1OTguMSw3My43LDQxOC4yLDAuMjAyLDAuMDQ1LC0yLjQ1NSw2LjdcIixcbiAgZWxsaXBzZTogXCJiZXNzZWxcIixcbiAgZGF0dW1OYW1lOiBcIlBvdHNkYW0gUmF1ZW5iZXJnIDE5NTAgREhETlwiXG59O1xuXG5leHBvcnRzLmNhcnRoYWdlID0ge1xuICB0b3dnczg0OiBcIi0yNjMuMCw2LjAsNDMxLjBcIixcbiAgZWxsaXBzZTogXCJjbGFyazgwXCIsXG4gIGRhdHVtTmFtZTogXCJDYXJ0aGFnZSAxOTM0IFR1bmlzaWFcIlxufTtcblxuZXhwb3J0cy5oZXJtYW5uc2tvZ2VsID0ge1xuICB0b3dnczg0OiBcIjU3Ny4zMjYsOTAuMTI5LDQ2My45MTksNS4xMzcsMS40NzQsNS4yOTcsMi40MjMyXCIsXG4gIGVsbGlwc2U6IFwiYmVzc2VsXCIsXG4gIGRhdHVtTmFtZTogXCJIZXJtYW5uc2tvZ2VsXCJcbn07XG5cbmV4cG9ydHMub3NuaTUyID0ge1xuICB0b3dnczg0OiBcIjQ4Mi41MzAsLTEzMC41OTYsNTY0LjU1NywtMS4wNDIsLTAuMjE0LC0wLjYzMSw4LjE1XCIsXG4gIGVsbGlwc2U6IFwiYWlyeVwiLFxuICBkYXR1bU5hbWU6IFwiSXJpc2ggTmF0aW9uYWxcIlxufTtcblxuZXhwb3J0cy5pcmU2NSA9IHtcbiAgdG93Z3M4NDogXCI0ODIuNTMwLC0xMzAuNTk2LDU2NC41NTcsLTEuMDQyLC0wLjIxNCwtMC42MzEsOC4xNVwiLFxuICBlbGxpcHNlOiBcIm1vZF9haXJ5XCIsXG4gIGRhdHVtTmFtZTogXCJJcmVsYW5kIDE5NjVcIlxufTtcblxuZXhwb3J0cy5yYXNzYWRpcmFuID0ge1xuICB0b3dnczg0OiBcIi0xMzMuNjMsLTE1Ny41LC0xNTguNjJcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSYXNzYWRpcmFuXCJcbn07XG5cbmV4cG9ydHMubnpnZDQ5ID0ge1xuICB0b3dnczg0OiBcIjU5LjQ3LC01LjA0LDE4Ny40NCwwLjQ3LC0wLjEsMS4wMjQsLTQuNTk5M1wiLFxuICBlbGxpcHNlOiBcImludGxcIixcbiAgZGF0dW1OYW1lOiBcIk5ldyBaZWFsYW5kIEdlb2RldGljIERhdHVtIDE5NDlcIlxufTtcblxuZXhwb3J0cy5vc2diMzYgPSB7XG4gIHRvd2dzODQ6IFwiNDQ2LjQ0OCwtMTI1LjE1Nyw1NDIuMDYwLDAuMTUwMiwwLjI0NzAsMC44NDIxLC0yMC40ODk0XCIsXG4gIGVsbGlwc2U6IFwiYWlyeVwiLFxuICBkYXR1bU5hbWU6IFwiQWlyeSAxODMwXCJcbn07XG5cbmV4cG9ydHMuc19qdHNrID0ge1xuICB0b3dnczg0OiBcIjU4OSw3Niw0ODBcIixcbiAgZWxsaXBzZTogJ2Jlc3NlbCcsXG4gIGRhdHVtTmFtZTogJ1MtSlRTSyAoRmVycm8pJ1xufTtcblxuZXhwb3J0cy5iZWR1YXJhbSA9IHtcbiAgdG93Z3M4NDogJy0xMDYsLTg3LDE4OCcsXG4gIGVsbGlwc2U6ICdjbHJrODAnLFxuICBkYXR1bU5hbWU6ICdCZWR1YXJhbSdcbn07XG5cbmV4cG9ydHMuZ3VudW5nX3NlZ2FyYSA9IHtcbiAgdG93Z3M4NDogJy00MDMsNjg0LDQxJyxcbiAgZWxsaXBzZTogJ2Jlc3NlbCcsXG4gIGRhdHVtTmFtZTogJ0d1bnVuZyBTZWdhcmEgSmFrYXJ0YSdcbn07XG5cbmV4cG9ydHMucm5iNzIgPSB7XG4gIHRvd2dzODQ6IFwiMTA2Ljg2OSwtNTIuMjk3OCwxMDMuNzI0LC0wLjMzNjU3LDAuNDU2OTU1LC0xLjg0MjE4LDFcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSZXNlYXUgTmF0aW9uYWwgQmVsZ2UgMTk3MlwiXG59O1xuIiwiaW1wb3J0IHtQSkRfM1BBUkFNLCBQSkRfN1BBUkFNLCBQSkRfR1JJRFNISUZULCBQSkRfV0dTODQsIFBKRF9OT0RBVFVNLCBTRUNfVE9fUkFEfSBmcm9tICcuL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5mdW5jdGlvbiBkYXR1bShkYXR1bUNvZGUsIGRhdHVtX3BhcmFtcywgYSwgYiwgZXMsIGVwMiwgbmFkZ3JpZHMpIHtcbiAgdmFyIG91dCA9IHt9O1xuXG4gIGlmIChkYXR1bUNvZGUgPT09IHVuZGVmaW5lZCB8fCBkYXR1bUNvZGUgPT09ICdub25lJykge1xuICAgIG91dC5kYXR1bV90eXBlID0gUEpEX05PREFUVU07XG4gIH0gZWxzZSB7XG4gICAgb3V0LmRhdHVtX3R5cGUgPSBQSkRfV0dTODQ7XG4gIH1cblxuICBpZiAoZGF0dW1fcGFyYW1zKSB7XG4gICAgb3V0LmRhdHVtX3BhcmFtcyA9IGRhdHVtX3BhcmFtcy5tYXAocGFyc2VGbG9hdCk7XG4gICAgaWYgKG91dC5kYXR1bV9wYXJhbXNbMF0gIT09IDAgfHwgb3V0LmRhdHVtX3BhcmFtc1sxXSAhPT0gMCB8fCBvdXQuZGF0dW1fcGFyYW1zWzJdICE9PSAwKSB7XG4gICAgICBvdXQuZGF0dW1fdHlwZSA9IFBKRF8zUEFSQU07XG4gICAgfVxuICAgIGlmIChvdXQuZGF0dW1fcGFyYW1zLmxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChvdXQuZGF0dW1fcGFyYW1zWzNdICE9PSAwIHx8IG91dC5kYXR1bV9wYXJhbXNbNF0gIT09IDAgfHwgb3V0LmRhdHVtX3BhcmFtc1s1XSAhPT0gMCB8fCBvdXQuZGF0dW1fcGFyYW1zWzZdICE9PSAwKSB7XG4gICAgICAgIG91dC5kYXR1bV90eXBlID0gUEpEXzdQQVJBTTtcbiAgICAgICAgb3V0LmRhdHVtX3BhcmFtc1szXSAqPSBTRUNfVE9fUkFEO1xuICAgICAgICBvdXQuZGF0dW1fcGFyYW1zWzRdICo9IFNFQ19UT19SQUQ7XG4gICAgICAgIG91dC5kYXR1bV9wYXJhbXNbNV0gKj0gU0VDX1RPX1JBRDtcbiAgICAgICAgb3V0LmRhdHVtX3BhcmFtc1s2XSA9IChvdXQuZGF0dW1fcGFyYW1zWzZdIC8gMTAwMDAwMC4wKSArIDEuMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmFkZ3JpZHMpIHtcbiAgICBvdXQuZGF0dW1fdHlwZSA9IFBKRF9HUklEU0hJRlQ7XG4gICAgb3V0LmdyaWRzID0gbmFkZ3JpZHM7XG4gIH1cbiAgb3V0LmEgPSBhOyAvL2RhdHVtIG9iamVjdCBhbHNvIHVzZXMgdGhlc2UgdmFsdWVzXG4gIG91dC5iID0gYjtcbiAgb3V0LmVzID0gZXM7XG4gIG91dC5lcDIgPSBlcDI7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRhdHVtO1xuIiwiLyoqXG4gKiBSZXNvdXJjZXMgZm9yIGRldGFpbHMgb2YgTlR2MiBmaWxlIGZvcm1hdHM6XG4gKiAtIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MDEyNzIwNDgyMmlmXy9odHRwOi8vd3d3Lm1ncy5nb3Yub24uY2E6ODAvc3RkcHJvZGNvbnN1bWUvZ3JvdXBzL2NvbnRlbnQvQG1ncy9AaWFuZGl0L2RvY3VtZW50cy9yZXNvdXJjZWxpc3Qvc3RlbDAyXzA0NzQ0Ny5wZGZcbiAqIC0gaHR0cDovL21pbWFrYS5jb20vaGVscC9ncy9odG1sLzAwNF9OVFYyJTIwRGF0YSUyMEZvcm1hdC5odG1cbiAqL1xuXG52YXIgbG9hZGVkTmFkZ3JpZHMgPSB7fTtcblxuLyoqXG4gKiBMb2FkIGEgYmluYXJ5IE5UdjIgZmlsZSAoLmdzYikgdG8gYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBpbiBhIHByb2ogc3RyaW5nIGxpa2UgK25hZGdyaWRzPTxrZXk+LiBQYXNzIHRoZSBOVHYyIGZpbGVcbiAqIGFzIGFuIEFycmF5QnVmZmVyLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuYWRncmlkKGtleSwgZGF0YSkge1xuICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhkYXRhKTtcbiAgdmFyIGlzTGl0dGxlRW5kaWFuID0gZGV0ZWN0TGl0dGxlRW5kaWFuKHZpZXcpO1xuICB2YXIgaGVhZGVyID0gcmVhZEhlYWRlcih2aWV3LCBpc0xpdHRsZUVuZGlhbik7XG4gIGlmIChoZWFkZXIublN1YmdyaWRzID4gMSkge1xuICAgIGNvbnNvbGUubG9nKCdPbmx5IHNpbmdsZSBOVHYyIHN1YmdyaWRzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkLCBzdWJzZXF1ZW50IHN1YiBncmlkcyBhcmUgaWdub3JlZCcpO1xuICB9XG4gIHZhciBzdWJncmlkcyA9IHJlYWRTdWJncmlkcyh2aWV3LCBoZWFkZXIsIGlzTGl0dGxlRW5kaWFuKTtcbiAgdmFyIG5hZGdyaWQgPSB7aGVhZGVyOiBoZWFkZXIsIHN1YmdyaWRzOiBzdWJncmlkc307XG4gIGxvYWRlZE5hZGdyaWRzW2tleV0gPSBuYWRncmlkO1xuICByZXR1cm4gbmFkZ3JpZDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHByb2o0IHZhbHVlIGZvciBuYWRncmlkcywgcmV0dXJuIGFuIGFycmF5IG9mIGxvYWRlZCBncmlkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmFkZ3JpZHMobmFkZ3JpZHMpIHtcbiAgLy8gRm9ybWF0IGRldGFpbHM6IGh0dHA6Ly9wcm9qLm1hcHRvb2xzLm9yZy9nZW5fcGFybXMuaHRtbFxuICBpZiAobmFkZ3JpZHMgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gbnVsbDsgfVxuICB2YXIgZ3JpZHMgPSBuYWRncmlkcy5zcGxpdCgnLCcpO1xuICByZXR1cm4gZ3JpZHMubWFwKHBhcnNlTmFkZ3JpZFN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTmFkZ3JpZFN0cmluZyh2YWx1ZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG9wdGlvbmFsID0gdmFsdWVbMF0gPT09ICdAJztcbiAgaWYgKG9wdGlvbmFsKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuICBpZiAodmFsdWUgPT09ICdudWxsJykge1xuICAgIHJldHVybiB7bmFtZTogJ251bGwnLCBtYW5kYXRvcnk6ICFvcHRpb25hbCwgZ3JpZDogbnVsbCwgaXNOdWxsOiB0cnVlfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IHZhbHVlLFxuICAgIG1hbmRhdG9yeTogIW9wdGlvbmFsLFxuICAgIGdyaWQ6IGxvYWRlZE5hZGdyaWRzW3ZhbHVlXSB8fCBudWxsLFxuICAgIGlzTnVsbDogZmFsc2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2Vjb25kc1RvUmFkaWFucyhzZWNvbmRzKSB7XG4gIHJldHVybiAoc2Vjb25kcyAvIDM2MDApICogTWF0aC5QSSAvIDE4MDtcbn1cblxuZnVuY3Rpb24gZGV0ZWN0TGl0dGxlRW5kaWFuKHZpZXcpIHtcbiAgdmFyIG5GaWVsZHMgPSB2aWV3LmdldEludDMyKDgsIGZhbHNlKTtcbiAgaWYgKG5GaWVsZHMgPT09IDExKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG5GaWVsZHMgPSB2aWV3LmdldEludDMyKDgsIHRydWUpO1xuICBpZiAobkZpZWxkcyAhPT0gMTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBkZXRlY3QgbmFkZ3JpZCBlbmRpYW4tbmVzcywgZGVmYXVsdGluZyB0byBsaXR0bGUtZW5kaWFuJyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRIZWFkZXIodmlldywgaXNMaXR0bGVFbmRpYW4pIHtcbiAgcmV0dXJuIHtcbiAgICBuRmllbGRzOiB2aWV3LmdldEludDMyKDgsIGlzTGl0dGxlRW5kaWFuKSxcbiAgICBuU3ViZ3JpZEZpZWxkczogdmlldy5nZXRJbnQzMigyNCwgaXNMaXR0bGVFbmRpYW4pLFxuICAgIG5TdWJncmlkczogdmlldy5nZXRJbnQzMig0MCwgaXNMaXR0bGVFbmRpYW4pLFxuICAgIHNoaWZ0VHlwZTogZGVjb2RlU3RyaW5nKHZpZXcsIDU2LCA1NiArIDgpLnRyaW0oKSxcbiAgICBmcm9tU2VtaU1ham9yQXhpczogdmlldy5nZXRGbG9hdDY0KDEyMCwgaXNMaXR0bGVFbmRpYW4pLFxuICAgIGZyb21TZW1pTWlub3JBeGlzOiB2aWV3LmdldEZsb2F0NjQoMTM2LCBpc0xpdHRsZUVuZGlhbiksXG4gICAgdG9TZW1pTWFqb3JBeGlzOiB2aWV3LmdldEZsb2F0NjQoMTUyLCBpc0xpdHRsZUVuZGlhbiksXG4gICAgdG9TZW1pTWlub3JBeGlzOiB2aWV3LmdldEZsb2F0NjQoMTY4LCBpc0xpdHRsZUVuZGlhbiksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyh2aWV3LCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRTdWJncmlkcyh2aWV3LCBoZWFkZXIsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBncmlkT2Zmc2V0ID0gMTc2O1xuICB2YXIgZ3JpZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXIublN1YmdyaWRzOyBpKyspIHtcbiAgICB2YXIgc3ViSGVhZGVyID0gcmVhZEdyaWRIZWFkZXIodmlldywgZ3JpZE9mZnNldCwgaXNMaXR0bGVFbmRpYW4pO1xuICAgIHZhciBub2RlcyA9IHJlYWRHcmlkTm9kZXModmlldywgZ3JpZE9mZnNldCwgc3ViSGVhZGVyLCBpc0xpdHRsZUVuZGlhbik7XG4gICAgdmFyIGxuZ0NvbHVtbkNvdW50ID0gTWF0aC5yb3VuZChcbiAgICAgIDEgKyAoc3ViSGVhZGVyLnVwcGVyTG9uZ2l0dWRlIC0gc3ViSGVhZGVyLmxvd2VyTG9uZ2l0dWRlKSAvIHN1YkhlYWRlci5sb25naXR1ZGVJbnRlcnZhbCk7XG4gICAgdmFyIGxhdENvbHVtbkNvdW50ID0gTWF0aC5yb3VuZChcbiAgICAgIDEgKyAoc3ViSGVhZGVyLnVwcGVyTGF0aXR1ZGUgLSBzdWJIZWFkZXIubG93ZXJMYXRpdHVkZSkgLyBzdWJIZWFkZXIubGF0aXR1ZGVJbnRlcnZhbCk7XG4gICAgLy8gUHJvajQgb3BlcmF0ZXMgb24gcmFkaWFucyB3aGVyZWFzIHRoZSBjb29yZGluYXRlcyBhcmUgaW4gc2Vjb25kcyBpbiB0aGUgZ3JpZFxuICAgIGdyaWRzLnB1c2goe1xuICAgICAgbGw6IFtzZWNvbmRzVG9SYWRpYW5zKHN1YkhlYWRlci5sb3dlckxvbmdpdHVkZSksIHNlY29uZHNUb1JhZGlhbnMoc3ViSGVhZGVyLmxvd2VyTGF0aXR1ZGUpXSxcbiAgICAgIGRlbDogW3NlY29uZHNUb1JhZGlhbnMoc3ViSGVhZGVyLmxvbmdpdHVkZUludGVydmFsKSwgc2Vjb25kc1RvUmFkaWFucyhzdWJIZWFkZXIubGF0aXR1ZGVJbnRlcnZhbCldLFxuICAgICAgbGltOiBbbG5nQ29sdW1uQ291bnQsIGxhdENvbHVtbkNvdW50XSxcbiAgICAgIGNvdW50OiBzdWJIZWFkZXIuZ3JpZE5vZGVDb3VudCxcbiAgICAgIGN2czogbWFwTm9kZXMobm9kZXMpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGdyaWRzO1xufVxuXG5mdW5jdGlvbiBtYXBOb2Rlcyhub2Rlcykge1xuICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uIChyKSB7cmV0dXJuIFtzZWNvbmRzVG9SYWRpYW5zKHIubG9uZ2l0dWRlU2hpZnQpLCBzZWNvbmRzVG9SYWRpYW5zKHIubGF0aXR1ZGVTaGlmdCldO30pO1xufVxuXG5mdW5jdGlvbiByZWFkR3JpZEhlYWRlcih2aWV3LCBvZmZzZXQsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogZGVjb2RlU3RyaW5nKHZpZXcsIG9mZnNldCArIDgsIG9mZnNldCArIDE2KS50cmltKCksXG4gICAgcGFyZW50OiBkZWNvZGVTdHJpbmcodmlldywgb2Zmc2V0ICsgMjQsIG9mZnNldCArIDI0ICsgOCkudHJpbSgpLFxuICAgIGxvd2VyTGF0aXR1ZGU6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQgKyA3MiwgaXNMaXR0bGVFbmRpYW4pLFxuICAgIHVwcGVyTGF0aXR1ZGU6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQgKyA4OCwgaXNMaXR0bGVFbmRpYW4pLFxuICAgIGxvd2VyTG9uZ2l0dWRlOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0ICsgMTA0LCBpc0xpdHRsZUVuZGlhbiksXG4gICAgdXBwZXJMb25naXR1ZGU6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQgKyAxMjAsIGlzTGl0dGxlRW5kaWFuKSxcbiAgICBsYXRpdHVkZUludGVydmFsOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0ICsgMTM2LCBpc0xpdHRsZUVuZGlhbiksXG4gICAgbG9uZ2l0dWRlSW50ZXJ2YWw6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQgKyAxNTIsIGlzTGl0dGxlRW5kaWFuKSxcbiAgICBncmlkTm9kZUNvdW50OiB2aWV3LmdldEludDMyKG9mZnNldCArIDE2OCwgaXNMaXR0bGVFbmRpYW4pXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRHcmlkTm9kZXModmlldywgb2Zmc2V0LCBncmlkSGVhZGVyLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbm9kZXNPZmZzZXQgPSBvZmZzZXQgKyAxNzY7XG4gIHZhciBncmlkUmVjb3JkTGVuZ3RoID0gMTY7XG4gIHZhciBncmlkU2hpZnRSZWNvcmRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JpZEhlYWRlci5ncmlkTm9kZUNvdW50OyBpKyspIHtcbiAgICB2YXIgcmVjb3JkID0ge1xuICAgICAgbGF0aXR1ZGVTaGlmdDogdmlldy5nZXRGbG9hdDMyKG5vZGVzT2Zmc2V0ICsgaSAqIGdyaWRSZWNvcmRMZW5ndGgsIGlzTGl0dGxlRW5kaWFuKSxcbiAgICAgIGxvbmdpdHVkZVNoaWZ0OiB2aWV3LmdldEZsb2F0MzIobm9kZXNPZmZzZXQgKyBpICogZ3JpZFJlY29yZExlbmd0aCArIDQsIGlzTGl0dGxlRW5kaWFuKSxcbiAgICAgIGxhdGl0dWRlQWNjdXJhY3k6IHZpZXcuZ2V0RmxvYXQzMihub2Rlc09mZnNldCArIGkgKiBncmlkUmVjb3JkTGVuZ3RoICsgOCwgaXNMaXR0bGVFbmRpYW4pLFxuICAgICAgbG9uZ2l0dWRlQWNjdXJhY3k6IHZpZXcuZ2V0RmxvYXQzMihub2Rlc09mZnNldCArIGkgKiBncmlkUmVjb3JkTGVuZ3RoICsgMTIsIGlzTGl0dGxlRW5kaWFuKSxcbiAgICB9O1xuICAgIGdyaWRTaGlmdFJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG4gIHJldHVybiBncmlkU2hpZnRSZWNvcmRzO1xufVxuIiwiaW1wb3J0IHBhcnNlQ29kZSBmcm9tICcuL3BhcnNlQ29kZSc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4vZXh0ZW5kJztcbmltcG9ydCBwcm9qZWN0aW9ucyBmcm9tICcuL3Byb2plY3Rpb25zJztcbmltcG9ydCB7c3BoZXJlIGFzIGRjX3NwaGVyZSwgZWNjZW50cmljaXR5IGFzIGRjX2VjY2VudHJpY2l0eX0gZnJvbSAnLi9kZXJpdmVDb25zdGFudHMnO1xuaW1wb3J0IERhdHVtIGZyb20gJy4vY29uc3RhbnRzL0RhdHVtJztcbmltcG9ydCBkYXR1bSBmcm9tICcuL2RhdHVtJztcbmltcG9ydCBtYXRjaCBmcm9tICcuL21hdGNoJztcbmltcG9ydCB7Z2V0TmFkZ3JpZHN9IGZyb20gXCIuL25hZGdyaWRcIjtcblxuZnVuY3Rpb24gUHJvamVjdGlvbihzcnNDb2RlLGNhbGxiYWNrKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9qZWN0aW9uKSkge1xuICAgIHJldHVybiBuZXcgUHJvamVjdGlvbihzcnNDb2RlKTtcbiAgfVxuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKGVycm9yKXtcbiAgICBpZihlcnJvcil7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIHZhciBqc29uID0gcGFyc2VDb2RlKHNyc0NvZGUpO1xuICBpZih0eXBlb2YganNvbiAhPT0gJ29iamVjdCcpe1xuICAgIGNhbGxiYWNrKHNyc0NvZGUpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3VyUHJvaiA9IFByb2plY3Rpb24ucHJvamVjdGlvbnMuZ2V0KGpzb24ucHJvak5hbWUpO1xuICBpZighb3VyUHJvail7XG4gICAgY2FsbGJhY2soc3JzQ29kZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChqc29uLmRhdHVtQ29kZSAmJiBqc29uLmRhdHVtQ29kZSAhPT0gJ25vbmUnKSB7XG4gICAgdmFyIGRhdHVtRGVmID0gbWF0Y2goRGF0dW0sIGpzb24uZGF0dW1Db2RlKTtcbiAgICBpZiAoZGF0dW1EZWYpIHtcbiAgICAgIGpzb24uZGF0dW1fcGFyYW1zID0ganNvbi5kYXR1bV9wYXJhbXMgfHwgKGRhdHVtRGVmLnRvd2dzODQgPyBkYXR1bURlZi50b3dnczg0LnNwbGl0KCcsJykgOiBudWxsKTtcbiAgICAgIGpzb24uZWxscHMgPSBkYXR1bURlZi5lbGxpcHNlO1xuICAgICAganNvbi5kYXR1bU5hbWUgPSBkYXR1bURlZi5kYXR1bU5hbWUgPyBkYXR1bURlZi5kYXR1bU5hbWUgOiBqc29uLmRhdHVtQ29kZTtcbiAgICB9XG4gIH1cbiAganNvbi5rMCA9IGpzb24uazAgfHwgMS4wO1xuICBqc29uLmF4aXMgPSBqc29uLmF4aXMgfHwgJ2VudSc7XG4gIGpzb24uZWxscHMgPSBqc29uLmVsbHBzIHx8ICd3Z3M4NCc7XG4gIGpzb24ubGF0MSA9IGpzb24ubGF0MSB8fCBqc29uLmxhdDA7IC8vIExhbWJlcnRfQ29uZm9ybWFsX0NvbmljXzFTUCwgZm9yIGV4YW1wbGUsIG5lZWRzIHRoaXNcblxuICB2YXIgc3BoZXJlXyA9IGRjX3NwaGVyZShqc29uLmEsIGpzb24uYiwganNvbi5yZiwganNvbi5lbGxwcywganNvbi5zcGhlcmUpO1xuICB2YXIgZWNjID0gZGNfZWNjZW50cmljaXR5KHNwaGVyZV8uYSwgc3BoZXJlXy5iLCBzcGhlcmVfLnJmLCBqc29uLlJfQSk7XG4gIHZhciBuYWRncmlkcyA9IGdldE5hZGdyaWRzKGpzb24ubmFkZ3JpZHMpO1xuICB2YXIgZGF0dW1PYmogPSBqc29uLmRhdHVtIHx8IGRhdHVtKGpzb24uZGF0dW1Db2RlLCBqc29uLmRhdHVtX3BhcmFtcywgc3BoZXJlXy5hLCBzcGhlcmVfLmIsIGVjYy5lcywgZWNjLmVwMixcbiAgICBuYWRncmlkcyk7XG5cbiAgZXh0ZW5kKHRoaXMsIGpzb24pOyAvLyB0cmFuc2ZlciBldmVyeXRoaW5nIG92ZXIgZnJvbSB0aGUgcHJvamVjdGlvbiBiZWNhdXNlIHdlIGRvbid0IGtub3cgd2hhdCB3ZSdsbCBuZWVkXG4gIGV4dGVuZCh0aGlzLCBvdXJQcm9qKTsgLy8gdHJhbnNmZXIgYWxsIHRoZSBtZXRob2RzIGZyb20gdGhlIHByb2plY3Rpb25cblxuICAvLyBjb3B5IHRoZSA0IHRoaW5ncyBvdmVyIHdlIGNhbGN1bGF0ZWQgaW4gZGVyaXZlQ29uc3RhbnRzLnNwaGVyZVxuICB0aGlzLmEgPSBzcGhlcmVfLmE7XG4gIHRoaXMuYiA9IHNwaGVyZV8uYjtcbiAgdGhpcy5yZiA9IHNwaGVyZV8ucmY7XG4gIHRoaXMuc3BoZXJlID0gc3BoZXJlXy5zcGhlcmU7XG5cbiAgLy8gY29weSB0aGUgMyB0aGluZ3Mgd2UgY2FsY3VsYXRlZCBpbiBkZXJpdmVDb25zdGFudHMuZWNjZW50cmljaXR5XG4gIHRoaXMuZXMgPSBlY2MuZXM7XG4gIHRoaXMuZSA9IGVjYy5lO1xuICB0aGlzLmVwMiA9IGVjYy5lcDI7XG5cbiAgLy8gYWRkIGluIHRoZSBkYXR1bSBvYmplY3RcbiAgdGhpcy5kYXR1bSA9IGRhdHVtT2JqO1xuXG4gIC8vIGluaXQgdGhlIHByb2plY3Rpb25cbiAgdGhpcy5pbml0KCk7XG5cbiAgLy8gbGVnZWN5IGNhbGxiYWNrIGZyb20gYmFjayBpbiB0aGUgZGF5IHdoZW4gaXQgd2VudCB0byBzcGF0aWFscmVmZXJlbmNlLm9yZ1xuICBjYWxsYmFjayhudWxsLCB0aGlzKTtcblxufVxuUHJvamVjdGlvbi5wcm9qZWN0aW9ucyA9IHByb2plY3Rpb25zO1xuUHJvamVjdGlvbi5wcm9qZWN0aW9ucy5zdGFydCgpO1xuZXhwb3J0IGRlZmF1bHQgUHJvamVjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCB7UEpEXzNQQVJBTSwgUEpEXzdQQVJBTSwgSEFMRl9QSX0gZnJvbSAnLi9jb25zdGFudHMvdmFsdWVzJztcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlRGF0dW1zKHNvdXJjZSwgZGVzdCkge1xuICBpZiAoc291cmNlLmRhdHVtX3R5cGUgIT09IGRlc3QuZGF0dW1fdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTsgLy8gZmFsc2UsIGRhdHVtcyBhcmUgbm90IGVxdWFsXG4gIH0gZWxzZSBpZiAoc291cmNlLmEgIT09IGRlc3QuYSB8fCBNYXRoLmFicyhzb3VyY2UuZXMgLSBkZXN0LmVzKSA+IDAuMDAwMDAwMDAwMDUwKSB7XG4gICAgLy8gdGhlIHRvbGVyYW5jZSBmb3IgZXMgaXMgdG8gZW5zdXJlIHRoYXQgR1JTODAgYW5kIFdHUzg0XG4gICAgLy8gYXJlIGNvbnNpZGVyZWQgaWRlbnRpY2FsXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKHNvdXJjZS5kYXR1bV90eXBlID09PSBQSkRfM1BBUkFNKSB7XG4gICAgcmV0dXJuIChzb3VyY2UuZGF0dW1fcGFyYW1zWzBdID09PSBkZXN0LmRhdHVtX3BhcmFtc1swXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzFdID09PSBkZXN0LmRhdHVtX3BhcmFtc1sxXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzJdID09PSBkZXN0LmRhdHVtX3BhcmFtc1syXSk7XG4gIH0gZWxzZSBpZiAoc291cmNlLmRhdHVtX3R5cGUgPT09IFBKRF83UEFSQU0pIHtcbiAgICByZXR1cm4gKHNvdXJjZS5kYXR1bV9wYXJhbXNbMF0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzBdICYmIHNvdXJjZS5kYXR1bV9wYXJhbXNbMV0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzFdICYmIHNvdXJjZS5kYXR1bV9wYXJhbXNbMl0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzJdICYmIHNvdXJjZS5kYXR1bV9wYXJhbXNbM10gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzNdICYmIHNvdXJjZS5kYXR1bV9wYXJhbXNbNF0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzRdICYmIHNvdXJjZS5kYXR1bV9wYXJhbXNbNV0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzVdICYmIHNvdXJjZS5kYXR1bV9wYXJhbXNbNl0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzZdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gZGF0dW1zIGFyZSBlcXVhbFxuICB9XG59IC8vIGNzX2NvbXBhcmVfZGF0dW1zKClcblxuLypcbiAqIFRoZSBmdW5jdGlvbiBDb252ZXJ0X0dlb2RldGljX1RvX0dlb2NlbnRyaWMgY29udmVydHMgZ2VvZGV0aWMgY29vcmRpbmF0ZXNcbiAqIChsYXRpdHVkZSwgbG9uZ2l0dWRlLCBhbmQgaGVpZ2h0KSB0byBnZW9jZW50cmljIGNvb3JkaW5hdGVzIChYLCBZLCBaKSxcbiAqIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBlbGxpcHNvaWQgcGFyYW1ldGVycy5cbiAqXG4gKiAgICBMYXRpdHVkZSAgOiBHZW9kZXRpYyBsYXRpdHVkZSBpbiByYWRpYW5zICAgICAgICAgICAgICAgICAgICAgKGlucHV0KVxuICogICAgTG9uZ2l0dWRlIDogR2VvZGV0aWMgbG9uZ2l0dWRlIGluIHJhZGlhbnMgICAgICAgICAgICAgICAgICAgIChpbnB1dClcbiAqICAgIEhlaWdodCAgICA6IEdlb2RldGljIGhlaWdodCwgaW4gbWV0ZXJzICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQpXG4gKiAgICBYICAgICAgICAgOiBDYWxjdWxhdGVkIEdlb2NlbnRyaWMgWCBjb29yZGluYXRlLCBpbiBtZXRlcnMgICAgKG91dHB1dClcbiAqICAgIFkgICAgICAgICA6IENhbGN1bGF0ZWQgR2VvY2VudHJpYyBZIGNvb3JkaW5hdGUsIGluIG1ldGVycyAgICAob3V0cHV0KVxuICogICAgWiAgICAgICAgIDogQ2FsY3VsYXRlZCBHZW9jZW50cmljIFogY29vcmRpbmF0ZSwgaW4gbWV0ZXJzICAgIChvdXRwdXQpXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VvZGV0aWNUb0dlb2NlbnRyaWMocCwgZXMsIGEpIHtcbiAgdmFyIExvbmdpdHVkZSA9IHAueDtcbiAgdmFyIExhdGl0dWRlID0gcC55O1xuICB2YXIgSGVpZ2h0ID0gcC56ID8gcC56IDogMDsgLy9aIHZhbHVlIG5vdCBhbHdheXMgc3VwcGxpZWRcblxuICB2YXIgUm47IC8qICBFYXJ0aCByYWRpdXMgYXQgbG9jYXRpb24gICovXG4gIHZhciBTaW5fTGF0OyAvKiAgTWF0aC5zaW4oTGF0aXR1ZGUpICAqL1xuICB2YXIgU2luMl9MYXQ7IC8qICBTcXVhcmUgb2YgTWF0aC5zaW4oTGF0aXR1ZGUpICAqL1xuICB2YXIgQ29zX0xhdDsgLyogIE1hdGguY29zKExhdGl0dWRlKSAgKi9cblxuICAvKlxuICAgKiogRG9uJ3QgYmxvdyB1cCBpZiBMYXRpdHVkZSBpcyBqdXN0IGEgbGl0dGxlIG91dCBvZiB0aGUgdmFsdWVcbiAgICoqIHJhbmdlIGFzIGl0IG1heSBqdXN0IGJlIGEgcm91bmRpbmcgaXNzdWUuICBBbHNvIHJlbW92ZWQgbG9uZ2l0dWRlXG4gICAqKiB0ZXN0LCBpdCBzaG91bGQgYmUgd3JhcHBlZCBieSBNYXRoLmNvcygpIGFuZCBNYXRoLnNpbigpLiAgTkZXIGZvciBQUk9KLjQsIFNlcC8yMDAxLlxuICAgKi9cbiAgaWYgKExhdGl0dWRlIDwgLUhBTEZfUEkgJiYgTGF0aXR1ZGUgPiAtMS4wMDEgKiBIQUxGX1BJKSB7XG4gICAgTGF0aXR1ZGUgPSAtSEFMRl9QSTtcbiAgfSBlbHNlIGlmIChMYXRpdHVkZSA+IEhBTEZfUEkgJiYgTGF0aXR1ZGUgPCAxLjAwMSAqIEhBTEZfUEkpIHtcbiAgICBMYXRpdHVkZSA9IEhBTEZfUEk7XG4gIH0gZWxzZSBpZiAoTGF0aXR1ZGUgPCAtSEFMRl9QSSkge1xuICAgIC8qIExhdGl0dWRlIG91dCBvZiByYW5nZSAqL1xuICAgIC8vLi5yZXBvcnRFcnJvcignZ2VvY2VudDpsYXQgb3V0IG9mIHJhbmdlOicgKyBMYXRpdHVkZSk7XG4gICAgcmV0dXJuIHsgeDogLUluZmluaXR5LCB5OiAtSW5maW5pdHksIHo6IHAueiB9O1xuICB9IGVsc2UgaWYgKExhdGl0dWRlID4gSEFMRl9QSSkge1xuICAgIC8qIExhdGl0dWRlIG91dCBvZiByYW5nZSAqL1xuICAgIHJldHVybiB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSwgejogcC56IH07XG4gIH1cblxuICBpZiAoTG9uZ2l0dWRlID4gTWF0aC5QSSkge1xuICAgIExvbmdpdHVkZSAtPSAoMiAqIE1hdGguUEkpO1xuICB9XG4gIFNpbl9MYXQgPSBNYXRoLnNpbihMYXRpdHVkZSk7XG4gIENvc19MYXQgPSBNYXRoLmNvcyhMYXRpdHVkZSk7XG4gIFNpbjJfTGF0ID0gU2luX0xhdCAqIFNpbl9MYXQ7XG4gIFJuID0gYSAvIChNYXRoLnNxcnQoMS4wZTAgLSBlcyAqIFNpbjJfTGF0KSk7XG4gIHJldHVybiB7XG4gICAgeDogKFJuICsgSGVpZ2h0KSAqIENvc19MYXQgKiBNYXRoLmNvcyhMb25naXR1ZGUpLFxuICAgIHk6IChSbiArIEhlaWdodCkgKiBDb3NfTGF0ICogTWF0aC5zaW4oTG9uZ2l0dWRlKSxcbiAgICB6OiAoKFJuICogKDEgLSBlcykpICsgSGVpZ2h0KSAqIFNpbl9MYXRcbiAgfTtcbn0gLy8gY3NfZ2VvZGV0aWNfdG9fZ2VvY2VudHJpYygpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW9jZW50cmljVG9HZW9kZXRpYyhwLCBlcywgYSwgYikge1xuICAvKiBsb2NhbCBkZWZpbnRpb25zIGFuZCB2YXJpYWJsZXMgKi9cbiAgLyogZW5kLWNyaXRlcml1bSBvZiBsb29wLCBhY2N1cmFjeSBvZiBzaW4oTGF0aXR1ZGUpICovXG4gIHZhciBnZW5hdSA9IDFlLTEyO1xuICB2YXIgZ2VuYXUyID0gKGdlbmF1ICogZ2VuYXUpO1xuICB2YXIgbWF4aXRlciA9IDMwO1xuXG4gIHZhciBQOyAvKiBkaXN0YW5jZSBiZXR3ZWVuIHNlbWktbWlub3IgYXhpcyBhbmQgbG9jYXRpb24gKi9cbiAgdmFyIFJSOyAvKiBkaXN0YW5jZSBiZXR3ZWVuIGNlbnRlciBhbmQgbG9jYXRpb24gKi9cbiAgdmFyIENUOyAvKiBzaW4gb2YgZ2VvY2VudHJpYyBsYXRpdHVkZSAqL1xuICB2YXIgU1Q7IC8qIGNvcyBvZiBnZW9jZW50cmljIGxhdGl0dWRlICovXG4gIHZhciBSWDtcbiAgdmFyIFJLO1xuICB2YXIgUk47IC8qIEVhcnRoIHJhZGl1cyBhdCBsb2NhdGlvbiAqL1xuICB2YXIgQ1BISTA7IC8qIGNvcyBvZiBzdGFydCBvciBvbGQgZ2VvZGV0aWMgbGF0aXR1ZGUgaW4gaXRlcmF0aW9ucyAqL1xuICB2YXIgU1BISTA7IC8qIHNpbiBvZiBzdGFydCBvciBvbGQgZ2VvZGV0aWMgbGF0aXR1ZGUgaW4gaXRlcmF0aW9ucyAqL1xuICB2YXIgQ1BISTsgLyogY29zIG9mIHNlYXJjaGVkIGdlb2RldGljIGxhdGl0dWRlICovXG4gIHZhciBTUEhJOyAvKiBzaW4gb2Ygc2VhcmNoZWQgZ2VvZGV0aWMgbGF0aXR1ZGUgKi9cbiAgdmFyIFNEUEhJOyAvKiBlbmQtY3JpdGVyaXVtOiBhZGRpdGlvbi10aGVvcmVtIG9mIHNpbihMYXRpdHVkZShpdGVyKS1MYXRpdHVkZShpdGVyLTEpKSAqL1xuICB2YXIgaXRlcjsgLyogIyBvZiBjb250aW5vdXMgaXRlcmF0aW9uLCBtYXguIDMwIGlzIGFsd2F5cyBlbm91Z2ggKHMuYS4pICovXG5cbiAgdmFyIFggPSBwLng7XG4gIHZhciBZID0gcC55O1xuICB2YXIgWiA9IHAueiA/IHAueiA6IDAuMDsgLy9aIHZhbHVlIG5vdCBhbHdheXMgc3VwcGxpZWRcbiAgdmFyIExvbmdpdHVkZTtcbiAgdmFyIExhdGl0dWRlO1xuICB2YXIgSGVpZ2h0O1xuXG4gIFAgPSBNYXRoLnNxcnQoWCAqIFggKyBZICogWSk7XG4gIFJSID0gTWF0aC5zcXJ0KFggKiBYICsgWSAqIFkgKyBaICogWik7XG5cbiAgLyogICAgICBzcGVjaWFsIGNhc2VzIGZvciBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlICovXG4gIGlmIChQIC8gYSA8IGdlbmF1KSB7XG5cbiAgICAvKiAgc3BlY2lhbCBjYXNlLCBpZiBQPTAuIChYPTAuLCBZPTAuKSAqL1xuICAgIExvbmdpdHVkZSA9IDAuMDtcblxuICAgIC8qICBpZiAoWCxZLFopPSgwLiwwLiwwLikgdGhlbiBIZWlnaHQgYmVjb21lcyBzZW1pLW1pbm9yIGF4aXNcbiAgICAgKiAgb2YgZWxsaXBzb2lkICg9Y2VudGVyIG9mIG1hc3MpLCBMYXRpdHVkZSBiZWNvbWVzIFBJLzIgKi9cbiAgICBpZiAoUlIgLyBhIDwgZ2VuYXUpIHtcbiAgICAgIExhdGl0dWRlID0gSEFMRl9QSTtcbiAgICAgIEhlaWdodCA9IC1iO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcC54LFxuICAgICAgICB5OiBwLnksXG4gICAgICAgIHo6IHAuelxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLyogIGVsbGlwc29pZGFsIChnZW9kZXRpYykgbG9uZ2l0dWRlXG4gICAgICogIGludGVydmFsOiAtUEkgPCBMb25naXR1ZGUgPD0gK1BJICovXG4gICAgTG9uZ2l0dWRlID0gTWF0aC5hdGFuMihZLCBYKTtcbiAgfVxuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEZvbGxvd2luZyBpdGVyYXRpdmUgYWxnb3JpdGhtIHdhcyBkZXZlbG9wcGVkIGJ5XG4gICAqIFwiSW5zdGl0dXQgZm9yIEVyZG1lc3N1bmdcIiwgVW5pdmVyc2l0eSBvZiBIYW5ub3ZlciwgSnVseSAxOTg4LlxuICAgKiBJbnRlcm5ldDogd3d3LmlmZS51bmktaGFubm92ZXIuZGVcbiAgICogSXRlcmF0aXZlIGNvbXB1dGF0aW9uIG9mIENQSEksU1BISSBhbmQgSGVpZ2h0LlxuICAgKiBJdGVyYXRpb24gb2YgQ1BISSBhbmQgU1BISSB0byAxMCoqLTEyIHJhZGlhbiByZXNwLlxuICAgKiAyKjEwKiotNyBhcmNzZWMuXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICBDVCA9IFogLyBSUjtcbiAgU1QgPSBQIC8gUlI7XG4gIFJYID0gMS4wIC8gTWF0aC5zcXJ0KDEuMCAtIGVzICogKDIuMCAtIGVzKSAqIFNUICogU1QpO1xuICBDUEhJMCA9IFNUICogKDEuMCAtIGVzKSAqIFJYO1xuICBTUEhJMCA9IENUICogUlg7XG4gIGl0ZXIgPSAwO1xuXG4gIC8qIGxvb3AgdG8gZmluZCBzaW4oTGF0aXR1ZGUpIHJlc3AuIExhdGl0dWRlXG4gICAqIHVudGlsIHxzaW4oTGF0aXR1ZGUoaXRlciktTGF0aXR1ZGUoaXRlci0xKSl8IDwgZ2VuYXUgKi9cbiAgZG8ge1xuICAgIGl0ZXIrKztcbiAgICBSTiA9IGEgLyBNYXRoLnNxcnQoMS4wIC0gZXMgKiBTUEhJMCAqIFNQSEkwKTtcblxuICAgIC8qICBlbGxpcHNvaWRhbCAoZ2VvZGV0aWMpIGhlaWdodCAqL1xuICAgIEhlaWdodCA9IFAgKiBDUEhJMCArIFogKiBTUEhJMCAtIFJOICogKDEuMCAtIGVzICogU1BISTAgKiBTUEhJMCk7XG5cbiAgICBSSyA9IGVzICogUk4gLyAoUk4gKyBIZWlnaHQpO1xuICAgIFJYID0gMS4wIC8gTWF0aC5zcXJ0KDEuMCAtIFJLICogKDIuMCAtIFJLKSAqIFNUICogU1QpO1xuICAgIENQSEkgPSBTVCAqICgxLjAgLSBSSykgKiBSWDtcbiAgICBTUEhJID0gQ1QgKiBSWDtcbiAgICBTRFBISSA9IFNQSEkgKiBDUEhJMCAtIENQSEkgKiBTUEhJMDtcbiAgICBDUEhJMCA9IENQSEk7XG4gICAgU1BISTAgPSBTUEhJO1xuICB9XG4gIHdoaWxlIChTRFBISSAqIFNEUEhJID4gZ2VuYXUyICYmIGl0ZXIgPCBtYXhpdGVyKTtcblxuICAvKiAgICAgIGVsbGlwc29pZGFsIChnZW9kZXRpYykgbGF0aXR1ZGUgKi9cbiAgTGF0aXR1ZGUgPSBNYXRoLmF0YW4oU1BISSAvIE1hdGguYWJzKENQSEkpKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBMb25naXR1ZGUsXG4gICAgeTogTGF0aXR1ZGUsXG4gICAgejogSGVpZ2h0XG4gIH07XG59IC8vIGNzX2dlb2NlbnRyaWNfdG9fZ2VvZGV0aWMoKVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8vIHBqX2dlb2NlbnRpY190b193Z3M4NCggcCApXG4vLyAgcCA9IHBvaW50IHRvIHRyYW5zZm9ybSBpbiBnZW9jZW50cmljIGNvb3JkaW5hdGVzICh4LHkseilcblxuXG4vKiogcG9pbnQgb2JqZWN0LCBub3RoaW5nIGZhbmN5LCBqdXN0IGFsbG93cyB2YWx1ZXMgdG8gYmVcbiAgICBwYXNzZWQgYmFjayBhbmQgZm9ydGggYnkgcmVmZXJlbmNlIHJhdGhlciB0aGFuIGJ5IHZhbHVlLlxuICAgIE90aGVyIHBvaW50IGNsYXNzZXMgbWF5IGJlIHVzZWQgYXMgbG9uZyBhcyB0aGV5IGhhdmVcbiAgICB4IGFuZCB5IHByb3BlcnRpZXMsIHdoaWNoIHdpbGwgZ2V0IG1vZGlmaWVkIGluIHRoZSB0cmFuc2Zvcm0gbWV0aG9kLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW9jZW50cmljVG9XZ3M4NChwLCBkYXR1bV90eXBlLCBkYXR1bV9wYXJhbXMpIHtcblxuICBpZiAoZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSkge1xuICAgIC8vIGlmKCB4W2lvXSA9PT0gSFVHRV9WQUwgKVxuICAgIC8vICAgIGNvbnRpbnVlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwLnggKyBkYXR1bV9wYXJhbXNbMF0sXG4gICAgICB5OiBwLnkgKyBkYXR1bV9wYXJhbXNbMV0sXG4gICAgICB6OiBwLnogKyBkYXR1bV9wYXJhbXNbMl0sXG4gICAgfTtcbiAgfSBlbHNlIGlmIChkYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSB7XG4gICAgdmFyIER4X0JGID0gZGF0dW1fcGFyYW1zWzBdO1xuICAgIHZhciBEeV9CRiA9IGRhdHVtX3BhcmFtc1sxXTtcbiAgICB2YXIgRHpfQkYgPSBkYXR1bV9wYXJhbXNbMl07XG4gICAgdmFyIFJ4X0JGID0gZGF0dW1fcGFyYW1zWzNdO1xuICAgIHZhciBSeV9CRiA9IGRhdHVtX3BhcmFtc1s0XTtcbiAgICB2YXIgUnpfQkYgPSBkYXR1bV9wYXJhbXNbNV07XG4gICAgdmFyIE1fQkYgPSBkYXR1bV9wYXJhbXNbNl07XG4gICAgLy8gaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgLy8gICAgY29udGludWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1fQkYgKiAocC54IC0gUnpfQkYgKiBwLnkgKyBSeV9CRiAqIHAueikgKyBEeF9CRixcbiAgICAgIHk6IE1fQkYgKiAoUnpfQkYgKiBwLnggKyBwLnkgLSBSeF9CRiAqIHAueikgKyBEeV9CRixcbiAgICAgIHo6IE1fQkYgKiAoLVJ5X0JGICogcC54ICsgUnhfQkYgKiBwLnkgKyBwLnopICsgRHpfQkZcbiAgICB9O1xuICB9XG59IC8vIGNzX2dlb2NlbnRyaWNfdG9fd2dzODRcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLyBwal9nZW9jZW50aWNfZnJvbV93Z3M4NCgpXG4vLyAgY29vcmRpbmF0ZSBzeXN0ZW0gZGVmaW5pdGlvbixcbi8vICBwb2ludCB0byB0cmFuc2Zvcm0gaW4gZ2VvY2VudHJpYyBjb29yZGluYXRlcyAoeCx5LHopXG5leHBvcnQgZnVuY3Rpb24gZ2VvY2VudHJpY0Zyb21XZ3M4NChwLCBkYXR1bV90eXBlLCBkYXR1bV9wYXJhbXMpIHtcblxuICBpZiAoZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSkge1xuICAgIC8vaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgLy8gICAgY29udGludWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHAueCAtIGRhdHVtX3BhcmFtc1swXSxcbiAgICAgIHk6IHAueSAtIGRhdHVtX3BhcmFtc1sxXSxcbiAgICAgIHo6IHAueiAtIGRhdHVtX3BhcmFtc1syXSxcbiAgICB9O1xuXG4gIH0gZWxzZSBpZiAoZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkge1xuICAgIHZhciBEeF9CRiA9IGRhdHVtX3BhcmFtc1swXTtcbiAgICB2YXIgRHlfQkYgPSBkYXR1bV9wYXJhbXNbMV07XG4gICAgdmFyIER6X0JGID0gZGF0dW1fcGFyYW1zWzJdO1xuICAgIHZhciBSeF9CRiA9IGRhdHVtX3BhcmFtc1szXTtcbiAgICB2YXIgUnlfQkYgPSBkYXR1bV9wYXJhbXNbNF07XG4gICAgdmFyIFJ6X0JGID0gZGF0dW1fcGFyYW1zWzVdO1xuICAgIHZhciBNX0JGID0gZGF0dW1fcGFyYW1zWzZdO1xuICAgIHZhciB4X3RtcCA9IChwLnggLSBEeF9CRikgLyBNX0JGO1xuICAgIHZhciB5X3RtcCA9IChwLnkgLSBEeV9CRikgLyBNX0JGO1xuICAgIHZhciB6X3RtcCA9IChwLnogLSBEel9CRikgLyBNX0JGO1xuICAgIC8vaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgLy8gICAgY29udGludWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeF90bXAgKyBSel9CRiAqIHlfdG1wIC0gUnlfQkYgKiB6X3RtcCxcbiAgICAgIHk6IC1Sel9CRiAqIHhfdG1wICsgeV90bXAgKyBSeF9CRiAqIHpfdG1wLFxuICAgICAgejogUnlfQkYgKiB4X3RtcCAtIFJ4X0JGICogeV90bXAgKyB6X3RtcFxuICAgIH07XG4gIH0gLy9jc19nZW9jZW50cmljX2Zyb21fd2dzODQoKVxufVxuIiwiaW1wb3J0IHtcbiAgUEpEXzNQQVJBTSxcbiAgUEpEXzdQQVJBTSxcbiAgUEpEX0dSSURTSElGVCxcbiAgUEpEX05PREFUVU0sXG4gIFIyRCxcbiAgU1JTX1dHUzg0X0VTUVVBUkVELFxuICBTUlNfV0dTODRfU0VNSU1BSk9SLCBTUlNfV0dTODRfU0VNSU1JTk9SXG59IGZyb20gJy4vY29uc3RhbnRzL3ZhbHVlcyc7XG5cbmltcG9ydCB7Z2VvZGV0aWNUb0dlb2NlbnRyaWMsIGdlb2NlbnRyaWNUb0dlb2RldGljLCBnZW9jZW50cmljVG9XZ3M4NCwgZ2VvY2VudHJpY0Zyb21XZ3M4NCwgY29tcGFyZURhdHVtc30gZnJvbSAnLi9kYXR1bVV0aWxzJztcbmltcG9ydCBhZGp1c3RfbG9uIGZyb20gXCIuL2NvbW1vbi9hZGp1c3RfbG9uXCI7XG5mdW5jdGlvbiBjaGVja1BhcmFtcyh0eXBlKSB7XG4gIHJldHVybiAodHlwZSA9PT0gUEpEXzNQQVJBTSB8fCB0eXBlID09PSBQSkRfN1BBUkFNKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc291cmNlLCBkZXN0LCBwb2ludCkge1xuICAvLyBTaG9ydCBjdXQgaWYgdGhlIGRhdHVtcyBhcmUgaWRlbnRpY2FsLlxuICBpZiAoY29tcGFyZURhdHVtcyhzb3VyY2UsIGRlc3QpKSB7XG4gICAgcmV0dXJuIHBvaW50OyAvLyBpbiB0aGlzIGNhc2UsIHplcm8gaXMgc3VjZXNzLFxuICAgIC8vIHdoZXJlYXMgY3NfY29tcGFyZV9kYXR1bXMgcmV0dXJucyAxIHRvIGluZGljYXRlIFRSVUVcbiAgICAvLyBjb25mdXNpbmcsIHNob3VsZCBmaXggdGhpc1xuICB9XG5cbiAgLy8gRXhwbGljaXRseSBza2lwIGRhdHVtIHRyYW5zZm9ybSBieSBzZXR0aW5nICdkYXR1bT1ub25lJyBhcyBwYXJhbWV0ZXIgZm9yIGVpdGhlciBzb3VyY2Ugb3IgZGVzdFxuICBpZiAoc291cmNlLmRhdHVtX3R5cGUgPT09IFBKRF9OT0RBVFVNIHx8IGRlc3QuZGF0dW1fdHlwZSA9PT0gUEpEX05PREFUVU0pIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICAvLyBJZiB0aGlzIGRhdHVtIHJlcXVpcmVzIGdyaWQgc2hpZnRzLCB0aGVuIGFwcGx5IGl0IHRvIGdlb2RldGljIGNvb3JkaW5hdGVzLlxuICB2YXIgc291cmNlX2EgPSBzb3VyY2UuYTtcbiAgdmFyIHNvdXJjZV9lcyA9IHNvdXJjZS5lcztcbiAgaWYgKHNvdXJjZS5kYXR1bV90eXBlID09PSBQSkRfR1JJRFNISUZUKSB7XG4gICAgdmFyIGdyaWRTaGlmdENvZGUgPSBhcHBseUdyaWRTaGlmdChzb3VyY2UsIGZhbHNlLCBwb2ludCk7XG4gICAgaWYgKGdyaWRTaGlmdENvZGUgIT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNvdXJjZV9hID0gU1JTX1dHUzg0X1NFTUlNQUpPUjtcbiAgICBzb3VyY2VfZXMgPSBTUlNfV0dTODRfRVNRVUFSRUQ7XG4gIH1cblxuICB2YXIgZGVzdF9hID0gZGVzdC5hO1xuICB2YXIgZGVzdF9iID0gZGVzdC5iO1xuICB2YXIgZGVzdF9lcyA9IGRlc3QuZXM7XG4gIGlmIChkZXN0LmRhdHVtX3R5cGUgPT09IFBKRF9HUklEU0hJRlQpIHtcbiAgICBkZXN0X2EgPSBTUlNfV0dTODRfU0VNSU1BSk9SO1xuICAgIGRlc3RfYiA9IFNSU19XR1M4NF9TRU1JTUlOT1I7XG4gICAgZGVzdF9lcyA9IFNSU19XR1M4NF9FU1FVQVJFRDtcbiAgfVxuXG4gIC8vIERvIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCBnZW9jZW50cmljIGNvb3JkaW5hdGVzP1xuICBpZiAoc291cmNlX2VzID09PSBkZXN0X2VzICYmIHNvdXJjZV9hID09PSBkZXN0X2EgJiYgIWNoZWNrUGFyYW1zKHNvdXJjZS5kYXR1bV90eXBlKSAmJiAgIWNoZWNrUGFyYW1zKGRlc3QuZGF0dW1fdHlwZSkpIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICAvLyBDb252ZXJ0IHRvIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMuXG4gIHBvaW50ID0gZ2VvZGV0aWNUb0dlb2NlbnRyaWMocG9pbnQsIHNvdXJjZV9lcywgc291cmNlX2EpO1xuICAvLyBDb252ZXJ0IGJldHdlZW4gZGF0dW1zXG4gIGlmIChjaGVja1BhcmFtcyhzb3VyY2UuZGF0dW1fdHlwZSkpIHtcbiAgICBwb2ludCA9IGdlb2NlbnRyaWNUb1dnczg0KHBvaW50LCBzb3VyY2UuZGF0dW1fdHlwZSwgc291cmNlLmRhdHVtX3BhcmFtcyk7XG4gIH1cbiAgaWYgKGNoZWNrUGFyYW1zKGRlc3QuZGF0dW1fdHlwZSkpIHtcbiAgICBwb2ludCA9IGdlb2NlbnRyaWNGcm9tV2dzODQocG9pbnQsIGRlc3QuZGF0dW1fdHlwZSwgZGVzdC5kYXR1bV9wYXJhbXMpO1xuICB9XG4gIHBvaW50ID0gZ2VvY2VudHJpY1RvR2VvZGV0aWMocG9pbnQsIGRlc3RfZXMsIGRlc3RfYSwgZGVzdF9iKTtcblxuICBpZiAoZGVzdC5kYXR1bV90eXBlID09PSBQSkRfR1JJRFNISUZUKSB7XG4gICAgdmFyIGRlc3RHcmlkU2hpZnRSZXN1bHQgPSBhcHBseUdyaWRTaGlmdChkZXN0LCB0cnVlLCBwb2ludCk7XG4gICAgaWYgKGRlc3RHcmlkU2hpZnRSZXN1bHQgIT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlHcmlkU2hpZnQoc291cmNlLCBpbnZlcnNlLCBwb2ludCkge1xuICBpZiAoc291cmNlLmdyaWRzID09PSBudWxsIHx8IHNvdXJjZS5ncmlkcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmxvZygnR3JpZCBzaGlmdCBncmlkcyBub3QgZm91bmQnKTtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGlucHV0ID0ge3g6IC1wb2ludC54LCB5OiBwb2ludC55fTtcbiAgdmFyIG91dHB1dCA9IHt4OiBOdW1iZXIuTmFOLCB5OiBOdW1iZXIuTmFOfTtcbiAgdmFyIG9ubHlNYW5kYXRvcnlHcmlkcyA9IGZhbHNlO1xuICB2YXIgYXR0ZW1wdGVkR3JpZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UuZ3JpZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JpZCA9IHNvdXJjZS5ncmlkc1tpXTtcbiAgICBhdHRlbXB0ZWRHcmlkcy5wdXNoKGdyaWQubmFtZSk7XG4gICAgaWYgKGdyaWQuaXNOdWxsKSB7XG4gICAgICBvdXRwdXQgPSBpbnB1dDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvbmx5TWFuZGF0b3J5R3JpZHMgPSBncmlkLm1hbmRhdG9yeTtcbiAgICBpZiAoZ3JpZC5ncmlkID09PSBudWxsKSB7XG4gICAgICBpZiAoZ3JpZC5tYW5kYXRvcnkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJVbmFibGUgdG8gZmluZCBtYW5kYXRvcnkgZ3JpZCAnXCIgKyBncmlkLm5hbWUgKyBcIidcIik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgc3ViZ3JpZCA9IGdyaWQuZ3JpZC5zdWJncmlkc1swXTtcbiAgICAvLyBza2lwIHRhYmxlcyB0aGF0IGRvbid0IG1hdGNoIG91ciBwb2ludCBhdCBhbGxcbiAgICB2YXIgZXBzaWxvbiA9IChNYXRoLmFicyhzdWJncmlkLmRlbFsxXSkgKyBNYXRoLmFicyhzdWJncmlkLmRlbFswXSkpIC8gMTAwMDAuMDtcbiAgICB2YXIgbWluWCA9IHN1YmdyaWQubGxbMF0gLSBlcHNpbG9uO1xuICAgIHZhciBtaW5ZID0gc3ViZ3JpZC5sbFsxXSAtIGVwc2lsb247XG4gICAgdmFyIG1heFggPSBzdWJncmlkLmxsWzBdICsgKHN1YmdyaWQubGltWzBdIC0gMSkgKiBzdWJncmlkLmRlbFswXSArIGVwc2lsb247XG4gICAgdmFyIG1heFkgPSBzdWJncmlkLmxsWzFdICsgKHN1YmdyaWQubGltWzFdIC0gMSkgKiBzdWJncmlkLmRlbFsxXSArIGVwc2lsb247XG4gICAgaWYgKG1pblkgPiBpbnB1dC55IHx8IG1pblggPiBpbnB1dC54IHx8IG1heFkgPCBpbnB1dC55IHx8IG1heFggPCBpbnB1dC54ICkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG91dHB1dCA9IGFwcGx5U3ViZ3JpZFNoaWZ0KGlucHV0LCBpbnZlcnNlLCBzdWJncmlkKTtcbiAgICBpZiAoIWlzTmFOKG91dHB1dC54KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpc05hTihvdXRwdXQueCkpIHtcbiAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBmaW5kIGEgZ3JpZCBzaGlmdCB0YWJsZSBmb3IgbG9jYXRpb24gJ1wiK1xuICAgICAgLWlucHV0LnggKiBSMkQgKyBcIiBcIiArIGlucHV0LnkgKiBSMkQgKyBcIiB0cmllZDogJ1wiICsgYXR0ZW1wdGVkR3JpZHMgKyBcIidcIik7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHBvaW50LnggPSAtb3V0cHV0Lng7XG4gIHBvaW50LnkgPSBvdXRwdXQueTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3ViZ3JpZFNoaWZ0KHBpbiwgaW52ZXJzZSwgY3QpIHtcbiAgdmFyIHZhbCA9IHt4OiBOdW1iZXIuTmFOLCB5OiBOdW1iZXIuTmFOfTtcbiAgaWYgKGlzTmFOKHBpbi54KSkgeyByZXR1cm4gdmFsOyB9XG4gIHZhciB0YiA9IHt4OiBwaW4ueCwgeTogcGluLnl9O1xuICB0Yi54IC09IGN0LmxsWzBdO1xuICB0Yi55IC09IGN0LmxsWzFdO1xuICB0Yi54ID0gYWRqdXN0X2xvbih0Yi54IC0gTWF0aC5QSSkgKyBNYXRoLlBJO1xuICB2YXIgdCA9IG5hZEludGVycG9sYXRlKHRiLCBjdCk7XG4gIGlmIChpbnZlcnNlKSB7XG4gICAgaWYgKGlzTmFOKHQueCkpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHQueCA9IHRiLnggLSB0Lng7XG4gICAgdC55ID0gdGIueSAtIHQueTtcbiAgICB2YXIgaSA9IDksIHRvbCA9IDFlLTEyO1xuICAgIHZhciBkaWYsIGRlbDtcbiAgICBkbyB7XG4gICAgICBkZWwgPSBuYWRJbnRlcnBvbGF0ZSh0LCBjdCk7XG4gICAgICBpZiAoaXNOYU4oZGVsLngpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW52ZXJzZSBncmlkIHNoaWZ0IGl0ZXJhdGlvbiBmYWlsZWQsIHByZXN1bWFibHkgYXQgZ3JpZCBlZGdlLiAgVXNpbmcgZmlyc3QgYXBwcm94aW1hdGlvbi5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGlmID0ge3g6IHRiLnggLSAoZGVsLnggKyB0LngpLCB5OiB0Yi55IC0gKGRlbC55ICsgdC55KX07XG4gICAgICB0LnggKz0gZGlmLng7XG4gICAgICB0LnkgKz0gZGlmLnk7XG4gICAgfSB3aGlsZSAoaS0tICYmIE1hdGguYWJzKGRpZi54KSA+IHRvbCAmJiBNYXRoLmFicyhkaWYueSkgPiB0b2wpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgY29uc29sZS5sb2coXCJJbnZlcnNlIGdyaWQgc2hpZnQgaXRlcmF0b3IgZmFpbGVkIHRvIGNvbnZlcmdlLlwiKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHZhbC54ID0gYWRqdXN0X2xvbih0LnggKyBjdC5sbFswXSk7XG4gICAgdmFsLnkgPSB0LnkgKyBjdC5sbFsxXTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWlzTmFOKHQueCkpIHtcbiAgICAgIHZhbC54ID0gcGluLnggKyB0Lng7XG4gICAgICB2YWwueSA9IHBpbi55ICsgdC55O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBuYWRJbnRlcnBvbGF0ZShwaW4sIGN0KSB7XG4gIHZhciB0ID0ge3g6IHBpbi54IC8gY3QuZGVsWzBdLCB5OiBwaW4ueSAvIGN0LmRlbFsxXX07XG4gIHZhciBpbmR4ID0ge3g6IE1hdGguZmxvb3IodC54KSwgeTogTWF0aC5mbG9vcih0LnkpfTtcbiAgdmFyIGZyY3QgPSB7eDogdC54IC0gMS4wICogaW5keC54LCB5OiB0LnkgLSAxLjAgKiBpbmR4Lnl9O1xuICB2YXIgdmFsPSB7eDogTnVtYmVyLk5hTiwgeTogTnVtYmVyLk5hTn07XG4gIHZhciBpbng7XG4gIGlmIChpbmR4LnggPCAwIHx8IGluZHgueCA+PSBjdC5saW1bMF0pIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChpbmR4LnkgPCAwIHx8IGluZHgueSA+PSBjdC5saW1bMV0pIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlueCA9IChpbmR4LnkgKiBjdC5saW1bMF0pICsgaW5keC54O1xuICB2YXIgZjAwID0ge3g6IGN0LmN2c1tpbnhdWzBdLCB5OiBjdC5jdnNbaW54XVsxXX07XG4gIGlueCsrO1xuICB2YXIgZjEwPSB7eDogY3QuY3ZzW2lueF1bMF0sIHk6IGN0LmN2c1tpbnhdWzFdfTtcbiAgaW54ICs9IGN0LmxpbVswXTtcbiAgdmFyIGYxMSA9IHt4OiBjdC5jdnNbaW54XVswXSwgeTogY3QuY3ZzW2lueF1bMV19O1xuICBpbngtLTtcbiAgdmFyIGYwMSA9IHt4OiBjdC5jdnNbaW54XVswXSwgeTogY3QuY3ZzW2lueF1bMV19O1xuICB2YXIgbTExID0gZnJjdC54ICogZnJjdC55LCBtMTAgPSBmcmN0LnggKiAoMS4wIC0gZnJjdC55KSxcbiAgICBtMDAgPSAoMS4wIC0gZnJjdC54KSAqICgxLjAgLSBmcmN0LnkpLCBtMDEgPSAoMS4wIC0gZnJjdC54KSAqIGZyY3QueTtcbiAgdmFsLnggPSAobTAwICogZjAwLnggKyBtMTAgKiBmMTAueCArIG0wMSAqIGYwMS54ICsgbTExICogZjExLngpO1xuICB2YWwueSA9IChtMDAgKiBmMDAueSArIG0xMCAqIGYxMC55ICsgbTAxICogZjAxLnkgKyBtMTEgKiBmMTEueSk7XG4gIHJldHVybiB2YWw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjcnMsIGRlbm9ybSwgcG9pbnQpIHtcbiAgdmFyIHhpbiA9IHBvaW50LngsXG4gICAgeWluID0gcG9pbnQueSxcbiAgICB6aW4gPSBwb2ludC56IHx8IDAuMDtcbiAgdmFyIHYsIHQsIGk7XG4gIHZhciBvdXQgPSB7fTtcbiAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIGlmIChkZW5vcm0gJiYgaSA9PT0gMiAmJiBwb2ludC56ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgdiA9IHhpbjtcbiAgICAgIGlmIChcImV3XCIuaW5kZXhPZihjcnMuYXhpc1tpXSkgIT09IC0xKSB7XG4gICAgICAgIHQgPSAneCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gJ3knO1xuICAgICAgfVxuXG4gICAgfVxuICAgIGVsc2UgaWYgKGkgPT09IDEpIHtcbiAgICAgIHYgPSB5aW47XG4gICAgICBpZiAoXCJuc1wiLmluZGV4T2YoY3JzLmF4aXNbaV0pICE9PSAtMSkge1xuICAgICAgICB0ID0gJ3knO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9ICd4JztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2ID0gemluO1xuICAgICAgdCA9ICd6JztcbiAgICB9XG4gICAgc3dpdGNoIChjcnMuYXhpc1tpXSkge1xuICAgIGNhc2UgJ2UnOlxuICAgICAgb3V0W3RdID0gdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3cnOlxuICAgICAgb3V0W3RdID0gLXY7XG4gICAgICBicmVhaztcbiAgICBjYXNlICduJzpcbiAgICAgIG91dFt0XSA9IHY7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzJzpcbiAgICAgIG91dFt0XSA9IC12O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndSc6XG4gICAgICBpZiAocG9pbnRbdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXQueiA9IHY7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkJzpcbiAgICAgIGlmIChwb2ludFt0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dC56ID0gLXY7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy9jb25zb2xlLmxvZyhcIkVSUk9SOiB1bmtub3cgYXhpcyAoXCIrY3JzLmF4aXNbaV0rXCIpIC0gY2hlY2sgZGVmaW5pdGlvbiBvZiBcIitjcnMucHJvak5hbWUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYXJyYXkpe1xuICB2YXIgb3V0ID0ge1xuICAgIHg6IGFycmF5WzBdLFxuICAgIHk6IGFycmF5WzFdXG4gIH07XG4gIGlmIChhcnJheS5sZW5ndGg+Mikge1xuICAgIG91dC56ID0gYXJyYXlbMl07XG4gIH1cbiAgaWYgKGFycmF5Lmxlbmd0aD4zKSB7XG4gICAgb3V0Lm0gPSBhcnJheVszXTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChwb2ludCkge1xuICBjaGVja0Nvb3JkKHBvaW50LngpO1xuICBjaGVja0Nvb3JkKHBvaW50LnkpO1xufVxuZnVuY3Rpb24gY2hlY2tDb29yZChudW0pIHtcbiAgaWYgKHR5cGVvZiBOdW1iZXIuaXNGaW5pdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG51bSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29vcmRpbmF0ZXMgbXVzdCBiZSBmaW5pdGUgbnVtYmVycycpO1xuICB9XG4gIGlmICh0eXBlb2YgbnVtICE9PSAnbnVtYmVyJyB8fCBudW0gIT09IG51bSB8fCAhaXNGaW5pdGUobnVtKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nvb3JkaW5hdGVzIG11c3QgYmUgZmluaXRlIG51bWJlcnMnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtEMlIsIFIyRCwgUEpEXzNQQVJBTSwgUEpEXzdQQVJBTX0gZnJvbSAnLi9jb25zdGFudHMvdmFsdWVzJztcbmltcG9ydCBkYXR1bV90cmFuc2Zvcm0gZnJvbSAnLi9kYXR1bV90cmFuc2Zvcm0nO1xuaW1wb3J0IGFkanVzdF9heGlzIGZyb20gJy4vYWRqdXN0X2F4aXMnO1xuaW1wb3J0IHByb2ogZnJvbSAnLi9Qcm9qJztcbmltcG9ydCB0b1BvaW50IGZyb20gJy4vY29tbW9uL3RvUG9pbnQnO1xuaW1wb3J0IGNoZWNrU2FuaXR5IGZyb20gJy4vY2hlY2tTYW5pdHknO1xuXG5mdW5jdGlvbiBjaGVja05vdFdHUyhzb3VyY2UsIGRlc3QpIHtcbiAgcmV0dXJuICgoc291cmNlLmRhdHVtLmRhdHVtX3R5cGUgPT09IFBKRF8zUEFSQU0gfHwgc291cmNlLmRhdHVtLmRhdHVtX3R5cGUgPT09IFBKRF83UEFSQU0pICYmIGRlc3QuZGF0dW1Db2RlICE9PSAnV0dTODQnKSB8fCAoKGRlc3QuZGF0dW0uZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSB8fCBkZXN0LmRhdHVtLmRhdHVtX3R5cGUgPT09IFBKRF83UEFSQU0pICYmIHNvdXJjZS5kYXR1bUNvZGUgIT09ICdXR1M4NCcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm0oc291cmNlLCBkZXN0LCBwb2ludCwgZW5mb3JjZUF4aXMpIHtcbiAgdmFyIHdnczg0O1xuICBpZiAoQXJyYXkuaXNBcnJheShwb2ludCkpIHtcbiAgICBwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xuICB9XG4gIGNoZWNrU2FuaXR5KHBvaW50KTtcbiAgLy8gV29ya2Fyb3VuZCBmb3IgZGF0dW0gc2hpZnRzIHRvd2dzODQsIGlmIGVpdGhlciBzb3VyY2Ugb3IgZGVzdGluYXRpb24gcHJvamVjdGlvbiBpcyBub3Qgd2dzODRcbiAgaWYgKHNvdXJjZS5kYXR1bSAmJiBkZXN0LmRhdHVtICYmIGNoZWNrTm90V0dTKHNvdXJjZSwgZGVzdCkpIHtcbiAgICB3Z3M4NCA9IG5ldyBwcm9qKCdXR1M4NCcpO1xuICAgIHBvaW50ID0gdHJhbnNmb3JtKHNvdXJjZSwgd2dzODQsIHBvaW50LCBlbmZvcmNlQXhpcyk7XG4gICAgc291cmNlID0gd2dzODQ7XG4gIH1cbiAgLy8gREdSLCAyMDEwLzExLzEyXG4gIGlmIChlbmZvcmNlQXhpcyAmJiBzb3VyY2UuYXhpcyAhPT0gJ2VudScpIHtcbiAgICBwb2ludCA9IGFkanVzdF9heGlzKHNvdXJjZSwgZmFsc2UsIHBvaW50KTtcbiAgfVxuICAvLyBUcmFuc2Zvcm0gc291cmNlIHBvaW50cyB0byBsb25nL2xhdCwgaWYgdGhleSBhcmVuJ3QgYWxyZWFkeS5cbiAgaWYgKHNvdXJjZS5wcm9qTmFtZSA9PT0gJ2xvbmdsYXQnKSB7XG4gICAgcG9pbnQgPSB7XG4gICAgICB4OiBwb2ludC54ICogRDJSLFxuICAgICAgeTogcG9pbnQueSAqIEQyUixcbiAgICAgIHo6IHBvaW50LnogfHwgMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNvdXJjZS50b19tZXRlcikge1xuICAgICAgcG9pbnQgPSB7XG4gICAgICAgIHg6IHBvaW50LnggKiBzb3VyY2UudG9fbWV0ZXIsXG4gICAgICAgIHk6IHBvaW50LnkgKiBzb3VyY2UudG9fbWV0ZXIsXG4gICAgICAgIHo6IHBvaW50LnogfHwgMFxuICAgICAgfTtcbiAgICB9XG4gICAgcG9pbnQgPSBzb3VyY2UuaW52ZXJzZShwb2ludCk7IC8vIENvbnZlcnQgQ2FydGVzaWFuIHRvIGxvbmdsYXRcbiAgICBpZiAoIXBvaW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIC8vIEFkanVzdCBmb3IgdGhlIHByaW1lIG1lcmlkaWFuIGlmIG5lY2Vzc2FyeVxuICBpZiAoc291cmNlLmZyb21fZ3JlZW53aWNoKSB7XG4gICAgcG9pbnQueCArPSBzb3VyY2UuZnJvbV9ncmVlbndpY2g7XG4gIH1cblxuICAvLyBDb252ZXJ0IGRhdHVtcyBpZiBuZWVkZWQsIGFuZCBpZiBwb3NzaWJsZS5cbiAgcG9pbnQgPSBkYXR1bV90cmFuc2Zvcm0oc291cmNlLmRhdHVtLCBkZXN0LmRhdHVtLCBwb2ludCk7XG4gIGlmICghcG9pbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBBZGp1c3QgZm9yIHRoZSBwcmltZSBtZXJpZGlhbiBpZiBuZWNlc3NhcnlcbiAgaWYgKGRlc3QuZnJvbV9ncmVlbndpY2gpIHtcbiAgICBwb2ludCA9IHtcbiAgICAgIHg6IHBvaW50LnggLSBkZXN0LmZyb21fZ3JlZW53aWNoLFxuICAgICAgeTogcG9pbnQueSxcbiAgICAgIHo6IHBvaW50LnogfHwgMFxuICAgIH07XG4gIH1cblxuICBpZiAoZGVzdC5wcm9qTmFtZSA9PT0gJ2xvbmdsYXQnKSB7XG4gICAgLy8gY29udmVydCByYWRpYW5zIHRvIGRlY2ltYWwgZGVncmVlc1xuICAgIHBvaW50ID0ge1xuICAgICAgeDogcG9pbnQueCAqIFIyRCxcbiAgICAgIHk6IHBvaW50LnkgKiBSMkQsXG4gICAgICB6OiBwb2ludC56IHx8IDBcbiAgICB9O1xuICB9IGVsc2UgeyAvLyBlbHNlIHByb2plY3RcbiAgICBwb2ludCA9IGRlc3QuZm9yd2FyZChwb2ludCk7XG4gICAgaWYgKGRlc3QudG9fbWV0ZXIpIHtcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICB4OiBwb2ludC54IC8gZGVzdC50b19tZXRlcixcbiAgICAgICAgeTogcG9pbnQueSAvIGRlc3QudG9fbWV0ZXIsXG4gICAgICAgIHo6IHBvaW50LnogfHwgMFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBER1IsIDIwMTAvMTEvMTJcbiAgaWYgKGVuZm9yY2VBeGlzICYmIGRlc3QuYXhpcyAhPT0gJ2VudScpIHtcbiAgICByZXR1cm4gYWRqdXN0X2F4aXMoZGVzdCwgdHJ1ZSwgcG9pbnQpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50O1xufVxuIiwiaW1wb3J0IHByb2ogZnJvbSAnLi9Qcm9qJztcbmltcG9ydCB0cmFuc2Zvcm0gZnJvbSAnLi90cmFuc2Zvcm0nO1xudmFyIHdnczg0ID0gcHJvaignV0dTODQnKTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoZnJvbSwgdG8sIGNvb3JkcywgZW5mb3JjZUF4aXMpIHtcbiAgdmFyIHRyYW5zZm9ybWVkQXJyYXksIG91dCwga2V5cztcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRzKSkge1xuICAgIHRyYW5zZm9ybWVkQXJyYXkgPSB0cmFuc2Zvcm0oZnJvbSwgdG8sIGNvb3JkcywgZW5mb3JjZUF4aXMpIHx8IHt4OiBOYU4sIHk6IE5hTn07XG4gICAgaWYgKGNvb3Jkcy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKHR5cGVvZiBmcm9tLm5hbWUgIT09ICd1bmRlZmluZWQnICYmIGZyb20ubmFtZSA9PT0gJ2dlb2NlbnQnKSB8fCAodHlwZW9mIHRvLm5hbWUgIT09ICd1bmRlZmluZWQnICYmIHRvLm5hbWUgPT09ICdnZW9jZW50JykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm1lZEFycmF5LnogPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIFt0cmFuc2Zvcm1lZEFycmF5LngsIHRyYW5zZm9ybWVkQXJyYXkueSwgdHJhbnNmb3JtZWRBcnJheS56XS5jb25jYXQoY29vcmRzLnNwbGljZSgzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt0cmFuc2Zvcm1lZEFycmF5LngsIHRyYW5zZm9ybWVkQXJyYXkueSwgY29vcmRzWzJdXS5jb25jYXQoY29vcmRzLnNwbGljZSgzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbdHJhbnNmb3JtZWRBcnJheS54LCB0cmFuc2Zvcm1lZEFycmF5LnldLmNvbmNhdChjb29yZHMuc3BsaWNlKDIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt0cmFuc2Zvcm1lZEFycmF5LngsIHRyYW5zZm9ybWVkQXJyYXkueV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCA9IHRyYW5zZm9ybShmcm9tLCB0bywgY29vcmRzLCBlbmZvcmNlQXhpcyk7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGNvb3Jkcyk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCh0eXBlb2YgZnJvbS5uYW1lICE9PSAndW5kZWZpbmVkJyAmJiBmcm9tLm5hbWUgPT09ICdnZW9jZW50JykgfHwgKHR5cGVvZiB0by5uYW1lICE9PSAndW5kZWZpbmVkJyAmJiB0by5uYW1lID09PSAnZ2VvY2VudCcpKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICd4JyB8fCBrZXkgPT09ICd5JyB8fCBrZXkgPT09ICd6Jykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ3gnIHx8IGtleSA9PT0gJ3knKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXRba2V5XSA9IGNvb3Jkc1trZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9qKGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBwcm9qKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgaWYgKGl0ZW0ub1Byb2opIHtcbiAgICByZXR1cm4gaXRlbS5vUHJvajtcbiAgfVxuICByZXR1cm4gcHJvaihpdGVtKTtcbn1cblxuZnVuY3Rpb24gcHJvajQoZnJvbVByb2osIHRvUHJvaiwgY29vcmQpIHtcbiAgZnJvbVByb2ogPSBjaGVja1Byb2ooZnJvbVByb2opO1xuICB2YXIgc2luZ2xlID0gZmFsc2U7XG4gIHZhciBvYmo7XG4gIGlmICh0eXBlb2YgdG9Qcm9qID09PSAndW5kZWZpbmVkJykge1xuICAgIHRvUHJvaiA9IGZyb21Qcm9qO1xuICAgIGZyb21Qcm9qID0gd2dzODQ7XG4gICAgc2luZ2xlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG9Qcm9qLnggIT09ICd1bmRlZmluZWQnIHx8IEFycmF5LmlzQXJyYXkodG9Qcm9qKSkge1xuICAgIGNvb3JkID0gdG9Qcm9qO1xuICAgIHRvUHJvaiA9IGZyb21Qcm9qO1xuICAgIGZyb21Qcm9qID0gd2dzODQ7XG4gICAgc2luZ2xlID0gdHJ1ZTtcbiAgfVxuICB0b1Byb2ogPSBjaGVja1Byb2oodG9Qcm9qKTtcbiAgaWYgKGNvb3JkKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyKGZyb21Qcm9qLCB0b1Byb2osIGNvb3JkKTtcbiAgfSBlbHNlIHtcbiAgICBvYmogPSB7XG4gICAgICBmb3J3YXJkOiBmdW5jdGlvbiAoY29vcmRzLCBlbmZvcmNlQXhpcykge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIoZnJvbVByb2osIHRvUHJvaiwgY29vcmRzLCBlbmZvcmNlQXhpcyk7XG4gICAgICB9LFxuICAgICAgaW52ZXJzZTogZnVuY3Rpb24gKGNvb3JkcywgZW5mb3JjZUF4aXMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKHRvUHJvaiwgZnJvbVByb2osIGNvb3JkcywgZW5mb3JjZUF4aXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHNpbmdsZSkge1xuICAgICAgb2JqLm9Qcm9qID0gdG9Qcm9qO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBwcm9qNDsiLCJcblxuXG4vKipcbiAqIFVUTSB6b25lcyBhcmUgZ3JvdXBlZCwgYW5kIGFzc2lnbmVkIHRvIG9uZSBvZiBhIGdyb3VwIG9mIDZcbiAqIHNldHMuXG4gKlxuICoge2ludH0gQHByaXZhdGVcbiAqL1xudmFyIE5VTV8xMDBLX1NFVFMgPSA2O1xuXG4vKipcbiAqIFRoZSBjb2x1bW4gbGV0dGVycyAoZm9yIGVhc3RpbmcpIG9mIHRoZSBsb3dlciBsZWZ0IHZhbHVlLCBwZXJcbiAqIHNldC5cbiAqXG4gKiB7c3RyaW5nfSBAcHJpdmF0ZVxuICovXG52YXIgU0VUX09SSUdJTl9DT0xVTU5fTEVUVEVSUyA9ICdBSlNBSlMnO1xuXG4vKipcbiAqIFRoZSByb3cgbGV0dGVycyAoZm9yIG5vcnRoaW5nKSBvZiB0aGUgbG93ZXIgbGVmdCB2YWx1ZSwgcGVyXG4gKiBzZXQuXG4gKlxuICoge3N0cmluZ30gQHByaXZhdGVcbiAqL1xudmFyIFNFVF9PUklHSU5fUk9XX0xFVFRFUlMgPSAnQUZBRkFGJztcblxudmFyIEEgPSA2NTsgLy8gQVxudmFyIEkgPSA3MzsgLy8gSVxudmFyIE8gPSA3OTsgLy8gT1xudmFyIFYgPSA4NjsgLy8gVlxudmFyIFogPSA5MDsgLy8gWlxuZXhwb3J0IGRlZmF1bHQge1xuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICB0b1BvaW50OiB0b1BvaW50XG59O1xuLyoqXG4gKiBDb252ZXJzaW9uIG9mIGxhdC9sb24gdG8gTUdSUy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbGwgT2JqZWN0IGxpdGVyYWwgd2l0aCBsYXQgYW5kIGxvbiBwcm9wZXJ0aWVzIG9uIGFcbiAqICAgICBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcGFyYW0ge2ludH0gYWNjdXJhY3kgQWNjdXJhY3kgaW4gZGlnaXRzICg1IGZvciAxIG0sIDQgZm9yIDEwIG0sIDMgZm9yXG4gKiAgICAgIDEwMCBtLCAyIGZvciAxMDAwIG0gb3IgMSBmb3IgMTAwMDAgbSkuIE9wdGlvbmFsLCBkZWZhdWx0IGlzIDUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBNR1JTIHN0cmluZyBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uIGFuZCBhY2N1cmFjeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQobGwsIGFjY3VyYWN5KSB7XG4gIGFjY3VyYWN5ID0gYWNjdXJhY3kgfHwgNTsgLy8gZGVmYXVsdCBhY2N1cmFjeSAxbVxuICByZXR1cm4gZW5jb2RlKExMdG9VVE0oe1xuICAgIGxhdDogbGxbMV0sXG4gICAgbG9uOiBsbFswXVxuICB9KSwgYWNjdXJhY3kpO1xufTtcblxuLyoqXG4gKiBDb252ZXJzaW9uIG9mIE1HUlMgdG8gbGF0L2xvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWdycyBNR1JTIHN0cmluZy5cbiAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSB3aXRoIGxlZnQgKGxvbmdpdHVkZSksIGJvdHRvbSAobGF0aXR1ZGUpLCByaWdodFxuICogICAgIChsb25naXR1ZGUpIGFuZCB0b3AgKGxhdGl0dWRlKSB2YWx1ZXMgaW4gV0dTODQsIHJlcHJlc2VudGluZyB0aGVcbiAqICAgICBib3VuZGluZyBib3ggZm9yIHRoZSBwcm92aWRlZCBNR1JTIHJlZmVyZW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UobWdycykge1xuICB2YXIgYmJveCA9IFVUTXRvTEwoZGVjb2RlKG1ncnMudG9VcHBlckNhc2UoKSkpO1xuICBpZiAoYmJveC5sYXQgJiYgYmJveC5sb24pIHtcbiAgICByZXR1cm4gW2Jib3gubG9uLCBiYm94LmxhdCwgYmJveC5sb24sIGJib3gubGF0XTtcbiAgfVxuICByZXR1cm4gW2Jib3gubGVmdCwgYmJveC5ib3R0b20sIGJib3gucmlnaHQsIGJib3gudG9wXTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KG1ncnMpIHtcbiAgdmFyIGJib3ggPSBVVE10b0xMKGRlY29kZShtZ3JzLnRvVXBwZXJDYXNlKCkpKTtcbiAgaWYgKGJib3gubGF0ICYmIGJib3gubG9uKSB7XG4gICAgcmV0dXJuIFtiYm94LmxvbiwgYmJveC5sYXRdO1xuICB9XG4gIHJldHVybiBbKGJib3gubGVmdCArIGJib3gucmlnaHQpIC8gMiwgKGJib3gudG9wICsgYmJveC5ib3R0b20pIC8gMl07XG59O1xuLyoqXG4gKiBDb252ZXJzaW9uIGZyb20gZGVncmVlcyB0byByYWRpYW5zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVnIHRoZSBhbmdsZSBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgYW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuZnVuY3Rpb24gZGVnVG9SYWQoZGVnKSB7XG4gIHJldHVybiAoZGVnICogKE1hdGguUEkgLyAxODAuMCkpO1xufVxuXG4vKipcbiAqIENvbnZlcnNpb24gZnJvbSByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBhbmdsZSBpbiBkZWdyZWVzLlxuICovXG5mdW5jdGlvbiByYWRUb0RlZyhyYWQpIHtcbiAgcmV0dXJuICgxODAuMCAqIChyYWQgLyBNYXRoLlBJKSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzZXQgb2YgTG9uZ2l0dWRlIGFuZCBMYXRpdHVkZSBjby1vcmRpbmF0ZXMgdG8gVVRNXG4gKiB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gbGwgT2JqZWN0IGxpdGVyYWwgd2l0aCBsYXQgYW5kIGxvbiBwcm9wZXJ0aWVzXG4gKiAgICAgcmVwcmVzZW50aW5nIHRoZSBXR1M4NCBjb29yZGluYXRlIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyB0aGUgVVRNIHZhbHVlIHdpdGggZWFzdGluZyxcbiAqICAgICBub3J0aGluZywgem9uZU51bWJlciBhbmQgem9uZUxldHRlciBwcm9wZXJ0aWVzLCBhbmQgYW4gb3B0aW9uYWxcbiAqICAgICBhY2N1cmFjeSBwcm9wZXJ0eSBpbiBkaWdpdHMuIFJldHVybnMgbnVsbCBpZiB0aGUgY29udmVyc2lvbiBmYWlsZWQuXG4gKi9cbmZ1bmN0aW9uIExMdG9VVE0obGwpIHtcbiAgdmFyIExhdCA9IGxsLmxhdDtcbiAgdmFyIExvbmcgPSBsbC5sb247XG4gIHZhciBhID0gNjM3ODEzNy4wOyAvL2VsbGlwLnJhZGl1cztcbiAgdmFyIGVjY1NxdWFyZWQgPSAwLjAwNjY5NDM4OyAvL2VsbGlwLmVjY3NxO1xuICB2YXIgazAgPSAwLjk5OTY7XG4gIHZhciBMb25nT3JpZ2luO1xuICB2YXIgZWNjUHJpbWVTcXVhcmVkO1xuICB2YXIgTiwgVCwgQywgQSwgTTtcbiAgdmFyIExhdFJhZCA9IGRlZ1RvUmFkKExhdCk7XG4gIHZhciBMb25nUmFkID0gZGVnVG9SYWQoTG9uZyk7XG4gIHZhciBMb25nT3JpZ2luUmFkO1xuICB2YXIgWm9uZU51bWJlcjtcbiAgLy8gKGludClcbiAgWm9uZU51bWJlciA9IE1hdGguZmxvb3IoKExvbmcgKyAxODApIC8gNikgKyAxO1xuXG4gIC8vTWFrZSBzdXJlIHRoZSBsb25naXR1ZGUgMTgwLjAwIGlzIGluIFpvbmUgNjBcbiAgaWYgKExvbmcgPT09IDE4MCkge1xuICAgIFpvbmVOdW1iZXIgPSA2MDtcbiAgfVxuXG4gIC8vIFNwZWNpYWwgem9uZSBmb3IgTm9yd2F5XG4gIGlmIChMYXQgPj0gNTYuMCAmJiBMYXQgPCA2NC4wICYmIExvbmcgPj0gMy4wICYmIExvbmcgPCAxMi4wKSB7XG4gICAgWm9uZU51bWJlciA9IDMyO1xuICB9XG5cbiAgLy8gU3BlY2lhbCB6b25lcyBmb3IgU3ZhbGJhcmRcbiAgaWYgKExhdCA+PSA3Mi4wICYmIExhdCA8IDg0LjApIHtcbiAgICBpZiAoTG9uZyA+PSAwLjAgJiYgTG9uZyA8IDkuMCkge1xuICAgICAgWm9uZU51bWJlciA9IDMxO1xuICAgIH1cbiAgICBlbHNlIGlmIChMb25nID49IDkuMCAmJiBMb25nIDwgMjEuMCkge1xuICAgICAgWm9uZU51bWJlciA9IDMzO1xuICAgIH1cbiAgICBlbHNlIGlmIChMb25nID49IDIxLjAgJiYgTG9uZyA8IDMzLjApIHtcbiAgICAgIFpvbmVOdW1iZXIgPSAzNTtcbiAgICB9XG4gICAgZWxzZSBpZiAoTG9uZyA+PSAzMy4wICYmIExvbmcgPCA0Mi4wKSB7XG4gICAgICBab25lTnVtYmVyID0gMzc7XG4gICAgfVxuICB9XG5cbiAgTG9uZ09yaWdpbiA9IChab25lTnVtYmVyIC0gMSkgKiA2IC0gMTgwICsgMzsgLy8rMyBwdXRzIG9yaWdpblxuICAvLyBpbiBtaWRkbGUgb2ZcbiAgLy8gem9uZVxuICBMb25nT3JpZ2luUmFkID0gZGVnVG9SYWQoTG9uZ09yaWdpbik7XG5cbiAgZWNjUHJpbWVTcXVhcmVkID0gKGVjY1NxdWFyZWQpIC8gKDEgLSBlY2NTcXVhcmVkKTtcblxuICBOID0gYSAvIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCAqIE1hdGguc2luKExhdFJhZCkgKiBNYXRoLnNpbihMYXRSYWQpKTtcbiAgVCA9IE1hdGgudGFuKExhdFJhZCkgKiBNYXRoLnRhbihMYXRSYWQpO1xuICBDID0gZWNjUHJpbWVTcXVhcmVkICogTWF0aC5jb3MoTGF0UmFkKSAqIE1hdGguY29zKExhdFJhZCk7XG4gIEEgPSBNYXRoLmNvcyhMYXRSYWQpICogKExvbmdSYWQgLSBMb25nT3JpZ2luUmFkKTtcblxuICBNID0gYSAqICgoMSAtIGVjY1NxdWFyZWQgLyA0IC0gMyAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gNjQgLSA1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2KSAqIExhdFJhZCAtICgzICogZWNjU3F1YXJlZCAvIDggKyAzICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAzMiArIDQ1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMTAyNCkgKiBNYXRoLnNpbigyICogTGF0UmFkKSArICgxNSAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2ICsgNDUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAxMDI0KSAqIE1hdGguc2luKDQgKiBMYXRSYWQpIC0gKDM1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMzA3MikgKiBNYXRoLnNpbig2ICogTGF0UmFkKSk7XG5cbiAgdmFyIFVUTUVhc3RpbmcgPSAoazAgKiBOICogKEEgKyAoMSAtIFQgKyBDKSAqIEEgKiBBICogQSAvIDYuMCArICg1IC0gMTggKiBUICsgVCAqIFQgKyA3MiAqIEMgLSA1OCAqIGVjY1ByaW1lU3F1YXJlZCkgKiBBICogQSAqIEEgKiBBICogQSAvIDEyMC4wKSArIDUwMDAwMC4wKTtcblxuICB2YXIgVVRNTm9ydGhpbmcgPSAoazAgKiAoTSArIE4gKiBNYXRoLnRhbihMYXRSYWQpICogKEEgKiBBIC8gMiArICg1IC0gVCArIDkgKiBDICsgNCAqIEMgKiBDKSAqIEEgKiBBICogQSAqIEEgLyAyNC4wICsgKDYxIC0gNTggKiBUICsgVCAqIFQgKyA2MDAgKiBDIC0gMzMwICogZWNjUHJpbWVTcXVhcmVkKSAqIEEgKiBBICogQSAqIEEgKiBBICogQSAvIDcyMC4wKSkpO1xuICBpZiAoTGF0IDwgMC4wKSB7XG4gICAgVVRNTm9ydGhpbmcgKz0gMTAwMDAwMDAuMDsgLy8xMDAwMDAwMCBtZXRlciBvZmZzZXQgZm9yXG4gICAgLy8gc291dGhlcm4gaGVtaXNwaGVyZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub3J0aGluZzogTWF0aC5yb3VuZChVVE1Ob3J0aGluZyksXG4gICAgZWFzdGluZzogTWF0aC5yb3VuZChVVE1FYXN0aW5nKSxcbiAgICB6b25lTnVtYmVyOiBab25lTnVtYmVyLFxuICAgIHpvbmVMZXR0ZXI6IGdldExldHRlckRlc2lnbmF0b3IoTGF0KVxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIFVUTSBjb29yZHMgdG8gbGF0L2xvbmcsIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogY2xhc3Mgd2hlcmUgdGhlIFpvbmUgY2FuIGJlIHNwZWNpZmllZCBhcyBhIHNpbmdsZSBzdHJpbmcgZWcuXCI2ME5cIiB3aGljaFxuICogaXMgdGhlbiBicm9rZW4gZG93biBpbnRvIHRoZSBab25lTnVtYmVyIGFuZCBab25lTGV0dGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gdXRtIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggbm9ydGhpbmcsIGVhc3RpbmcsIHpvbmVOdW1iZXJcbiAqICAgICBhbmQgem9uZUxldHRlciBwcm9wZXJ0aWVzLiBJZiBhbiBvcHRpb25hbCBhY2N1cmFjeSBwcm9wZXJ0eSBpc1xuICogICAgIHByb3ZpZGVkIChpbiBtZXRlcnMpLCBhIGJvdW5kaW5nIGJveCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2ZcbiAqICAgICBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIGVpdGhlciBsYXQgYW5kIGxvbiB2YWx1ZXNcbiAqICAgICAoaWYgbm8gYWNjdXJhY3kgd2FzIHByb3ZpZGVkKSwgb3IgdG9wLCByaWdodCwgYm90dG9tIGFuZCBsZWZ0IHZhbHVlc1xuICogICAgIGZvciB0aGUgYm91bmRpbmcgYm94IGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBhY2N1cmFjeS5cbiAqICAgICBSZXR1cm5zIG51bGwgaWYgdGhlIGNvbnZlcnNpb24gZmFpbGVkLlxuICovXG5mdW5jdGlvbiBVVE10b0xMKHV0bSkge1xuXG4gIHZhciBVVE1Ob3J0aGluZyA9IHV0bS5ub3J0aGluZztcbiAgdmFyIFVUTUVhc3RpbmcgPSB1dG0uZWFzdGluZztcbiAgdmFyIHpvbmVMZXR0ZXIgPSB1dG0uem9uZUxldHRlcjtcbiAgdmFyIHpvbmVOdW1iZXIgPSB1dG0uem9uZU51bWJlcjtcbiAgLy8gY2hlY2sgdGhlIFpvbmVOdW1tYmVyIGlzIHZhbGlkXG4gIGlmICh6b25lTnVtYmVyIDwgMCB8fCB6b25lTnVtYmVyID4gNjApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBrMCA9IDAuOTk5NjtcbiAgdmFyIGEgPSA2Mzc4MTM3LjA7IC8vZWxsaXAucmFkaXVzO1xuICB2YXIgZWNjU3F1YXJlZCA9IDAuMDA2Njk0Mzg7IC8vZWxsaXAuZWNjc3E7XG4gIHZhciBlY2NQcmltZVNxdWFyZWQ7XG4gIHZhciBlMSA9ICgxIC0gTWF0aC5zcXJ0KDEgLSBlY2NTcXVhcmVkKSkgLyAoMSArIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCkpO1xuICB2YXIgTjEsIFQxLCBDMSwgUjEsIEQsIE07XG4gIHZhciBMb25nT3JpZ2luO1xuICB2YXIgbXUsIHBoaTFSYWQ7XG5cbiAgLy8gcmVtb3ZlIDUwMCwwMDAgbWV0ZXIgb2Zmc2V0IGZvciBsb25naXR1ZGVcbiAgdmFyIHggPSBVVE1FYXN0aW5nIC0gNTAwMDAwLjA7XG4gIHZhciB5ID0gVVRNTm9ydGhpbmc7XG5cbiAgLy8gV2UgbXVzdCBrbm93IHNvbWVob3cgaWYgd2UgYXJlIGluIHRoZSBOb3J0aGVybiBvciBTb3V0aGVyblxuICAvLyBoZW1pc3BoZXJlLCB0aGlzIGlzIHRoZSBvbmx5IHRpbWUgd2UgdXNlIHRoZSBsZXR0ZXIgU28gZXZlblxuICAvLyBpZiB0aGUgWm9uZSBsZXR0ZXIgaXNuJ3QgZXhhY3RseSBjb3JyZWN0IGl0IHNob3VsZCBpbmRpY2F0ZVxuICAvLyB0aGUgaGVtaXNwaGVyZSBjb3JyZWN0bHlcbiAgaWYgKHpvbmVMZXR0ZXIgPCAnTicpIHtcbiAgICB5IC09IDEwMDAwMDAwLjA7IC8vIHJlbW92ZSAxMCwwMDAsMDAwIG1ldGVyIG9mZnNldCB1c2VkXG4gICAgLy8gZm9yIHNvdXRoZXJuIGhlbWlzcGhlcmVcbiAgfVxuXG4gIC8vIFRoZXJlIGFyZSA2MCB6b25lcyB3aXRoIHpvbmUgMSBiZWluZyBhdCBXZXN0IC0xODAgdG8gLTE3NFxuICBMb25nT3JpZ2luID0gKHpvbmVOdW1iZXIgLSAxKSAqIDYgLSAxODAgKyAzOyAvLyArMyBwdXRzIG9yaWdpblxuICAvLyBpbiBtaWRkbGUgb2ZcbiAgLy8gem9uZVxuXG4gIGVjY1ByaW1lU3F1YXJlZCA9IChlY2NTcXVhcmVkKSAvICgxIC0gZWNjU3F1YXJlZCk7XG5cbiAgTSA9IHkgLyBrMDtcbiAgbXUgPSBNIC8gKGEgKiAoMSAtIGVjY1NxdWFyZWQgLyA0IC0gMyAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gNjQgLSA1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2KSk7XG5cbiAgcGhpMVJhZCA9IG11ICsgKDMgKiBlMSAvIDIgLSAyNyAqIGUxICogZTEgKiBlMSAvIDMyKSAqIE1hdGguc2luKDIgKiBtdSkgKyAoMjEgKiBlMSAqIGUxIC8gMTYgLSA1NSAqIGUxICogZTEgKiBlMSAqIGUxIC8gMzIpICogTWF0aC5zaW4oNCAqIG11KSArICgxNTEgKiBlMSAqIGUxICogZTEgLyA5NikgKiBNYXRoLnNpbig2ICogbXUpO1xuICAvLyBkb3VibGUgcGhpMSA9IFByb2pNYXRoLnJhZFRvRGVnKHBoaTFSYWQpO1xuXG4gIE4xID0gYSAvIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCAqIE1hdGguc2luKHBoaTFSYWQpICogTWF0aC5zaW4ocGhpMVJhZCkpO1xuICBUMSA9IE1hdGgudGFuKHBoaTFSYWQpICogTWF0aC50YW4ocGhpMVJhZCk7XG4gIEMxID0gZWNjUHJpbWVTcXVhcmVkICogTWF0aC5jb3MocGhpMVJhZCkgKiBNYXRoLmNvcyhwaGkxUmFkKTtcbiAgUjEgPSBhICogKDEgLSBlY2NTcXVhcmVkKSAvIE1hdGgucG93KDEgLSBlY2NTcXVhcmVkICogTWF0aC5zaW4ocGhpMVJhZCkgKiBNYXRoLnNpbihwaGkxUmFkKSwgMS41KTtcbiAgRCA9IHggLyAoTjEgKiBrMCk7XG5cbiAgdmFyIGxhdCA9IHBoaTFSYWQgLSAoTjEgKiBNYXRoLnRhbihwaGkxUmFkKSAvIFIxKSAqIChEICogRCAvIDIgLSAoNSArIDMgKiBUMSArIDEwICogQzEgLSA0ICogQzEgKiBDMSAtIDkgKiBlY2NQcmltZVNxdWFyZWQpICogRCAqIEQgKiBEICogRCAvIDI0ICsgKDYxICsgOTAgKiBUMSArIDI5OCAqIEMxICsgNDUgKiBUMSAqIFQxIC0gMjUyICogZWNjUHJpbWVTcXVhcmVkIC0gMyAqIEMxICogQzEpICogRCAqIEQgKiBEICogRCAqIEQgKiBEIC8gNzIwKTtcbiAgbGF0ID0gcmFkVG9EZWcobGF0KTtcblxuICB2YXIgbG9uID0gKEQgLSAoMSArIDIgKiBUMSArIEMxKSAqIEQgKiBEICogRCAvIDYgKyAoNSAtIDIgKiBDMSArIDI4ICogVDEgLSAzICogQzEgKiBDMSArIDggKiBlY2NQcmltZVNxdWFyZWQgKyAyNCAqIFQxICogVDEpICogRCAqIEQgKiBEICogRCAqIEQgLyAxMjApIC8gTWF0aC5jb3MocGhpMVJhZCk7XG4gIGxvbiA9IExvbmdPcmlnaW4gKyByYWRUb0RlZyhsb24pO1xuXG4gIHZhciByZXN1bHQ7XG4gIGlmICh1dG0uYWNjdXJhY3kpIHtcbiAgICB2YXIgdG9wUmlnaHQgPSBVVE10b0xMKHtcbiAgICAgIG5vcnRoaW5nOiB1dG0ubm9ydGhpbmcgKyB1dG0uYWNjdXJhY3ksXG4gICAgICBlYXN0aW5nOiB1dG0uZWFzdGluZyArIHV0bS5hY2N1cmFjeSxcbiAgICAgIHpvbmVMZXR0ZXI6IHV0bS56b25lTGV0dGVyLFxuICAgICAgem9uZU51bWJlcjogdXRtLnpvbmVOdW1iZXJcbiAgICB9KTtcbiAgICByZXN1bHQgPSB7XG4gICAgICB0b3A6IHRvcFJpZ2h0LmxhdCxcbiAgICAgIHJpZ2h0OiB0b3BSaWdodC5sb24sXG4gICAgICBib3R0b206IGxhdCxcbiAgICAgIGxlZnQ6IGxvblxuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgbGF0OiBsYXQsXG4gICAgICBsb246IGxvblxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBNR1JTIGxldHRlciBkZXNpZ25hdG9yIGZvciB0aGUgZ2l2ZW4gbGF0aXR1ZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIGluIFdHUzg0IHRvIGdldCB0aGUgbGV0dGVyIGRlc2lnbmF0b3JcbiAqICAgICBmb3IuXG4gKiBAcmV0dXJuIHtjaGFyfSBUaGUgbGV0dGVyIGRlc2lnbmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldExldHRlckRlc2lnbmF0b3IobGF0KSB7XG4gIC8vVGhpcyBpcyBoZXJlIGFzIGFuIGVycm9yIGZsYWcgdG8gc2hvdyB0aGF0IHRoZSBMYXRpdHVkZSBpc1xuICAvL291dHNpZGUgTUdSUyBsaW1pdHNcbiAgdmFyIExldHRlckRlc2lnbmF0b3IgPSAnWic7XG5cbiAgaWYgKCg4NCA+PSBsYXQpICYmIChsYXQgPj0gNzIpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdYJztcbiAgfVxuICBlbHNlIGlmICgoNzIgPiBsYXQpICYmIChsYXQgPj0gNjQpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdXJztcbiAgfVxuICBlbHNlIGlmICgoNjQgPiBsYXQpICYmIChsYXQgPj0gNTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdWJztcbiAgfVxuICBlbHNlIGlmICgoNTYgPiBsYXQpICYmIChsYXQgPj0gNDgpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdVJztcbiAgfVxuICBlbHNlIGlmICgoNDggPiBsYXQpICYmIChsYXQgPj0gNDApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdUJztcbiAgfVxuICBlbHNlIGlmICgoNDAgPiBsYXQpICYmIChsYXQgPj0gMzIpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdTJztcbiAgfVxuICBlbHNlIGlmICgoMzIgPiBsYXQpICYmIChsYXQgPj0gMjQpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdSJztcbiAgfVxuICBlbHNlIGlmICgoMjQgPiBsYXQpICYmIChsYXQgPj0gMTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdRJztcbiAgfVxuICBlbHNlIGlmICgoMTYgPiBsYXQpICYmIChsYXQgPj0gOCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1AnO1xuICB9XG4gIGVsc2UgaWYgKCg4ID4gbGF0KSAmJiAobGF0ID49IDApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdOJztcbiAgfVxuICBlbHNlIGlmICgoMCA+IGxhdCkgJiYgKGxhdCA+PSAtOCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ00nO1xuICB9XG4gIGVsc2UgaWYgKCgtOCA+IGxhdCkgJiYgKGxhdCA+PSAtMTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdMJztcbiAgfVxuICBlbHNlIGlmICgoLTE2ID4gbGF0KSAmJiAobGF0ID49IC0yNCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0snO1xuICB9XG4gIGVsc2UgaWYgKCgtMjQgPiBsYXQpICYmIChsYXQgPj0gLTMyKSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnSic7XG4gIH1cbiAgZWxzZSBpZiAoKC0zMiA+IGxhdCkgJiYgKGxhdCA+PSAtNDApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdIJztcbiAgfVxuICBlbHNlIGlmICgoLTQwID4gbGF0KSAmJiAobGF0ID49IC00OCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0cnO1xuICB9XG4gIGVsc2UgaWYgKCgtNDggPiBsYXQpICYmIChsYXQgPj0gLTU2KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnRic7XG4gIH1cbiAgZWxzZSBpZiAoKC01NiA+IGxhdCkgJiYgKGxhdCA+PSAtNjQpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdFJztcbiAgfVxuICBlbHNlIGlmICgoLTY0ID4gbGF0KSAmJiAobGF0ID49IC03MikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0QnO1xuICB9XG4gIGVsc2UgaWYgKCgtNzIgPiBsYXQpICYmIChsYXQgPj0gLTgwKSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnQyc7XG4gIH1cbiAgcmV0dXJuIExldHRlckRlc2lnbmF0b3I7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIFVUTSBsb2NhdGlvbiBhcyBNR1JTIHN0cmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IHV0bSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGVhc3RpbmcsIG5vcnRoaW5nLFxuICogICAgIHpvbmVMZXR0ZXIsIHpvbmVOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhY2N1cmFjeSBBY2N1cmFjeSBpbiBkaWdpdHMgKDEtNSkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE1HUlMgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gVVRNIGxvY2F0aW9uLlxuICovXG5mdW5jdGlvbiBlbmNvZGUodXRtLCBhY2N1cmFjeSkge1xuICAvLyBwcmVwZW5kIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgdmFyIHNlYXN0aW5nID0gXCIwMDAwMFwiICsgdXRtLmVhc3RpbmcsXG4gICAgc25vcnRoaW5nID0gXCIwMDAwMFwiICsgdXRtLm5vcnRoaW5nO1xuXG4gIHJldHVybiB1dG0uem9uZU51bWJlciArIHV0bS56b25lTGV0dGVyICsgZ2V0MTAwa0lEKHV0bS5lYXN0aW5nLCB1dG0ubm9ydGhpbmcsIHV0bS56b25lTnVtYmVyKSArIHNlYXN0aW5nLnN1YnN0cihzZWFzdGluZy5sZW5ndGggLSA1LCBhY2N1cmFjeSkgKyBzbm9ydGhpbmcuc3Vic3RyKHNub3J0aGluZy5sZW5ndGggLSA1LCBhY2N1cmFjeSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0d28gbGV0dGVyIDEwMGsgZGVzaWduYXRvciBmb3IgYSBnaXZlbiBVVE0gZWFzdGluZyxcbiAqIG5vcnRoaW5nIGFuZCB6b25lIG51bWJlciB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGVhc3RpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3J0aGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IHpvbmVOdW1iZXJcbiAqIEByZXR1cm4gdGhlIHR3byBsZXR0ZXIgMTAwayBkZXNpZ25hdG9yIGZvciB0aGUgZ2l2ZW4gVVRNIGxvY2F0aW9uLlxuICovXG5mdW5jdGlvbiBnZXQxMDBrSUQoZWFzdGluZywgbm9ydGhpbmcsIHpvbmVOdW1iZXIpIHtcbiAgdmFyIHNldFBhcm0gPSBnZXQxMDBrU2V0Rm9yWm9uZSh6b25lTnVtYmVyKTtcbiAgdmFyIHNldENvbHVtbiA9IE1hdGguZmxvb3IoZWFzdGluZyAvIDEwMDAwMCk7XG4gIHZhciBzZXRSb3cgPSBNYXRoLmZsb29yKG5vcnRoaW5nIC8gMTAwMDAwKSAlIDIwO1xuICByZXR1cm4gZ2V0TGV0dGVyMTAwa0lEKHNldENvbHVtbiwgc2V0Um93LCBzZXRQYXJtKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFVUTSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgTUdSUyAxMDBLIHNldCBpdCBpcyBpbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGkgQW4gVVRNIHpvbmUgbnVtYmVyLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgMTAwayBzZXQgdGhlIFVUTSB6b25lIGlzIGluLlxuICovXG5mdW5jdGlvbiBnZXQxMDBrU2V0Rm9yWm9uZShpKSB7XG4gIHZhciBzZXRQYXJtID0gaSAlIE5VTV8xMDBLX1NFVFM7XG4gIGlmIChzZXRQYXJtID09PSAwKSB7XG4gICAgc2V0UGFybSA9IE5VTV8xMDBLX1NFVFM7XG4gIH1cblxuICByZXR1cm4gc2V0UGFybTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHR3by1sZXR0ZXIgTUdSUyAxMDBrIGRlc2lnbmF0b3IgZ2l2ZW4gaW5mb3JtYXRpb25cbiAqIHRyYW5zbGF0ZWQgZnJvbSB0aGUgVVRNIG5vcnRoaW5nLCBlYXN0aW5nIGFuZCB6b25lIG51bWJlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiB0aGUgY29sdW1uIGluZGV4IGFzIGl0IHJlbGF0ZXMgdG8gdGhlIE1HUlNcbiAqICAgICAgICAxMDBrIHNldCBzcHJlYWRzaGVldCwgY3JlYXRlZCBmcm9tIHRoZSBVVE0gZWFzdGluZy5cbiAqICAgICAgICBWYWx1ZXMgYXJlIDEtOC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3cgdGhlIHJvdyBpbmRleCBhcyBpdCByZWxhdGVzIHRvIHRoZSBNR1JTIDEwMGsgc2V0XG4gKiAgICAgICAgc3ByZWFkc2hlZXQsIGNyZWF0ZWQgZnJvbSB0aGUgVVRNIG5vcnRoaW5nIHZhbHVlLiBWYWx1ZXNcbiAqICAgICAgICBhcmUgZnJvbSAwLTE5LlxuICogQHBhcmFtIHtudW1iZXJ9IHBhcm0gdGhlIHNldCBibG9jaywgYXMgaXQgcmVsYXRlcyB0byB0aGUgTUdSUyAxMDBrIHNldFxuICogICAgICAgIHNwcmVhZHNoZWV0LCBjcmVhdGVkIGZyb20gdGhlIFVUTSB6b25lLiBWYWx1ZXMgYXJlIGZyb21cbiAqICAgICAgICAxLTYwLlxuICogQHJldHVybiB0d28gbGV0dGVyIE1HUlMgMTAwayBjb2RlLlxuICovXG5mdW5jdGlvbiBnZXRMZXR0ZXIxMDBrSUQoY29sdW1uLCByb3csIHBhcm0pIHtcbiAgLy8gY29sT3JpZ2luIGFuZCByb3dPcmlnaW4gYXJlIHRoZSBsZXR0ZXJzIGF0IHRoZSBvcmlnaW4gb2YgdGhlIHNldFxuICB2YXIgaW5kZXggPSBwYXJtIC0gMTtcbiAgdmFyIGNvbE9yaWdpbiA9IFNFVF9PUklHSU5fQ09MVU1OX0xFVFRFUlMuY2hhckNvZGVBdChpbmRleCk7XG4gIHZhciByb3dPcmlnaW4gPSBTRVRfT1JJR0lOX1JPV19MRVRURVJTLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIC8vIGNvbEludCBhbmQgcm93SW50IGFyZSB0aGUgbGV0dGVycyB0byBidWlsZCB0byByZXR1cm5cbiAgdmFyIGNvbEludCA9IGNvbE9yaWdpbiArIGNvbHVtbiAtIDE7XG4gIHZhciByb3dJbnQgPSByb3dPcmlnaW4gKyByb3c7XG4gIHZhciByb2xsb3ZlciA9IGZhbHNlO1xuXG4gIGlmIChjb2xJbnQgPiBaKSB7XG4gICAgY29sSW50ID0gY29sSW50IC0gWiArIEEgLSAxO1xuICAgIHJvbGxvdmVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjb2xJbnQgPT09IEkgfHwgKGNvbE9yaWdpbiA8IEkgJiYgY29sSW50ID4gSSkgfHwgKChjb2xJbnQgPiBJIHx8IGNvbE9yaWdpbiA8IEkpICYmIHJvbGxvdmVyKSkge1xuICAgIGNvbEludCsrO1xuICB9XG5cbiAgaWYgKGNvbEludCA9PT0gTyB8fCAoY29sT3JpZ2luIDwgTyAmJiBjb2xJbnQgPiBPKSB8fCAoKGNvbEludCA+IE8gfHwgY29sT3JpZ2luIDwgTykgJiYgcm9sbG92ZXIpKSB7XG4gICAgY29sSW50Kys7XG5cbiAgICBpZiAoY29sSW50ID09PSBJKSB7XG4gICAgICBjb2xJbnQrKztcbiAgICB9XG4gIH1cblxuICBpZiAoY29sSW50ID4gWikge1xuICAgIGNvbEludCA9IGNvbEludCAtIFogKyBBIC0gMTtcbiAgfVxuXG4gIGlmIChyb3dJbnQgPiBWKSB7XG4gICAgcm93SW50ID0gcm93SW50IC0gViArIEEgLSAxO1xuICAgIHJvbGxvdmVyID0gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICByb2xsb3ZlciA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCgocm93SW50ID09PSBJKSB8fCAoKHJvd09yaWdpbiA8IEkpICYmIChyb3dJbnQgPiBJKSkpIHx8ICgoKHJvd0ludCA+IEkpIHx8IChyb3dPcmlnaW4gPCBJKSkgJiYgcm9sbG92ZXIpKSB7XG4gICAgcm93SW50Kys7XG4gIH1cblxuICBpZiAoKChyb3dJbnQgPT09IE8pIHx8ICgocm93T3JpZ2luIDwgTykgJiYgKHJvd0ludCA+IE8pKSkgfHwgKCgocm93SW50ID4gTykgfHwgKHJvd09yaWdpbiA8IE8pKSAmJiByb2xsb3ZlcikpIHtcbiAgICByb3dJbnQrKztcblxuICAgIGlmIChyb3dJbnQgPT09IEkpIHtcbiAgICAgIHJvd0ludCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyb3dJbnQgPiBWKSB7XG4gICAgcm93SW50ID0gcm93SW50IC0gViArIEEgLSAxO1xuICB9XG5cbiAgdmFyIHR3b0xldHRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29sSW50KSArIFN0cmluZy5mcm9tQ2hhckNvZGUocm93SW50KTtcbiAgcmV0dXJuIHR3b0xldHRlcjtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIFVUTSBwYXJhbWV0ZXJzIGZyb20gYSBNR1JTIHN0cmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ncnNTdHJpbmcgYW4gVVBQRVJDQVNFIGNvb3JkaW5hdGUgc3RyaW5nIGlzIGV4cGVjdGVkLlxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGVhc3RpbmcsIG5vcnRoaW5nLCB6b25lTGV0dGVyLFxuICogICAgIHpvbmVOdW1iZXIgYW5kIGFjY3VyYWN5IChpbiBtZXRlcnMpIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShtZ3JzU3RyaW5nKSB7XG5cbiAgaWYgKG1ncnNTdHJpbmcgJiYgbWdyc1N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyAoXCJNR1JTUG9pbnQgY292ZXJ0aW5nIGZyb20gbm90aGluZ1wiKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBtZ3JzU3RyaW5nLmxlbmd0aDtcblxuICB2YXIgaHVuSyA9IG51bGw7XG4gIHZhciBzYiA9IFwiXCI7XG4gIHZhciB0ZXN0Q2hhcjtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGdldCBab25lIG51bWJlclxuICB3aGlsZSAoISgvW0EtWl0vKS50ZXN0KHRlc3RDaGFyID0gbWdyc1N0cmluZy5jaGFyQXQoaSkpKSB7XG4gICAgaWYgKGkgPj0gMikge1xuICAgICAgdGhyb3cgKFwiTUdSU1BvaW50IGJhZCBjb252ZXJzaW9uIGZyb206IFwiICsgbWdyc1N0cmluZyk7XG4gICAgfVxuICAgIHNiICs9IHRlc3RDaGFyO1xuICAgIGkrKztcbiAgfVxuXG4gIHZhciB6b25lTnVtYmVyID0gcGFyc2VJbnQoc2IsIDEwKTtcblxuICBpZiAoaSA9PT0gMCB8fCBpICsgMyA+IGxlbmd0aCkge1xuICAgIC8vIEEgZ29vZCBNR1JTIHN0cmluZyBoYXMgdG8gYmUgNC01IGRpZ2l0cyBsb25nLFxuICAgIC8vICMjQUFBLyNBQUEgYXQgbGVhc3QuXG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGJhZCBjb252ZXJzaW9uIGZyb206IFwiICsgbWdyc1N0cmluZyk7XG4gIH1cblxuICB2YXIgem9uZUxldHRlciA9IG1ncnNTdHJpbmcuY2hhckF0KGkrKyk7XG5cbiAgLy8gU2hvdWxkIHdlIGNoZWNrIHRoZSB6b25lIGxldHRlciBoZXJlPyBXaHkgbm90LlxuICBpZiAoem9uZUxldHRlciA8PSAnQScgfHwgem9uZUxldHRlciA9PT0gJ0InIHx8IHpvbmVMZXR0ZXIgPT09ICdZJyB8fCB6b25lTGV0dGVyID49ICdaJyB8fCB6b25lTGV0dGVyID09PSAnSScgfHwgem9uZUxldHRlciA9PT0gJ08nKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IHpvbmUgbGV0dGVyIFwiICsgem9uZUxldHRlciArIFwiIG5vdCBoYW5kbGVkOiBcIiArIG1ncnNTdHJpbmcpO1xuICB9XG5cbiAgaHVuSyA9IG1ncnNTdHJpbmcuc3Vic3RyaW5nKGksIGkgKz0gMik7XG5cbiAgdmFyIHNldCA9IGdldDEwMGtTZXRGb3Jab25lKHpvbmVOdW1iZXIpO1xuXG4gIHZhciBlYXN0MTAwayA9IGdldEVhc3RpbmdGcm9tQ2hhcihodW5LLmNoYXJBdCgwKSwgc2V0KTtcbiAgdmFyIG5vcnRoMTAwayA9IGdldE5vcnRoaW5nRnJvbUNoYXIoaHVuSy5jaGFyQXQoMSksIHNldCk7XG5cbiAgLy8gV2UgaGF2ZSBhIGJ1ZyB3aGVyZSB0aGUgbm9ydGhpbmcgbWF5IGJlIDIwMDAwMDAgdG9vIGxvdy5cbiAgLy8gSG93XG4gIC8vIGRvIHdlIGtub3cgd2hlbiB0byByb2xsIG92ZXI/XG5cbiAgd2hpbGUgKG5vcnRoMTAwayA8IGdldE1pbk5vcnRoaW5nKHpvbmVMZXR0ZXIpKSB7XG4gICAgbm9ydGgxMDBrICs9IDIwMDAwMDA7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIGNoYXIgaW5kZXggZm9yIGVhc3Rpbmcvbm9ydGhpbmcgc2VwYXJhdG9yXG4gIHZhciByZW1haW5kZXIgPSBsZW5ndGggLSBpO1xuXG4gIGlmIChyZW1haW5kZXIgJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGhhcyB0byBoYXZlIGFuIGV2ZW4gbnVtYmVyIFxcbm9mIGRpZ2l0cyBhZnRlciB0aGUgem9uZSBsZXR0ZXIgYW5kIHR3byAxMDBrbSBsZXR0ZXJzIC0gZnJvbnQgXFxuaGFsZiBmb3IgZWFzdGluZyBtZXRlcnMsIHNlY29uZCBoYWxmIGZvciBcXG5ub3J0aGluZyBtZXRlcnNcIiArIG1ncnNTdHJpbmcpO1xuICB9XG5cbiAgdmFyIHNlcCA9IHJlbWFpbmRlciAvIDI7XG5cbiAgdmFyIHNlcEVhc3RpbmcgPSAwLjA7XG4gIHZhciBzZXBOb3J0aGluZyA9IDAuMDtcbiAgdmFyIGFjY3VyYWN5Qm9udXMsIHNlcEVhc3RpbmdTdHJpbmcsIHNlcE5vcnRoaW5nU3RyaW5nLCBlYXN0aW5nLCBub3J0aGluZztcbiAgaWYgKHNlcCA+IDApIHtcbiAgICBhY2N1cmFjeUJvbnVzID0gMTAwMDAwLjAgLyBNYXRoLnBvdygxMCwgc2VwKTtcbiAgICBzZXBFYXN0aW5nU3RyaW5nID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSwgaSArIHNlcCk7XG4gICAgc2VwRWFzdGluZyA9IHBhcnNlRmxvYXQoc2VwRWFzdGluZ1N0cmluZykgKiBhY2N1cmFjeUJvbnVzO1xuICAgIHNlcE5vcnRoaW5nU3RyaW5nID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSArIHNlcCk7XG4gICAgc2VwTm9ydGhpbmcgPSBwYXJzZUZsb2F0KHNlcE5vcnRoaW5nU3RyaW5nKSAqIGFjY3VyYWN5Qm9udXM7XG4gIH1cblxuICBlYXN0aW5nID0gc2VwRWFzdGluZyArIGVhc3QxMDBrO1xuICBub3J0aGluZyA9IHNlcE5vcnRoaW5nICsgbm9ydGgxMDBrO1xuXG4gIHJldHVybiB7XG4gICAgZWFzdGluZzogZWFzdGluZyxcbiAgICBub3J0aGluZzogbm9ydGhpbmcsXG4gICAgem9uZUxldHRlcjogem9uZUxldHRlcixcbiAgICB6b25lTnVtYmVyOiB6b25lTnVtYmVyLFxuICAgIGFjY3VyYWN5OiBhY2N1cmFjeUJvbnVzXG4gIH07XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIGZpcnN0IGxldHRlciBmcm9tIGEgdHdvLWxldHRlciBNR1JTIDEwMGsgem9uZSwgYW5kIGdpdmVuIHRoZVxuICogTUdSUyB0YWJsZSBzZXQgZm9yIHRoZSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgZWFzdGluZyB2YWx1ZSB0aGF0XG4gKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG90aGVyLCBzZWNvbmRhcnkgZWFzdGluZyB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtjaGFyfSBlIFRoZSBmaXJzdCBsZXR0ZXIgZnJvbSBhIHR3by1sZXR0ZXIgTUdSUyAxMDDCtGsgem9uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzZXQgVGhlIE1HUlMgdGFibGUgc2V0IGZvciB0aGUgem9uZSBudW1iZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBlYXN0aW5nIHZhbHVlIGZvciB0aGUgZ2l2ZW4gbGV0dGVyIGFuZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGdldEVhc3RpbmdGcm9tQ2hhcihlLCBzZXQpIHtcbiAgLy8gY29sT3JpZ2luIGlzIHRoZSBsZXR0ZXIgYXQgdGhlIG9yaWdpbiBvZiB0aGUgc2V0IGZvciB0aGVcbiAgLy8gY29sdW1uXG4gIHZhciBjdXJDb2wgPSBTRVRfT1JJR0lOX0NPTFVNTl9MRVRURVJTLmNoYXJDb2RlQXQoc2V0IC0gMSk7XG4gIHZhciBlYXN0aW5nVmFsdWUgPSAxMDAwMDAuMDtcbiAgdmFyIHJld2luZE1hcmtlciA9IGZhbHNlO1xuXG4gIHdoaWxlIChjdXJDb2wgIT09IGUuY2hhckNvZGVBdCgwKSkge1xuICAgIGN1ckNvbCsrO1xuICAgIGlmIChjdXJDb2wgPT09IEkpIHtcbiAgICAgIGN1ckNvbCsrO1xuICAgIH1cbiAgICBpZiAoY3VyQ29sID09PSBPKSB7XG4gICAgICBjdXJDb2wrKztcbiAgICB9XG4gICAgaWYgKGN1ckNvbCA+IFopIHtcbiAgICAgIGlmIChyZXdpbmRNYXJrZXIpIHtcbiAgICAgICAgdGhyb3cgKFwiQmFkIGNoYXJhY3RlcjogXCIgKyBlKTtcbiAgICAgIH1cbiAgICAgIGN1ckNvbCA9IEE7XG4gICAgICByZXdpbmRNYXJrZXIgPSB0cnVlO1xuICAgIH1cbiAgICBlYXN0aW5nVmFsdWUgKz0gMTAwMDAwLjA7XG4gIH1cblxuICByZXR1cm4gZWFzdGluZ1ZhbHVlO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBzZWNvbmQgbGV0dGVyIGZyb20gYSB0d28tbGV0dGVyIE1HUlMgMTAwayB6b25lLCBhbmQgZ2l2ZW4gdGhlXG4gKiBNR1JTIHRhYmxlIHNldCBmb3IgdGhlIHpvbmUgbnVtYmVyLCBmaWd1cmUgb3V0IHRoZSBub3J0aGluZyB2YWx1ZSB0aGF0XG4gKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG90aGVyLCBzZWNvbmRhcnkgbm9ydGhpbmcgdmFsdWUuIFlvdSBoYXZlIHRvXG4gKiByZW1lbWJlciB0aGF0IE5vcnRoaW5ncyBhcmUgZGV0ZXJtaW5lZCBmcm9tIHRoZSBlcXVhdG9yLCBhbmQgdGhlIHZlcnRpY2FsXG4gKiBjeWNsZSBvZiBsZXR0ZXJzIG1lYW4gYSAyMDAwMDAwIGFkZGl0aW9uYWwgbm9ydGhpbmcgbWV0ZXJzLiBUaGlzIGhhcHBlbnNcbiAqIGFwcHJveC4gZXZlcnkgMTggZGVncmVlcyBvZiBsYXRpdHVkZS4gVGhpcyBtZXRob2QgZG9lcyAqTk9UKiBjb3VudCBhbnlcbiAqIGFkZGl0aW9uYWwgbm9ydGhpbmdzLiBZb3UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvdyBtYW55IDIwMDAwMDAgbWV0ZXJzIG5lZWRcbiAqIHRvIGJlIGFkZGVkIGZvciB0aGUgem9uZSBsZXR0ZXIgb2YgdGhlIE1HUlMgY29vcmRpbmF0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtjaGFyfSBuIFNlY29uZCBsZXR0ZXIgb2YgdGhlIE1HUlMgMTAwayB6b25lXG4gKiBAcGFyYW0ge251bWJlcn0gc2V0IFRoZSBNR1JTIHRhYmxlIHNldCBudW1iZXIsIHdoaWNoIGlzIGRlcGVuZGVudCBvbiB0aGVcbiAqICAgICBVVE0gem9uZSBudW1iZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBub3J0aGluZyB2YWx1ZSBmb3IgdGhlIGdpdmVuIGxldHRlciBhbmQgc2V0LlxuICovXG5mdW5jdGlvbiBnZXROb3J0aGluZ0Zyb21DaGFyKG4sIHNldCkge1xuXG4gIGlmIChuID4gJ1YnKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGdpdmVuIGludmFsaWQgTm9ydGhpbmcgXCIgKyBuKTtcbiAgfVxuXG4gIC8vIHJvd09yaWdpbiBpcyB0aGUgbGV0dGVyIGF0IHRoZSBvcmlnaW4gb2YgdGhlIHNldCBmb3IgdGhlXG4gIC8vIGNvbHVtblxuICB2YXIgY3VyUm93ID0gU0VUX09SSUdJTl9ST1dfTEVUVEVSUy5jaGFyQ29kZUF0KHNldCAtIDEpO1xuICB2YXIgbm9ydGhpbmdWYWx1ZSA9IDAuMDtcbiAgdmFyIHJld2luZE1hcmtlciA9IGZhbHNlO1xuXG4gIHdoaWxlIChjdXJSb3cgIT09IG4uY2hhckNvZGVBdCgwKSkge1xuICAgIGN1clJvdysrO1xuICAgIGlmIChjdXJSb3cgPT09IEkpIHtcbiAgICAgIGN1clJvdysrO1xuICAgIH1cbiAgICBpZiAoY3VyUm93ID09PSBPKSB7XG4gICAgICBjdXJSb3crKztcbiAgICB9XG4gICAgLy8gZml4aW5nIGEgYnVnIG1ha2luZyB3aG9sZSBhcHBsaWNhdGlvbiBoYW5nIGluIHRoaXMgbG9vcFxuICAgIC8vIHdoZW4gJ24nIGlzIGEgd3JvbmcgY2hhcmFjdGVyXG4gICAgaWYgKGN1clJvdyA+IFYpIHtcbiAgICAgIGlmIChyZXdpbmRNYXJrZXIpIHsgLy8gbWFraW5nIHN1cmUgdGhhdCB0aGlzIGxvb3AgZW5kc1xuICAgICAgICB0aHJvdyAoXCJCYWQgY2hhcmFjdGVyOiBcIiArIG4pO1xuICAgICAgfVxuICAgICAgY3VyUm93ID0gQTtcbiAgICAgIHJld2luZE1hcmtlciA9IHRydWU7XG4gICAgfVxuICAgIG5vcnRoaW5nVmFsdWUgKz0gMTAwMDAwLjA7XG4gIH1cblxuICByZXR1cm4gbm9ydGhpbmdWYWx1ZTtcbn1cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gZ2V0TWluTm9ydGhpbmcgcmV0dXJucyB0aGUgbWluaW11bSBub3J0aGluZyB2YWx1ZSBvZiBhIE1HUlNcbiAqIHpvbmUuXG4gKlxuICogUG9ydGVkIGZyb20gR2VvdHJhbnMnIGMgTGF0dGl0dWRlX0JhbmRfVmFsdWUgc3RydWN0dXJlIHRhYmxlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2NoYXJ9IHpvbmVMZXR0ZXIgVGhlIE1HUlMgem9uZSB0byBnZXQgdGhlIG1pbiBub3J0aGluZyBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldE1pbk5vcnRoaW5nKHpvbmVMZXR0ZXIpIHtcbiAgdmFyIG5vcnRoaW5nO1xuICBzd2l0Y2ggKHpvbmVMZXR0ZXIpIHtcbiAgY2FzZSAnQyc6XG4gICAgbm9ydGhpbmcgPSAxMTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0QnOlxuICAgIG5vcnRoaW5nID0gMjAwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdFJzpcbiAgICBub3J0aGluZyA9IDI4MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnRic6XG4gICAgbm9ydGhpbmcgPSAzNzAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0cnOlxuICAgIG5vcnRoaW5nID0gNDYwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdIJzpcbiAgICBub3J0aGluZyA9IDU1MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnSic6XG4gICAgbm9ydGhpbmcgPSA2NDAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0snOlxuICAgIG5vcnRoaW5nID0gNzMwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdMJzpcbiAgICBub3J0aGluZyA9IDgyMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnTSc6XG4gICAgbm9ydGhpbmcgPSA5MTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ04nOlxuICAgIG5vcnRoaW5nID0gMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdQJzpcbiAgICBub3J0aGluZyA9IDgwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdRJzpcbiAgICBub3J0aGluZyA9IDE3MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnUic6XG4gICAgbm9ydGhpbmcgPSAyNjAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1MnOlxuICAgIG5vcnRoaW5nID0gMzUwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdUJzpcbiAgICBub3J0aGluZyA9IDQ0MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnVSc6XG4gICAgbm9ydGhpbmcgPSA1MzAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1YnOlxuICAgIG5vcnRoaW5nID0gNjIwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdXJzpcbiAgICBub3J0aGluZyA9IDcwMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnWCc6XG4gICAgbm9ydGhpbmcgPSA3OTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgbm9ydGhpbmcgPSAtMS4wO1xuICB9XG4gIGlmIChub3J0aGluZyA+PSAwLjApIHtcbiAgICByZXR1cm4gbm9ydGhpbmc7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgKFwiSW52YWxpZCB6b25lIGxldHRlcjogXCIgKyB6b25lTGV0dGVyKTtcbiAgfVxuXG59XG4iLCJpbXBvcnQge3RvUG9pbnQsIGZvcndhcmR9IGZyb20gJ21ncnMnO1xuXG5mdW5jdGlvbiBQb2ludCh4LCB5LCB6KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb2ludCkpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIHopO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgdGhpcy54ID0geFswXTtcbiAgICB0aGlzLnkgPSB4WzFdO1xuICAgIHRoaXMueiA9IHhbMl0gfHwgMC4wO1xuICB9IGVsc2UgaWYodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgdGhpcy54ID0geC54O1xuICAgIHRoaXMueSA9IHgueTtcbiAgICB0aGlzLnogPSB4LnogfHwgMC4wO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgY29vcmRzID0geC5zcGxpdCgnLCcpO1xuICAgIHRoaXMueCA9IHBhcnNlRmxvYXQoY29vcmRzWzBdLCAxMCk7XG4gICAgdGhpcy55ID0gcGFyc2VGbG9hdChjb29yZHNbMV0sIDEwKTtcbiAgICB0aGlzLnogPSBwYXJzZUZsb2F0KGNvb3Jkc1syXSwgMTApIHx8IDAuMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy56ID0geiB8fCAwLjA7XG4gIH1cbiAgY29uc29sZS53YXJuKCdwcm9qNC5Qb2ludCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiAzLCB1c2UgcHJvajQudG9Qb2ludCcpO1xufVxuXG5Qb2ludC5mcm9tTUdSUyA9IGZ1bmN0aW9uKG1ncnNTdHIpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0b1BvaW50KG1ncnNTdHIpKTtcbn07XG5Qb2ludC5wcm90b3R5cGUudG9NR1JTID0gZnVuY3Rpb24oYWNjdXJhY3kpIHtcbiAgcmV0dXJuIGZvcndhcmQoW3RoaXMueCwgdGhpcy55XSwgYWNjdXJhY3kpO1xufTtcbmV4cG9ydCBkZWZhdWx0IFBvaW50O1xuIiwidmFyIEMwMCA9IDE7XG52YXIgQzAyID0gMC4yNTtcbnZhciBDMDQgPSAwLjA0Njg3NTtcbnZhciBDMDYgPSAwLjAxOTUzMTI1O1xudmFyIEMwOCA9IDAuMDEwNjgxMTUyMzQzNzU7XG52YXIgQzIyID0gMC43NTtcbnZhciBDNDQgPSAwLjQ2ODc1O1xudmFyIEM0NiA9IDAuMDEzMDIwODMzMzMzMzMzMzMzMzM7XG52YXIgQzQ4ID0gMC4wMDcxMjA3NjgyMjkxNjY2NjY2NjtcbnZhciBDNjYgPSAwLjM2NDU4MzMzMzMzMzMzMzMzMzMzO1xudmFyIEM2OCA9IDAuMDA1Njk2NjE0NTgzMzMzMzMzMzM7XG52YXIgQzg4ID0gMC4zMDc2MTcxODc1O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlcykge1xuICB2YXIgZW4gPSBbXTtcbiAgZW5bMF0gPSBDMDAgLSBlcyAqIChDMDIgKyBlcyAqIChDMDQgKyBlcyAqIChDMDYgKyBlcyAqIEMwOCkpKTtcbiAgZW5bMV0gPSBlcyAqIChDMjIgLSBlcyAqIChDMDQgKyBlcyAqIChDMDYgKyBlcyAqIEMwOCkpKTtcbiAgdmFyIHQgPSBlcyAqIGVzO1xuICBlblsyXSA9IHQgKiAoQzQ0IC0gZXMgKiAoQzQ2ICsgZXMgKiBDNDgpKTtcbiAgdCAqPSBlcztcbiAgZW5bM10gPSB0ICogKEM2NiAtIGVzICogQzY4KTtcbiAgZW5bNF0gPSB0ICogZXMgKiBDODg7XG4gIHJldHVybiBlbjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwaGksIHNwaGksIGNwaGksIGVuKSB7XG4gIGNwaGkgKj0gc3BoaTtcbiAgc3BoaSAqPSBzcGhpO1xuICByZXR1cm4gKGVuWzBdICogcGhpIC0gY3BoaSAqIChlblsxXSArIHNwaGkgKiAoZW5bMl0gKyBzcGhpICogKGVuWzNdICsgc3BoaSAqIGVuWzRdKSkpKTtcbn0iLCJpbXBvcnQgcGpfbWxmbiBmcm9tIFwiLi9wal9tbGZuXCI7XG5pbXBvcnQge0VQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxudmFyIE1BWF9JVEVSID0gMjA7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFyZywgZXMsIGVuKSB7XG4gIHZhciBrID0gMSAvICgxIC0gZXMpO1xuICB2YXIgcGhpID0gYXJnO1xuICBmb3IgKHZhciBpID0gTUFYX0lURVI7IGk7IC0taSkgeyAvKiByYXJlbHkgZ29lcyBvdmVyIDIgaXRlcmF0aW9ucyAqL1xuICAgIHZhciBzID0gTWF0aC5zaW4ocGhpKTtcbiAgICB2YXIgdCA9IDEgLSBlcyAqIHMgKiBzO1xuICAgIC8vdCA9IHRoaXMucGpfbWxmbihwaGksIHMsIE1hdGguY29zKHBoaSksIGVuKSAtIGFyZztcbiAgICAvL3BoaSAtPSB0ICogKHQgKiBNYXRoLnNxcnQodCkpICogaztcbiAgICB0ID0gKHBqX21sZm4ocGhpLCBzLCBNYXRoLmNvcyhwaGkpLCBlbikgLSBhcmcpICogKHQgKiBNYXRoLnNxcnQodCkpICogaztcbiAgICBwaGkgLT0gdDtcbiAgICBpZiAoTWF0aC5hYnModCkgPCBFUFNMTikge1xuICAgICAgcmV0dXJuIHBoaTtcbiAgICB9XG4gIH1cbiAgLy8uLnJlcG9ydEVycm9yKFwiY2Fzczpwal9pbnZfbWxmbjogQ29udmVyZ2VuY2UgZXJyb3JcIik7XG4gIHJldHVybiBwaGk7XG59XG4iLCIvLyBIZWF2aWx5IGJhc2VkIG9uIHRoaXMgdG1lcmMgcHJvamVjdGlvbiBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21ibG9jaC9tYXBzaGFwZXItcHJvai9ibG9iL21hc3Rlci9zcmMvcHJvamVjdGlvbnMvdG1lcmMuanNcblxuaW1wb3J0IHBqX2VuZm4gZnJvbSAnLi4vY29tbW9uL3BqX2VuZm4nO1xuaW1wb3J0IHBqX21sZm4gZnJvbSAnLi4vY29tbW9uL3BqX21sZm4nO1xuaW1wb3J0IHBqX2ludl9tbGZuIGZyb20gJy4uL2NvbW1vbi9wal9pbnZfbWxmbic7XG5pbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5cbmltcG9ydCB7RVBTTE4sIEhBTEZfUEl9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuaW1wb3J0IHNpZ24gZnJvbSAnLi4vY29tbW9uL3NpZ24nO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgdGhpcy54MCA9IHRoaXMueDAgIT09IHVuZGVmaW5lZCA/IHRoaXMueDAgOiAwO1xuICB0aGlzLnkwID0gdGhpcy55MCAhPT0gdW5kZWZpbmVkID8gdGhpcy55MCA6IDA7XG4gIHRoaXMubG9uZzAgPSB0aGlzLmxvbmcwICE9PSB1bmRlZmluZWQgPyB0aGlzLmxvbmcwIDogMDtcbiAgdGhpcy5sYXQwID0gdGhpcy5sYXQwICE9PSB1bmRlZmluZWQgPyB0aGlzLmxhdDAgOiAwO1xuXG4gIGlmICh0aGlzLmVzKSB7XG4gICAgdGhpcy5lbiA9IHBqX2VuZm4odGhpcy5lcyk7XG4gICAgdGhpcy5tbDAgPSBwal9tbGZuKHRoaXMubGF0MCwgTWF0aC5zaW4odGhpcy5sYXQwKSwgTWF0aC5jb3ModGhpcy5sYXQwKSwgdGhpcy5lbik7XG4gIH1cbn1cblxuLyoqXG4gICAgVHJhbnN2ZXJzZSBNZXJjYXRvciBGb3J3YXJkICAtIGxvbmcvbGF0IHRvIHgveVxuICAgIGxvbmcvbGF0IGluIHJhZGlhbnNcbiAgKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICB2YXIgZGVsdGFfbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIGNvbjtcbiAgdmFyIHgsIHk7XG4gIHZhciBzaW5fcGhpID0gTWF0aC5zaW4obGF0KTtcbiAgdmFyIGNvc19waGkgPSBNYXRoLmNvcyhsYXQpO1xuXG4gIGlmICghdGhpcy5lcykge1xuICAgIHZhciBiID0gY29zX3BoaSAqIE1hdGguc2luKGRlbHRhX2xvbik7XG5cbiAgICBpZiAoKE1hdGguYWJzKE1hdGguYWJzKGIpIC0gMSkpIDwgRVBTTE4pIHtcbiAgICAgIHJldHVybiAoOTMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHggPSAwLjUgKiB0aGlzLmEgKiB0aGlzLmswICogTWF0aC5sb2coKDEgKyBiKSAvICgxIC0gYikpICsgdGhpcy54MDtcbiAgICAgIHkgPSBjb3NfcGhpICogTWF0aC5jb3MoZGVsdGFfbG9uKSAvIE1hdGguc3FydCgxIC0gTWF0aC5wb3coYiwgMikpO1xuICAgICAgYiA9IE1hdGguYWJzKHkpO1xuXG4gICAgICBpZiAoYiA+PSAxKSB7XG4gICAgICAgIGlmICgoYiAtIDEpID4gRVBTTE4pIHtcbiAgICAgICAgICByZXR1cm4gKDkzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHkgPSBNYXRoLmFjb3MoeSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXQgPCAwKSB7XG4gICAgICAgIHkgPSAteTtcbiAgICAgIH1cblxuICAgICAgeSA9IHRoaXMuYSAqIHRoaXMuazAgKiAoeSAtIHRoaXMubGF0MCkgKyB0aGlzLnkwO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgYWwgPSBjb3NfcGhpICogZGVsdGFfbG9uO1xuICAgIHZhciBhbHMgPSBNYXRoLnBvdyhhbCwgMik7XG4gICAgdmFyIGMgPSB0aGlzLmVwMiAqIE1hdGgucG93KGNvc19waGksIDIpO1xuICAgIHZhciBjcyA9IE1hdGgucG93KGMsIDIpO1xuICAgIHZhciB0cSA9IE1hdGguYWJzKGNvc19waGkpID4gRVBTTE4gPyBNYXRoLnRhbihsYXQpIDogMDtcbiAgICB2YXIgdCA9IE1hdGgucG93KHRxLCAyKTtcbiAgICB2YXIgdHMgPSBNYXRoLnBvdyh0LCAyKTtcbiAgICBjb24gPSAxIC0gdGhpcy5lcyAqIE1hdGgucG93KHNpbl9waGksIDIpO1xuICAgIGFsID0gYWwgLyBNYXRoLnNxcnQoY29uKTtcbiAgICB2YXIgbWwgPSBwal9tbGZuKGxhdCwgc2luX3BoaSwgY29zX3BoaSwgdGhpcy5lbik7XG5cbiAgICB4ID0gdGhpcy5hICogKHRoaXMuazAgKiBhbCAqICgxICtcbiAgICAgIGFscyAvIDYgKiAoMSAtIHQgKyBjICtcbiAgICAgIGFscyAvIDIwICogKDUgLSAxOCAqIHQgKyB0cyArIDE0ICogYyAtIDU4ICogdCAqIGMgK1xuICAgICAgYWxzIC8gNDIgKiAoNjEgKyAxNzkgKiB0cyAtIHRzICogdCAtIDQ3OSAqIHQpKSkpKSArXG4gICAgICB0aGlzLngwO1xuXG4gICAgeSA9IHRoaXMuYSAqICh0aGlzLmswICogKG1sIC0gdGhpcy5tbDAgK1xuICAgICAgc2luX3BoaSAqIGRlbHRhX2xvbiAqIGFsIC8gMiAqICgxICtcbiAgICAgIGFscyAvIDEyICogKDUgLSB0ICsgOSAqIGMgKyA0ICogY3MgK1xuICAgICAgYWxzIC8gMzAgKiAoNjEgKyB0cyAtIDU4ICogdCArIDI3MCAqIGMgLSAzMzAgKiB0ICogYyArXG4gICAgICBhbHMgLyA1NiAqICgxMzg1ICsgNTQzICogdHMgLSB0cyAqIHQgLSAzMTExICogdCkpKSkpKSArXG4gICAgICB0aGlzLnkwO1xuICB9XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcblxuICByZXR1cm4gcDtcbn1cblxuLyoqXG4gICAgVHJhbnN2ZXJzZSBNZXJjYXRvciBJbnZlcnNlICAtICB4L3kgdG8gbG9uZy9sYXRcbiAgKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIGNvbiwgcGhpO1xuICB2YXIgbGF0LCBsb247XG4gIHZhciB4ID0gKHAueCAtIHRoaXMueDApICogKDEgLyB0aGlzLmEpO1xuICB2YXIgeSA9IChwLnkgLSB0aGlzLnkwKSAqICgxIC8gdGhpcy5hKTtcblxuICBpZiAoIXRoaXMuZXMpIHtcbiAgICB2YXIgZiA9IE1hdGguZXhwKHggLyB0aGlzLmswKTtcbiAgICB2YXIgZyA9IDAuNSAqIChmIC0gMSAvIGYpO1xuICAgIHZhciB0ZW1wID0gdGhpcy5sYXQwICsgeSAvIHRoaXMuazA7XG4gICAgdmFyIGggPSBNYXRoLmNvcyh0ZW1wKTtcbiAgICBjb24gPSBNYXRoLnNxcnQoKDEgLSBNYXRoLnBvdyhoLCAyKSkgLyAoMSArIE1hdGgucG93KGcsIDIpKSk7XG4gICAgbGF0ID0gTWF0aC5hc2luKGNvbik7XG5cbiAgICBpZiAoeSA8IDApIHtcbiAgICAgIGxhdCA9IC1sYXQ7XG4gICAgfVxuXG4gICAgaWYgKChnID09PSAwKSAmJiAoaCA9PT0gMCkpIHtcbiAgICAgIGxvbiA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbG9uID0gYWRqdXN0X2xvbihNYXRoLmF0YW4yKGcsIGgpICsgdGhpcy5sb25nMCk7XG4gICAgfVxuICB9XG4gIGVsc2UgeyAvLyBlbGxpcHNvaWRhbCBmb3JtXG4gICAgY29uID0gdGhpcy5tbDAgKyB5IC8gdGhpcy5rMDtcbiAgICBwaGkgPSBwal9pbnZfbWxmbihjb24sIHRoaXMuZXMsIHRoaXMuZW4pO1xuXG4gICAgaWYgKE1hdGguYWJzKHBoaSkgPCBIQUxGX1BJKSB7XG4gICAgICB2YXIgc2luX3BoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgICB2YXIgY29zX3BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgICB2YXIgdGFuX3BoaSA9IE1hdGguYWJzKGNvc19waGkpID4gRVBTTE4gPyBNYXRoLnRhbihwaGkpIDogMDtcbiAgICAgIHZhciBjID0gdGhpcy5lcDIgKiBNYXRoLnBvdyhjb3NfcGhpLCAyKTtcbiAgICAgIHZhciBjcyA9IE1hdGgucG93KGMsIDIpO1xuICAgICAgdmFyIHQgPSBNYXRoLnBvdyh0YW5fcGhpLCAyKTtcbiAgICAgIHZhciB0cyA9IE1hdGgucG93KHQsIDIpO1xuICAgICAgY29uID0gMSAtIHRoaXMuZXMgKiBNYXRoLnBvdyhzaW5fcGhpLCAyKTtcbiAgICAgIHZhciBkID0geCAqIE1hdGguc3FydChjb24pIC8gdGhpcy5rMDtcbiAgICAgIHZhciBkcyA9IE1hdGgucG93KGQsIDIpO1xuICAgICAgY29uID0gY29uICogdGFuX3BoaTtcblxuICAgICAgbGF0ID0gcGhpIC0gKGNvbiAqIGRzIC8gKDEgLSB0aGlzLmVzKSkgKiAwLjUgKiAoMSAtXG4gICAgICAgIGRzIC8gMTIgKiAoNSArIDMgKiB0IC0gOSAqIGMgKiB0ICsgYyAtIDQgKiBjcyAtXG4gICAgICAgIGRzIC8gMzAgKiAoNjEgKyA5MCAqIHQgLSAyNTIgKiBjICogdCArIDQ1ICogdHMgKyA0NiAqIGMgLVxuICAgICAgICBkcyAvIDU2ICogKDEzODUgKyAzNjMzICogdCArIDQwOTUgKiB0cyArIDE1NzQgKiB0cyAqIHQpKSkpO1xuXG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAoZCAqICgxIC1cbiAgICAgICAgZHMgLyA2ICogKDEgKyAyICogdCArIGMgLVxuICAgICAgICBkcyAvIDIwICogKDUgKyAyOCAqIHQgKyAyNCAqIHRzICsgOCAqIGMgKiB0ICsgNiAqIGMgLVxuICAgICAgICBkcyAvIDQyICogKDYxICsgNjYyICogdCArIDEzMjAgKiB0cyArIDcyMCAqIHRzICogdCkpKSkgLyBjb3NfcGhpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGF0ID0gSEFMRl9QSSAqIHNpZ24oeSk7XG4gICAgICBsb24gPSAwO1xuICAgIH1cbiAgfVxuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuXG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiRmFzdF9UcmFuc3ZlcnNlX01lcmNhdG9yXCIsIFwiRmFzdCBUcmFuc3ZlcnNlIE1lcmNhdG9yXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHZhciByID0gTWF0aC5leHAoeCk7XG4gIHIgPSAociAtIDEgLyByKSAvIDI7XG4gIHJldHVybiByO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHkpIHtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICB5ID0gTWF0aC5hYnMoeSk7XG4gIHZhciBhID0gTWF0aC5tYXgoeCwgeSk7XG4gIHZhciBiID0gTWF0aC5taW4oeCwgeSkgLyAoYSA/IGEgOiAxKTtcblxuICByZXR1cm4gYSAqIE1hdGguc3FydCgxICsgTWF0aC5wb3coYiwgMikpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICB2YXIgeSA9IDEgKyB4O1xuICB2YXIgeiA9IHkgLSAxO1xuXG4gIHJldHVybiB6ID09PSAwID8geCA6IHggKiBNYXRoLmxvZyh5KSAvIHo7XG59XG4iLCJpbXBvcnQgaHlwb3QgZnJvbSAnLi9oeXBvdCc7XG5pbXBvcnQgbG9nMXB5IGZyb20gJy4vbG9nMXB5JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICB2YXIgeSA9IE1hdGguYWJzKHgpO1xuICB5ID0gbG9nMXB5KHkgKiAoMSArIHkgLyAoaHlwb3QoMSwgeSkgKyAxKSkpO1xuXG4gIHJldHVybiB4IDwgMCA/IC15IDogeTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBwLCBCKSB7XG4gIHZhciBjb3NfMkIgPSAyICogTWF0aC5jb3MoMiAqIEIpO1xuICB2YXIgaSA9IHBwLmxlbmd0aCAtIDE7XG4gIHZhciBoMSA9IHBwW2ldO1xuICB2YXIgaDIgPSAwO1xuICB2YXIgaDtcblxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBoID0gLWgyICsgY29zXzJCICogaDEgKyBwcFtpXTtcbiAgICBoMiA9IGgxO1xuICAgIGgxID0gaDtcbiAgfVxuXG4gIHJldHVybiAoQiArIGggKiBNYXRoLnNpbigyICogQikpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocHAsIGFyZ19yKSB7XG4gIHZhciByID0gMiAqIE1hdGguY29zKGFyZ19yKTtcbiAgdmFyIGkgPSBwcC5sZW5ndGggLSAxO1xuICB2YXIgaHIxID0gcHBbaV07XG4gIHZhciBocjIgPSAwO1xuICB2YXIgaHI7XG5cbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaHIgPSAtaHIyICsgciAqIGhyMSArIHBwW2ldO1xuICAgIGhyMiA9IGhyMTtcbiAgICBocjEgPSBocjtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNpbihhcmdfcikgKiBocjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHIgPSBNYXRoLmV4cCh4KTtcbiAgciA9IChyICsgMSAvIHIpIC8gMjtcbiAgcmV0dXJuIHI7XG59IiwiaW1wb3J0IHNpbmggZnJvbSAnLi9zaW5oJztcbmltcG9ydCBjb3NoIGZyb20gJy4vY29zaCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBwLCBhcmdfciwgYXJnX2kpIHtcbiAgdmFyIHNpbl9hcmdfciA9IE1hdGguc2luKGFyZ19yKTtcbiAgdmFyIGNvc19hcmdfciA9IE1hdGguY29zKGFyZ19yKTtcbiAgdmFyIHNpbmhfYXJnX2kgPSBzaW5oKGFyZ19pKTtcbiAgdmFyIGNvc2hfYXJnX2kgPSBjb3NoKGFyZ19pKTtcbiAgdmFyIHIgPSAyICogY29zX2FyZ19yICogY29zaF9hcmdfaTtcbiAgdmFyIGkgPSAtMiAqIHNpbl9hcmdfciAqIHNpbmhfYXJnX2k7XG4gIHZhciBqID0gcHAubGVuZ3RoIC0gMTtcbiAgdmFyIGhyID0gcHBbal07XG4gIHZhciBoaTEgPSAwO1xuICB2YXIgaHIxID0gMDtcbiAgdmFyIGhpID0gMDtcbiAgdmFyIGhyMjtcbiAgdmFyIGhpMjtcblxuICB3aGlsZSAoLS1qID49IDApIHtcbiAgICBocjIgPSBocjE7XG4gICAgaGkyID0gaGkxO1xuICAgIGhyMSA9IGhyO1xuICAgIGhpMSA9IGhpO1xuICAgIGhyID0gLWhyMiArIHIgKiBocjEgLSBpICogaGkxICsgcHBbal07XG4gICAgaGkgPSAtaGkyICsgaSAqIGhyMSArIHIgKiBoaTE7XG4gIH1cblxuICByID0gc2luX2FyZ19yICogY29zaF9hcmdfaTtcbiAgaSA9IGNvc19hcmdfciAqIHNpbmhfYXJnX2k7XG5cbiAgcmV0dXJuIFtyICogaHIgLSBpICogaGksIHIgKiBoaSArIGkgKiBocl07XG59XG4iLCIvLyBIZWF2aWx5IGJhc2VkIG9uIHRoaXMgZXRtZXJjIHByb2plY3Rpb24gaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYmxvY2gvbWFwc2hhcGVyLXByb2ovYmxvYi9tYXN0ZXIvc3JjL3Byb2plY3Rpb25zL2V0bWVyYy5qc1xuXG5pbXBvcnQgdG1lcmMgZnJvbSAnLi4vcHJvamVjdGlvbnMvdG1lcmMnO1xuaW1wb3J0IHNpbmggZnJvbSAnLi4vY29tbW9uL3NpbmgnO1xuaW1wb3J0IGh5cG90IGZyb20gJy4uL2NvbW1vbi9oeXBvdCc7XG5pbXBvcnQgYXNpbmh5IGZyb20gJy4uL2NvbW1vbi9hc2luaHknO1xuaW1wb3J0IGdhdGcgZnJvbSAnLi4vY29tbW9uL2dhdGcnO1xuaW1wb3J0IGNsZW5zIGZyb20gJy4uL2NvbW1vbi9jbGVucyc7XG5pbXBvcnQgY2xlbnNfY21wbHggZnJvbSAnLi4vY29tbW9uL2NsZW5zX2NtcGx4JztcbmltcG9ydCBhZGp1c3RfbG9uIGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbG9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIGlmICghdGhpcy5hcHByb3ggJiYgKGlzTmFOKHRoaXMuZXMpIHx8IHRoaXMuZXMgPD0gMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBlbGxpcHRpY2FsIHVzYWdlLiBUcnkgdXNpbmcgdGhlICthcHByb3ggb3B0aW9uIGluIHRoZSBwcm9qIHN0cmluZywgb3IgUFJPSkVDVElPTltcIkZhc3RfVHJhbnN2ZXJzZV9NZXJjYXRvclwiXSBpbiB0aGUgV0tULicpO1xuICB9XG4gIGlmICh0aGlzLmFwcHJveCkge1xuICAgIC8vIFdoZW4gJythcHByb3gnIGlzIHNldCwgdXNlIHRtZXJjIGluc3RlYWRcbiAgICB0bWVyYy5pbml0LmFwcGx5KHRoaXMpO1xuICAgIHRoaXMuZm9yd2FyZCA9IHRtZXJjLmZvcndhcmQ7XG4gICAgdGhpcy5pbnZlcnNlID0gdG1lcmMuaW52ZXJzZTtcbiAgfVxuXG4gIHRoaXMueDAgPSB0aGlzLngwICE9PSB1bmRlZmluZWQgPyB0aGlzLngwIDogMDtcbiAgdGhpcy55MCA9IHRoaXMueTAgIT09IHVuZGVmaW5lZCA/IHRoaXMueTAgOiAwO1xuICB0aGlzLmxvbmcwID0gdGhpcy5sb25nMCAhPT0gdW5kZWZpbmVkID8gdGhpcy5sb25nMCA6IDA7XG4gIHRoaXMubGF0MCA9IHRoaXMubGF0MCAhPT0gdW5kZWZpbmVkID8gdGhpcy5sYXQwIDogMDtcblxuICB0aGlzLmNnYiA9IFtdO1xuICB0aGlzLmNiZyA9IFtdO1xuICB0aGlzLnV0ZyA9IFtdO1xuICB0aGlzLmd0dSA9IFtdO1xuXG4gIHZhciBmID0gdGhpcy5lcyAvICgxICsgTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKSk7XG4gIHZhciBuID0gZiAvICgyIC0gZik7XG4gIHZhciBucCA9IG47XG5cbiAgdGhpcy5jZ2JbMF0gPSBuICogKDIgKyBuICogKC0yIC8gMyArIG4gKiAoLTIgKyBuICogKDExNiAvIDQ1ICsgbiAqICgyNiAvIDQ1ICsgbiAqICgtMjg1NCAvIDY3NSApKSkpKSk7XG4gIHRoaXMuY2JnWzBdID0gbiAqICgtMiArIG4gKiAoIDIgLyAzICsgbiAqICggNCAvIDMgKyBuICogKC04MiAvIDQ1ICsgbiAqICgzMiAvIDQ1ICsgbiAqICg0NjQyIC8gNDcyNSkpKSkpKTtcblxuICBucCA9IG5wICogbjtcbiAgdGhpcy5jZ2JbMV0gPSBucCAqICg3IC8gMyArIG4gKiAoLTggLyA1ICsgbiAqICgtMjI3IC8gNDUgKyBuICogKDI3MDQgLyAzMTUgKyBuICogKDIzMjMgLyA5NDUpKSkpKTtcbiAgdGhpcy5jYmdbMV0gPSBucCAqICg1IC8gMyArIG4gKiAoLTE2IC8gMTUgKyBuICogKCAtMTMgLyA5ICsgbiAqICg5MDQgLyAzMTUgKyBuICogKC0xNTIyIC8gOTQ1KSkpKSk7XG5cbiAgbnAgPSBucCAqIG47XG4gIHRoaXMuY2diWzJdID0gbnAgKiAoNTYgLyAxNSArIG4gKiAoLTEzNiAvIDM1ICsgbiAqICgtMTI2MiAvIDEwNSArIG4gKiAoNzM4MTQgLyAyODM1KSkpKTtcbiAgdGhpcy5jYmdbMl0gPSBucCAqICgtMjYgLyAxNSArIG4gKiAoMzQgLyAyMSArIG4gKiAoOCAvIDUgKyBuICogKC0xMjY4NiAvIDI4MzUpKSkpO1xuXG4gIG5wID0gbnAgKiBuO1xuICB0aGlzLmNnYlszXSA9IG5wICogKDQyNzkgLyA2MzAgKyBuICogKC0zMzIgLyAzNSArIG4gKiAoLTM5OTU3MiAvIDE0MTc1KSkpO1xuICB0aGlzLmNiZ1szXSA9IG5wICogKDEyMzcgLyA2MzAgKyBuICogKC0xMiAvIDUgKyBuICogKCAtMjQ4MzIgLyAxNDE3NSkpKTtcblxuICBucCA9IG5wICogbjtcbiAgdGhpcy5jZ2JbNF0gPSBucCAqICg0MTc0IC8gMzE1ICsgbiAqICgtMTQ0ODM4IC8gNjIzNykpO1xuICB0aGlzLmNiZ1s0XSA9IG5wICogKC03MzQgLyAzMTUgKyBuICogKDEwOTU5OCAvIDMxMTg1KSk7XG5cbiAgbnAgPSBucCAqIG47XG4gIHRoaXMuY2diWzVdID0gbnAgKiAoNjAxNjc2IC8gMjIyNzUpO1xuICB0aGlzLmNiZ1s1XSA9IG5wICogKDQ0NDMzNyAvIDE1NTkyNSk7XG5cbiAgbnAgPSBNYXRoLnBvdyhuLCAyKTtcbiAgdGhpcy5RbiA9IHRoaXMuazAgLyAoMSArIG4pICogKDEgKyBucCAqICgxIC8gNCArIG5wICogKDEgLyA2NCArIG5wIC8gMjU2KSkpO1xuXG4gIHRoaXMudXRnWzBdID0gbiAqICgtMC41ICsgbiAqICggMiAvIDMgKyBuICogKC0zNyAvIDk2ICsgbiAqICggMSAvIDM2MCArIG4gKiAoODEgLyA1MTIgKyBuICogKC05NjE5OSAvIDYwNDgwMCkpKSkpKTtcbiAgdGhpcy5ndHVbMF0gPSBuICogKDAuNSArIG4gKiAoLTIgLyAzICsgbiAqICg1IC8gMTYgKyBuICogKDQxIC8gMTgwICsgbiAqICgtMTI3IC8gMjg4ICsgbiAqICg3ODkxIC8gMzc4MDApKSkpKSk7XG5cbiAgdGhpcy51dGdbMV0gPSBucCAqICgtMSAvIDQ4ICsgbiAqICgtMSAvIDE1ICsgbiAqICg0MzcgLyAxNDQwICsgbiAqICgtNDYgLyAxMDUgKyBuICogKDExMTg3MTEgLyAzODcwNzIwKSkpKSk7XG4gIHRoaXMuZ3R1WzFdID0gbnAgKiAoMTMgLyA0OCArIG4gKiAoLTMgLyA1ICsgbiAqICg1NTcgLyAxNDQwICsgbiAqICgyODEgLyA2MzAgKyBuICogKC0xOTgzNDMzIC8gMTkzNTM2MCkpKSkpO1xuXG4gIG5wID0gbnAgKiBuO1xuICB0aGlzLnV0Z1syXSA9IG5wICogKC0xNyAvIDQ4MCArIG4gKiAoMzcgLyA4NDAgKyBuICogKDIwOSAvIDQ0ODAgKyBuICogKC01NTY5IC8gOTA3MjAgKSkpKTtcbiAgdGhpcy5ndHVbMl0gPSBucCAqICg2MSAvIDI0MCArIG4gKiAoLTEwMyAvIDE0MCArIG4gKiAoMTUwNjEgLyAyNjg4MCArIG4gKiAoMTY3NjAzIC8gMTgxNDQwKSkpKTtcblxuICBucCA9IG5wICogbjtcbiAgdGhpcy51dGdbM10gPSBucCAqICgtNDM5NyAvIDE2MTI4MCArIG4gKiAoMTEgLyA1MDQgKyBuICogKDgzMDI1MSAvIDcyNTc2MDApKSk7XG4gIHRoaXMuZ3R1WzNdID0gbnAgKiAoNDk1NjEgLyAxNjEyODAgKyBuICogKC0xNzkgLyAxNjggKyBuICogKDY2MDE2NjEgLyA3MjU3NjAwKSkpO1xuXG4gIG5wID0gbnAgKiBuO1xuICB0aGlzLnV0Z1s0XSA9IG5wICogKC00NTgzIC8gMTYxMjgwICsgbiAqICgxMDg4NDcgLyAzOTkxNjgwKSk7XG4gIHRoaXMuZ3R1WzRdID0gbnAgKiAoMzQ3MjkgLyA4MDY0MCArIG4gKiAoLTM0MTg4ODkgLyAxOTk1ODQwKSk7XG5cbiAgbnAgPSBucCAqIG47XG4gIHRoaXMudXRnWzVdID0gbnAgKiAoLTIwNjQ4NjkzIC8gNjM4NjY4ODAwKTtcbiAgdGhpcy5ndHVbNV0gPSBucCAqICgyMTIzNzg5NDEgLyAzMTkzMzQ0MDApO1xuXG4gIHZhciBaID0gZ2F0Zyh0aGlzLmNiZywgdGhpcy5sYXQwKTtcbiAgdGhpcy5aYiA9IC10aGlzLlFuICogKFogKyBjbGVucyh0aGlzLmd0dSwgMiAqIFopKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuICB2YXIgQ2UgPSBhZGp1c3RfbG9uKHAueCAtIHRoaXMubG9uZzApO1xuICB2YXIgQ24gPSBwLnk7XG5cbiAgQ24gPSBnYXRnKHRoaXMuY2JnLCBDbik7XG4gIHZhciBzaW5fQ24gPSBNYXRoLnNpbihDbik7XG4gIHZhciBjb3NfQ24gPSBNYXRoLmNvcyhDbik7XG4gIHZhciBzaW5fQ2UgPSBNYXRoLnNpbihDZSk7XG4gIHZhciBjb3NfQ2UgPSBNYXRoLmNvcyhDZSk7XG5cbiAgQ24gPSBNYXRoLmF0YW4yKHNpbl9DbiwgY29zX0NlICogY29zX0NuKTtcbiAgQ2UgPSBNYXRoLmF0YW4yKHNpbl9DZSAqIGNvc19DbiwgaHlwb3Qoc2luX0NuLCBjb3NfQ24gKiBjb3NfQ2UpKTtcbiAgQ2UgPSBhc2luaHkoTWF0aC50YW4oQ2UpKTtcblxuICB2YXIgdG1wID0gY2xlbnNfY21wbHgodGhpcy5ndHUsIDIgKiBDbiwgMiAqIENlKTtcblxuICBDbiA9IENuICsgdG1wWzBdO1xuICBDZSA9IENlICsgdG1wWzFdO1xuXG4gIHZhciB4O1xuICB2YXIgeTtcblxuICBpZiAoTWF0aC5hYnMoQ2UpIDw9IDIuNjIzMzk1MTYyNzc4KSB7XG4gICAgeCA9IHRoaXMuYSAqICh0aGlzLlFuICogQ2UpICsgdGhpcy54MDtcbiAgICB5ID0gdGhpcy5hICogKHRoaXMuUW4gKiBDbiArIHRoaXMuWmIpICsgdGhpcy55MDtcbiAgfVxuICBlbHNlIHtcbiAgICB4ID0gSW5maW5pdHk7XG4gICAgeSA9IEluZmluaXR5O1xuICB9XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcblxuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuICB2YXIgQ2UgPSAocC54IC0gdGhpcy54MCkgKiAoMSAvIHRoaXMuYSk7XG4gIHZhciBDbiA9IChwLnkgLSB0aGlzLnkwKSAqICgxIC8gdGhpcy5hKTtcblxuICBDbiA9IChDbiAtIHRoaXMuWmIpIC8gdGhpcy5RbjtcbiAgQ2UgPSBDZSAvIHRoaXMuUW47XG5cbiAgdmFyIGxvbjtcbiAgdmFyIGxhdDtcblxuICBpZiAoTWF0aC5hYnMoQ2UpIDw9IDIuNjIzMzk1MTYyNzc4KSB7XG4gICAgdmFyIHRtcCA9IGNsZW5zX2NtcGx4KHRoaXMudXRnLCAyICogQ24sIDIgKiBDZSk7XG5cbiAgICBDbiA9IENuICsgdG1wWzBdO1xuICAgIENlID0gQ2UgKyB0bXBbMV07XG4gICAgQ2UgPSBNYXRoLmF0YW4oc2luaChDZSkpO1xuXG4gICAgdmFyIHNpbl9DbiA9IE1hdGguc2luKENuKTtcbiAgICB2YXIgY29zX0NuID0gTWF0aC5jb3MoQ24pO1xuICAgIHZhciBzaW5fQ2UgPSBNYXRoLnNpbihDZSk7XG4gICAgdmFyIGNvc19DZSA9IE1hdGguY29zKENlKTtcblxuICAgIENuID0gTWF0aC5hdGFuMihzaW5fQ24gKiBjb3NfQ2UsIGh5cG90KHNpbl9DZSwgY29zX0NlICogY29zX0NuKSk7XG4gICAgQ2UgPSBNYXRoLmF0YW4yKHNpbl9DZSwgY29zX0NlICogY29zX0NuKTtcblxuICAgIGxvbiA9IGFkanVzdF9sb24oQ2UgKyB0aGlzLmxvbmcwKTtcbiAgICBsYXQgPSBnYXRnKHRoaXMuY2diLCBDbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgbG9uID0gSW5maW5pdHk7XG4gICAgbGF0ID0gSW5maW5pdHk7XG4gIH1cblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcblxuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIkV4dGVuZGVkX1RyYW5zdmVyc2VfTWVyY2F0b3JcIiwgXCJFeHRlbmRlZCBUcmFuc3ZlcnNlIE1lcmNhdG9yXCIsIFwiZXRtZXJjXCIsIFwiVHJhbnN2ZXJzZV9NZXJjYXRvclwiLCBcIlRyYW5zdmVyc2UgTWVyY2F0b3JcIiwgXCJ0bWVyY1wiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi9hZGp1c3RfbG9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oem9uZSwgbG9uKSB7XG4gIGlmICh6b25lID09PSB1bmRlZmluZWQpIHtcbiAgICB6b25lID0gTWF0aC5mbG9vcigoYWRqdXN0X2xvbihsb24pICsgTWF0aC5QSSkgKiAzMCAvIE1hdGguUEkpICsgMTtcblxuICAgIGlmICh6b25lIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmICh6b25lID4gNjApIHtcbiAgICAgIHJldHVybiA2MDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHpvbmU7XG59XG4iLCJpbXBvcnQgYWRqdXN0X3pvbmUgZnJvbSAnLi4vY29tbW9uL2FkanVzdF96b25lJztcbmltcG9ydCBldG1lcmMgZnJvbSAnLi9ldG1lcmMnO1xuZXhwb3J0IHZhciBkZXBlbmRzT24gPSAnZXRtZXJjJztcbmltcG9ydCB7RDJSfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgdmFyIHpvbmUgPSBhZGp1c3Rfem9uZSh0aGlzLnpvbmUsIHRoaXMubG9uZzApO1xuICBpZiAoem9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHV0bSB6b25lJyk7XG4gIH1cbiAgdGhpcy5sYXQwID0gMDtcbiAgdGhpcy5sb25nMCA9ICAoKDYgKiBNYXRoLmFicyh6b25lKSkgLSAxODMpICogRDJSO1xuICB0aGlzLngwID0gNTAwMDAwO1xuICB0aGlzLnkwID0gdGhpcy51dG1Tb3V0aCA/IDEwMDAwMDAwIDogMDtcbiAgdGhpcy5rMCA9IDAuOTk5NjtcblxuICBldG1lcmMuaW5pdC5hcHBseSh0aGlzKTtcbiAgdGhpcy5mb3J3YXJkID0gZXRtZXJjLmZvcndhcmQ7XG4gIHRoaXMuaW52ZXJzZSA9IGV0bWVyYy5pbnZlcnNlO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiVW5pdmVyc2FsIFRyYW5zdmVyc2UgTWVyY2F0b3IgU3lzdGVtXCIsIFwidXRtXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBuYW1lczogbmFtZXMsXG4gIGRlcGVuZHNPbjogZGVwZW5kc09uXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXNpbnAsIGV4cCkge1xuICByZXR1cm4gKE1hdGgucG93KCgxIC0gZXNpbnApIC8gKDEgKyBlc2lucCksIGV4cCkpO1xufSIsImltcG9ydCBzcmF0IGZyb20gJy4uL2NvbW1vbi9zcmF0JztcbnZhciBNQVhfSVRFUiA9IDIwO1xuaW1wb3J0IHtIQUxGX1BJLCBGT1JUUEl9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgdmFyIHNwaGkgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICB2YXIgY3BoaSA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gIGNwaGkgKj0gY3BoaTtcbiAgdGhpcy5yYyA9IE1hdGguc3FydCgxIC0gdGhpcy5lcykgLyAoMSAtIHRoaXMuZXMgKiBzcGhpICogc3BoaSk7XG4gIHRoaXMuQyA9IE1hdGguc3FydCgxICsgdGhpcy5lcyAqIGNwaGkgKiBjcGhpIC8gKDEgLSB0aGlzLmVzKSk7XG4gIHRoaXMucGhpYzAgPSBNYXRoLmFzaW4oc3BoaSAvIHRoaXMuQyk7XG4gIHRoaXMucmF0ZXhwID0gMC41ICogdGhpcy5DICogdGhpcy5lO1xuICB0aGlzLksgPSBNYXRoLnRhbigwLjUgKiB0aGlzLnBoaWMwICsgRk9SVFBJKSAvIChNYXRoLnBvdyhNYXRoLnRhbigwLjUgKiB0aGlzLmxhdDAgKyBGT1JUUEkpLCB0aGlzLkMpICogc3JhdCh0aGlzLmUgKiBzcGhpLCB0aGlzLnJhdGV4cCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgcC55ID0gMiAqIE1hdGguYXRhbih0aGlzLksgKiBNYXRoLnBvdyhNYXRoLnRhbigwLjUgKiBsYXQgKyBGT1JUUEkpLCB0aGlzLkMpICogc3JhdCh0aGlzLmUgKiBNYXRoLnNpbihsYXQpLCB0aGlzLnJhdGV4cCkpIC0gSEFMRl9QSTtcbiAgcC54ID0gdGhpcy5DICogbG9uO1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuICB2YXIgREVMX1RPTCA9IDFlLTE0O1xuICB2YXIgbG9uID0gcC54IC8gdGhpcy5DO1xuICB2YXIgbGF0ID0gcC55O1xuICB2YXIgbnVtID0gTWF0aC5wb3coTWF0aC50YW4oMC41ICogbGF0ICsgRk9SVFBJKSAvIHRoaXMuSywgMSAvIHRoaXMuQyk7XG4gIGZvciAodmFyIGkgPSBNQVhfSVRFUjsgaSA+IDA7IC0taSkge1xuICAgIGxhdCA9IDIgKiBNYXRoLmF0YW4obnVtICogc3JhdCh0aGlzLmUgKiBNYXRoLnNpbihwLnkpLCAtIDAuNSAqIHRoaXMuZSkpIC0gSEFMRl9QSTtcbiAgICBpZiAoTWF0aC5hYnMobGF0IC0gcC55KSA8IERFTF9UT0wpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwLnkgPSBsYXQ7XG4gIH1cbiAgLyogY29udmVyZ2VuY2UgZmFpbGVkICovXG4gIGlmICghaSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcImdhdXNzXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgZ2F1c3MgZnJvbSAnLi9nYXVzcyc7XG5pbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBnYXVzcy5pbml0LmFwcGx5KHRoaXMpO1xuICBpZiAoIXRoaXMucmMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5zaW5jMCA9IE1hdGguc2luKHRoaXMucGhpYzApO1xuICB0aGlzLmNvc2MwID0gTWF0aC5jb3ModGhpcy5waGljMCk7XG4gIHRoaXMuUjIgPSAyICogdGhpcy5yYztcbiAgaWYgKCF0aGlzLnRpdGxlKSB7XG4gICAgdGhpcy50aXRsZSA9IFwiT2JsaXF1ZSBTdGVyZW9ncmFwaGljIEFsdGVybmF0aXZlXCI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuICB2YXIgc2luYywgY29zYywgY29zbCwgaztcbiAgcC54ID0gYWRqdXN0X2xvbihwLnggLSB0aGlzLmxvbmcwKTtcbiAgZ2F1c3MuZm9yd2FyZC5hcHBseSh0aGlzLCBbcF0pO1xuICBzaW5jID0gTWF0aC5zaW4ocC55KTtcbiAgY29zYyA9IE1hdGguY29zKHAueSk7XG4gIGNvc2wgPSBNYXRoLmNvcyhwLngpO1xuICBrID0gdGhpcy5rMCAqIHRoaXMuUjIgLyAoMSArIHRoaXMuc2luYzAgKiBzaW5jICsgdGhpcy5jb3NjMCAqIGNvc2MgKiBjb3NsKTtcbiAgcC54ID0gayAqIGNvc2MgKiBNYXRoLnNpbihwLngpO1xuICBwLnkgPSBrICogKHRoaXMuY29zYzAgKiBzaW5jIC0gdGhpcy5zaW5jMCAqIGNvc2MgKiBjb3NsKTtcbiAgcC54ID0gdGhpcy5hICogcC54ICsgdGhpcy54MDtcbiAgcC55ID0gdGhpcy5hICogcC55ICsgdGhpcy55MDtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIHNpbmMsIGNvc2MsIGxvbiwgbGF0LCByaG87XG4gIHAueCA9IChwLnggLSB0aGlzLngwKSAvIHRoaXMuYTtcbiAgcC55ID0gKHAueSAtIHRoaXMueTApIC8gdGhpcy5hO1xuXG4gIHAueCAvPSB0aGlzLmswO1xuICBwLnkgLz0gdGhpcy5rMDtcbiAgaWYgKChyaG8gPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KSkpIHtcbiAgICB2YXIgYyA9IDIgKiBNYXRoLmF0YW4yKHJobywgdGhpcy5SMik7XG4gICAgc2luYyA9IE1hdGguc2luKGMpO1xuICAgIGNvc2MgPSBNYXRoLmNvcyhjKTtcbiAgICBsYXQgPSBNYXRoLmFzaW4oY29zYyAqIHRoaXMuc2luYzAgKyBwLnkgKiBzaW5jICogdGhpcy5jb3NjMCAvIHJobyk7XG4gICAgbG9uID0gTWF0aC5hdGFuMihwLnggKiBzaW5jLCByaG8gKiB0aGlzLmNvc2MwICogY29zYyAtIHAueSAqIHRoaXMuc2luYzAgKiBzaW5jKTtcbiAgfVxuICBlbHNlIHtcbiAgICBsYXQgPSB0aGlzLnBoaWMwO1xuICAgIGxvbiA9IDA7XG4gIH1cblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgZ2F1c3MuaW52ZXJzZS5hcHBseSh0aGlzLCBbcF0pO1xuICBwLnggPSBhZGp1c3RfbG9uKHAueCArIHRoaXMubG9uZzApO1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIlN0ZXJlb2dyYXBoaWNfTm9ydGhfUG9sZVwiLCBcIk9ibGlxdWVfU3RlcmVvZ3JhcGhpY1wiLCBcIlBvbGFyX1N0ZXJlb2dyYXBoaWNcIiwgXCJzdGVyZWFcIixcIk9ibGlxdWUgU3RlcmVvZ3JhcGhpYyBBbHRlcm5hdGl2ZVwiLFwiRG91YmxlX1N0ZXJlb2dyYXBoaWNcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCB7RVBTTE4sIEhBTEZfUEl9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5pbXBvcnQgc2lnbiBmcm9tICcuLi9jb21tb24vc2lnbic7XG5pbXBvcnQgbXNmbnogZnJvbSAnLi4vY29tbW9uL21zZm56JztcbmltcG9ydCB0c2ZueiBmcm9tICcuLi9jb21tb24vdHNmbnonO1xuaW1wb3J0IHBoaTJ6IGZyb20gJy4uL2NvbW1vbi9waGkyeic7XG5pbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBzc2ZuXyhwaGl0LCBzaW5waGksIGVjY2VuKSB7XG4gIHNpbnBoaSAqPSBlY2NlbjtcbiAgcmV0dXJuIChNYXRoLnRhbigwLjUgKiAoSEFMRl9QSSArIHBoaXQpKSAqIE1hdGgucG93KCgxIC0gc2lucGhpKSAvICgxICsgc2lucGhpKSwgMC41ICogZWNjZW4pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHRoaXMuY29zbGF0MCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gIHRoaXMuc2lubGF0MCA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmICh0aGlzLmswID09PSAxICYmICFpc05hTih0aGlzLmxhdF90cykgJiYgTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8PSBFUFNMTikge1xuICAgICAgdGhpcy5rMCA9IDAuNSAqICgxICsgc2lnbih0aGlzLmxhdDApICogTWF0aC5zaW4odGhpcy5sYXRfdHMpKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuY29zbGF0MCkgPD0gRVBTTE4pIHtcbiAgICAgIGlmICh0aGlzLmxhdDAgPiAwKSB7XG4gICAgICAgIC8vTm9ydGggcG9sZVxuICAgICAgICAvL3RyYWNlKCdzdGVyZTpub3J0aCBwb2xlJyk7XG4gICAgICAgIHRoaXMuY29uID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvL1NvdXRoIHBvbGVcbiAgICAgICAgLy90cmFjZSgnc3RlcmU6c291dGggcG9sZScpO1xuICAgICAgICB0aGlzLmNvbiA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnMgPSBNYXRoLnNxcnQoTWF0aC5wb3coMSArIHRoaXMuZSwgMSArIHRoaXMuZSkgKiBNYXRoLnBvdygxIC0gdGhpcy5lLCAxIC0gdGhpcy5lKSk7XG4gICAgaWYgKHRoaXMuazAgPT09IDEgJiYgIWlzTmFOKHRoaXMubGF0X3RzKSAmJiBNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG4gICAgICB0aGlzLmswID0gMC41ICogdGhpcy5jb25zICogbXNmbnoodGhpcy5lLCBNYXRoLnNpbih0aGlzLmxhdF90cyksIE1hdGguY29zKHRoaXMubGF0X3RzKSkgLyB0c2Zueih0aGlzLmUsIHRoaXMuY29uICogdGhpcy5sYXRfdHMsIHRoaXMuY29uICogTWF0aC5zaW4odGhpcy5sYXRfdHMpKTtcbiAgICB9XG4gICAgdGhpcy5tczEgPSBtc2Zueih0aGlzLmUsIHRoaXMuc2lubGF0MCwgdGhpcy5jb3NsYXQwKTtcbiAgICB0aGlzLlgwID0gMiAqIE1hdGguYXRhbih0aGlzLnNzZm5fKHRoaXMubGF0MCwgdGhpcy5zaW5sYXQwLCB0aGlzLmUpKSAtIEhBTEZfUEk7XG4gICAgdGhpcy5jb3NYMCA9IE1hdGguY29zKHRoaXMuWDApO1xuICAgIHRoaXMuc2luWDAgPSBNYXRoLnNpbih0aGlzLlgwKTtcbiAgfVxufVxuXG4vLyBTdGVyZW9ncmFwaGljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICB2YXIgc2lubGF0ID0gTWF0aC5zaW4obGF0KTtcbiAgdmFyIGNvc2xhdCA9IE1hdGguY29zKGxhdCk7XG4gIHZhciBBLCBYLCBzaW5YLCBjb3NYLCB0cywgcmg7XG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblxuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMobG9uIC0gdGhpcy5sb25nMCkgLSBNYXRoLlBJKSA8PSBFUFNMTiAmJiBNYXRoLmFicyhsYXQgKyB0aGlzLmxhdDApIDw9IEVQU0xOKSB7XG4gICAgLy9jYXNlIG9mIHRoZSBvcmlnaW5lIHBvaW50XG4gICAgLy90cmFjZSgnc3RlcmU6dGhpcyBpcyB0aGUgb3JpZ2luIHBvaW50Jyk7XG4gICAgcC54ID0gTmFOO1xuICAgIHAueSA9IE5hTjtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICAvL3RyYWNlKCdzdGVyZTpzcGhlcmUgY2FzZScpO1xuICAgIEEgPSAyICogdGhpcy5rMCAvICgxICsgdGhpcy5zaW5sYXQwICogc2lubGF0ICsgdGhpcy5jb3NsYXQwICogY29zbGF0ICogTWF0aC5jb3MoZGxvbikpO1xuICAgIHAueCA9IHRoaXMuYSAqIEEgKiBjb3NsYXQgKiBNYXRoLnNpbihkbG9uKSArIHRoaXMueDA7XG4gICAgcC55ID0gdGhpcy5hICogQSAqICh0aGlzLmNvc2xhdDAgKiBzaW5sYXQgLSB0aGlzLnNpbmxhdDAgKiBjb3NsYXQgKiBNYXRoLmNvcyhkbG9uKSkgKyB0aGlzLnkwO1xuICAgIHJldHVybiBwO1xuICB9XG4gIGVsc2Uge1xuICAgIFggPSAyICogTWF0aC5hdGFuKHRoaXMuc3Nmbl8obGF0LCBzaW5sYXQsIHRoaXMuZSkpIC0gSEFMRl9QSTtcbiAgICBjb3NYID0gTWF0aC5jb3MoWCk7XG4gICAgc2luWCA9IE1hdGguc2luKFgpO1xuICAgIGlmIChNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG4gICAgICB0cyA9IHRzZm56KHRoaXMuZSwgbGF0ICogdGhpcy5jb24sIHRoaXMuY29uICogc2lubGF0KTtcbiAgICAgIHJoID0gMiAqIHRoaXMuYSAqIHRoaXMuazAgKiB0cyAvIHRoaXMuY29ucztcbiAgICAgIHAueCA9IHRoaXMueDAgKyByaCAqIE1hdGguc2luKGxvbiAtIHRoaXMubG9uZzApO1xuICAgICAgcC55ID0gdGhpcy55MCAtIHRoaXMuY29uICogcmggKiBNYXRoLmNvcyhsb24gLSB0aGlzLmxvbmcwKTtcbiAgICAgIC8vdHJhY2UocC50b1N0cmluZygpKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLnNpbmxhdDApIDwgRVBTTE4pIHtcbiAgICAgIC8vRXFcbiAgICAgIC8vdHJhY2UoJ3N0ZXJlOmVxdWF0ZXVyJyk7XG4gICAgICBBID0gMiAqIHRoaXMuYSAqIHRoaXMuazAgLyAoMSArIGNvc1ggKiBNYXRoLmNvcyhkbG9uKSk7XG4gICAgICBwLnkgPSBBICogc2luWDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL290aGVyIGNhc2VcbiAgICAgIC8vdHJhY2UoJ3N0ZXJlOm5vcm1hbCBjYXNlJyk7XG4gICAgICBBID0gMiAqIHRoaXMuYSAqIHRoaXMuazAgKiB0aGlzLm1zMSAvICh0aGlzLmNvc1gwICogKDEgKyB0aGlzLnNpblgwICogc2luWCArIHRoaXMuY29zWDAgKiBjb3NYICogTWF0aC5jb3MoZGxvbikpKTtcbiAgICAgIHAueSA9IEEgKiAodGhpcy5jb3NYMCAqIHNpblggLSB0aGlzLnNpblgwICogY29zWCAqIE1hdGguY29zKGRsb24pKSArIHRoaXMueTA7XG4gICAgfVxuICAgIHAueCA9IEEgKiBjb3NYICogTWF0aC5zaW4oZGxvbikgKyB0aGlzLngwO1xuICB9XG4gIC8vdHJhY2UocC50b1N0cmluZygpKTtcbiAgcmV0dXJuIHA7XG59XG5cbi8vKiBTdGVyZW9ncmFwaGljIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuICBwLnggLT0gdGhpcy54MDtcbiAgcC55IC09IHRoaXMueTA7XG4gIHZhciBsb24sIGxhdCwgdHMsIGNlLCBDaGk7XG4gIHZhciByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICB2YXIgYyA9IDIgKiBNYXRoLmF0YW4ocmggLyAoMiAqIHRoaXMuYSAqIHRoaXMuazApKTtcbiAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIGxhdCA9IHRoaXMubGF0MDtcbiAgICBpZiAocmggPD0gRVBTTE4pIHtcbiAgICAgIHAueCA9IGxvbjtcbiAgICAgIHAueSA9IGxhdDtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBsYXQgPSBNYXRoLmFzaW4oTWF0aC5jb3MoYykgKiB0aGlzLnNpbmxhdDAgKyBwLnkgKiBNYXRoLnNpbihjKSAqIHRoaXMuY29zbGF0MCAvIHJoKTtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8IEVQU0xOKSB7XG4gICAgICBpZiAodGhpcy5sYXQwID4gMCkge1xuICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSAxICogcC55KSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIHAueSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54ICogTWF0aC5zaW4oYyksIHJoICogdGhpcy5jb3NsYXQwICogTWF0aC5jb3MoYykgLSBwLnkgKiB0aGlzLnNpbmxhdDAgKiBNYXRoLnNpbihjKSkpO1xuICAgIH1cbiAgICBwLnggPSBsb247XG4gICAgcC55ID0gbGF0O1xuICAgIHJldHVybiBwO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG4gICAgICBpZiAocmggPD0gRVBTTE4pIHtcbiAgICAgICAgbGF0ID0gdGhpcy5sYXQwO1xuICAgICAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgICAgICBwLnggPSBsb247XG4gICAgICAgIHAueSA9IGxhdDtcbiAgICAgICAgLy90cmFjZShwLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICAgIHAueCAqPSB0aGlzLmNvbjtcbiAgICAgIHAueSAqPSB0aGlzLmNvbjtcbiAgICAgIHRzID0gcmggKiB0aGlzLmNvbnMgLyAoMiAqIHRoaXMuYSAqIHRoaXMuazApO1xuICAgICAgbGF0ID0gdGhpcy5jb24gKiBwaGkyeih0aGlzLmUsIHRzKTtcbiAgICAgIGxvbiA9IHRoaXMuY29uICogYWRqdXN0X2xvbih0aGlzLmNvbiAqIHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSAxICogcC55KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2UgPSAyICogTWF0aC5hdGFuKHJoICogdGhpcy5jb3NYMCAvICgyICogdGhpcy5hICogdGhpcy5rMCAqIHRoaXMubXMxKSk7XG4gICAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgICAgaWYgKHJoIDw9IEVQU0xOKSB7XG4gICAgICAgIENoaSA9IHRoaXMuWDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgQ2hpID0gTWF0aC5hc2luKE1hdGguY29zKGNlKSAqIHRoaXMuc2luWDAgKyBwLnkgKiBNYXRoLnNpbihjZSkgKiB0aGlzLmNvc1gwIC8gcmgpO1xuICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCAqIE1hdGguc2luKGNlKSwgcmggKiB0aGlzLmNvc1gwICogTWF0aC5jb3MoY2UpIC0gcC55ICogdGhpcy5zaW5YMCAqIE1hdGguc2luKGNlKSkpO1xuICAgICAgfVxuICAgICAgbGF0ID0gLTEgKiBwaGkyeih0aGlzLmUsIE1hdGgudGFuKDAuNSAqIChIQUxGX1BJICsgQ2hpKSkpO1xuICAgIH1cbiAgfVxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcblxuICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG4gIHJldHVybiBwO1xuXG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJzdGVyZVwiLCBcIlN0ZXJlb2dyYXBoaWNfU291dGhfUG9sZVwiLCBcIlBvbGFyIFN0ZXJlb2dyYXBoaWMgKHZhcmlhbnQgQilcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lcyxcbiAgc3Nmbl86IHNzZm5fXG59O1xuIiwiLypcbiAgcmVmZXJlbmNlczpcbiAgICBGb3JtdWxlcyBldCBjb25zdGFudGVzIHBvdXIgbGUgQ2FsY3VsIHBvdXIgbGFcbiAgICBwcm9qZWN0aW9uIGN5bGluZHJpcXVlIGNvbmZvcm1lIMOgIGF4ZSBvYmxpcXVlIGV0IHBvdXIgbGEgdHJhbnNmb3JtYXRpb24gZW50cmVcbiAgICBkZXMgc3lzdMOobWVzIGRlIHLDqWbDqXJlbmNlLlxuICAgIGh0dHA6Ly93d3cuc3dpc3N0b3BvLmFkbWluLmNoL2ludGVybmV0L3N3aXNzdG9wby9mci9ob21lL3RvcGljcy9zdXJ2ZXkvc3lzL3JlZnN5cy9zd2l0emVybGFuZC5wYXJzeXNyZWxhdGVkMS4zMTIxNi5kb3dubG9hZExpc3QuNzcwMDQuRG93bmxvYWRGaWxlLnRtcC9zd2lzc3Byb2plY3Rpb25mci5wZGZcbiAgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHZhciBwaHkwID0gdGhpcy5sYXQwO1xuICB0aGlzLmxhbWJkYTAgPSB0aGlzLmxvbmcwO1xuICB2YXIgc2luUGh5MCA9IE1hdGguc2luKHBoeTApO1xuICB2YXIgc2VtaU1ham9yQXhpcyA9IHRoaXMuYTtcbiAgdmFyIGludkYgPSB0aGlzLnJmO1xuICB2YXIgZmxhdHRlbmluZyA9IDEgLyBpbnZGO1xuICB2YXIgZTIgPSAyICogZmxhdHRlbmluZyAtIE1hdGgucG93KGZsYXR0ZW5pbmcsIDIpO1xuICB2YXIgZSA9IHRoaXMuZSA9IE1hdGguc3FydChlMik7XG4gIHRoaXMuUiA9IHRoaXMuazAgKiBzZW1pTWFqb3JBeGlzICogTWF0aC5zcXJ0KDEgLSBlMikgLyAoMSAtIGUyICogTWF0aC5wb3coc2luUGh5MCwgMikpO1xuICB0aGlzLmFscGhhID0gTWF0aC5zcXJ0KDEgKyBlMiAvICgxIC0gZTIpICogTWF0aC5wb3coTWF0aC5jb3MocGh5MCksIDQpKTtcbiAgdGhpcy5iMCA9IE1hdGguYXNpbihzaW5QaHkwIC8gdGhpcy5hbHBoYSk7XG4gIHZhciBrMSA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgdGhpcy5iMCAvIDIpKTtcbiAgdmFyIGsyID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBwaHkwIC8gMikpO1xuICB2YXIgazMgPSBNYXRoLmxvZygoMSArIGUgKiBzaW5QaHkwKSAvICgxIC0gZSAqIHNpblBoeTApKTtcbiAgdGhpcy5LID0gazEgLSB0aGlzLmFscGhhICogazIgKyB0aGlzLmFscGhhICogZSAvIDIgKiBrMztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuICB2YXIgU2ExID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgLSBwLnkgLyAyKSk7XG4gIHZhciBTYTIgPSB0aGlzLmUgLyAyICogTWF0aC5sb2coKDEgKyB0aGlzLmUgKiBNYXRoLnNpbihwLnkpKSAvICgxIC0gdGhpcy5lICogTWF0aC5zaW4ocC55KSkpO1xuICB2YXIgUyA9IC10aGlzLmFscGhhICogKFNhMSArIFNhMikgKyB0aGlzLks7XG5cbiAgLy8gc3BoZXJpYyBsYXRpdHVkZVxuICB2YXIgYiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKFMpKSAtIE1hdGguUEkgLyA0KTtcblxuICAvLyBzcGhlcmljIGxvbmdpdHVkZVxuICB2YXIgSSA9IHRoaXMuYWxwaGEgKiAocC54IC0gdGhpcy5sYW1iZGEwKTtcblxuICAvLyBwc29ldWRvIGVxdWF0b3JpYWwgcm90YXRpb25cbiAgdmFyIHJvdEkgPSBNYXRoLmF0YW4oTWF0aC5zaW4oSSkgLyAoTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLnRhbihiKSArIE1hdGguY29zKHRoaXMuYjApICogTWF0aC5jb3MoSSkpKTtcblxuICB2YXIgcm90QiA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmIwKSAqIE1hdGguc2luKGIpIC0gTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLmNvcyhiKSAqIE1hdGguY29zKEkpKTtcblxuICBwLnkgPSB0aGlzLlIgLyAyICogTWF0aC5sb2coKDEgKyBNYXRoLnNpbihyb3RCKSkgLyAoMSAtIE1hdGguc2luKHJvdEIpKSkgKyB0aGlzLnkwO1xuICBwLnggPSB0aGlzLlIgKiByb3RJICsgdGhpcy54MDtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIFkgPSBwLnggLSB0aGlzLngwO1xuICB2YXIgWCA9IHAueSAtIHRoaXMueTA7XG5cbiAgdmFyIHJvdEkgPSBZIC8gdGhpcy5SO1xuICB2YXIgcm90QiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKFggLyB0aGlzLlIpKSAtIE1hdGguUEkgLyA0KTtcblxuICB2YXIgYiA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmIwKSAqIE1hdGguc2luKHJvdEIpICsgTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLmNvcyhyb3RCKSAqIE1hdGguY29zKHJvdEkpKTtcbiAgdmFyIEkgPSBNYXRoLmF0YW4oTWF0aC5zaW4ocm90SSkgLyAoTWF0aC5jb3ModGhpcy5iMCkgKiBNYXRoLmNvcyhyb3RJKSAtIE1hdGguc2luKHRoaXMuYjApICogTWF0aC50YW4ocm90QikpKTtcblxuICB2YXIgbGFtYmRhID0gdGhpcy5sYW1iZGEwICsgSSAvIHRoaXMuYWxwaGE7XG5cbiAgdmFyIFMgPSAwO1xuICB2YXIgcGh5ID0gYjtcbiAgdmFyIHByZXZQaHkgPSAtMTAwMDtcbiAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gIHdoaWxlIChNYXRoLmFicyhwaHkgLSBwcmV2UGh5KSA+IDAuMDAwMDAwMSkge1xuICAgIGlmICgrK2l0ZXJhdGlvbiA+IDIwKSB7XG4gICAgICAvLy4uLnJlcG9ydEVycm9yKFwib21lcmNGd2RJbmZpbml0eVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy9TID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBwaHkgLyAyKSk7XG4gICAgUyA9IDEgLyB0aGlzLmFscGhhICogKE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgYiAvIDIpKSAtIHRoaXMuSykgKyB0aGlzLmUgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIE1hdGguYXNpbih0aGlzLmUgKiBNYXRoLnNpbihwaHkpKSAvIDIpKTtcbiAgICBwcmV2UGh5ID0gcGh5O1xuICAgIHBoeSA9IDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoUykpIC0gTWF0aC5QSSAvIDI7XG4gIH1cblxuICBwLnggPSBsYW1iZGE7XG4gIHAueSA9IHBoeTtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJzb21lcmNcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCB0c2ZueiBmcm9tICcuLi9jb21tb24vdHNmbnonO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IHBoaTJ6IGZyb20gJy4uL2NvbW1vbi9waGkyeic7XG5pbXBvcnQgeyBEMlIsIEVQU0xOLCBIQUxGX1BJLCBUV09fUEksIEZPUlRQSSB9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG52YXIgVE9MID0gMWUtNztcblxuZnVuY3Rpb24gaXNUeXBlQShQKSB7XG4gIHZhciB0eXBlQVByb2plY3Rpb25zID0gWydIb3RpbmVfT2JsaXF1ZV9NZXJjYXRvcicsJ0hvdGluZV9PYmxpcXVlX01lcmNhdG9yX0F6aW11dGhfTmF0dXJhbF9PcmlnaW4nXTtcbiAgdmFyIHByb2plY3Rpb25OYW1lID0gdHlwZW9mIFAuUFJPSkVDVElPTiA9PT0gXCJvYmplY3RcIiA/IE9iamVjdC5rZXlzKFAuUFJPSkVDVElPTilbMF0gOiBQLlBST0pFQ1RJT047XG4gIFxuICByZXR1cm4gJ25vX3VvZmYnIGluIFAgfHwgJ25vX29mZicgaW4gUCB8fCB0eXBlQVByb2plY3Rpb25zLmluZGV4T2YocHJvamVjdGlvbk5hbWUpICE9PSAtMTtcbn1cblxuXG4vKiBJbml0aWFsaXplIHRoZSBPYmxpcXVlIE1lcmNhdG9yICBwcm9qZWN0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkgeyAgXG4gIHZhciBjb24sIGNvbSwgY29zcGgwLCBELCBGLCBILCBMLCBzaW5waDAsIHAsIEosIGdhbW1hID0gMCxcbiAgICBnYW1tYTAsIGxhbWMgPSAwLCBsYW0xID0gMCwgbGFtMiA9IDAsIHBoaTEgPSAwLCBwaGkyID0gMCwgYWxwaGFfYyA9IDAsIEFCO1xuICBcbiAgLy8gb25seSBUeXBlIEEgdXNlcyB0aGUgbm9fb2ZmIG9yIG5vX3VvZmYgcHJvcGVydHlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL3Byb2ouNC9pc3N1ZXMvMTA0XG4gIHRoaXMubm9fb2ZmID0gaXNUeXBlQSh0aGlzKTtcbiAgdGhpcy5ub19yb3QgPSAnbm9fcm90JyBpbiB0aGlzO1xuICBcbiAgdmFyIGFscCA9IGZhbHNlO1xuICBpZiAoXCJhbHBoYVwiIGluIHRoaXMpIHtcbiAgICBhbHAgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGdhbSA9IGZhbHNlO1xuICBpZiAoXCJyZWN0aWZpZWRfZ3JpZF9hbmdsZVwiIGluIHRoaXMpIHtcbiAgICBnYW0gPSB0cnVlO1xuICB9XG5cbiAgaWYgKGFscCkge1xuICAgIGFscGhhX2MgPSB0aGlzLmFscGhhO1xuICB9XG4gIFxuICBpZiAoZ2FtKSB7XG4gICAgZ2FtbWEgPSAodGhpcy5yZWN0aWZpZWRfZ3JpZF9hbmdsZSAqIEQyUik7XG4gIH1cbiAgXG4gIGlmIChhbHAgfHwgZ2FtKSB7XG4gICAgbGFtYyA9IHRoaXMubG9uZ2M7XG4gIH0gZWxzZSB7XG4gICAgbGFtMSA9IHRoaXMubG9uZzE7XG4gICAgcGhpMSA9IHRoaXMubGF0MTtcbiAgICBsYW0yID0gdGhpcy5sb25nMjtcbiAgICBwaGkyID0gdGhpcy5sYXQyO1xuICAgIFxuICAgIGlmIChNYXRoLmFicyhwaGkxIC0gcGhpMikgPD0gVE9MIHx8IChjb24gPSBNYXRoLmFicyhwaGkxKSkgPD0gVE9MIHx8XG4gICAgICAgIE1hdGguYWJzKGNvbiAtIEhBTEZfUEkpIDw9IFRPTCB8fCBNYXRoLmFicyhNYXRoLmFicyh0aGlzLmxhdDApIC0gSEFMRl9QSSkgPD0gVE9MIHx8XG4gICAgICAgIE1hdGguYWJzKE1hdGguYWJzKHBoaTIpIC0gSEFMRl9QSSkgPD0gVE9MKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgXG4gIHZhciBvbmVfZXMgPSAxLjAgLSB0aGlzLmVzO1xuICBjb20gPSBNYXRoLnNxcnQob25lX2VzKTtcbiAgXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDApID4gRVBTTE4pIHtcbiAgICBzaW5waDAgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICAgIGNvc3BoMCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gICAgY29uID0gMSAtIHRoaXMuZXMgKiBzaW5waDAgKiBzaW5waDA7XG4gICAgdGhpcy5CID0gY29zcGgwICogY29zcGgwO1xuICAgIHRoaXMuQiA9IE1hdGguc3FydCgxICsgdGhpcy5lcyAqIHRoaXMuQiAqIHRoaXMuQiAvIG9uZV9lcyk7XG4gICAgdGhpcy5BID0gdGhpcy5CICogdGhpcy5rMCAqIGNvbSAvIGNvbjtcbiAgICBEID0gdGhpcy5CICogY29tIC8gKGNvc3BoMCAqIE1hdGguc3FydChjb24pKTtcbiAgICBGID0gRCAqIEQgLTE7XG4gICAgXG4gICAgaWYgKEYgPD0gMCkge1xuICAgICAgRiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIEYgPSBNYXRoLnNxcnQoRik7XG4gICAgICBpZiAodGhpcy5sYXQwIDwgMCkge1xuICAgICAgICBGID0gLUY7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMuRSA9IEYgKz0gRDtcbiAgICB0aGlzLkUgKj0gTWF0aC5wb3codHNmbnoodGhpcy5lLCB0aGlzLmxhdDAsIHNpbnBoMCksIHRoaXMuQik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5CID0gMSAvIGNvbTtcbiAgICB0aGlzLkEgPSB0aGlzLmswO1xuICAgIHRoaXMuRSA9IEQgPSBGID0gMTtcbiAgfVxuICBcbiAgaWYgKGFscCB8fCBnYW0pIHtcbiAgICBpZiAoYWxwKSB7XG4gICAgICBnYW1tYTAgPSBNYXRoLmFzaW4oTWF0aC5zaW4oYWxwaGFfYykgLyBEKTtcbiAgICAgIGlmICghZ2FtKSB7XG4gICAgICAgIGdhbW1hID0gYWxwaGFfYztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2FtbWEwID0gZ2FtbWE7XG4gICAgICBhbHBoYV9jID0gTWF0aC5hc2luKEQgKiBNYXRoLnNpbihnYW1tYTApKTtcbiAgICB9XG4gICAgdGhpcy5sYW0wID0gbGFtYyAtIE1hdGguYXNpbigwLjUgKiAoRiAtIDEgLyBGKSAqIE1hdGgudGFuKGdhbW1hMCkpIC8gdGhpcy5CO1xuICB9IGVsc2Uge1xuICAgIEggPSBNYXRoLnBvdyh0c2Zueih0aGlzLmUsIHBoaTEsIE1hdGguc2luKHBoaTEpKSwgdGhpcy5CKTtcbiAgICBMID0gTWF0aC5wb3codHNmbnoodGhpcy5lLCBwaGkyLCBNYXRoLnNpbihwaGkyKSksIHRoaXMuQik7XG4gICAgRiA9IHRoaXMuRSAvIEg7XG4gICAgcCA9IChMIC0gSCkgLyAoTCArIEgpO1xuICAgIEogPSB0aGlzLkUgKiB0aGlzLkU7XG4gICAgSiA9IChKIC0gTCAqIEgpIC8gKEogKyBMICogSCk7XG4gICAgY29uID0gbGFtMSAtIGxhbTI7XG4gICAgXG4gICAgaWYgKGNvbiA8IC1NYXRoLnBpKSB7XG4gICAgICBsYW0yIC09VFdPX1BJO1xuICAgIH0gZWxzZSBpZiAoY29uID4gTWF0aC5waSkge1xuICAgICAgbGFtMiArPSBUV09fUEk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubGFtMCA9IGFkanVzdF9sb24oMC41ICogKGxhbTEgKyBsYW0yKSAtIE1hdGguYXRhbihKICogTWF0aC50YW4oMC41ICogdGhpcy5CICogKGxhbTEgLSBsYW0yKSkgLyBwKSAvIHRoaXMuQik7XG4gICAgZ2FtbWEwID0gTWF0aC5hdGFuKDIgKiBNYXRoLnNpbih0aGlzLkIgKiBhZGp1c3RfbG9uKGxhbTEgLSB0aGlzLmxhbTApKSAvIChGIC0gMSAvIEYpKTtcbiAgICBnYW1tYSA9IGFscGhhX2MgPSBNYXRoLmFzaW4oRCAqIE1hdGguc2luKGdhbW1hMCkpO1xuICB9XG4gIFxuICB0aGlzLnNpbmdhbSA9IE1hdGguc2luKGdhbW1hMCk7XG4gIHRoaXMuY29zZ2FtID0gTWF0aC5jb3MoZ2FtbWEwKTtcbiAgdGhpcy5zaW5yb3QgPSBNYXRoLnNpbihnYW1tYSk7XG4gIHRoaXMuY29zcm90ID0gTWF0aC5jb3MoZ2FtbWEpO1xuICBcbiAgdGhpcy5yQiA9IDEgLyB0aGlzLkI7XG4gIHRoaXMuQXJCID0gdGhpcy5BICogdGhpcy5yQjtcbiAgdGhpcy5CckEgPSAxIC8gdGhpcy5BckI7XG4gIEFCID0gdGhpcy5BICogdGhpcy5CO1xuICBcbiAgaWYgKHRoaXMubm9fb2ZmKSB7XG4gICAgdGhpcy51XzAgPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudV8wID0gTWF0aC5hYnModGhpcy5BckIgKiBNYXRoLmF0YW4oTWF0aC5zcXJ0KEQgKiBEIC0gMSkgLyBNYXRoLmNvcyhhbHBoYV9jKSkpO1xuICAgIFxuICAgIGlmICh0aGlzLmxhdDAgPCAwKSB7XG4gICAgICB0aGlzLnVfMCA9IC0gdGhpcy51XzA7XG4gICAgfSAgXG4gIH1cbiAgICBcbiAgRiA9IDAuNSAqIGdhbW1hMDtcbiAgdGhpcy52X3BvbGVfbiA9IHRoaXMuQXJCICogTWF0aC5sb2coTWF0aC50YW4oRk9SVFBJIC0gRikpO1xuICB0aGlzLnZfcG9sZV9zID0gdGhpcy5BckIgKiBNYXRoLmxvZyhNYXRoLnRhbihGT1JUUEkgKyBGKSk7XG59XG5cblxuLyogT2JsaXF1ZSBNZXJjYXRvciBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGNvb3JkcyA9IHt9O1xuICB2YXIgUywgVCwgVSwgViwgVywgdGVtcCwgdSwgdjtcbiAgcC54ID0gcC54IC0gdGhpcy5sYW0wO1xuICBcbiAgaWYgKE1hdGguYWJzKE1hdGguYWJzKHAueSkgLSBIQUxGX1BJKSA+IEVQU0xOKSB7XG4gICAgVyA9IHRoaXMuRSAvIE1hdGgucG93KHRzZm56KHRoaXMuZSwgcC55LCBNYXRoLnNpbihwLnkpKSwgdGhpcy5CKTtcbiAgICBcbiAgICB0ZW1wID0gMSAvIFc7XG4gICAgUyA9IDAuNSAqIChXIC0gdGVtcCk7XG4gICAgVCA9IDAuNSAqIChXICsgdGVtcCk7XG4gICAgViA9IE1hdGguc2luKHRoaXMuQiAqIHAueCk7XG4gICAgVSA9IChTICogdGhpcy5zaW5nYW0gLSBWICogdGhpcy5jb3NnYW0pIC8gVDtcbiAgICAgICAgXG4gICAgaWYgKE1hdGguYWJzKE1hdGguYWJzKFUpIC0gMS4wKSA8IEVQU0xOKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgXG4gICAgdiA9IDAuNSAqIHRoaXMuQXJCICogTWF0aC5sb2coKDEgLSBVKS8oMSArIFUpKTtcbiAgICB0ZW1wID0gTWF0aC5jb3ModGhpcy5CICogcC54KTtcbiAgICBcbiAgICBpZiAoTWF0aC5hYnModGVtcCkgPCBUT0wpIHtcbiAgICAgIHUgPSB0aGlzLkEgKiBwLng7XG4gICAgfSBlbHNlIHtcbiAgICAgIHUgPSB0aGlzLkFyQiAqIE1hdGguYXRhbjIoKFMgKiB0aGlzLmNvc2dhbSArIFYgKiB0aGlzLnNpbmdhbSksIHRlbXApO1xuICAgIH0gICAgXG4gIH0gZWxzZSB7XG4gICAgdiA9IHAueSA+IDAgPyB0aGlzLnZfcG9sZV9uIDogdGhpcy52X3BvbGVfcztcbiAgICB1ID0gdGhpcy5BckIgKiBwLnk7XG4gIH1cbiAgICAgXG4gIGlmICh0aGlzLm5vX3JvdCkge1xuICAgIGNvb3Jkcy54ID0gdTtcbiAgICBjb29yZHMueSA9IHY7XG4gIH0gZWxzZSB7XG4gICAgdSAtPSB0aGlzLnVfMDtcbiAgICBjb29yZHMueCA9IHYgKiB0aGlzLmNvc3JvdCArIHUgKiB0aGlzLnNpbnJvdDtcbiAgICBjb29yZHMueSA9IHUgKiB0aGlzLmNvc3JvdCAtIHYgKiB0aGlzLnNpbnJvdDtcbiAgfVxuICBcbiAgY29vcmRzLnggPSAodGhpcy5hICogY29vcmRzLnggKyB0aGlzLngwKTtcbiAgY29vcmRzLnkgPSAodGhpcy5hICogY29vcmRzLnkgKyB0aGlzLnkwKTtcbiAgXG4gIHJldHVybiBjb29yZHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIHUsIHYsIFFwLCBTcCwgVHAsIFZwLCBVcDtcbiAgdmFyIGNvb3JkcyA9IHt9O1xuICBcbiAgcC54ID0gKHAueCAtIHRoaXMueDApICogKDEuMCAvIHRoaXMuYSk7XG4gIHAueSA9IChwLnkgLSB0aGlzLnkwKSAqICgxLjAgLyB0aGlzLmEpO1xuXG4gIGlmICh0aGlzLm5vX3JvdCkge1xuICAgIHYgPSBwLnk7XG4gICAgdSA9IHAueDtcbiAgfSBlbHNlIHtcbiAgICB2ID0gcC54ICogdGhpcy5jb3Nyb3QgLSBwLnkgKiB0aGlzLnNpbnJvdDtcbiAgICB1ID0gcC55ICogdGhpcy5jb3Nyb3QgKyBwLnggKiB0aGlzLnNpbnJvdCArIHRoaXMudV8wO1xuICB9XG4gIFxuICBRcCA9IE1hdGguZXhwKC10aGlzLkJyQSAqIHYpO1xuICBTcCA9IDAuNSAqIChRcCAtIDEgLyBRcCk7XG4gIFRwID0gMC41ICogKFFwICsgMSAvIFFwKTtcbiAgVnAgPSBNYXRoLnNpbih0aGlzLkJyQSAqIHUpO1xuICBVcCA9IChWcCAqIHRoaXMuY29zZ2FtICsgU3AgKiB0aGlzLnNpbmdhbSkgLyBUcDtcbiAgXG4gIGlmIChNYXRoLmFicyhNYXRoLmFicyhVcCkgLSAxKSA8IEVQU0xOKSB7XG4gICAgY29vcmRzLnggPSAwO1xuICAgIGNvb3Jkcy55ID0gVXAgPCAwID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICB9IGVsc2Uge1xuICAgIGNvb3Jkcy55ID0gdGhpcy5FIC8gTWF0aC5zcXJ0KCgxICsgVXApIC8gKDEgLSBVcCkpO1xuICAgIGNvb3Jkcy55ID0gcGhpMnoodGhpcy5lLCBNYXRoLnBvdyhjb29yZHMueSwgMSAvIHRoaXMuQikpO1xuICAgIFxuICAgIGlmIChjb29yZHMueSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICAgICAgXG4gICAgY29vcmRzLnggPSAtdGhpcy5yQiAqIE1hdGguYXRhbjIoKFNwICogdGhpcy5jb3NnYW0gLSBWcCAqIHRoaXMuc2luZ2FtKSwgTWF0aC5jb3ModGhpcy5CckEgKiB1KSk7XG4gIH1cbiAgXG4gIGNvb3Jkcy54ICs9IHRoaXMubGFtMDtcbiAgXG4gIHJldHVybiBjb29yZHM7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJIb3RpbmVfT2JsaXF1ZV9NZXJjYXRvclwiLCBcIkhvdGluZSBPYmxpcXVlIE1lcmNhdG9yXCIsIFwiSG90aW5lX09ibGlxdWVfTWVyY2F0b3JfQXppbXV0aF9OYXR1cmFsX09yaWdpblwiLCBcIkhvdGluZV9PYmxpcXVlX01lcmNhdG9yX1R3b19Qb2ludF9OYXR1cmFsX09yaWdpblwiLCBcIkhvdGluZV9PYmxpcXVlX01lcmNhdG9yX0F6aW11dGhfQ2VudGVyXCIsIFwiT2JsaXF1ZV9NZXJjYXRvclwiLCBcIm9tZXJjXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgbXNmbnogZnJvbSAnLi4vY29tbW9uL21zZm56JztcbmltcG9ydCB0c2ZueiBmcm9tICcuLi9jb21tb24vdHNmbnonO1xuaW1wb3J0IHNpZ24gZnJvbSAnLi4vY29tbW9uL3NpZ24nO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IHBoaTJ6IGZyb20gJy4uL2NvbW1vbi9waGkyeic7XG5pbXBvcnQge0hBTEZfUEksIEVQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBcbiAgLy9kb3VibGUgbGF0MDsgICAgICAgICAgICAgICAgICAgIC8qIHRoZSByZWZlcmVuY2UgbGF0aXR1ZGUgICAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSBsb25nMDsgICAgICAgICAgICAgICAgICAgLyogdGhlIHJlZmVyZW5jZSBsb25naXR1ZGUgICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIGxhdDE7ICAgICAgICAgICAgICAgICAgICAvKiBmaXJzdCBzdGFuZGFyZCBwYXJhbGxlbCAgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgbGF0MjsgICAgICAgICAgICAgICAgICAgIC8qIHNlY29uZCBzdGFuZGFyZCBwYXJhbGxlbCAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSByX21hajsgICAgICAgICAgICAgICAgICAgLyogbWFqb3IgYXhpcyAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIHJfbWluOyAgICAgICAgICAgICAgICAgICAvKiBtaW5vciBheGlzICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgZmFsc2VfZWFzdDsgICAgICAgICAgICAgIC8qIHggb2Zmc2V0IGluIG1ldGVycyAgICAgICAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSBmYWxzZV9ub3J0aDsgICAgICAgICAgICAgLyogeSBvZmZzZXQgaW4gbWV0ZXJzICAgICAgICAgICAgICAgICAgICovXG4gIFxuICAvL3RoZSBhYm92ZSB2YWx1ZSBjYW4gYmUgc2V0IHdpdGggcHJvajQuZGVmc1xuICAvL2V4YW1wbGU6IHByb2o0LmRlZnMoXCJFUFNHOjIxNTRcIixcIitwcm9qPWxjYyArbGF0XzE9NDkgK2xhdF8yPTQ0ICtsYXRfMD00Ni41ICtsb25fMD0zICt4XzA9NzAwMDAwICt5XzA9NjYwMDAwMCArZWxscHM9R1JTODAgK3Rvd2dzODQ9MCwwLDAsMCwwLDAsMCArdW5pdHM9bSArbm9fZGVmc1wiKTtcblxuICBpZiAoIXRoaXMubGF0Mikge1xuICAgIHRoaXMubGF0MiA9IHRoaXMubGF0MTtcbiAgfSAvL2lmIGxhdDIgaXMgbm90IGRlZmluZWRcbiAgaWYgKCF0aGlzLmswKSB7XG4gICAgdGhpcy5rMCA9IDE7XG4gIH1cbiAgdGhpcy54MCA9IHRoaXMueDAgfHwgMDtcbiAgdGhpcy55MCA9IHRoaXMueTAgfHwgMDtcbiAgLy8gU3RhbmRhcmQgUGFyYWxsZWxzIGNhbm5vdCBiZSBlcXVhbCBhbmQgb24gb3Bwb3NpdGUgc2lkZXMgb2YgdGhlIGVxdWF0b3JcbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSArIHRoaXMubGF0MikgPCBFUFNMTikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0ZW1wID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmUgPSBNYXRoLnNxcnQoMSAtIHRlbXAgKiB0ZW1wKTtcblxuICB2YXIgc2luMSA9IE1hdGguc2luKHRoaXMubGF0MSk7XG4gIHZhciBjb3MxID0gTWF0aC5jb3ModGhpcy5sYXQxKTtcbiAgdmFyIG1zMSA9IG1zZm56KHRoaXMuZSwgc2luMSwgY29zMSk7XG4gIHZhciB0czEgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MSwgc2luMSk7XG5cbiAgdmFyIHNpbjIgPSBNYXRoLnNpbih0aGlzLmxhdDIpO1xuICB2YXIgY29zMiA9IE1hdGguY29zKHRoaXMubGF0Mik7XG4gIHZhciBtczIgPSBtc2Zueih0aGlzLmUsIHNpbjIsIGNvczIpO1xuICB2YXIgdHMyID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDIsIHNpbjIpO1xuXG4gIHZhciB0czAgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MCwgTWF0aC5zaW4odGhpcy5sYXQwKSk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSAtIHRoaXMubGF0MikgPiBFUFNMTikge1xuICAgIHRoaXMubnMgPSBNYXRoLmxvZyhtczEgLyBtczIpIC8gTWF0aC5sb2codHMxIC8gdHMyKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm5zID0gc2luMTtcbiAgfVxuICBpZiAoaXNOYU4odGhpcy5ucykpIHtcbiAgICB0aGlzLm5zID0gc2luMTtcbiAgfVxuICB0aGlzLmYwID0gbXMxIC8gKHRoaXMubnMgKiBNYXRoLnBvdyh0czEsIHRoaXMubnMpKTtcbiAgdGhpcy5yaCA9IHRoaXMuYSAqIHRoaXMuZjAgKiBNYXRoLnBvdyh0czAsIHRoaXMubnMpO1xuICBpZiAoIXRoaXMudGl0bGUpIHtcbiAgICB0aGlzLnRpdGxlID0gXCJMYW1iZXJ0IENvbmZvcm1hbCBDb25pY1wiO1xuICB9XG59XG5cbi8vIExhbWJlcnQgQ29uZm9ybWFsIGNvbmljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcblxuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIC8vIHNpbmd1bGFyIGNhc2VzIDpcbiAgaWYgKE1hdGguYWJzKDIgKiBNYXRoLmFicyhsYXQpIC0gTWF0aC5QSSkgPD0gRVBTTE4pIHtcbiAgICBsYXQgPSBzaWduKGxhdCkgKiAoSEFMRl9QSSAtIDIgKiBFUFNMTik7XG4gIH1cblxuICB2YXIgY29uID0gTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpO1xuICB2YXIgdHMsIHJoMTtcbiAgaWYgKGNvbiA+IEVQU0xOKSB7XG4gICAgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCwgTWF0aC5zaW4obGF0KSk7XG4gICAgcmgxID0gdGhpcy5hICogdGhpcy5mMCAqIE1hdGgucG93KHRzLCB0aGlzLm5zKTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb24gPSBsYXQgKiB0aGlzLm5zO1xuICAgIGlmIChjb24gPD0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJoMSA9IDA7XG4gIH1cbiAgdmFyIHRoZXRhID0gdGhpcy5ucyAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHAueCA9IHRoaXMuazAgKiAocmgxICogTWF0aC5zaW4odGhldGEpKSArIHRoaXMueDA7XG4gIHAueSA9IHRoaXMuazAgKiAodGhpcy5yaCAtIHJoMSAqIE1hdGguY29zKHRoZXRhKSkgKyB0aGlzLnkwO1xuXG4gIHJldHVybiBwO1xufVxuXG4vLyBMYW1iZXJ0IENvbmZvcm1hbCBDb25pYyBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG5cbiAgdmFyIHJoMSwgY29uLCB0cztcbiAgdmFyIGxhdCwgbG9uO1xuICB2YXIgeCA9IChwLnggLSB0aGlzLngwKSAvIHRoaXMuazA7XG4gIHZhciB5ID0gKHRoaXMucmggLSAocC55IC0gdGhpcy55MCkgLyB0aGlzLmswKTtcbiAgaWYgKHRoaXMubnMgPiAwKSB7XG4gICAgcmgxID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIGNvbiA9IDE7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmgxID0gLU1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICBjb24gPSAtMTtcbiAgfVxuICB2YXIgdGhldGEgPSAwO1xuICBpZiAocmgxICE9PSAwKSB7XG4gICAgdGhldGEgPSBNYXRoLmF0YW4yKChjb24gKiB4KSwgKGNvbiAqIHkpKTtcbiAgfVxuICBpZiAoKHJoMSAhPT0gMCkgfHwgKHRoaXMubnMgPiAwKSkge1xuICAgIGNvbiA9IDEgLyB0aGlzLm5zO1xuICAgIHRzID0gTWF0aC5wb3coKHJoMSAvICh0aGlzLmEgKiB0aGlzLmYwKSksIGNvbik7XG4gICAgbGF0ID0gcGhpMnoodGhpcy5lLCB0cyk7XG4gICAgaWYgKGxhdCA9PT0gLTk5OTkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBsYXQgPSAtSEFMRl9QSTtcbiAgfVxuICBsb24gPSBhZGp1c3RfbG9uKHRoZXRhIC8gdGhpcy5ucyArIHRoaXMubG9uZzApO1xuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcbiAgXCJMYW1iZXJ0IFRhbmdlbnRpYWwgQ29uZm9ybWFsIENvbmljIFByb2plY3Rpb25cIixcbiAgXCJMYW1iZXJ0X0NvbmZvcm1hbF9Db25pY1wiLFxuICBcIkxhbWJlcnRfQ29uZm9ybWFsX0NvbmljXzFTUFwiLFxuICBcIkxhbWJlcnRfQ29uZm9ybWFsX0NvbmljXzJTUFwiLFxuICBcImxjY1wiLFxuICBcIkxhbWJlcnQgQ29uaWMgQ29uZm9ybWFsICgxU1ApXCIsXG4gIFwiTGFtYmVydCBDb25pYyBDb25mb3JtYWwgKDJTUClcIlxuXTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICB0aGlzLmEgPSA2Mzc3Mzk3LjE1NTtcbiAgdGhpcy5lcyA9IDAuMDA2Njc0MzcyMjMwNjE0O1xuICB0aGlzLmUgPSBNYXRoLnNxcnQodGhpcy5lcyk7XG4gIGlmICghdGhpcy5sYXQwKSB7XG4gICAgdGhpcy5sYXQwID0gMC44NjM5Mzc5Nzk3MzcxOTM7XG4gIH1cbiAgaWYgKCF0aGlzLmxvbmcwKSB7XG4gICAgdGhpcy5sb25nMCA9IDAuNzQxNzY0OTMyMDk3NTkwMSAtIDAuMzA4MzQxNTAxMTg1NjY1O1xuICB9XG4gIC8qIGlmIHNjYWxlIG5vdCBzZXQgZGVmYXVsdCB0byAwLjk5OTkgKi9cbiAgaWYgKCF0aGlzLmswKSB7XG4gICAgdGhpcy5rMCA9IDAuOTk5OTtcbiAgfVxuICB0aGlzLnM0NSA9IDAuNzg1Mzk4MTYzMzk3NDQ4OyAvKiA0NSAqL1xuICB0aGlzLnM5MCA9IDIgKiB0aGlzLnM0NTtcbiAgdGhpcy5maTAgPSB0aGlzLmxhdDA7XG4gIHRoaXMuZTIgPSB0aGlzLmVzO1xuICB0aGlzLmUgPSBNYXRoLnNxcnQodGhpcy5lMik7XG4gIHRoaXMuYWxmYSA9IE1hdGguc3FydCgxICsgKHRoaXMuZTIgKiBNYXRoLnBvdyhNYXRoLmNvcyh0aGlzLmZpMCksIDQpKSAvICgxIC0gdGhpcy5lMikpO1xuICB0aGlzLnVxID0gMS4wNDIxNjg1NjM4MDQ3NDtcbiAgdGhpcy51MCA9IE1hdGguYXNpbihNYXRoLnNpbih0aGlzLmZpMCkgLyB0aGlzLmFsZmEpO1xuICB0aGlzLmcgPSBNYXRoLnBvdygoMSArIHRoaXMuZSAqIE1hdGguc2luKHRoaXMuZmkwKSkgLyAoMSAtIHRoaXMuZSAqIE1hdGguc2luKHRoaXMuZmkwKSksIHRoaXMuYWxmYSAqIHRoaXMuZSAvIDIpO1xuICB0aGlzLmsgPSBNYXRoLnRhbih0aGlzLnUwIC8gMiArIHRoaXMuczQ1KSAvIE1hdGgucG93KE1hdGgudGFuKHRoaXMuZmkwIC8gMiArIHRoaXMuczQ1KSwgdGhpcy5hbGZhKSAqIHRoaXMuZztcbiAgdGhpcy5rMSA9IHRoaXMuazA7XG4gIHRoaXMubjAgPSB0aGlzLmEgKiBNYXRoLnNxcnQoMSAtIHRoaXMuZTIpIC8gKDEgLSB0aGlzLmUyICogTWF0aC5wb3coTWF0aC5zaW4odGhpcy5maTApLCAyKSk7XG4gIHRoaXMuczAgPSAxLjM3MDA4MzQ2MjgxNTU1O1xuICB0aGlzLm4gPSBNYXRoLnNpbih0aGlzLnMwKTtcbiAgdGhpcy5ybzAgPSB0aGlzLmsxICogdGhpcy5uMCAvIE1hdGgudGFuKHRoaXMuczApO1xuICB0aGlzLmFkID0gdGhpcy5zOTAgLSB0aGlzLnVxO1xufVxuXG4vKiBlbGxpcHNvaWQgKi9cbi8qIGNhbGN1bGF0ZSB4eSBmcm9tIGxhdC9sb24gKi9cbi8qIENvbnN0YW50cywgaWRlbnRpY2FsIHRvIGludmVyc2UgdHJhbnNmb3JtIGZ1bmN0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBnZmksIHUsIGRlbHRhdiwgcywgZCwgZXBzLCBybztcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIGRlbHRhX2xvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIC8qIFRyYW5zZm9ybWF0aW9uICovXG4gIGdmaSA9IE1hdGgucG93KCgoMSArIHRoaXMuZSAqIE1hdGguc2luKGxhdCkpIC8gKDEgLSB0aGlzLmUgKiBNYXRoLnNpbihsYXQpKSksICh0aGlzLmFsZmEgKiB0aGlzLmUgLyAyKSk7XG4gIHUgPSAyICogKE1hdGguYXRhbih0aGlzLmsgKiBNYXRoLnBvdyhNYXRoLnRhbihsYXQgLyAyICsgdGhpcy5zNDUpLCB0aGlzLmFsZmEpIC8gZ2ZpKSAtIHRoaXMuczQ1KTtcbiAgZGVsdGF2ID0gLWRlbHRhX2xvbiAqIHRoaXMuYWxmYTtcbiAgcyA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmFkKSAqIE1hdGguc2luKHUpICsgTWF0aC5zaW4odGhpcy5hZCkgKiBNYXRoLmNvcyh1KSAqIE1hdGguY29zKGRlbHRhdikpO1xuICBkID0gTWF0aC5hc2luKE1hdGguY29zKHUpICogTWF0aC5zaW4oZGVsdGF2KSAvIE1hdGguY29zKHMpKTtcbiAgZXBzID0gdGhpcy5uICogZDtcbiAgcm8gPSB0aGlzLnJvMCAqIE1hdGgucG93KE1hdGgudGFuKHRoaXMuczAgLyAyICsgdGhpcy5zNDUpLCB0aGlzLm4pIC8gTWF0aC5wb3coTWF0aC50YW4ocyAvIDIgKyB0aGlzLnM0NSksIHRoaXMubik7XG4gIHAueSA9IHJvICogTWF0aC5jb3MoZXBzKSAvIDE7XG4gIHAueCA9IHJvICogTWF0aC5zaW4oZXBzKSAvIDE7XG5cbiAgaWYgKCF0aGlzLmN6ZWNoKSB7XG4gICAgcC55ICo9IC0xO1xuICAgIHAueCAqPSAtMTtcbiAgfVxuICByZXR1cm4gKHApO1xufVxuXG4vKiBjYWxjdWxhdGUgbGF0L2xvbiBmcm9tIHh5ICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHZhciB1LCBkZWx0YXYsIHMsIGQsIGVwcywgcm8sIGZpMTtcbiAgdmFyIG9rO1xuXG4gIC8qIFRyYW5zZm9ybWF0aW9uICovXG4gIC8qIHJldmVydCB5LCB4Ki9cbiAgdmFyIHRtcCA9IHAueDtcbiAgcC54ID0gcC55O1xuICBwLnkgPSB0bXA7XG4gIGlmICghdGhpcy5jemVjaCkge1xuICAgIHAueSAqPSAtMTtcbiAgICBwLnggKj0gLTE7XG4gIH1cbiAgcm8gPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgZXBzID0gTWF0aC5hdGFuMihwLnksIHAueCk7XG4gIGQgPSBlcHMgLyBNYXRoLnNpbih0aGlzLnMwKTtcbiAgcyA9IDIgKiAoTWF0aC5hdGFuKE1hdGgucG93KHRoaXMucm8wIC8gcm8sIDEgLyB0aGlzLm4pICogTWF0aC50YW4odGhpcy5zMCAvIDIgKyB0aGlzLnM0NSkpIC0gdGhpcy5zNDUpO1xuICB1ID0gTWF0aC5hc2luKE1hdGguY29zKHRoaXMuYWQpICogTWF0aC5zaW4ocykgLSBNYXRoLnNpbih0aGlzLmFkKSAqIE1hdGguY29zKHMpICogTWF0aC5jb3MoZCkpO1xuICBkZWx0YXYgPSBNYXRoLmFzaW4oTWF0aC5jb3MocykgKiBNYXRoLnNpbihkKSAvIE1hdGguY29zKHUpKTtcbiAgcC54ID0gdGhpcy5sb25nMCAtIGRlbHRhdiAvIHRoaXMuYWxmYTtcbiAgZmkxID0gdTtcbiAgb2sgPSAwO1xuICB2YXIgaXRlciA9IDA7XG4gIGRvIHtcbiAgICBwLnkgPSAyICogKE1hdGguYXRhbihNYXRoLnBvdyh0aGlzLmssIC0gMSAvIHRoaXMuYWxmYSkgKiBNYXRoLnBvdyhNYXRoLnRhbih1IC8gMiArIHRoaXMuczQ1KSwgMSAvIHRoaXMuYWxmYSkgKiBNYXRoLnBvdygoMSArIHRoaXMuZSAqIE1hdGguc2luKGZpMSkpIC8gKDEgLSB0aGlzLmUgKiBNYXRoLnNpbihmaTEpKSwgdGhpcy5lIC8gMikpIC0gdGhpcy5zNDUpO1xuICAgIGlmIChNYXRoLmFicyhmaTEgLSBwLnkpIDwgMC4wMDAwMDAwMDAxKSB7XG4gICAgICBvayA9IDE7XG4gICAgfVxuICAgIGZpMSA9IHAueTtcbiAgICBpdGVyICs9IDE7XG4gIH0gd2hpbGUgKG9rID09PSAwICYmIGl0ZXIgPCAxNSk7XG4gIGlmIChpdGVyID49IDE1KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKHApO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiS3JvdmFrXCIsIFwia3JvdmFrXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlMCwgZTEsIGUyLCBlMywgcGhpKSB7XG4gIHJldHVybiAoZTAgKiBwaGkgLSBlMSAqIE1hdGguc2luKDIgKiBwaGkpICsgZTIgKiBNYXRoLnNpbig0ICogcGhpKSAtIGUzICogTWF0aC5zaW4oNiAqIHBoaSkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuICgxIC0gMC4yNSAqIHggKiAoMSArIHggLyAxNiAqICgzICsgMS4yNSAqIHgpKSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKDAuMzc1ICogeCAqICgxICsgMC4yNSAqIHggKiAoMSArIDAuNDY4NzUgKiB4KSkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuICgwLjA1ODU5Mzc1ICogeCAqIHggKiAoMSArIDAuNzUgKiB4KSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKHggKiB4ICogeCAqICgzNSAvIDMwNzIpKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBlLCBzaW5waGkpIHtcbiAgdmFyIHRlbXAgPSBlICogc2lucGhpO1xuICByZXR1cm4gYSAvIE1hdGguc3FydCgxIC0gdGVtcCAqIHRlbXApO1xufSIsImltcG9ydCB7SEFMRl9QSX0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5pbXBvcnQgc2lnbiBmcm9tICcuL3NpZ24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoTWF0aC5hYnMoeCkgPCBIQUxGX1BJKSA/IHggOiAoeCAtIChzaWduKHgpICogTWF0aC5QSSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWwsIGUwLCBlMSwgZTIsIGUzKSB7XG4gIHZhciBwaGk7XG4gIHZhciBkcGhpO1xuXG4gIHBoaSA9IG1sIC8gZTA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICAgIGRwaGkgPSAobWwgLSAoZTAgKiBwaGkgLSBlMSAqIE1hdGguc2luKDIgKiBwaGkpICsgZTIgKiBNYXRoLnNpbig0ICogcGhpKSAtIGUzICogTWF0aC5zaW4oNiAqIHBoaSkpKSAvIChlMCAtIDIgKiBlMSAqIE1hdGguY29zKDIgKiBwaGkpICsgNCAqIGUyICogTWF0aC5jb3MoNCAqIHBoaSkgLSA2ICogZTMgKiBNYXRoLmNvcyg2ICogcGhpKSk7XG4gICAgcGhpICs9IGRwaGk7XG4gICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IDAuMDAwMDAwMDAwMSkge1xuICAgICAgcmV0dXJuIHBoaTtcbiAgICB9XG4gIH1cblxuICAvLy4ucmVwb3J0RXJyb3IoXCJJTUxGTi1DT05WOkxhdGl0dWRlIGZhaWxlZCB0byBjb252ZXJnZSBhZnRlciAxNSBpdGVyYXRpb25zXCIpO1xuICByZXR1cm4gTmFOO1xufSIsImltcG9ydCBtbGZuIGZyb20gJy4uL2NvbW1vbi9tbGZuJztcbmltcG9ydCBlMGZuIGZyb20gJy4uL2NvbW1vbi9lMGZuJztcbmltcG9ydCBlMWZuIGZyb20gJy4uL2NvbW1vbi9lMWZuJztcbmltcG9ydCBlMmZuIGZyb20gJy4uL2NvbW1vbi9lMmZuJztcbmltcG9ydCBlM2ZuIGZyb20gJy4uL2NvbW1vbi9lM2ZuJztcbmltcG9ydCBnTiBmcm9tICcuLi9jb21tb24vZ04nO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IGFkanVzdF9sYXQgZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sYXQnO1xuaW1wb3J0IGltbGZuIGZyb20gJy4uL2NvbW1vbi9pbWxmbic7XG5pbXBvcnQge0hBTEZfUEksIEVQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIGlmICghdGhpcy5zcGhlcmUpIHtcbiAgICB0aGlzLmUwID0gZTBmbih0aGlzLmVzKTtcbiAgICB0aGlzLmUxID0gZTFmbih0aGlzLmVzKTtcbiAgICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgICB0aGlzLmUzID0gZTNmbih0aGlzLmVzKTtcbiAgICB0aGlzLm1sMCA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQwKTtcbiAgfVxufVxuXG4vKiBDYXNzaW5pIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG5cbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdmFyIHgsIHk7XG4gIHZhciBsYW0gPSBwLng7XG4gIHZhciBwaGkgPSBwLnk7XG4gIGxhbSA9IGFkanVzdF9sb24obGFtIC0gdGhpcy5sb25nMCk7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgeCA9IHRoaXMuYSAqIE1hdGguYXNpbihNYXRoLmNvcyhwaGkpICogTWF0aC5zaW4obGFtKSk7XG4gICAgeSA9IHRoaXMuYSAqIChNYXRoLmF0YW4yKE1hdGgudGFuKHBoaSksIE1hdGguY29zKGxhbSkpIC0gdGhpcy5sYXQwKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvL2VsbGlwc29pZFxuICAgIHZhciBzaW5waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgIHZhciBjb3NwaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIHZhciBubCA9IGdOKHRoaXMuYSwgdGhpcy5lLCBzaW5waGkpO1xuICAgIHZhciB0bCA9IE1hdGgudGFuKHBoaSkgKiBNYXRoLnRhbihwaGkpO1xuICAgIHZhciBhbCA9IGxhbSAqIE1hdGguY29zKHBoaSk7XG4gICAgdmFyIGFzcSA9IGFsICogYWw7XG4gICAgdmFyIGNsID0gdGhpcy5lcyAqIGNvc3BoaSAqIGNvc3BoaSAvICgxIC0gdGhpcy5lcyk7XG4gICAgdmFyIG1sID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBwaGkpO1xuXG4gICAgeCA9IG5sICogYWwgKiAoMSAtIGFzcSAqIHRsICogKDEgLyA2IC0gKDggLSB0bCArIDggKiBjbCkgKiBhc3EgLyAxMjApKTtcbiAgICB5ID0gbWwgLSB0aGlzLm1sMCArIG5sICogc2lucGhpIC8gY29zcGhpICogYXNxICogKDAuNSArICg1IC0gdGwgKyA2ICogY2wpICogYXNxIC8gMjQpO1xuXG5cbiAgfVxuXG4gIHAueCA9IHggKyB0aGlzLngwO1xuICBwLnkgPSB5ICsgdGhpcy55MDtcbiAgcmV0dXJuIHA7XG59XG5cbi8qIEludmVyc2UgZXF1YXRpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgeCA9IHAueCAvIHRoaXMuYTtcbiAgdmFyIHkgPSBwLnkgLyB0aGlzLmE7XG4gIHZhciBwaGksIGxhbTtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICB2YXIgZGQgPSB5ICsgdGhpcy5sYXQwO1xuICAgIHBoaSA9IE1hdGguYXNpbihNYXRoLnNpbihkZCkgKiBNYXRoLmNvcyh4KSk7XG4gICAgbGFtID0gTWF0aC5hdGFuMihNYXRoLnRhbih4KSwgTWF0aC5jb3MoZGQpKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvKiBlbGxpcHNvaWQgKi9cbiAgICB2YXIgbWwxID0gdGhpcy5tbDAgLyB0aGlzLmEgKyB5O1xuICAgIHZhciBwaGkxID0gaW1sZm4obWwxLCB0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMocGhpMSkgLSBIQUxGX1BJKSA8PSBFUFNMTikge1xuICAgICAgcC54ID0gdGhpcy5sb25nMDtcbiAgICAgIHAueSA9IEhBTEZfUEk7XG4gICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgcC55ICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHZhciBubDEgPSBnTih0aGlzLmEsIHRoaXMuZSwgTWF0aC5zaW4ocGhpMSkpO1xuXG4gICAgdmFyIHJsMSA9IG5sMSAqIG5sMSAqIG5sMSAvIHRoaXMuYSAvIHRoaXMuYSAqICgxIC0gdGhpcy5lcyk7XG4gICAgdmFyIHRsMSA9IE1hdGgucG93KE1hdGgudGFuKHBoaTEpLCAyKTtcbiAgICB2YXIgZGwgPSB4ICogdGhpcy5hIC8gbmwxO1xuICAgIHZhciBkc3EgPSBkbCAqIGRsO1xuICAgIHBoaSA9IHBoaTEgLSBubDEgKiBNYXRoLnRhbihwaGkxKSAvIHJsMSAqIGRsICogZGwgKiAoMC41IC0gKDEgKyAzICogdGwxKSAqIGRsICogZGwgLyAyNCk7XG4gICAgbGFtID0gZGwgKiAoMSAtIGRzcSAqICh0bDEgLyAzICsgKDEgKyAzICogdGwxKSAqIHRsMSAqIGRzcSAvIDE1KSkgLyBNYXRoLmNvcyhwaGkxKTtcblxuICB9XG5cbiAgcC54ID0gYWRqdXN0X2xvbihsYW0gKyB0aGlzLmxvbmcwKTtcbiAgcC55ID0gYWRqdXN0X2xhdChwaGkpO1xuICByZXR1cm4gcDtcblxufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiQ2Fzc2luaVwiLCBcIkNhc3NpbmlfU29sZG5lclwiLCBcImNhc3NcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGVjY2VudCwgc2lucGhpKSB7XG4gIHZhciBjb247XG4gIGlmIChlY2NlbnQgPiAxLjBlLTcpIHtcbiAgICBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gICAgcmV0dXJuICgoMSAtIGVjY2VudCAqIGVjY2VudCkgKiAoc2lucGhpIC8gKDEgLSBjb24gKiBjb24pIC0gKDAuNSAvIGVjY2VudCkgKiBNYXRoLmxvZygoMSAtIGNvbikgLyAoMSArIGNvbikpKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuICgyICogc2lucGhpKTtcbiAgfVxufSIsIlxuaW1wb3J0IHtIQUxGX1BJLCBFUFNMTiwgRk9SVFBJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuaW1wb3J0IHFzZm56IGZyb20gJy4uL2NvbW1vbi9xc2Zueic7XG5pbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5cbi8qXG4gIHJlZmVyZW5jZVxuICAgIFwiTmV3IEVxdWFsLUFyZWEgTWFwIFByb2plY3Rpb25zIGZvciBOb25jaXJjdWxhciBSZWdpb25zXCIsIEpvaG4gUC4gU255ZGVyLFxuICAgIFRoZSBBbWVyaWNhbiBDYXJ0b2dyYXBoZXIsIFZvbCAxNSwgTm8uIDQsIE9jdG9iZXIgMTk4OCwgcHAuIDM0MS0zNTUuXG4gICovXG5cbmV4cG9ydCB2YXIgU19QT0xFID0gMTtcblxuZXhwb3J0IHZhciBOX1BPTEUgPSAyO1xuZXhwb3J0IHZhciBFUVVJVCA9IDM7XG5leHBvcnQgdmFyIE9CTElRID0gNDtcblxuLyogSW5pdGlhbGl6ZSB0aGUgTGFtYmVydCBBemltdXRoYWwgRXF1YWwgQXJlYSBwcm9qZWN0aW9uXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgdmFyIHQgPSBNYXRoLmFicyh0aGlzLmxhdDApO1xuICBpZiAoTWF0aC5hYnModCAtIEhBTEZfUEkpIDwgRVBTTE4pIHtcbiAgICB0aGlzLm1vZGUgPSB0aGlzLmxhdDAgPCAwID8gdGhpcy5TX1BPTEUgOiB0aGlzLk5fUE9MRTtcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyh0KSA8IEVQU0xOKSB7XG4gICAgdGhpcy5tb2RlID0gdGhpcy5FUVVJVDtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm1vZGUgPSB0aGlzLk9CTElRO1xuICB9XG4gIGlmICh0aGlzLmVzID4gMCkge1xuICAgIHZhciBzaW5waGk7XG5cbiAgICB0aGlzLnFwID0gcXNmbnoodGhpcy5lLCAxKTtcbiAgICB0aGlzLm1tZiA9IDAuNSAvICgxIC0gdGhpcy5lcyk7XG4gICAgdGhpcy5hcGEgPSBhdXRoc2V0KHRoaXMuZXMpO1xuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSB0aGlzLk5fUE9MRTpcbiAgICAgIHRoaXMuZGQgPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLlNfUE9MRTpcbiAgICAgIHRoaXMuZGQgPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLkVRVUlUOlxuICAgICAgdGhpcy5ycSA9IE1hdGguc3FydCgwLjUgKiB0aGlzLnFwKTtcbiAgICAgIHRoaXMuZGQgPSAxIC8gdGhpcy5ycTtcbiAgICAgIHRoaXMueG1mID0gMTtcbiAgICAgIHRoaXMueW1mID0gMC41ICogdGhpcy5xcDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5PQkxJUTpcbiAgICAgIHRoaXMucnEgPSBNYXRoLnNxcnQoMC41ICogdGhpcy5xcCk7XG4gICAgICBzaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICAgICAgdGhpcy5zaW5iMSA9IHFzZm56KHRoaXMuZSwgc2lucGhpKSAvIHRoaXMucXA7XG4gICAgICB0aGlzLmNvc2IxID0gTWF0aC5zcXJ0KDEgLSB0aGlzLnNpbmIxICogdGhpcy5zaW5iMSk7XG4gICAgICB0aGlzLmRkID0gTWF0aC5jb3ModGhpcy5sYXQwKSAvIChNYXRoLnNxcnQoMSAtIHRoaXMuZXMgKiBzaW5waGkgKiBzaW5waGkpICogdGhpcy5ycSAqIHRoaXMuY29zYjEpO1xuICAgICAgdGhpcy55bWYgPSAodGhpcy54bWYgPSB0aGlzLnJxKSAvIHRoaXMuZGQ7XG4gICAgICB0aGlzLnhtZiAqPSB0aGlzLmRkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEpIHtcbiAgICAgIHRoaXMuc2lucGgwID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgICAgIHRoaXMuY29zcGgwID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgICB9XG4gIH1cbn1cblxuLyogTGFtYmVydCBBemltdXRoYWwgRXF1YWwgQXJlYSBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuXG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciB4LCB5LCBjb3NsYW0sIHNpbmxhbSwgc2lucGhpLCBxLCBzaW5iLCBjb3NiLCBiLCBjb3NwaGk7XG4gIHZhciBsYW0gPSBwLng7XG4gIHZhciBwaGkgPSBwLnk7XG5cbiAgbGFtID0gYWRqdXN0X2xvbihsYW0gLSB0aGlzLmxvbmcwKTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBjb3NwaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvc2xhbSA9IE1hdGguY29zKGxhbSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpIHtcbiAgICAgIHkgPSAodGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSA/IDEgKyBjb3NwaGkgKiBjb3NsYW0gOiAxICsgdGhpcy5zaW5waDAgKiBzaW5waGkgKyB0aGlzLmNvc3BoMCAqIGNvc3BoaSAqIGNvc2xhbTtcbiAgICAgIGlmICh5IDw9IEVQU0xOKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgeSA9IE1hdGguc3FydCgyIC8geSk7XG4gICAgICB4ID0geSAqIGNvc3BoaSAqIE1hdGguc2luKGxhbSk7XG4gICAgICB5ICo9ICh0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpID8gc2lucGhpIDogdGhpcy5jb3NwaDAgKiBzaW5waGkgLSB0aGlzLnNpbnBoMCAqIGNvc3BoaSAqIGNvc2xhbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSB7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSkge1xuICAgICAgICBjb3NsYW0gPSAtY29zbGFtO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHBoaSArIHRoaXMubGF0MCkgPCBFUFNMTikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHkgPSBGT1JUUEkgLSBwaGkgKiAwLjU7XG4gICAgICB5ID0gMiAqICgodGhpcy5tb2RlID09PSB0aGlzLlNfUE9MRSkgPyBNYXRoLmNvcyh5KSA6IE1hdGguc2luKHkpKTtcbiAgICAgIHggPSB5ICogTWF0aC5zaW4obGFtKTtcbiAgICAgIHkgKj0gY29zbGFtO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBzaW5iID0gMDtcbiAgICBjb3NiID0gMDtcbiAgICBiID0gMDtcbiAgICBjb3NsYW0gPSBNYXRoLmNvcyhsYW0pO1xuICAgIHNpbmxhbSA9IE1hdGguc2luKGxhbSk7XG4gICAgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBxID0gcXNmbnoodGhpcy5lLCBzaW5waGkpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG4gICAgICBzaW5iID0gcSAvIHRoaXMucXA7XG4gICAgICBjb3NiID0gTWF0aC5zcXJ0KDEgLSBzaW5iICogc2luYik7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSB0aGlzLk9CTElROlxuICAgICAgYiA9IDEgKyB0aGlzLnNpbmIxICogc2luYiArIHRoaXMuY29zYjEgKiBjb3NiICogY29zbGFtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLkVRVUlUOlxuICAgICAgYiA9IDEgKyBjb3NiICogY29zbGFtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLk5fUE9MRTpcbiAgICAgIGIgPSBIQUxGX1BJICsgcGhpO1xuICAgICAgcSA9IHRoaXMucXAgLSBxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLlNfUE9MRTpcbiAgICAgIGIgPSBwaGkgLSBIQUxGX1BJO1xuICAgICAgcSA9IHRoaXMucXAgKyBxO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhiKSA8IEVQU0xOKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIHRoaXMuT0JMSVE6XG4gICAgY2FzZSB0aGlzLkVRVUlUOlxuICAgICAgYiA9IE1hdGguc3FydCgyIC8gYik7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRKSB7XG4gICAgICAgIHkgPSB0aGlzLnltZiAqIGIgKiAodGhpcy5jb3NiMSAqIHNpbmIgLSB0aGlzLnNpbmIxICogY29zYiAqIGNvc2xhbSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeSA9IChiID0gTWF0aC5zcXJ0KDIgLyAoMSArIGNvc2IgKiBjb3NsYW0pKSkgKiBzaW5iICogdGhpcy55bWY7XG4gICAgICB9XG4gICAgICB4ID0gdGhpcy54bWYgKiBiICogY29zYiAqIHNpbmxhbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5OX1BPTEU6XG4gICAgY2FzZSB0aGlzLlNfUE9MRTpcbiAgICAgIGlmIChxID49IDApIHtcbiAgICAgICAgeCA9IChiID0gTWF0aC5zcXJ0KHEpKSAqIHNpbmxhbTtcbiAgICAgICAgeSA9IGNvc2xhbSAqICgodGhpcy5tb2RlID09PSB0aGlzLlNfUE9MRSkgPyBiIDogLWIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHggPSB5ID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHAueCA9IHRoaXMuYSAqIHggKyB0aGlzLngwO1xuICBwLnkgPSB0aGlzLmEgKiB5ICsgdGhpcy55MDtcbiAgcmV0dXJuIHA7XG59XG5cbi8qIEludmVyc2UgZXF1YXRpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgeCA9IHAueCAvIHRoaXMuYTtcbiAgdmFyIHkgPSBwLnkgLyB0aGlzLmE7XG4gIHZhciBsYW0sIHBoaSwgY0NlLCBzQ2UsIHEsIHJobywgYWI7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHZhciBjb3N6ID0gMCxcbiAgICAgIHJoLCBzaW56ID0gMDtcblxuICAgIHJoID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIHBoaSA9IHJoICogMC41O1xuICAgIGlmIChwaGkgPiAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGhpID0gMiAqIE1hdGguYXNpbihwaGkpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG4gICAgICBzaW56ID0gTWF0aC5zaW4ocGhpKTtcbiAgICAgIGNvc3ogPSBNYXRoLmNvcyhwaGkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgdGhpcy5FUVVJVDpcbiAgICAgIHBoaSA9IChNYXRoLmFicyhyaCkgPD0gRVBTTE4pID8gMCA6IE1hdGguYXNpbih5ICogc2lueiAvIHJoKTtcbiAgICAgIHggKj0gc2luejtcbiAgICAgIHkgPSBjb3N6ICogcmg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuT0JMSVE6XG4gICAgICBwaGkgPSAoTWF0aC5hYnMocmgpIDw9IEVQU0xOKSA/IHRoaXMubGF0MCA6IE1hdGguYXNpbihjb3N6ICogdGhpcy5zaW5waDAgKyB5ICogc2lueiAqIHRoaXMuY29zcGgwIC8gcmgpO1xuICAgICAgeCAqPSBzaW56ICogdGhpcy5jb3NwaDA7XG4gICAgICB5ID0gKGNvc3ogLSBNYXRoLnNpbihwaGkpICogdGhpcy5zaW5waDApICogcmg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuTl9QT0xFOlxuICAgICAgeSA9IC15O1xuICAgICAgcGhpID0gSEFMRl9QSSAtIHBoaTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5TX1BPTEU6XG4gICAgICBwaGkgLT0gSEFMRl9QSTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsYW0gPSAoeSA9PT0gMCAmJiAodGhpcy5tb2RlID09PSB0aGlzLkVRVUlUIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSkpID8gMCA6IE1hdGguYXRhbjIoeCwgeSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgYWIgPSAwO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG4gICAgICB4IC89IHRoaXMuZGQ7XG4gICAgICB5ICo9IHRoaXMuZGQ7XG4gICAgICByaG8gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICBpZiAocmhvIDwgRVBTTE4pIHtcbiAgICAgICAgcC54ID0gdGhpcy5sb25nMDtcbiAgICAgICAgcC55ID0gdGhpcy5sYXQwO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICAgIHNDZSA9IDIgKiBNYXRoLmFzaW4oMC41ICogcmhvIC8gdGhpcy5ycSk7XG4gICAgICBjQ2UgPSBNYXRoLmNvcyhzQ2UpO1xuICAgICAgeCAqPSAoc0NlID0gTWF0aC5zaW4oc0NlKSk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRKSB7XG4gICAgICAgIGFiID0gY0NlICogdGhpcy5zaW5iMSArIHkgKiBzQ2UgKiB0aGlzLmNvc2IxIC8gcmhvO1xuICAgICAgICBxID0gdGhpcy5xcCAqIGFiO1xuICAgICAgICB5ID0gcmhvICogdGhpcy5jb3NiMSAqIGNDZSAtIHkgKiB0aGlzLnNpbmIxICogc0NlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFiID0geSAqIHNDZSAvIHJobztcbiAgICAgICAgcSA9IHRoaXMucXAgKiBhYjtcbiAgICAgICAgeSA9IHJobyAqIGNDZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSB7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSkge1xuICAgICAgICB5ID0gLXk7XG4gICAgICB9XG4gICAgICBxID0gKHggKiB4ICsgeSAqIHkpO1xuICAgICAgaWYgKCFxKSB7XG4gICAgICAgIHAueCA9IHRoaXMubG9uZzA7XG4gICAgICAgIHAueSA9IHRoaXMubGF0MDtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG4gICAgICBhYiA9IDEgLSBxIC8gdGhpcy5xcDtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSB7XG4gICAgICAgIGFiID0gLWFiO1xuICAgICAgfVxuICAgIH1cbiAgICBsYW0gPSBNYXRoLmF0YW4yKHgsIHkpO1xuICAgIHBoaSA9IGF1dGhsYXQoTWF0aC5hc2luKGFiKSwgdGhpcy5hcGEpO1xuICB9XG5cbiAgcC54ID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgbGFtKTtcbiAgcC55ID0gcGhpO1xuICByZXR1cm4gcDtcbn1cblxuLyogZGV0ZXJtaW5lIGxhdGl0dWRlIGZyb20gYXV0aGFsaWMgbGF0aXR1ZGUgKi9cbnZhciBQMDAgPSAwLjMzMzMzMzMzMzMzMzMzMzMzMzMzO1xuXG52YXIgUDAxID0gMC4xNzIyMjIyMjIyMjIyMjIyMjIyMjtcbnZhciBQMDIgPSAwLjEwMjU3OTM2NTA3OTM2NTA3OTM2O1xudmFyIFAxMCA9IDAuMDYzODg4ODg4ODg4ODg4ODg4ODg7XG52YXIgUDExID0gMC4wNjY0MDIxMTY0MDIxMTY0MDIxMTtcbnZhciBQMjAgPSAwLjAxNjQxNTAxMjk0MjE5MTU0NDQzO1xuXG5mdW5jdGlvbiBhdXRoc2V0KGVzKSB7XG4gIHZhciB0O1xuICB2YXIgQVBBID0gW107XG4gIEFQQVswXSA9IGVzICogUDAwO1xuICB0ID0gZXMgKiBlcztcbiAgQVBBWzBdICs9IHQgKiBQMDE7XG4gIEFQQVsxXSA9IHQgKiBQMTA7XG4gIHQgKj0gZXM7XG4gIEFQQVswXSArPSB0ICogUDAyO1xuICBBUEFbMV0gKz0gdCAqIFAxMTtcbiAgQVBBWzJdID0gdCAqIFAyMDtcbiAgcmV0dXJuIEFQQTtcbn1cblxuZnVuY3Rpb24gYXV0aGxhdChiZXRhLCBBUEEpIHtcbiAgdmFyIHQgPSBiZXRhICsgYmV0YTtcbiAgcmV0dXJuIChiZXRhICsgQVBBWzBdICogTWF0aC5zaW4odCkgKyBBUEFbMV0gKiBNYXRoLnNpbih0ICsgdCkgKyBBUEFbMl0gKiBNYXRoLnNpbih0ICsgdCArIHQpKTtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIkxhbWJlcnQgQXppbXV0aGFsIEVxdWFsIEFyZWFcIiwgXCJMYW1iZXJ0X0F6aW11dGhhbF9FcXVhbF9BcmVhXCIsIFwibGFlYVwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzLFxuICBTX1BPTEU6IFNfUE9MRSxcbiAgTl9QT0xFOiBOX1BPTEUsXG4gIEVRVUlUOiBFUVVJVCxcbiAgT0JMSVE6IE9CTElRXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICBpZiAoTWF0aC5hYnMoeCkgPiAxKSB7XG4gICAgeCA9ICh4ID4gMSkgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIE1hdGguYXNpbih4KTtcbn0iLCJpbXBvcnQgbXNmbnogZnJvbSAnLi4vY29tbW9uL21zZm56JztcbmltcG9ydCBxc2ZueiBmcm9tICcuLi9jb21tb24vcXNmbnonO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IGFzaW56IGZyb20gJy4uL2NvbW1vbi9hc2lueic7XG5pbXBvcnQge0VQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSArIHRoaXMubGF0MikgPCBFUFNMTikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnRlbXAgPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZXMgPSAxIC0gTWF0aC5wb3codGhpcy50ZW1wLCAyKTtcbiAgdGhpcy5lMyA9IE1hdGguc3FydCh0aGlzLmVzKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0MSk7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQxKTtcbiAgdGhpcy50MSA9IHRoaXMuc2luX3BvO1xuICB0aGlzLmNvbiA9IHRoaXMuc2luX3BvO1xuICB0aGlzLm1zMSA9IG1zZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG4gIHRoaXMucXMxID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0Mik7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcbiAgdGhpcy50MiA9IHRoaXMuc2luX3BvO1xuICB0aGlzLm1zMiA9IG1zZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG4gIHRoaXMucXMyID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgdGhpcy50MyA9IHRoaXMuc2luX3BvO1xuICB0aGlzLnFzMCA9IHFzZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSAtIHRoaXMubGF0MikgPiBFUFNMTikge1xuICAgIHRoaXMubnMwID0gKHRoaXMubXMxICogdGhpcy5tczEgLSB0aGlzLm1zMiAqIHRoaXMubXMyKSAvICh0aGlzLnFzMiAtIHRoaXMucXMxKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm5zMCA9IHRoaXMuY29uO1xuICB9XG4gIHRoaXMuYyA9IHRoaXMubXMxICogdGhpcy5tczEgKyB0aGlzLm5zMCAqIHRoaXMucXMxO1xuICB0aGlzLnJoID0gdGhpcy5hICogTWF0aC5zcXJ0KHRoaXMuYyAtIHRoaXMubnMwICogdGhpcy5xczApIC8gdGhpcy5uczA7XG59XG5cbi8qIEFsYmVycyBDb25pY2FsIEVxdWFsIEFyZWEgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuXG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgdGhpcy5zaW5fcGhpID0gTWF0aC5zaW4obGF0KTtcbiAgdGhpcy5jb3NfcGhpID0gTWF0aC5jb3MobGF0KTtcblxuICB2YXIgcXMgPSBxc2Zueih0aGlzLmUzLCB0aGlzLnNpbl9waGksIHRoaXMuY29zX3BoaSk7XG4gIHZhciByaDEgPSB0aGlzLmEgKiBNYXRoLnNxcnQodGhpcy5jIC0gdGhpcy5uczAgKiBxcykgLyB0aGlzLm5zMDtcbiAgdmFyIHRoZXRhID0gdGhpcy5uczAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgeCA9IHJoMSAqIE1hdGguc2luKHRoZXRhKSArIHRoaXMueDA7XG4gIHZhciB5ID0gdGhpcy5yaCAtIHJoMSAqIE1hdGguY29zKHRoZXRhKSArIHRoaXMueTA7XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIHJoMSwgcXMsIGNvbiwgdGhldGEsIGxvbiwgbGF0O1xuXG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgPSB0aGlzLnJoIC0gcC55ICsgdGhpcy55MDtcbiAgaWYgKHRoaXMubnMwID49IDApIHtcbiAgICByaDEgPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBjb24gPSAxO1xuICB9XG4gIGVsc2Uge1xuICAgIHJoMSA9IC1NYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBjb24gPSAtMTtcbiAgfVxuICB0aGV0YSA9IDA7XG4gIGlmIChyaDEgIT09IDApIHtcbiAgICB0aGV0YSA9IE1hdGguYXRhbjIoY29uICogcC54LCBjb24gKiBwLnkpO1xuICB9XG4gIGNvbiA9IHJoMSAqIHRoaXMubnMwIC8gdGhpcy5hO1xuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBsYXQgPSBNYXRoLmFzaW4oKHRoaXMuYyAtIGNvbiAqIGNvbikgLyAoMiAqIHRoaXMubnMwKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcXMgPSAodGhpcy5jIC0gY29uICogY29uKSAvIHRoaXMubnMwO1xuICAgIGxhdCA9IHRoaXMucGhpMXoodGhpcy5lMywgcXMpO1xuICB9XG5cbiAgbG9uID0gYWRqdXN0X2xvbih0aGV0YSAvIHRoaXMubnMwICsgdGhpcy5sb25nMCk7XG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn1cblxuLyogRnVuY3Rpb24gdG8gY29tcHV0ZSBwaGkxLCB0aGUgbGF0aXR1ZGUgZm9yIHRoZSBpbnZlcnNlIG9mIHRoZVxuICAgQWxiZXJzIENvbmljYWwgRXF1YWwtQXJlYSBwcm9qZWN0aW9uLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gcGhpMXooZWNjZW50LCBxcykge1xuICB2YXIgc2lucGhpLCBjb3NwaGksIGNvbiwgY29tLCBkcGhpO1xuICB2YXIgcGhpID0gYXNpbnooMC41ICogcXMpO1xuICBpZiAoZWNjZW50IDwgRVBTTE4pIHtcbiAgICByZXR1cm4gcGhpO1xuICB9XG5cbiAgdmFyIGVjY250cyA9IGVjY2VudCAqIGVjY2VudDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMjU7IGkrKykge1xuICAgIHNpbnBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgY29zcGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gICAgY29tID0gMSAtIGNvbiAqIGNvbjtcbiAgICBkcGhpID0gMC41ICogY29tICogY29tIC8gY29zcGhpICogKHFzIC8gKDEgLSBlY2NudHMpIC0gc2lucGhpIC8gY29tICsgMC41IC8gZWNjZW50ICogTWF0aC5sb2coKDEgLSBjb24pIC8gKDEgKyBjb24pKSk7XG4gICAgcGhpID0gcGhpICsgZHBoaTtcbiAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gMWUtNykge1xuICAgICAgcmV0dXJuIHBoaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJBbGJlcnNfQ29uaWNfRXF1YWxfQXJlYVwiLCBcIkFsYmVyc1wiLCBcImFlYVwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzLFxuICBwaGkxejogcGhpMXpcbn07XG4iLCJpbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5pbXBvcnQgYXNpbnogZnJvbSAnLi4vY29tbW9uL2FzaW56JztcbmltcG9ydCB7RVBTTE59IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG4vKlxuICByZWZlcmVuY2U6XG4gICAgV29sZnJhbSBNYXRod29ybGQgXCJHbm9tb25pYyBQcm9qZWN0aW9uXCJcbiAgICBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0dub21vbmljUHJvamVjdGlvbi5odG1sXG4gICAgQWNjZXNzZWQ6IDEydGggTm92ZW1iZXIgMjAwOVxuICAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG5cbiAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIHRoaXMuc2luX3AxNCA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHRoaXMuY29zX3AxNCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gIC8vIEFwcHJveGltYXRpb24gZm9yIHByb2plY3RpbmcgcG9pbnRzIHRvIHRoZSBob3Jpem9uIChpbmZpbml0eSlcbiAgdGhpcy5pbmZpbml0eV9kaXN0ID0gMTAwMCAqIHRoaXMuYTtcbiAgdGhpcy5yYyA9IDE7XG59XG5cbi8qIEdub21vbmljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBzaW5waGksIGNvc3BoaTsgLyogc2luIGFuZCBjb3MgdmFsdWUgICAgICAgICovXG4gIHZhciBkbG9uOyAvKiBkZWx0YSBsb25naXR1ZGUgdmFsdWUgICAgICAqL1xuICB2YXIgY29zbG9uOyAvKiBjb3Mgb2YgbG9uZ2l0dWRlICAgICAgICAqL1xuICB2YXIga3NwOyAvKiBzY2FsZSBmYWN0b3IgICAgICAgICAgKi9cbiAgdmFyIGc7XG4gIHZhciB4LCB5O1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblxuICBzaW5waGkgPSBNYXRoLnNpbihsYXQpO1xuICBjb3NwaGkgPSBNYXRoLmNvcyhsYXQpO1xuXG4gIGNvc2xvbiA9IE1hdGguY29zKGRsb24pO1xuICBnID0gdGhpcy5zaW5fcDE0ICogc2lucGhpICsgdGhpcy5jb3NfcDE0ICogY29zcGhpICogY29zbG9uO1xuICBrc3AgPSAxO1xuICBpZiAoKGcgPiAwKSB8fCAoTWF0aC5hYnMoZykgPD0gRVBTTE4pKSB7XG4gICAgeCA9IHRoaXMueDAgKyB0aGlzLmEgKiBrc3AgKiBjb3NwaGkgKiBNYXRoLnNpbihkbG9uKSAvIGc7XG4gICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiBrc3AgKiAodGhpcy5jb3NfcDE0ICogc2lucGhpIC0gdGhpcy5zaW5fcDE0ICogY29zcGhpICogY29zbG9uKSAvIGc7XG4gIH1cbiAgZWxzZSB7XG5cbiAgICAvLyBQb2ludCBpcyBpbiB0aGUgb3Bwb3NpbmcgaGVtaXNwaGVyZSBhbmQgaXMgdW5wcm9qZWN0YWJsZVxuICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gcmV0dXJuIGEgcmVhc29uYWJsZSBwb2ludCwgc28gd2UgcHJvamVjdFxuICAgIC8vIHRvIGluZmluaXR5LCBvbiBhIGJlYXJpbmdcbiAgICAvLyBlcXVpdmFsZW50IHRvIHRoZSBub3J0aGVybiBoZW1pc3BoZXJlIGVxdWl2YWxlbnRcbiAgICAvLyBUaGlzIGlzIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uIGZvciBzaG9ydCBzaGFwZXMgYW5kIGxpbmVzIHRoYXRcbiAgICAvLyBzdHJhZGRsZSB0aGUgaG9yaXpvbi5cblxuICAgIHggPSB0aGlzLngwICsgdGhpcy5pbmZpbml0eV9kaXN0ICogY29zcGhpICogTWF0aC5zaW4oZGxvbik7XG4gICAgeSA9IHRoaXMueTAgKyB0aGlzLmluZmluaXR5X2Rpc3QgKiAodGhpcy5jb3NfcDE0ICogc2lucGhpIC0gdGhpcy5zaW5fcDE0ICogY29zcGhpICogY29zbG9uKTtcblxuICB9XG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHZhciByaDsgLyogUmhvICovXG4gIHZhciBzaW5jLCBjb3NjO1xuICB2YXIgYztcbiAgdmFyIGxvbiwgbGF0O1xuXG4gIC8qIEludmVyc2UgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHAueCA9IChwLnggLSB0aGlzLngwKSAvIHRoaXMuYTtcbiAgcC55ID0gKHAueSAtIHRoaXMueTApIC8gdGhpcy5hO1xuXG4gIHAueCAvPSB0aGlzLmswO1xuICBwLnkgLz0gdGhpcy5rMDtcblxuICBpZiAoKHJoID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSkpKSB7XG4gICAgYyA9IE1hdGguYXRhbjIocmgsIHRoaXMucmMpO1xuICAgIHNpbmMgPSBNYXRoLnNpbihjKTtcbiAgICBjb3NjID0gTWF0aC5jb3MoYyk7XG5cbiAgICBsYXQgPSBhc2lueihjb3NjICogdGhpcy5zaW5fcDE0ICsgKHAueSAqIHNpbmMgKiB0aGlzLmNvc19wMTQpIC8gcmgpO1xuICAgIGxvbiA9IE1hdGguYXRhbjIocC54ICogc2luYywgcmggKiB0aGlzLmNvc19wMTQgKiBjb3NjIC0gcC55ICogdGhpcy5zaW5fcDE0ICogc2luYyk7XG4gICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgbG9uKTtcbiAgfVxuICBlbHNlIHtcbiAgICBsYXQgPSB0aGlzLnBoaWMwO1xuICAgIGxvbiA9IDA7XG4gIH1cblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJnbm9tXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQge0hBTEZfUEl9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlY2NlbnQsIHEpIHtcbiAgdmFyIHRlbXAgPSAxIC0gKDEgLSBlY2NlbnQgKiBlY2NlbnQpIC8gKDIgKiBlY2NlbnQpICogTWF0aC5sb2coKDEgLSBlY2NlbnQpIC8gKDEgKyBlY2NlbnQpKTtcbiAgaWYgKE1hdGguYWJzKE1hdGguYWJzKHEpIC0gdGVtcCkgPCAxLjBFLTYpIHtcbiAgICBpZiAocSA8IDApIHtcbiAgICAgIHJldHVybiAoLTEgKiBIQUxGX1BJKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gSEFMRl9QSTtcbiAgICB9XG4gIH1cbiAgLy92YXIgcGhpID0gMC41KiBxLygxLWVjY2VudCplY2NlbnQpO1xuICB2YXIgcGhpID0gTWF0aC5hc2luKDAuNSAqIHEpO1xuICB2YXIgZHBoaTtcbiAgdmFyIHNpbl9waGk7XG4gIHZhciBjb3NfcGhpO1xuICB2YXIgY29uO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDMwOyBpKyspIHtcbiAgICBzaW5fcGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBjb3NfcGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICBjb24gPSBlY2NlbnQgKiBzaW5fcGhpO1xuICAgIGRwaGkgPSBNYXRoLnBvdygxIC0gY29uICogY29uLCAyKSAvICgyICogY29zX3BoaSkgKiAocSAvICgxIC0gZWNjZW50ICogZWNjZW50KSAtIHNpbl9waGkgLyAoMSAtIGNvbiAqIGNvbikgKyAwLjUgLyBlY2NlbnQgKiBNYXRoLmxvZygoMSAtIGNvbikgLyAoMSArIGNvbikpKTtcbiAgICBwaGkgKz0gZHBoaTtcbiAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gMC4wMDAwMDAwMDAxKSB7XG4gICAgICByZXR1cm4gcGhpO1xuICAgIH1cbiAgfVxuXG4gIC8vY29uc29sZS5sb2coXCJJUVNGTi1DT05WOkxhdGl0dWRlIGZhaWxlZCB0byBjb252ZXJnZSBhZnRlciAzMCBpdGVyYXRpb25zXCIpO1xuICByZXR1cm4gTmFOO1xufVxuIiwiaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IHFzZm56IGZyb20gJy4uL2NvbW1vbi9xc2Zueic7XG5pbXBvcnQgbXNmbnogZnJvbSAnLi4vY29tbW9uL21zZm56JztcbmltcG9ydCBpcXNmbnogZnJvbSAnLi4vY29tbW9uL2lxc2Zueic7XG5cbi8qXG4gIHJlZmVyZW5jZTpcbiAgICBcIkNhcnRvZ3JhcGhpYyBQcm9qZWN0aW9uIFByb2NlZHVyZXMgZm9yIHRoZSBVTklYIEVudmlyb25tZW50LVxuICAgIEEgVXNlcidzIE1hbnVhbFwiIGJ5IEdlcmFsZCBJLiBFdmVuZGVuLFxuICAgIFVTR1MgT3BlbiBGaWxlIFJlcG9ydCA5MC0yODRhbmQgUmVsZWFzZSA0IEludGVyaW0gUmVwb3J0cyAoMjAwMylcbiovXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgLy9uby1vcFxuICBpZiAoIXRoaXMuc3BoZXJlKSB7XG4gICAgdGhpcy5rMCA9IG1zZm56KHRoaXMuZSwgTWF0aC5zaW4odGhpcy5sYXRfdHMpLCBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuICB9XG59XG5cbi8qIEN5bGluZHJpY2FsIEVxdWFsIEFyZWEgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHgsIHk7XG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgeCA9IHRoaXMueDAgKyB0aGlzLmEgKiBkbG9uICogTWF0aC5jb3ModGhpcy5sYXRfdHMpO1xuICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICogTWF0aC5zaW4obGF0KSAvIE1hdGguY29zKHRoaXMubGF0X3RzKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgcXMgPSBxc2Zueih0aGlzLmUsIE1hdGguc2luKGxhdCkpO1xuICAgIHggPSB0aGlzLngwICsgdGhpcy5hICogdGhpcy5rMCAqIGRsb247XG4gICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiBxcyAqIDAuNSAvIHRoaXMuazA7XG4gIH1cblxuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn1cblxuLyogQ3lsaW5kcmljYWwgRXF1YWwgQXJlYSBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuICBwLnggLT0gdGhpcy54MDtcbiAgcC55IC09IHRoaXMueTA7XG4gIHZhciBsb24sIGxhdDtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAocC54IC8gdGhpcy5hKSAvIE1hdGguY29zKHRoaXMubGF0X3RzKSk7XG4gICAgbGF0ID0gTWF0aC5hc2luKChwLnkgLyB0aGlzLmEpICogTWF0aC5jb3ModGhpcy5sYXRfdHMpKTtcbiAgfVxuICBlbHNlIHtcbiAgICBsYXQgPSBpcXNmbnoodGhpcy5lLCAyICogcC55ICogdGhpcy5rMCAvIHRoaXMuYSk7XG4gICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgcC54IC8gKHRoaXMuYSAqIHRoaXMuazApKTtcbiAgfVxuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcImNlYVwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IGFkanVzdF9sYXQgZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sYXQnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcblxuICB0aGlzLngwID0gdGhpcy54MCB8fCAwO1xuICB0aGlzLnkwID0gdGhpcy55MCB8fCAwO1xuICB0aGlzLmxhdDAgPSB0aGlzLmxhdDAgfHwgMDtcbiAgdGhpcy5sb25nMCA9IHRoaXMubG9uZzAgfHwgMDtcbiAgdGhpcy5sYXRfdHMgPSB0aGlzLmxhdF90cyB8fCAwO1xuICB0aGlzLnRpdGxlID0gdGhpcy50aXRsZSB8fCBcIkVxdWlkaXN0YW50IEN5bGluZHJpY2FsIChQbGF0ZSBDYXJyZSlcIjtcblxuICB0aGlzLnJjID0gTWF0aC5jb3ModGhpcy5sYXRfdHMpO1xufVxuXG4vLyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG5cbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciBkbGF0ID0gYWRqdXN0X2xhdChsYXQgLSB0aGlzLmxhdDApO1xuICBwLnggPSB0aGlzLngwICsgKHRoaXMuYSAqIGRsb24gKiB0aGlzLnJjKTtcbiAgcC55ID0gdGhpcy55MCArICh0aGlzLmEgKiBkbGF0KTtcbiAgcmV0dXJuIHA7XG59XG5cbi8vIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcblxuICB2YXIgeCA9IHAueDtcbiAgdmFyIHkgPSBwLnk7XG5cbiAgcC54ID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgKCh4IC0gdGhpcy54MCkgLyAodGhpcy5hICogdGhpcy5yYykpKTtcbiAgcC55ID0gYWRqdXN0X2xhdCh0aGlzLmxhdDAgKyAoKHkgLSB0aGlzLnkwKSAvICh0aGlzLmEpKSk7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiRXF1aXJlY3Rhbmd1bGFyXCIsIFwiRXF1aWRpc3RhbnRfQ3lsaW5kcmljYWxcIiwgXCJlcWNcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCBlMGZuIGZyb20gJy4uL2NvbW1vbi9lMGZuJztcbmltcG9ydCBlMWZuIGZyb20gJy4uL2NvbW1vbi9lMWZuJztcbmltcG9ydCBlMmZuIGZyb20gJy4uL2NvbW1vbi9lMmZuJztcbmltcG9ydCBlM2ZuIGZyb20gJy4uL2NvbW1vbi9lM2ZuJztcbmltcG9ydCBhZGp1c3RfbG9uIGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbG9uJztcbmltcG9ydCBhZGp1c3RfbGF0IGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbGF0JztcbmltcG9ydCBtbGZuIGZyb20gJy4uL2NvbW1vbi9tbGZuJztcbmltcG9ydCB7RVBTTE59IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5pbXBvcnQgZ04gZnJvbSAnLi4vY29tbW9uL2dOJztcbnZhciBNQVhfSVRFUiA9IDIwO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIHRoaXMudGVtcCA9IHRoaXMuYiAvIHRoaXMuYTtcbiAgdGhpcy5lcyA9IDEgLSBNYXRoLnBvdyh0aGlzLnRlbXAsIDIpOyAvLyBkZXZhaXQgZXRyZSBkYW5zIHRtZXJjLmpzIG1haXMgbiB5IGVzdCBwYXMgZG9uYyBqZSBjb21tZW50ZSBzaW5vbiByZXRvdXIgZGUgdmFsZXVycyBudWxsZXNcbiAgdGhpcy5lID0gTWF0aC5zcXJ0KHRoaXMuZXMpO1xuICB0aGlzLmUwID0gZTBmbih0aGlzLmVzKTtcbiAgdGhpcy5lMSA9IGUxZm4odGhpcy5lcyk7XG4gIHRoaXMuZTIgPSBlMmZuKHRoaXMuZXMpO1xuICB0aGlzLmUzID0gZTNmbih0aGlzLmVzKTtcbiAgdGhpcy5tbDAgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIHRoaXMubGF0MCk7IC8vc2kgcXVlIGRlcyB6ZXJvcyBsZSBjYWxjdWwgbmUgc2UgZmFpdCBwYXNcbn1cblxuLyogUG9seWNvbmljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciB4LCB5LCBlbDtcbiAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICBlbCA9IGRsb24gKiBNYXRoLnNpbihsYXQpO1xuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBpZiAoTWF0aC5hYnMobGF0KSA8PSBFUFNMTikge1xuICAgICAgeCA9IHRoaXMuYSAqIGRsb247XG4gICAgICB5ID0gLTEgKiB0aGlzLmEgKiB0aGlzLmxhdDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgeCA9IHRoaXMuYSAqIE1hdGguc2luKGVsKSAvIE1hdGgudGFuKGxhdCk7XG4gICAgICB5ID0gdGhpcy5hICogKGFkanVzdF9sYXQobGF0IC0gdGhpcy5sYXQwKSArICgxIC0gTWF0aC5jb3MoZWwpKSAvIE1hdGgudGFuKGxhdCkpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoTWF0aC5hYnMobGF0KSA8PSBFUFNMTikge1xuICAgICAgeCA9IHRoaXMuYSAqIGRsb247XG4gICAgICB5ID0gLTEgKiB0aGlzLm1sMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmwgPSBnTih0aGlzLmEsIHRoaXMuZSwgTWF0aC5zaW4obGF0KSkgLyBNYXRoLnRhbihsYXQpO1xuICAgICAgeCA9IG5sICogTWF0aC5zaW4oZWwpO1xuICAgICAgeSA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgbGF0KSAtIHRoaXMubWwwICsgbmwgKiAoMSAtIE1hdGguY29zKGVsKSk7XG4gICAgfVxuXG4gIH1cbiAgcC54ID0geCArIHRoaXMueDA7XG4gIHAueSA9IHkgKyB0aGlzLnkwO1xuICByZXR1cm4gcDtcbn1cblxuLyogSW52ZXJzZSBlcXVhdGlvbnNcbiAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuICB2YXIgbG9uLCBsYXQsIHgsIHksIGk7XG4gIHZhciBhbCwgYmw7XG4gIHZhciBwaGksIGRwaGk7XG4gIHggPSBwLnggLSB0aGlzLngwO1xuICB5ID0gcC55IC0gdGhpcy55MDtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBpZiAoTWF0aC5hYnMoeSArIHRoaXMuYSAqIHRoaXMubGF0MCkgPD0gRVBTTE4pIHtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24oeCAvIHRoaXMuYSArIHRoaXMubG9uZzApO1xuICAgICAgbGF0ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhbCA9IHRoaXMubGF0MCArIHkgLyB0aGlzLmE7XG4gICAgICBibCA9IHggKiB4IC8gdGhpcy5hIC8gdGhpcy5hICsgYWwgKiBhbDtcbiAgICAgIHBoaSA9IGFsO1xuICAgICAgdmFyIHRhbnBoaTtcbiAgICAgIGZvciAoaSA9IE1BWF9JVEVSOyBpOyAtLWkpIHtcbiAgICAgICAgdGFucGhpID0gTWF0aC50YW4ocGhpKTtcbiAgICAgICAgZHBoaSA9IC0xICogKGFsICogKHBoaSAqIHRhbnBoaSArIDEpIC0gcGhpIC0gMC41ICogKHBoaSAqIHBoaSArIGJsKSAqIHRhbnBoaSkgLyAoKHBoaSAtIGFsKSAvIHRhbnBoaSAtIDEpO1xuICAgICAgICBwaGkgKz0gZHBoaTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IEVQU0xOKSB7XG4gICAgICAgICAgbGF0ID0gcGhpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAoTWF0aC5hc2luKHggKiBNYXRoLnRhbihwaGkpIC8gdGhpcy5hKSkgLyBNYXRoLnNpbihsYXQpKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKE1hdGguYWJzKHkgKyB0aGlzLm1sMCkgPD0gRVBTTE4pIHtcbiAgICAgIGxhdCA9IDA7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyB4IC8gdGhpcy5hKTtcbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIGFsID0gKHRoaXMubWwwICsgeSkgLyB0aGlzLmE7XG4gICAgICBibCA9IHggKiB4IC8gdGhpcy5hIC8gdGhpcy5hICsgYWwgKiBhbDtcbiAgICAgIHBoaSA9IGFsO1xuICAgICAgdmFyIGNsLCBtbG4sIG1sbnAsIG1hO1xuICAgICAgdmFyIGNvbjtcbiAgICAgIGZvciAoaSA9IE1BWF9JVEVSOyBpOyAtLWkpIHtcbiAgICAgICAgY29uID0gdGhpcy5lICogTWF0aC5zaW4ocGhpKTtcbiAgICAgICAgY2wgPSBNYXRoLnNxcnQoMSAtIGNvbiAqIGNvbikgKiBNYXRoLnRhbihwaGkpO1xuICAgICAgICBtbG4gPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIHBoaSk7XG4gICAgICAgIG1sbnAgPSB0aGlzLmUwIC0gMiAqIHRoaXMuZTEgKiBNYXRoLmNvcygyICogcGhpKSArIDQgKiB0aGlzLmUyICogTWF0aC5jb3MoNCAqIHBoaSkgLSA2ICogdGhpcy5lMyAqIE1hdGguY29zKDYgKiBwaGkpO1xuICAgICAgICBtYSA9IG1sbiAvIHRoaXMuYTtcbiAgICAgICAgZHBoaSA9IChhbCAqIChjbCAqIG1hICsgMSkgLSBtYSAtIDAuNSAqIGNsICogKG1hICogbWEgKyBibCkpIC8gKHRoaXMuZXMgKiBNYXRoLnNpbigyICogcGhpKSAqIChtYSAqIG1hICsgYmwgLSAyICogYWwgKiBtYSkgLyAoNCAqIGNsKSArIChhbCAtIG1hKSAqIChjbCAqIG1sbnAgLSAyIC8gTWF0aC5zaW4oMiAqIHBoaSkpIC0gbWxucCk7XG4gICAgICAgIHBoaSAtPSBkcGhpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gRVBTTE4pIHtcbiAgICAgICAgICBsYXQgPSBwaGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9sYXQ9cGhpNHoodGhpcy5lLHRoaXMuZTAsdGhpcy5lMSx0aGlzLmUyLHRoaXMuZTMsYWwsYmwsMCwwKTtcbiAgICAgIGNsID0gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzICogTWF0aC5wb3coTWF0aC5zaW4obGF0KSwgMikpICogTWF0aC50YW4obGF0KTtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXNpbih4ICogY2wgLyB0aGlzLmEpIC8gTWF0aC5zaW4obGF0KSk7XG4gICAgfVxuICB9XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiUG9seWNvbmljXCIsIFwicG9seVwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IHtTRUNfVE9fUkFEfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuLypcbiAgcmVmZXJlbmNlXG4gICAgRGVwYXJ0bWVudCBvZiBMYW5kIGFuZCBTdXJ2ZXkgVGVjaG5pY2FsIENpcmN1bGFyIDE5NzMvMzJcbiAgICAgIGh0dHA6Ly93d3cubGluei5nb3Z0Lm56L2RvY3MvbWlzY2VsbGFuZW91cy9uei1tYXAtZGVmaW5pdGlvbi5wZGZcbiAgICBPU0cgVGVjaG5pY2FsIFJlcG9ydCA0LjFcbiAgICAgIGh0dHA6Ly93d3cubGluei5nb3Z0Lm56L2RvY3MvbWlzY2VsbGFuZW91cy9uem1nLnBkZlxuICAqL1xuXG4vKipcbiAqIGl0ZXJhdGlvbnM6IE51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJlZmluZSBpbnZlcnNlIHRyYW5zZm9ybS5cbiAqICAgICAwIC0+IGttIGFjY3VyYWN5XG4gKiAgICAgMSAtPiBtIGFjY3VyYWN5IC0tIHN1aXRhYmxlIGZvciBtb3N0IG1hcHBpbmcgYXBwbGljYXRpb25zXG4gKiAgICAgMiAtPiBtbSBhY2N1cmFjeVxuICovXG5leHBvcnQgdmFyIGl0ZXJhdGlvbnMgPSAxO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgdGhpcy5BID0gW107XG4gIHRoaXMuQVsxXSA9IDAuNjM5OTE3NTA3MztcbiAgdGhpcy5BWzJdID0gLTAuMTM1ODc5NzYxMztcbiAgdGhpcy5BWzNdID0gMC4wNjMyOTQ0MDk7XG4gIHRoaXMuQVs0XSA9IC0wLjAyNTI2ODUzO1xuICB0aGlzLkFbNV0gPSAwLjAxMTc4Nzk7XG4gIHRoaXMuQVs2XSA9IC0wLjAwNTUxNjE7XG4gIHRoaXMuQVs3XSA9IDAuMDAyNjkwNjtcbiAgdGhpcy5BWzhdID0gLTAuMDAxMzMzO1xuICB0aGlzLkFbOV0gPSAwLjAwMDY3O1xuICB0aGlzLkFbMTBdID0gLTAuMDAwMzQ7XG5cbiAgdGhpcy5CX3JlID0gW107XG4gIHRoaXMuQl9pbSA9IFtdO1xuICB0aGlzLkJfcmVbMV0gPSAwLjc1NTc4NTMyMjg7XG4gIHRoaXMuQl9pbVsxXSA9IDA7XG4gIHRoaXMuQl9yZVsyXSA9IDAuMjQ5MjA0NjQ2O1xuICB0aGlzLkJfaW1bMl0gPSAwLjAwMzM3MTUwNztcbiAgdGhpcy5CX3JlWzNdID0gLTAuMDAxNTQxNzM5O1xuICB0aGlzLkJfaW1bM10gPSAwLjA0MTA1ODU2MDtcbiAgdGhpcy5CX3JlWzRdID0gLTAuMTAxNjI5MDc7XG4gIHRoaXMuQl9pbVs0XSA9IDAuMDE3Mjc2MDk7XG4gIHRoaXMuQl9yZVs1XSA9IC0wLjI2NjIzNDg5O1xuICB0aGlzLkJfaW1bNV0gPSAtMC4zNjI0OTIxODtcbiAgdGhpcy5CX3JlWzZdID0gLTAuNjg3MDk4MztcbiAgdGhpcy5CX2ltWzZdID0gLTEuMTY1MTk2NztcblxuICB0aGlzLkNfcmUgPSBbXTtcbiAgdGhpcy5DX2ltID0gW107XG4gIHRoaXMuQ19yZVsxXSA9IDEuMzIzMTI3MDQzOTtcbiAgdGhpcy5DX2ltWzFdID0gMDtcbiAgdGhpcy5DX3JlWzJdID0gLTAuNTc3MjQ1Nzg5O1xuICB0aGlzLkNfaW1bMl0gPSAtMC4wMDc4MDk1OTg7XG4gIHRoaXMuQ19yZVszXSA9IDAuNTA4MzA3NTEzO1xuICB0aGlzLkNfaW1bM10gPSAtMC4xMTIyMDg5NTI7XG4gIHRoaXMuQ19yZVs0XSA9IC0wLjE1MDk0NzYyO1xuICB0aGlzLkNfaW1bNF0gPSAwLjE4MjAwNjAyO1xuICB0aGlzLkNfcmVbNV0gPSAxLjAxNDE4MTc5O1xuICB0aGlzLkNfaW1bNV0gPSAxLjY0NDk3Njk2O1xuICB0aGlzLkNfcmVbNl0gPSAxLjk2NjA1NDk7XG4gIHRoaXMuQ19pbVs2XSA9IDIuNTEyNzY0NTtcblxuICB0aGlzLkQgPSBbXTtcbiAgdGhpcy5EWzFdID0gMS41NjI3MDE0MjQzO1xuICB0aGlzLkRbMl0gPSAwLjUxODU0MDYzOTg7XG4gIHRoaXMuRFszXSA9IC0wLjAzMzMzMDk4O1xuICB0aGlzLkRbNF0gPSAtMC4xMDUyOTA2O1xuICB0aGlzLkRbNV0gPSAtMC4wMzY4NTk0O1xuICB0aGlzLkRbNl0gPSAwLjAwNzMxNztcbiAgdGhpcy5EWzddID0gMC4wMTIyMDtcbiAgdGhpcy5EWzhdID0gMC4wMDM5NDtcbiAgdGhpcy5EWzldID0gLTAuMDAxMztcbn1cblxuLyoqXG4gICAgTmV3IFplYWxhbmQgTWFwIEdyaWQgRm9yd2FyZCAgLSBsb25nL2xhdCB0byB4L3lcbiAgICBsb25nL2xhdCBpbiByYWRpYW5zXG4gICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBuO1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIHZhciBkZWx0YV9sYXQgPSBsYXQgLSB0aGlzLmxhdDA7XG4gIHZhciBkZWx0YV9sb24gPSBsb24gLSB0aGlzLmxvbmcwO1xuXG4gIC8vIDEuIENhbGN1bGF0ZSBkX3BoaSBhbmQgZF9wc2kgICAgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZF9sYW1iZGFcbiAgLy8gRm9yIHRoaXMgYWxnb3JpdGhtLCBkZWx0YV9sYXRpdHVkZSBpcyBpbiBzZWNvbmRzIG9mIGFyYyB4IDEwLTUsIHNvIHdlIG5lZWQgdG8gc2NhbGUgdG8gdGhvc2UgdW5pdHMuIExvbmdpdHVkZSBpcyByYWRpYW5zLlxuICB2YXIgZF9waGkgPSBkZWx0YV9sYXQgLyBTRUNfVE9fUkFEICogMUUtNTtcbiAgdmFyIGRfbGFtYmRhID0gZGVsdGFfbG9uO1xuICB2YXIgZF9waGlfbiA9IDE7IC8vIGRfcGhpXjBcblxuICB2YXIgZF9wc2kgPSAwO1xuICBmb3IgKG4gPSAxOyBuIDw9IDEwOyBuKyspIHtcbiAgICBkX3BoaV9uID0gZF9waGlfbiAqIGRfcGhpO1xuICAgIGRfcHNpID0gZF9wc2kgKyB0aGlzLkFbbl0gKiBkX3BoaV9uO1xuICB9XG5cbiAgLy8gMi4gQ2FsY3VsYXRlIHRoZXRhXG4gIHZhciB0aF9yZSA9IGRfcHNpO1xuICB2YXIgdGhfaW0gPSBkX2xhbWJkYTtcblxuICAvLyAzLiBDYWxjdWxhdGUgelxuICB2YXIgdGhfbl9yZSA9IDE7XG4gIHZhciB0aF9uX2ltID0gMDsgLy8gdGhldGFeMFxuICB2YXIgdGhfbl9yZTE7XG4gIHZhciB0aF9uX2ltMTtcblxuICB2YXIgel9yZSA9IDA7XG4gIHZhciB6X2ltID0gMDtcbiAgZm9yIChuID0gMTsgbiA8PSA2OyBuKyspIHtcbiAgICB0aF9uX3JlMSA9IHRoX25fcmUgKiB0aF9yZSAtIHRoX25faW0gKiB0aF9pbTtcbiAgICB0aF9uX2ltMSA9IHRoX25faW0gKiB0aF9yZSArIHRoX25fcmUgKiB0aF9pbTtcbiAgICB0aF9uX3JlID0gdGhfbl9yZTE7XG4gICAgdGhfbl9pbSA9IHRoX25faW0xO1xuICAgIHpfcmUgPSB6X3JlICsgdGhpcy5CX3JlW25dICogdGhfbl9yZSAtIHRoaXMuQl9pbVtuXSAqIHRoX25faW07XG4gICAgel9pbSA9IHpfaW0gKyB0aGlzLkJfaW1bbl0gKiB0aF9uX3JlICsgdGhpcy5CX3JlW25dICogdGhfbl9pbTtcbiAgfVxuXG4gIC8vIDQuIENhbGN1bGF0ZSBlYXN0aW5nIGFuZCBub3J0aGluZ1xuICBwLnggPSAoel9pbSAqIHRoaXMuYSkgKyB0aGlzLngwO1xuICBwLnkgPSAoel9yZSAqIHRoaXMuYSkgKyB0aGlzLnkwO1xuXG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAgICBOZXcgWmVhbGFuZCBNYXAgR3JpZCBJbnZlcnNlICAtICB4L3kgdG8gbG9uZy9sYXRcbiAgKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIG47XG4gIHZhciB4ID0gcC54O1xuICB2YXIgeSA9IHAueTtcblxuICB2YXIgZGVsdGFfeCA9IHggLSB0aGlzLngwO1xuICB2YXIgZGVsdGFfeSA9IHkgLSB0aGlzLnkwO1xuXG4gIC8vIDEuIENhbGN1bGF0ZSB6XG4gIHZhciB6X3JlID0gZGVsdGFfeSAvIHRoaXMuYTtcbiAgdmFyIHpfaW0gPSBkZWx0YV94IC8gdGhpcy5hO1xuXG4gIC8vIDJhLiBDYWxjdWxhdGUgdGhldGEgLSBmaXJzdCBhcHByb3hpbWF0aW9uIGdpdmVzIGttIGFjY3VyYWN5XG4gIHZhciB6X25fcmUgPSAxO1xuICB2YXIgel9uX2ltID0gMDsgLy8gel4wXG4gIHZhciB6X25fcmUxO1xuICB2YXIgel9uX2ltMTtcblxuICB2YXIgdGhfcmUgPSAwO1xuICB2YXIgdGhfaW0gPSAwO1xuICBmb3IgKG4gPSAxOyBuIDw9IDY7IG4rKykge1xuICAgIHpfbl9yZTEgPSB6X25fcmUgKiB6X3JlIC0gel9uX2ltICogel9pbTtcbiAgICB6X25faW0xID0gel9uX2ltICogel9yZSArIHpfbl9yZSAqIHpfaW07XG4gICAgel9uX3JlID0gel9uX3JlMTtcbiAgICB6X25faW0gPSB6X25faW0xO1xuICAgIHRoX3JlID0gdGhfcmUgKyB0aGlzLkNfcmVbbl0gKiB6X25fcmUgLSB0aGlzLkNfaW1bbl0gKiB6X25faW07XG4gICAgdGhfaW0gPSB0aF9pbSArIHRoaXMuQ19pbVtuXSAqIHpfbl9yZSArIHRoaXMuQ19yZVtuXSAqIHpfbl9pbTtcbiAgfVxuXG4gIC8vIDJiLiBJdGVyYXRlIHRvIHJlZmluZSB0aGUgYWNjdXJhY3kgb2YgdGhlIGNhbGN1bGF0aW9uXG4gIC8vICAgICAgICAwIGl0ZXJhdGlvbnMgZ2l2ZXMga20gYWNjdXJhY3lcbiAgLy8gICAgICAgIDEgaXRlcmF0aW9uIGdpdmVzIG0gYWNjdXJhY3kgLS0gZ29vZCBlbm91Z2ggZm9yIG1vc3QgbWFwcGluZyBhcHBsaWNhdGlvbnNcbiAgLy8gICAgICAgIDIgaXRlcmF0aW9ucyBiaXZlcyBtbSBhY2N1cmFjeVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgdmFyIHRoX25fcmUgPSB0aF9yZTtcbiAgICB2YXIgdGhfbl9pbSA9IHRoX2ltO1xuICAgIHZhciB0aF9uX3JlMTtcbiAgICB2YXIgdGhfbl9pbTE7XG5cbiAgICB2YXIgbnVtX3JlID0gel9yZTtcbiAgICB2YXIgbnVtX2ltID0gel9pbTtcbiAgICBmb3IgKG4gPSAyOyBuIDw9IDY7IG4rKykge1xuICAgICAgdGhfbl9yZTEgPSB0aF9uX3JlICogdGhfcmUgLSB0aF9uX2ltICogdGhfaW07XG4gICAgICB0aF9uX2ltMSA9IHRoX25faW0gKiB0aF9yZSArIHRoX25fcmUgKiB0aF9pbTtcbiAgICAgIHRoX25fcmUgPSB0aF9uX3JlMTtcbiAgICAgIHRoX25faW0gPSB0aF9uX2ltMTtcbiAgICAgIG51bV9yZSA9IG51bV9yZSArIChuIC0gMSkgKiAodGhpcy5CX3JlW25dICogdGhfbl9yZSAtIHRoaXMuQl9pbVtuXSAqIHRoX25faW0pO1xuICAgICAgbnVtX2ltID0gbnVtX2ltICsgKG4gLSAxKSAqICh0aGlzLkJfaW1bbl0gKiB0aF9uX3JlICsgdGhpcy5CX3JlW25dICogdGhfbl9pbSk7XG4gICAgfVxuXG4gICAgdGhfbl9yZSA9IDE7XG4gICAgdGhfbl9pbSA9IDA7XG4gICAgdmFyIGRlbl9yZSA9IHRoaXMuQl9yZVsxXTtcbiAgICB2YXIgZGVuX2ltID0gdGhpcy5CX2ltWzFdO1xuICAgIGZvciAobiA9IDI7IG4gPD0gNjsgbisrKSB7XG4gICAgICB0aF9uX3JlMSA9IHRoX25fcmUgKiB0aF9yZSAtIHRoX25faW0gKiB0aF9pbTtcbiAgICAgIHRoX25faW0xID0gdGhfbl9pbSAqIHRoX3JlICsgdGhfbl9yZSAqIHRoX2ltO1xuICAgICAgdGhfbl9yZSA9IHRoX25fcmUxO1xuICAgICAgdGhfbl9pbSA9IHRoX25faW0xO1xuICAgICAgZGVuX3JlID0gZGVuX3JlICsgbiAqICh0aGlzLkJfcmVbbl0gKiB0aF9uX3JlIC0gdGhpcy5CX2ltW25dICogdGhfbl9pbSk7XG4gICAgICBkZW5faW0gPSBkZW5faW0gKyBuICogKHRoaXMuQl9pbVtuXSAqIHRoX25fcmUgKyB0aGlzLkJfcmVbbl0gKiB0aF9uX2ltKTtcbiAgICB9XG5cbiAgICAvLyBDb21wbGV4IGRpdmlzaW9uXG4gICAgdmFyIGRlbjIgPSBkZW5fcmUgKiBkZW5fcmUgKyBkZW5faW0gKiBkZW5faW07XG4gICAgdGhfcmUgPSAobnVtX3JlICogZGVuX3JlICsgbnVtX2ltICogZGVuX2ltKSAvIGRlbjI7XG4gICAgdGhfaW0gPSAobnVtX2ltICogZGVuX3JlIC0gbnVtX3JlICogZGVuX2ltKSAvIGRlbjI7XG4gIH1cblxuICAvLyAzLiBDYWxjdWxhdGUgZF9waGkgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBkX2xhbWJkYVxuICB2YXIgZF9wc2kgPSB0aF9yZTtcbiAgdmFyIGRfbGFtYmRhID0gdGhfaW07XG4gIHZhciBkX3BzaV9uID0gMTsgLy8gZF9wc2leMFxuXG4gIHZhciBkX3BoaSA9IDA7XG4gIGZvciAobiA9IDE7IG4gPD0gOTsgbisrKSB7XG4gICAgZF9wc2lfbiA9IGRfcHNpX24gKiBkX3BzaTtcbiAgICBkX3BoaSA9IGRfcGhpICsgdGhpcy5EW25dICogZF9wc2lfbjtcbiAgfVxuXG4gIC8vIDQuIENhbGN1bGF0ZSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlXG4gIC8vIGRfcGhpIGlzIGNhbGN1YXRlZCBpbiBzZWNvbmQgb2YgYXJjICogMTBeLTUsIHNvIHdlIG5lZWQgdG8gc2NhbGUgYmFjayB0byByYWRpYW5zLiBkX2xhbWJkYSBpcyBpbiByYWRpYW5zLlxuICB2YXIgbGF0ID0gdGhpcy5sYXQwICsgKGRfcGhpICogU0VDX1RPX1JBRCAqIDFFNSk7XG4gIHZhciBsb24gPSB0aGlzLmxvbmcwICsgZF9sYW1iZGE7XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG5cbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJOZXdfWmVhbGFuZF9NYXBfR3JpZFwiLCBcIm56bWdcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCBhZGp1c3RfbG9uIGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbG9uJztcblxuLypcbiAgcmVmZXJlbmNlXG4gICAgXCJOZXcgRXF1YWwtQXJlYSBNYXAgUHJvamVjdGlvbnMgZm9yIE5vbmNpcmN1bGFyIFJlZ2lvbnNcIiwgSm9obiBQLiBTbnlkZXIsXG4gICAgVGhlIEFtZXJpY2FuIENhcnRvZ3JhcGhlciwgVm9sIDE1LCBOby4gNCwgT2N0b2JlciAxOTg4LCBwcC4gMzQxLTM1NS5cbiAgKi9cblxuXG4vKiBJbml0aWFsaXplIHRoZSBNaWxsZXIgQ3lsaW5kcmljYWwgcHJvamVjdGlvblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICAvL25vLW9wXG59XG5cbi8qIE1pbGxlciBDeWxpbmRyaWNhbCBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciB4ID0gdGhpcy54MCArIHRoaXMuYSAqIGRsb247XG4gIHZhciB5ID0gdGhpcy55MCArIHRoaXMuYSAqIE1hdGgubG9nKE1hdGgudGFuKChNYXRoLlBJIC8gNCkgKyAobGF0IC8gMi41KSkpICogMS4yNTtcblxuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn1cblxuLyogTWlsbGVyIEN5bGluZHJpY2FsIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcblxuICB2YXIgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgcC54IC8gdGhpcy5hKTtcbiAgdmFyIGxhdCA9IDIuNSAqIChNYXRoLmF0YW4oTWF0aC5leHAoMC44ICogcC55IC8gdGhpcy5hKSkgLSBNYXRoLlBJIC8gNCk7XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiTWlsbGVyX0N5bGluZHJpY2FsXCIsIFwibWlsbFwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IGFkanVzdF9sYXQgZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sYXQnO1xuaW1wb3J0IHBqX2VuZm4gZnJvbSAnLi4vY29tbW9uL3BqX2VuZm4nO1xudmFyIE1BWF9JVEVSID0gMjA7XG5pbXBvcnQgcGpfbWxmbiBmcm9tICcuLi9jb21tb24vcGpfbWxmbic7XG5pbXBvcnQgcGpfaW52X21sZm4gZnJvbSAnLi4vY29tbW9uL3BqX2ludl9tbGZuJztcbmltcG9ydCB7RVBTTE4sIEhBTEZfUEl9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5pbXBvcnQgYXNpbnogZnJvbSAnLi4vY29tbW9uL2FzaW56JztcblxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbiAgaWYgKCF0aGlzLnNwaGVyZSkge1xuICAgIHRoaXMuZW4gPSBwal9lbmZuKHRoaXMuZXMpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMubiA9IDE7XG4gICAgdGhpcy5tID0gMDtcbiAgICB0aGlzLmVzID0gMDtcbiAgICB0aGlzLkNfeSA9IE1hdGguc3FydCgodGhpcy5tICsgMSkgLyB0aGlzLm4pO1xuICAgIHRoaXMuQ194ID0gdGhpcy5DX3kgLyAodGhpcy5tICsgMSk7XG4gIH1cblxufVxuXG4vKiBTaW51c29pZGFsIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciB4LCB5O1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBpZiAoIXRoaXMubSkge1xuICAgICAgbGF0ID0gdGhpcy5uICE9PSAxID8gTWF0aC5hc2luKHRoaXMubiAqIE1hdGguc2luKGxhdCkpIDogbGF0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBrID0gdGhpcy5uICogTWF0aC5zaW4obGF0KTtcbiAgICAgIGZvciAodmFyIGkgPSBNQVhfSVRFUjsgaTsgLS1pKSB7XG4gICAgICAgIHZhciBWID0gKHRoaXMubSAqIGxhdCArIE1hdGguc2luKGxhdCkgLSBrKSAvICh0aGlzLm0gKyBNYXRoLmNvcyhsYXQpKTtcbiAgICAgICAgbGF0IC09IFY7XG4gICAgICAgIGlmIChNYXRoLmFicyhWKSA8IEVQU0xOKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgeCA9IHRoaXMuYSAqIHRoaXMuQ194ICogbG9uICogKHRoaXMubSArIE1hdGguY29zKGxhdCkpO1xuICAgIHkgPSB0aGlzLmEgKiB0aGlzLkNfeSAqIGxhdDtcblxuICB9XG4gIGVsc2Uge1xuXG4gICAgdmFyIHMgPSBNYXRoLnNpbihsYXQpO1xuICAgIHZhciBjID0gTWF0aC5jb3MobGF0KTtcbiAgICB5ID0gdGhpcy5hICogcGpfbWxmbihsYXQsIHMsIGMsIHRoaXMuZW4pO1xuICAgIHggPSB0aGlzLmEgKiBsb24gKiBjIC8gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzICogcyAqIHMpO1xuICB9XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIGxhdCwgdGVtcCwgbG9uLCBzO1xuXG4gIHAueCAtPSB0aGlzLngwO1xuICBsb24gPSBwLnggLyB0aGlzLmE7XG4gIHAueSAtPSB0aGlzLnkwO1xuICBsYXQgPSBwLnkgLyB0aGlzLmE7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbGF0IC89IHRoaXMuQ195O1xuICAgIGxvbiA9IGxvbiAvICh0aGlzLkNfeCAqICh0aGlzLm0gKyBNYXRoLmNvcyhsYXQpKSk7XG4gICAgaWYgKHRoaXMubSkge1xuICAgICAgbGF0ID0gYXNpbnooKHRoaXMubSAqIGxhdCArIE1hdGguc2luKGxhdCkpIC8gdGhpcy5uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5uICE9PSAxKSB7XG4gICAgICBsYXQgPSBhc2lueihNYXRoLnNpbihsYXQpIC8gdGhpcy5uKTtcbiAgICB9XG4gICAgbG9uID0gYWRqdXN0X2xvbihsb24gKyB0aGlzLmxvbmcwKTtcbiAgICBsYXQgPSBhZGp1c3RfbGF0KGxhdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGF0ID0gcGpfaW52X21sZm4ocC55IC8gdGhpcy5hLCB0aGlzLmVzLCB0aGlzLmVuKTtcbiAgICBzID0gTWF0aC5hYnMobGF0KTtcbiAgICBpZiAocyA8IEhBTEZfUEkpIHtcbiAgICAgIHMgPSBNYXRoLnNpbihsYXQpO1xuICAgICAgdGVtcCA9IHRoaXMubG9uZzAgKyBwLnggKiBNYXRoLnNxcnQoMSAtIHRoaXMuZXMgKiBzICogcykgLyAodGhpcy5hICogTWF0aC5jb3MobGF0KSk7XG4gICAgICAvL3RlbXAgPSB0aGlzLmxvbmcwICsgcC54IC8gKHRoaXMuYSAqIE1hdGguY29zKGxhdCkpO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0ZW1wKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHMgLSBFUFNMTikgPCBIQUxGX1BJKSB7XG4gICAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIH1cbiAgfVxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJTaW51c29pZGFsXCIsIFwic2ludVwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7fVxuaW1wb3J0IHtFUFNMTn0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG4vKiBNb2xsd2VpZGUgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG5cbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICB2YXIgZGVsdGFfbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIHRoZXRhID0gbGF0O1xuICB2YXIgY29uID0gTWF0aC5QSSAqIE1hdGguc2luKGxhdCk7XG5cbiAgLyogSXRlcmF0ZSB1c2luZyB0aGUgTmV3dG9uLVJhcGhzb24gbWV0aG9kIHRvIGZpbmQgdGhldGFcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgZGVsdGFfdGhldGEgPSAtKHRoZXRhICsgTWF0aC5zaW4odGhldGEpIC0gY29uKSAvICgxICsgTWF0aC5jb3ModGhldGEpKTtcbiAgICB0aGV0YSArPSBkZWx0YV90aGV0YTtcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFfdGhldGEpIDwgRVBTTE4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGV0YSAvPSAyO1xuXG4gIC8qIElmIHRoZSBsYXRpdHVkZSBpcyA5MCBkZWcsIGZvcmNlIHRoZSB4IGNvb3JkaW5hdGUgdG8gYmUgXCIwICsgZmFsc2UgZWFzdGluZ1wiXG4gICAgICAgdGhpcyBpcyBkb25lIGhlcmUgYmVjYXVzZSBvZiBwcmVjaXNpb24gcHJvYmxlbXMgd2l0aCBcImNvcyh0aGV0YSlcIlxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgaWYgKE1hdGguUEkgLyAyIC0gTWF0aC5hYnMobGF0KSA8IEVQU0xOKSB7XG4gICAgZGVsdGFfbG9uID0gMDtcbiAgfVxuICB2YXIgeCA9IDAuOTAwMzE2MzE2MTU4ICogdGhpcy5hICogZGVsdGFfbG9uICogTWF0aC5jb3ModGhldGEpICsgdGhpcy54MDtcbiAgdmFyIHkgPSAxLjQxNDIxMzU2MjM3MzEgKiB0aGlzLmEgKiBNYXRoLnNpbih0aGV0YSkgKyB0aGlzLnkwO1xuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHZhciB0aGV0YTtcbiAgdmFyIGFyZztcblxuICAvKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBwLnggLT0gdGhpcy54MDtcbiAgcC55IC09IHRoaXMueTA7XG4gIGFyZyA9IHAueSAvICgxLjQxNDIxMzU2MjM3MzEgKiB0aGlzLmEpO1xuXG4gIC8qIEJlY2F1c2Ugb2YgZGl2aXNpb24gYnkgemVybyBwcm9ibGVtcywgJ2FyZycgY2FuIG5vdCBiZSAxLiAgVGhlcmVmb3JlXG4gICAgICAgYSBudW1iZXIgdmVyeSBjbG9zZSB0byBvbmUgaXMgdXNlZCBpbnN0ZWFkLlxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBpZiAoTWF0aC5hYnMoYXJnKSA+IDAuOTk5OTk5OTk5OTk5KSB7XG4gICAgYXJnID0gMC45OTk5OTk5OTk5OTk7XG4gIH1cbiAgdGhldGEgPSBNYXRoLmFzaW4oYXJnKTtcbiAgdmFyIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIChwLnggLyAoMC45MDAzMTYzMTYxNTggKiB0aGlzLmEgKiBNYXRoLmNvcyh0aGV0YSkpKSk7XG4gIGlmIChsb24gPCAoLU1hdGguUEkpKSB7XG4gICAgbG9uID0gLU1hdGguUEk7XG4gIH1cbiAgaWYgKGxvbiA+IE1hdGguUEkpIHtcbiAgICBsb24gPSBNYXRoLlBJO1xuICB9XG4gIGFyZyA9ICgyICogdGhldGEgKyBNYXRoLnNpbigyICogdGhldGEpKSAvIE1hdGguUEk7XG4gIGlmIChNYXRoLmFicyhhcmcpID4gMSkge1xuICAgIGFyZyA9IDE7XG4gIH1cbiAgdmFyIGxhdCA9IE1hdGguYXNpbihhcmcpO1xuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIk1vbGx3ZWlkZVwiLCBcIm1vbGxcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCBlMGZuIGZyb20gJy4uL2NvbW1vbi9lMGZuJztcbmltcG9ydCBlMWZuIGZyb20gJy4uL2NvbW1vbi9lMWZuJztcbmltcG9ydCBlMmZuIGZyb20gJy4uL2NvbW1vbi9lMmZuJztcbmltcG9ydCBlM2ZuIGZyb20gJy4uL2NvbW1vbi9lM2ZuJztcbmltcG9ydCBtc2ZueiBmcm9tICcuLi9jb21tb24vbXNmbnonO1xuaW1wb3J0IG1sZm4gZnJvbSAnLi4vY29tbW9uL21sZm4nO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IGFkanVzdF9sYXQgZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sYXQnO1xuaW1wb3J0IGltbGZuIGZyb20gJy4uL2NvbW1vbi9pbWxmbic7XG5pbXBvcnQge0VQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG5cbiAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8vIFN0YW5kYXJkIFBhcmFsbGVscyBjYW5ub3QgYmUgZXF1YWwgYW5kIG9uIG9wcG9zaXRlIHNpZGVzIG9mIHRoZSBlcXVhdG9yXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgKyB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXQyID0gdGhpcy5sYXQyIHx8IHRoaXMubGF0MTtcbiAgdGhpcy50ZW1wID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmVzID0gMSAtIE1hdGgucG93KHRoaXMudGVtcCwgMik7XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gIHRoaXMuZTEgPSBlMWZuKHRoaXMuZXMpO1xuICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG5cbiAgdGhpcy5zaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDEpO1xuICB0aGlzLmNvc3BoaSA9IE1hdGguY29zKHRoaXMubGF0MSk7XG5cbiAgdGhpcy5tczEgPSBtc2Zueih0aGlzLmUsIHRoaXMuc2lucGhpLCB0aGlzLmNvc3BoaSk7XG4gIHRoaXMubWwxID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDEpO1xuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgLSB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcbiAgICB0aGlzLm5zID0gdGhpcy5zaW5waGk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5zaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDIpO1xuICAgIHRoaXMuY29zcGhpID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcbiAgICB0aGlzLm1zMiA9IG1zZm56KHRoaXMuZSwgdGhpcy5zaW5waGksIHRoaXMuY29zcGhpKTtcbiAgICB0aGlzLm1sMiA9IG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQyKTtcbiAgICB0aGlzLm5zID0gKHRoaXMubXMxIC0gdGhpcy5tczIpIC8gKHRoaXMubWwyIC0gdGhpcy5tbDEpO1xuICB9XG4gIHRoaXMuZyA9IHRoaXMubWwxICsgdGhpcy5tczEgLyB0aGlzLm5zO1xuICB0aGlzLm1sMCA9IG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQwKTtcbiAgdGhpcy5yaCA9IHRoaXMuYSAqICh0aGlzLmcgLSB0aGlzLm1sMCk7XG59XG5cbi8qIEVxdWlkaXN0YW50IENvbmljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciByaDE7XG5cbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgcmgxID0gdGhpcy5hICogKHRoaXMuZyAtIGxhdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIG1sID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBsYXQpO1xuICAgIHJoMSA9IHRoaXMuYSAqICh0aGlzLmcgLSBtbCk7XG4gIH1cbiAgdmFyIHRoZXRhID0gdGhpcy5ucyAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciB4ID0gdGhpcy54MCArIHJoMSAqIE1hdGguc2luKHRoZXRhKTtcbiAgdmFyIHkgPSB0aGlzLnkwICsgdGhpcy5yaCAtIHJoMSAqIE1hdGguY29zKHRoZXRhKTtcbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59XG5cbi8qIEludmVyc2UgZXF1YXRpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSA9IHRoaXMucmggLSBwLnkgKyB0aGlzLnkwO1xuICB2YXIgY29uLCByaDEsIGxhdCwgbG9uO1xuICBpZiAodGhpcy5ucyA+PSAwKSB7XG4gICAgcmgxID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG4gICAgY29uID0gMTtcbiAgfVxuICBlbHNlIHtcbiAgICByaDEgPSAtTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG4gICAgY29uID0gLTE7XG4gIH1cbiAgdmFyIHRoZXRhID0gMDtcbiAgaWYgKHJoMSAhPT0gMCkge1xuICAgIHRoZXRhID0gTWF0aC5hdGFuMihjb24gKiBwLngsIGNvbiAqIHAueSk7XG4gIH1cblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyB0aGV0YSAvIHRoaXMubnMpO1xuICAgIGxhdCA9IGFkanVzdF9sYXQodGhpcy5nIC0gcmgxIC8gdGhpcy5hKTtcbiAgICBwLnggPSBsb247XG4gICAgcC55ID0gbGF0O1xuICAgIHJldHVybiBwO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBtbCA9IHRoaXMuZyAtIHJoMSAvIHRoaXMuYTtcbiAgICBsYXQgPSBpbWxmbihtbCwgdGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMyk7XG4gICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgdGhldGEgLyB0aGlzLm5zKTtcbiAgICBwLnggPSBsb247XG4gICAgcC55ID0gbGF0O1xuICAgIHJldHVybiBwO1xuICB9XG5cbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIkVxdWlkaXN0YW50X0NvbmljXCIsIFwiZXFkY1wiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuXG5pbXBvcnQge0hBTEZfUEksIEVQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuaW1wb3J0IGFzaW56IGZyb20gJy4uL2NvbW1vbi9hc2lueic7XG5cbi8qIEluaXRpYWxpemUgdGhlIFZhbiBEZXIgR3JpbnRlbiBwcm9qZWN0aW9uXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIC8vdGhpcy5SID0gNjM3MDk5NzsgLy9SYWRpdXMgb2YgZWFydGhcbiAgdGhpcy5SID0gdGhpcy5hO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG5cbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgeCwgeTtcblxuICBpZiAoTWF0aC5hYnMobGF0KSA8PSBFUFNMTikge1xuICAgIHggPSB0aGlzLngwICsgdGhpcy5SICogZGxvbjtcbiAgICB5ID0gdGhpcy55MDtcbiAgfVxuICB2YXIgdGhldGEgPSBhc2lueigyICogTWF0aC5hYnMobGF0IC8gTWF0aC5QSSkpO1xuICBpZiAoKE1hdGguYWJzKGRsb24pIDw9IEVQU0xOKSB8fCAoTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpIDw9IEVQU0xOKSkge1xuICAgIHggPSB0aGlzLngwO1xuICAgIGlmIChsYXQgPj0gMCkge1xuICAgICAgeSA9IHRoaXMueTAgKyBNYXRoLlBJICogdGhpcy5SICogTWF0aC50YW4oMC41ICogdGhldGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHkgPSB0aGlzLnkwICsgTWF0aC5QSSAqIHRoaXMuUiAqIC1NYXRoLnRhbigwLjUgKiB0aGV0YSk7XG4gICAgfVxuICAgIC8vICByZXR1cm4oT0spO1xuICB9XG4gIHZhciBhbCA9IDAuNSAqIE1hdGguYWJzKChNYXRoLlBJIC8gZGxvbikgLSAoZGxvbiAvIE1hdGguUEkpKTtcbiAgdmFyIGFzcSA9IGFsICogYWw7XG4gIHZhciBzaW50aCA9IE1hdGguc2luKHRoZXRhKTtcbiAgdmFyIGNvc3RoID0gTWF0aC5jb3ModGhldGEpO1xuXG4gIHZhciBnID0gY29zdGggLyAoc2ludGggKyBjb3N0aCAtIDEpO1xuICB2YXIgZ3NxID0gZyAqIGc7XG4gIHZhciBtID0gZyAqICgyIC8gc2ludGggLSAxKTtcbiAgdmFyIG1zcSA9IG0gKiBtO1xuICB2YXIgY29uID0gTWF0aC5QSSAqIHRoaXMuUiAqIChhbCAqIChnIC0gbXNxKSArIE1hdGguc3FydChhc3EgKiAoZyAtIG1zcSkgKiAoZyAtIG1zcSkgLSAobXNxICsgYXNxKSAqIChnc3EgLSBtc3EpKSkgLyAobXNxICsgYXNxKTtcbiAgaWYgKGRsb24gPCAwKSB7XG4gICAgY29uID0gLWNvbjtcbiAgfVxuICB4ID0gdGhpcy54MCArIGNvbjtcbiAgLy9jb24gPSBNYXRoLmFicyhjb24gLyAoTWF0aC5QSSAqIHRoaXMuUikpO1xuICB2YXIgcSA9IGFzcSArIGc7XG4gIGNvbiA9IE1hdGguUEkgKiB0aGlzLlIgKiAobSAqIHEgLSBhbCAqIE1hdGguc3FydCgobXNxICsgYXNxKSAqIChhc3EgKyAxKSAtIHEgKiBxKSkgLyAobXNxICsgYXNxKTtcbiAgaWYgKGxhdCA+PSAwKSB7XG4gICAgLy95ID0gdGhpcy55MCArIE1hdGguUEkgKiB0aGlzLlIgKiBNYXRoLnNxcnQoMSAtIGNvbiAqIGNvbiAtIDIgKiBhbCAqIGNvbik7XG4gICAgeSA9IHRoaXMueTAgKyBjb247XG4gIH1cbiAgZWxzZSB7XG4gICAgLy95ID0gdGhpcy55MCAtIE1hdGguUEkgKiB0aGlzLlIgKiBNYXRoLnNxcnQoMSAtIGNvbiAqIGNvbiAtIDIgKiBhbCAqIGNvbik7XG4gICAgeSA9IHRoaXMueTAgLSBjb247XG4gIH1cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59XG5cbi8qIFZhbiBEZXIgR3JpbnRlbiBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIGxvbiwgbGF0O1xuICB2YXIgeHgsIHl5LCB4eXMsIGMxLCBjMiwgYzM7XG4gIHZhciBhMTtcbiAgdmFyIG0xO1xuICB2YXIgY29uO1xuICB2YXIgdGgxO1xuICB2YXIgZDtcblxuICAvKiBpbnZlcnNlIGVxdWF0aW9uc1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICBjb24gPSBNYXRoLlBJICogdGhpcy5SO1xuICB4eCA9IHAueCAvIGNvbjtcbiAgeXkgPSBwLnkgLyBjb247XG4gIHh5cyA9IHh4ICogeHggKyB5eSAqIHl5O1xuICBjMSA9IC1NYXRoLmFicyh5eSkgKiAoMSArIHh5cyk7XG4gIGMyID0gYzEgLSAyICogeXkgKiB5eSArIHh4ICogeHg7XG4gIGMzID0gLTIgKiBjMSArIDEgKyAyICogeXkgKiB5eSArIHh5cyAqIHh5cztcbiAgZCA9IHl5ICogeXkgLyBjMyArICgyICogYzIgKiBjMiAqIGMyIC8gYzMgLyBjMyAvIGMzIC0gOSAqIGMxICogYzIgLyBjMyAvIGMzKSAvIDI3O1xuICBhMSA9IChjMSAtIGMyICogYzIgLyAzIC8gYzMpIC8gYzM7XG4gIG0xID0gMiAqIE1hdGguc3FydCgtYTEgLyAzKTtcbiAgY29uID0gKCgzICogZCkgLyBhMSkgLyBtMTtcbiAgaWYgKE1hdGguYWJzKGNvbikgPiAxKSB7XG4gICAgaWYgKGNvbiA+PSAwKSB7XG4gICAgICBjb24gPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbiA9IC0xO1xuICAgIH1cbiAgfVxuICB0aDEgPSBNYXRoLmFjb3MoY29uKSAvIDM7XG4gIGlmIChwLnkgPj0gMCkge1xuICAgIGxhdCA9ICgtbTEgKiBNYXRoLmNvcyh0aDEgKyBNYXRoLlBJIC8gMykgLSBjMiAvIDMgLyBjMykgKiBNYXRoLlBJO1xuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IC0oLW0xICogTWF0aC5jb3ModGgxICsgTWF0aC5QSSAvIDMpIC0gYzIgLyAzIC8gYzMpICogTWF0aC5QSTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh4eCkgPCBFUFNMTikge1xuICAgIGxvbiA9IHRoaXMubG9uZzA7XG4gIH1cbiAgZWxzZSB7XG4gICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5QSSAqICh4eXMgLSAxICsgTWF0aC5zcXJ0KDEgKyAyICogKHh4ICogeHggLSB5eSAqIHl5KSArIHh5cyAqIHh5cykpIC8gMiAvIHh4KTtcbiAgfVxuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIlZhbl9kZXJfR3JpbnRlbl9JXCIsIFwiVmFuRGVyR3JpbnRlblwiLCBcInZhbmRnXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5pbXBvcnQge0hBTEZfUEksIEVQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuaW1wb3J0IG1sZm4gZnJvbSAnLi4vY29tbW9uL21sZm4nO1xuaW1wb3J0IGUwZm4gZnJvbSAnLi4vY29tbW9uL2UwZm4nO1xuaW1wb3J0IGUxZm4gZnJvbSAnLi4vY29tbW9uL2UxZm4nO1xuaW1wb3J0IGUyZm4gZnJvbSAnLi4vY29tbW9uL2UyZm4nO1xuaW1wb3J0IGUzZm4gZnJvbSAnLi4vY29tbW9uL2UzZm4nO1xuaW1wb3J0IGdOIGZyb20gJy4uL2NvbW1vbi9nTic7XG5pbXBvcnQgYXNpbnogZnJvbSAnLi4vY29tbW9uL2FzaW56JztcbmltcG9ydCBpbWxmbiBmcm9tICcuLi9jb21tb24vaW1sZm4nO1xuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHRoaXMuc2luX3AxMiA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHRoaXMuY29zX3AxMiA9IE1hdGguY29zKHRoaXMubGF0MCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHNpbnBoaSA9IE1hdGguc2luKHAueSk7XG4gIHZhciBjb3NwaGkgPSBNYXRoLmNvcyhwLnkpO1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciBlMCwgZTEsIGUyLCBlMywgTWxwLCBNbCwgdGFucGhpLCBObDEsIE5sLCBwc2ksIEF6LCBHLCBILCBHSCwgSHMsIGMsIGtwLCBjb3NfYywgcywgczIsIHMzLCBzNCwgczU7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgLSAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Ob3J0aCBQb2xlIGNhc2VcbiAgICAgIHAueCA9IHRoaXMueDAgKyB0aGlzLmEgKiAoSEFMRl9QSSAtIGxhdCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgLSB0aGlzLmEgKiAoSEFMRl9QSSAtIGxhdCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgKyAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Tb3V0aCBQb2xlIGNhc2VcbiAgICAgIHAueCA9IHRoaXMueDAgKyB0aGlzLmEgKiAoSEFMRl9QSSArIGxhdCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgKyB0aGlzLmEgKiAoSEFMRl9QSSArIGxhdCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vZGVmYXVsdCBjYXNlXG4gICAgICBjb3NfYyA9IHRoaXMuc2luX3AxMiAqIHNpbnBoaSArIHRoaXMuY29zX3AxMiAqIGNvc3BoaSAqIE1hdGguY29zKGRsb24pO1xuICAgICAgYyA9IE1hdGguYWNvcyhjb3NfYyk7XG4gICAgICBrcCA9IGMgPyBjIC8gTWF0aC5zaW4oYykgOiAxO1xuICAgICAgcC54ID0gdGhpcy54MCArIHRoaXMuYSAqIGtwICogY29zcGhpICogTWF0aC5zaW4oZGxvbik7XG4gICAgICBwLnkgPSB0aGlzLnkwICsgdGhpcy5hICoga3AgKiAodGhpcy5jb3NfcDEyICogc2lucGhpIC0gdGhpcy5zaW5fcDEyICogY29zcGhpICogTWF0aC5jb3MoZGxvbikpO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGUwID0gZTBmbih0aGlzLmVzKTtcbiAgICBlMSA9IGUxZm4odGhpcy5lcyk7XG4gICAgZTIgPSBlMmZuKHRoaXMuZXMpO1xuICAgIGUzID0gZTNmbih0aGlzLmVzKTtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5zaW5fcDEyIC0gMSkgPD0gRVBTTE4pIHtcbiAgICAgIC8vTm9ydGggUG9sZSBjYXNlXG4gICAgICBNbHAgPSB0aGlzLmEgKiBtbGZuKGUwLCBlMSwgZTIsIGUzLCBIQUxGX1BJKTtcbiAgICAgIE1sID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgbGF0KTtcbiAgICAgIHAueCA9IHRoaXMueDAgKyAoTWxwIC0gTWwpICogTWF0aC5zaW4oZGxvbik7XG4gICAgICBwLnkgPSB0aGlzLnkwIC0gKE1scCAtIE1sKSAqIE1hdGguY29zKGRsb24pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiArIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL1NvdXRoIFBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICBNbCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIGxhdCk7XG4gICAgICBwLnggPSB0aGlzLngwICsgKE1scCArIE1sKSAqIE1hdGguc2luKGRsb24pO1xuICAgICAgcC55ID0gdGhpcy55MCArIChNbHAgKyBNbCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vRGVmYXVsdCBjYXNlXG4gICAgICB0YW5waGkgPSBzaW5waGkgLyBjb3NwaGk7XG4gICAgICBObDEgPSBnTih0aGlzLmEsIHRoaXMuZSwgdGhpcy5zaW5fcDEyKTtcbiAgICAgIE5sID0gZ04odGhpcy5hLCB0aGlzLmUsIHNpbnBoaSk7XG4gICAgICBwc2kgPSBNYXRoLmF0YW4oKDEgLSB0aGlzLmVzKSAqIHRhbnBoaSArIHRoaXMuZXMgKiBObDEgKiB0aGlzLnNpbl9wMTIgLyAoTmwgKiBjb3NwaGkpKTtcbiAgICAgIEF6ID0gTWF0aC5hdGFuMihNYXRoLnNpbihkbG9uKSwgdGhpcy5jb3NfcDEyICogTWF0aC50YW4ocHNpKSAtIHRoaXMuc2luX3AxMiAqIE1hdGguY29zKGRsb24pKTtcbiAgICAgIGlmIChBeiA9PT0gMCkge1xuICAgICAgICBzID0gTWF0aC5hc2luKHRoaXMuY29zX3AxMiAqIE1hdGguc2luKHBzaSkgLSB0aGlzLnNpbl9wMTIgKiBNYXRoLmNvcyhwc2kpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKE1hdGguYWJzKE1hdGguYWJzKEF6KSAtIE1hdGguUEkpIDw9IEVQU0xOKSB7XG4gICAgICAgIHMgPSAtTWF0aC5hc2luKHRoaXMuY29zX3AxMiAqIE1hdGguc2luKHBzaSkgLSB0aGlzLnNpbl9wMTIgKiBNYXRoLmNvcyhwc2kpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzID0gTWF0aC5hc2luKE1hdGguc2luKGRsb24pICogTWF0aC5jb3MocHNpKSAvIE1hdGguc2luKEF6KSk7XG4gICAgICB9XG4gICAgICBHID0gdGhpcy5lICogdGhpcy5zaW5fcDEyIC8gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKTtcbiAgICAgIEggPSB0aGlzLmUgKiB0aGlzLmNvc19wMTIgKiBNYXRoLmNvcyhBeikgLyBNYXRoLnNxcnQoMSAtIHRoaXMuZXMpO1xuICAgICAgR0ggPSBHICogSDtcbiAgICAgIEhzID0gSCAqIEg7XG4gICAgICBzMiA9IHMgKiBzO1xuICAgICAgczMgPSBzMiAqIHM7XG4gICAgICBzNCA9IHMzICogcztcbiAgICAgIHM1ID0gczQgKiBzO1xuICAgICAgYyA9IE5sMSAqIHMgKiAoMSAtIHMyICogSHMgKiAoMSAtIEhzKSAvIDYgKyBzMyAvIDggKiBHSCAqICgxIC0gMiAqIEhzKSArIHM0IC8gMTIwICogKEhzICogKDQgLSA3ICogSHMpIC0gMyAqIEcgKiBHICogKDEgLSA3ICogSHMpKSAtIHM1IC8gNDggKiBHSCk7XG4gICAgICBwLnggPSB0aGlzLngwICsgYyAqIE1hdGguc2luKEF6KTtcbiAgICAgIHAueSA9IHRoaXMueTAgKyBjICogTWF0aC5jb3MoQXopO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9XG5cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgdmFyIHJoLCB6LCBzaW56LCBjb3N6LCBsb24sIGxhdCwgY29uLCBlMCwgZTEsIGUyLCBlMywgTWxwLCBNLCBOMSwgcHNpLCBBeiwgY29zQXosIHRtcCwgQSwgQiwgRCwgRWUsIEYsIHNpbnBzaTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBpZiAocmggPiAoMiAqIEhBTEZfUEkgKiB0aGlzLmEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHogPSByaCAvIHRoaXMuYTtcblxuICAgIHNpbnogPSBNYXRoLnNpbih6KTtcbiAgICBjb3N6ID0gTWF0aC5jb3Moeik7XG5cbiAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIGlmIChNYXRoLmFicyhyaCkgPD0gRVBTTE4pIHtcbiAgICAgIGxhdCA9IHRoaXMubGF0MDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsYXQgPSBhc2lueihjb3N6ICogdGhpcy5zaW5fcDEyICsgKHAueSAqIHNpbnogKiB0aGlzLmNvc19wMTIpIC8gcmgpO1xuICAgICAgY29uID0gTWF0aC5hYnModGhpcy5sYXQwKSAtIEhBTEZfUEk7XG4gICAgICBpZiAoTWF0aC5hYnMoY29uKSA8PSBFUFNMTikge1xuICAgICAgICBpZiAodGhpcy5sYXQwID49IDApIHtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSBwLnkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgLSBNYXRoLmF0YW4yKC1wLngsIHAueSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLypjb24gPSBjb3N6IC0gdGhpcy5zaW5fcDEyICogTWF0aC5zaW4obGF0KTtcbiAgICAgICAgaWYgKChNYXRoLmFicyhjb24pIDwgRVBTTE4pICYmIChNYXRoLmFicyhwLngpIDwgRVBTTE4pKSB7XG4gICAgICAgICAgLy9uby1vcCwganVzdCBrZWVwIHRoZSBsb24gdmFsdWUgYXMgaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IE1hdGguYXRhbjIoKHAueCAqIHNpbnogKiB0aGlzLmNvc19wMTIpLCAoY29uICogcmgpKTtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKChwLnggKiBzaW56ICogdGhpcy5jb3NfcDEyKSwgKGNvbiAqIHJoKSkpO1xuICAgICAgICB9Ki9cbiAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLnggKiBzaW56LCByaCAqIHRoaXMuY29zX3AxMiAqIGNvc3ogLSBwLnkgKiB0aGlzLnNpbl9wMTIgKiBzaW56KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICBlMCA9IGUwZm4odGhpcy5lcyk7XG4gICAgZTEgPSBlMWZuKHRoaXMuZXMpO1xuICAgIGUyID0gZTJmbih0aGlzLmVzKTtcbiAgICBlMyA9IGUzZm4odGhpcy5lcyk7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiAtIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL05vcnRoIHBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgICAgTSA9IE1scCAtIHJoO1xuICAgICAgbGF0ID0gaW1sZm4oTSAvIHRoaXMuYSwgZTAsIGUxLCBlMiwgZTMpO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIC0gMSAqIHAueSkpO1xuICAgICAgcC54ID0gbG9uO1xuICAgICAgcC55ID0gbGF0O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiArIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL1NvdXRoIHBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgICAgTSA9IHJoIC0gTWxwO1xuXG4gICAgICBsYXQgPSBpbWxmbihNIC8gdGhpcy5hLCBlMCwgZTEsIGUyLCBlMyk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgcC55KSk7XG4gICAgICBwLnggPSBsb247XG4gICAgICBwLnkgPSBsYXQ7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2RlZmF1bHQgY2FzZVxuICAgICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICAgIEF6ID0gTWF0aC5hdGFuMihwLngsIHAueSk7XG4gICAgICBOMSA9IGdOKHRoaXMuYSwgdGhpcy5lLCB0aGlzLnNpbl9wMTIpO1xuICAgICAgY29zQXogPSBNYXRoLmNvcyhBeik7XG4gICAgICB0bXAgPSB0aGlzLmUgKiB0aGlzLmNvc19wMTIgKiBjb3NBejtcbiAgICAgIEEgPSAtdG1wICogdG1wIC8gKDEgLSB0aGlzLmVzKTtcbiAgICAgIEIgPSAzICogdGhpcy5lcyAqICgxIC0gQSkgKiB0aGlzLnNpbl9wMTIgKiB0aGlzLmNvc19wMTIgKiBjb3NBeiAvICgxIC0gdGhpcy5lcyk7XG4gICAgICBEID0gcmggLyBOMTtcbiAgICAgIEVlID0gRCAtIEEgKiAoMSArIEEpICogTWF0aC5wb3coRCwgMykgLyA2IC0gQiAqICgxICsgMyAqIEEpICogTWF0aC5wb3coRCwgNCkgLyAyNDtcbiAgICAgIEYgPSAxIC0gQSAqIEVlICogRWUgLyAyIC0gRCAqIEVlICogRWUgKiBFZSAvIDY7XG4gICAgICBwc2kgPSBNYXRoLmFzaW4odGhpcy5zaW5fcDEyICogTWF0aC5jb3MoRWUpICsgdGhpcy5jb3NfcDEyICogTWF0aC5zaW4oRWUpICogY29zQXopO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hc2luKE1hdGguc2luKEF6KSAqIE1hdGguc2luKEVlKSAvIE1hdGguY29zKHBzaSkpKTtcbiAgICAgIHNpbnBzaSA9IE1hdGguc2luKHBzaSk7XG4gICAgICBsYXQgPSBNYXRoLmF0YW4yKChzaW5wc2kgLSB0aGlzLmVzICogRiAqIHRoaXMuc2luX3AxMikgKiBNYXRoLnRhbihwc2kpLCBzaW5wc2kgKiAoMSAtIHRoaXMuZXMpKTtcbiAgICAgIHAueCA9IGxvbjtcbiAgICAgIHAueSA9IGxhdDtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJBemltdXRoYWxfRXF1aWRpc3RhbnRcIiwgXCJhZXFkXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5pbXBvcnQgYXNpbnogZnJvbSAnLi4vY29tbW9uL2FzaW56JztcbmltcG9ydCB7RVBTTE4sIEhBTEZfUEl9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgLy9kb3VibGUgdGVtcDsgICAgICAvKiB0ZW1wb3JhcnkgdmFyaWFibGUgICAgKi9cblxuICAvKiBQbGFjZSBwYXJhbWV0ZXJzIGluIHN0YXRpYyBzdG9yYWdlIGZvciBjb21tb24gdXNlXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdGhpcy5zaW5fcDE0ID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgdGhpcy5jb3NfcDE0ID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbn1cblxuLyogT3J0aG9ncmFwaGljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBzaW5waGksIGNvc3BoaTsgLyogc2luIGFuZCBjb3MgdmFsdWUgICAgICAgICovXG4gIHZhciBkbG9uOyAvKiBkZWx0YSBsb25naXR1ZGUgdmFsdWUgICAgICAqL1xuICB2YXIgY29zbG9uOyAvKiBjb3Mgb2YgbG9uZ2l0dWRlICAgICAgICAqL1xuICB2YXIga3NwOyAvKiBzY2FsZSBmYWN0b3IgICAgICAgICAgKi9cbiAgdmFyIGcsIHgsIHk7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXG4gIHNpbnBoaSA9IE1hdGguc2luKGxhdCk7XG4gIGNvc3BoaSA9IE1hdGguY29zKGxhdCk7XG5cbiAgY29zbG9uID0gTWF0aC5jb3MoZGxvbik7XG4gIGcgPSB0aGlzLnNpbl9wMTQgKiBzaW5waGkgKyB0aGlzLmNvc19wMTQgKiBjb3NwaGkgKiBjb3Nsb247XG4gIGtzcCA9IDE7XG4gIGlmICgoZyA+IDApIHx8IChNYXRoLmFicyhnKSA8PSBFUFNMTikpIHtcbiAgICB4ID0gdGhpcy5hICoga3NwICogY29zcGhpICogTWF0aC5zaW4oZGxvbik7XG4gICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiBrc3AgKiAodGhpcy5jb3NfcDE0ICogc2lucGhpIC0gdGhpcy5zaW5fcDE0ICogY29zcGhpICogY29zbG9uKTtcbiAgfVxuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuICB2YXIgcmg7IC8qIGhlaWdodCBhYm92ZSBlbGxpcHNvaWQgICAgICAqL1xuICB2YXIgejsgLyogYW5nbGUgICAgICAgICAgKi9cbiAgdmFyIHNpbnosIGNvc3o7IC8qIHNpbiBvZiB6IGFuZCBjb3Mgb2YgeiAgICAgICovXG4gIHZhciBjb247XG4gIHZhciBsb24sIGxhdDtcbiAgLyogSW52ZXJzZSBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICB6ID0gYXNpbnoocmggLyB0aGlzLmEpO1xuXG4gIHNpbnogPSBNYXRoLnNpbih6KTtcbiAgY29zeiA9IE1hdGguY29zKHopO1xuXG4gIGxvbiA9IHRoaXMubG9uZzA7XG4gIGlmIChNYXRoLmFicyhyaCkgPD0gRVBTTE4pIHtcbiAgICBsYXQgPSB0aGlzLmxhdDA7XG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBsYXQgPSBhc2lueihjb3N6ICogdGhpcy5zaW5fcDE0ICsgKHAueSAqIHNpbnogKiB0aGlzLmNvc19wMTQpIC8gcmgpO1xuICBjb24gPSBNYXRoLmFicyh0aGlzLmxhdDApIC0gSEFMRl9QSTtcbiAgaWYgKE1hdGguYWJzKGNvbikgPD0gRVBTTE4pIHtcbiAgICBpZiAodGhpcy5sYXQwID49IDApIHtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54LCAtIHAueSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCAtIE1hdGguYXRhbjIoLXAueCwgcC55KSk7XG4gICAgfVxuICAgIHAueCA9IGxvbjtcbiAgICBwLnkgPSBsYXQ7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMigocC54ICogc2lueiksIHJoICogdGhpcy5jb3NfcDE0ICogY29zeiAtIHAueSAqIHRoaXMuc2luX3AxNCAqIHNpbnopKTtcbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wib3J0aG9cIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsIi8vIFFTQyBwcm9qZWN0aW9uIHJld3JpdHRlbiBmcm9tIHRoZSBvcmlnaW5hbCBQUk9KNFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL3Byb2ouNC9ibG9iL21hc3Rlci9zcmMvUEpfcXNjLmNcblxuaW1wb3J0IHtFUFNMTiwgVFdPX1BJLCBTUEksIEhBTEZfUEksIEZPUlRQSX0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5cbi8qIGNvbnN0YW50cyAqL1xudmFyIEZBQ0VfRU5VTSA9IHtcbiAgICBGUk9OVDogMSxcbiAgICBSSUdIVDogMixcbiAgICBCQUNLOiAzLFxuICAgIExFRlQ6IDQsXG4gICAgVE9QOiA1LFxuICAgIEJPVFRPTTogNlxufTtcblxudmFyIEFSRUFfRU5VTSA9IHtcbiAgICBBUkVBXzA6IDEsXG4gICAgQVJFQV8xOiAyLFxuICAgIEFSRUFfMjogMyxcbiAgICBBUkVBXzM6IDRcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuXG4gIHRoaXMueDAgPSB0aGlzLngwIHx8IDA7XG4gIHRoaXMueTAgPSB0aGlzLnkwIHx8IDA7XG4gIHRoaXMubGF0MCA9IHRoaXMubGF0MCB8fCAwO1xuICB0aGlzLmxvbmcwID0gdGhpcy5sb25nMCB8fCAwO1xuICB0aGlzLmxhdF90cyA9IHRoaXMubGF0X3RzIHx8IDA7XG4gIHRoaXMudGl0bGUgPSB0aGlzLnRpdGxlIHx8IFwiUXVhZHJpbGF0ZXJhbGl6ZWQgU3BoZXJpY2FsIEN1YmVcIjtcblxuICAvKiBEZXRlcm1pbmUgdGhlIGN1YmUgZmFjZSBmcm9tIHRoZSBjZW50ZXIgb2YgcHJvamVjdGlvbi4gKi9cbiAgaWYgKHRoaXMubGF0MCA+PSBIQUxGX1BJIC0gRk9SVFBJIC8gMi4wKSB7XG4gICAgdGhpcy5mYWNlID0gRkFDRV9FTlVNLlRPUDtcbiAgfSBlbHNlIGlmICh0aGlzLmxhdDAgPD0gLShIQUxGX1BJIC0gRk9SVFBJIC8gMi4wKSkge1xuICAgIHRoaXMuZmFjZSA9IEZBQ0VfRU5VTS5CT1RUT007XG4gIH0gZWxzZSBpZiAoTWF0aC5hYnModGhpcy5sb25nMCkgPD0gRk9SVFBJKSB7XG4gICAgdGhpcy5mYWNlID0gRkFDRV9FTlVNLkZST05UO1xuICB9IGVsc2UgaWYgKE1hdGguYWJzKHRoaXMubG9uZzApIDw9IEhBTEZfUEkgKyBGT1JUUEkpIHtcbiAgICB0aGlzLmZhY2UgPSB0aGlzLmxvbmcwID4gMC4wID8gRkFDRV9FTlVNLlJJR0hUIDogRkFDRV9FTlVNLkxFRlQ7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mYWNlID0gRkFDRV9FTlVNLkJBQ0s7XG4gIH1cblxuICAvKiBGaWxsIGluIHVzZWZ1bCB2YWx1ZXMgZm9yIHRoZSBlbGxpcHNvaWQgPC0+IHNwaGVyZSBzaGlmdFxuICAgKiBkZXNjcmliZWQgaW4gW0xLMTJdLiAqL1xuICBpZiAodGhpcy5lcyAhPT0gMCkge1xuICAgIHRoaXMub25lX21pbnVzX2YgPSAxIC0gKHRoaXMuYSAtIHRoaXMuYikgLyB0aGlzLmE7XG4gICAgdGhpcy5vbmVfbWludXNfZl9zcXVhcmVkID0gdGhpcy5vbmVfbWludXNfZiAqIHRoaXMub25lX21pbnVzX2Y7XG4gIH1cbn1cblxuLy8gUVNDIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIHh5ID0ge3g6IDAsIHk6IDB9O1xuICB2YXIgbGF0LCBsb247XG4gIHZhciB0aGV0YSwgcGhpO1xuICB2YXIgdCwgbXU7XG4gIC8qIG51OyAqL1xuICB2YXIgYXJlYSA9IHt2YWx1ZTogMH07XG5cbiAgLy8gbW92ZSBsb24gYWNjb3JkaW5nIHRvIHByb2plY3Rpb24ncyBsb25cbiAgcC54IC09IHRoaXMubG9uZzA7XG5cbiAgLyogQ29udmVydCB0aGUgZ2VvZGV0aWMgbGF0aXR1ZGUgdG8gYSBnZW9jZW50cmljIGxhdGl0dWRlLlxuICAgKiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBzaGlmdCBmcm9tIHRoZSBlbGxpcHNvaWQgdG8gdGhlIHNwaGVyZVxuICAgKiBkZXNjcmliZWQgaW4gW0xLMTJdLiAqL1xuICBpZiAodGhpcy5lcyAhPT0gMCkgey8vaWYgKFAtPmVzICE9IDApIHtcbiAgICBsYXQgPSBNYXRoLmF0YW4odGhpcy5vbmVfbWludXNfZl9zcXVhcmVkICogTWF0aC50YW4ocC55KSk7XG4gIH0gZWxzZSB7XG4gICAgbGF0ID0gcC55O1xuICB9XG5cbiAgLyogQ29udmVydCB0aGUgaW5wdXQgbGF0LCBsb24gaW50byB0aGV0YSwgcGhpIGFzIHVzZWQgYnkgUVNDLlxuICAgKiBUaGlzIGRlcGVuZHMgb24gdGhlIGN1YmUgZmFjZSBhbmQgdGhlIGFyZWEgb24gaXQuXG4gICAqIEZvciB0aGUgdG9wIGFuZCBib3R0b20gZmFjZSwgd2UgY2FuIGNvbXB1dGUgdGhldGEgYW5kIHBoaVxuICAgKiBkaXJlY3RseSBmcm9tIHBoaSwgbGFtLiBGb3IgdGhlIG90aGVyIGZhY2VzLCB3ZSBtdXN0IHVzZVxuICAgKiB1bml0IHNwaGVyZSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgYXMgYW4gaW50ZXJtZWRpYXRlIHN0ZXAuICovXG4gIGxvbiA9IHAueDsgLy9sb24gPSBscC5sYW07XG4gIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5UT1ApIHtcbiAgICBwaGkgPSBIQUxGX1BJIC0gbGF0O1xuICAgIGlmIChsb24gPj0gRk9SVFBJICYmIGxvbiA8PSBIQUxGX1BJICsgRk9SVFBJKSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMDtcbiAgICAgIHRoZXRhID0gbG9uIC0gSEFMRl9QSTtcbiAgICB9IGVsc2UgaWYgKGxvbiA+IEhBTEZfUEkgKyBGT1JUUEkgfHwgbG9uIDw9IC0oSEFMRl9QSSArIEZPUlRQSSkpIHtcbiAgICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8xO1xuICAgICAgdGhldGEgPSAobG9uID4gMC4wID8gbG9uIC0gU1BJIDogbG9uICsgU1BJKTtcbiAgICB9IGVsc2UgaWYgKGxvbiA+IC0oSEFMRl9QSSArIEZPUlRQSSkgJiYgbG9uIDw9IC1GT1JUUEkpIHtcbiAgICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8yO1xuICAgICAgdGhldGEgPSBsb24gKyBIQUxGX1BJO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMztcbiAgICAgIHRoZXRhID0gbG9uO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5CT1RUT00pIHtcbiAgICBwaGkgPSBIQUxGX1BJICsgbGF0O1xuICAgIGlmIChsb24gPj0gRk9SVFBJICYmIGxvbiA8PSBIQUxGX1BJICsgRk9SVFBJKSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMDtcbiAgICAgIHRoZXRhID0gLWxvbiArIEhBTEZfUEk7XG4gICAgfSBlbHNlIGlmIChsb24gPCBGT1JUUEkgJiYgbG9uID49IC1GT1JUUEkpIHtcbiAgICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8xO1xuICAgICAgdGhldGEgPSAtbG9uO1xuICAgIH0gZWxzZSBpZiAobG9uIDwgLUZPUlRQSSAmJiBsb24gPj0gLShIQUxGX1BJICsgRk9SVFBJKSkge1xuICAgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzI7XG4gICAgICB0aGV0YSA9IC1sb24gLSBIQUxGX1BJO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMztcbiAgICAgIHRoZXRhID0gKGxvbiA+IDAuMCA/IC1sb24gKyBTUEkgOiAtbG9uIC0gU1BJKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHEsIHIsIHM7XG4gICAgdmFyIHNpbmxhdCwgY29zbGF0O1xuICAgIHZhciBzaW5sb24sIGNvc2xvbjtcblxuICAgIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5SSUdIVCkge1xuICAgICAgbG9uID0gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obG9uLCArSEFMRl9QSSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5CQUNLKSB7XG4gICAgICBsb24gPSBxc2Nfc2hpZnRfbG9uX29yaWdpbihsb24sICtTUEkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uTEVGVCkge1xuICAgICAgbG9uID0gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obG9uLCAtSEFMRl9QSSk7XG4gICAgfVxuICAgIHNpbmxhdCA9IE1hdGguc2luKGxhdCk7XG4gICAgY29zbGF0ID0gTWF0aC5jb3MobGF0KTtcbiAgICBzaW5sb24gPSBNYXRoLnNpbihsb24pO1xuICAgIGNvc2xvbiA9IE1hdGguY29zKGxvbik7XG4gICAgcSA9IGNvc2xhdCAqIGNvc2xvbjtcbiAgICByID0gY29zbGF0ICogc2lubG9uO1xuICAgIHMgPSBzaW5sYXQ7XG5cbiAgICBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uRlJPTlQpIHtcbiAgICAgIHBoaSA9IE1hdGguYWNvcyhxKTtcbiAgICAgIHRoZXRhID0gcXNjX2Z3ZF9lcXVhdF9mYWNlX3RoZXRhKHBoaSwgcywgciwgYXJlYSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5SSUdIVCkge1xuICAgICAgcGhpID0gTWF0aC5hY29zKHIpO1xuICAgICAgdGhldGEgPSBxc2NfZndkX2VxdWF0X2ZhY2VfdGhldGEocGhpLCBzLCAtcSwgYXJlYSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5CQUNLKSB7XG4gICAgICBwaGkgPSBNYXRoLmFjb3MoLXEpO1xuICAgICAgdGhldGEgPSBxc2NfZndkX2VxdWF0X2ZhY2VfdGhldGEocGhpLCBzLCAtciwgYXJlYSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5MRUZUKSB7XG4gICAgICBwaGkgPSBNYXRoLmFjb3MoLXIpO1xuICAgICAgdGhldGEgPSBxc2NfZndkX2VxdWF0X2ZhY2VfdGhldGEocGhpLCBzLCBxLCBhcmVhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogSW1wb3NzaWJsZSAqL1xuICAgICAgcGhpID0gdGhldGEgPSAwO1xuICAgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzA7XG4gICAgfVxuICB9XG5cbiAgLyogQ29tcHV0ZSBtdSBhbmQgbnUgZm9yIHRoZSBhcmVhIG9mIGRlZmluaXRpb24uXG4gICAqIEZvciBtdSwgc2VlIEVxLiAoMy0yMSkgaW4gW09MNzZdLCBidXQgbm90ZSB0aGUgdHlwb3M6XG4gICAqIGNvbXBhcmUgd2l0aCBFcS4gKDMtMTQpLiBGb3IgbnUsIHNlZSBFcS4gKDMtMzgpLiAqL1xuICBtdSA9IE1hdGguYXRhbigoMTIgLyBTUEkpICogKHRoZXRhICsgTWF0aC5hY29zKE1hdGguc2luKHRoZXRhKSAqIE1hdGguY29zKEZPUlRQSSkpIC0gSEFMRl9QSSkpO1xuICB0ID0gTWF0aC5zcXJ0KCgxIC0gTWF0aC5jb3MocGhpKSkgLyAoTWF0aC5jb3MobXUpICogTWF0aC5jb3MobXUpKSAvICgxIC0gTWF0aC5jb3MoTWF0aC5hdGFuKDEgLyBNYXRoLmNvcyh0aGV0YSkpKSkpO1xuXG4gIC8qIEFwcGx5IHRoZSByZXN1bHQgdG8gdGhlIHJlYWwgYXJlYS4gKi9cbiAgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzEpIHtcbiAgICBtdSArPSBIQUxGX1BJO1xuICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzIpIHtcbiAgICBtdSArPSBTUEk7XG4gIH0gZWxzZSBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMykge1xuICAgIG11ICs9IDEuNSAqIFNQSTtcbiAgfVxuXG4gIC8qIE5vdyBjb21wdXRlIHgsIHkgZnJvbSBtdSBhbmQgbnUgKi9cbiAgeHkueCA9IHQgKiBNYXRoLmNvcyhtdSk7XG4gIHh5LnkgPSB0ICogTWF0aC5zaW4obXUpO1xuICB4eS54ID0geHkueCAqIHRoaXMuYSArIHRoaXMueDA7XG4gIHh5LnkgPSB4eS55ICogdGhpcy5hICsgdGhpcy55MDtcblxuICBwLnggPSB4eS54O1xuICBwLnkgPSB4eS55O1xuICByZXR1cm4gcDtcbn1cblxuLy8gUVNDIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIGxwID0ge2xhbTogMCwgcGhpOiAwfTtcbiAgdmFyIG11LCBudSwgY29zbXUsIHRhbm51O1xuICB2YXIgdGFudGhldGEsIHRoZXRhLCBjb3NwaGksIHBoaTtcbiAgdmFyIHQ7XG4gIHZhciBhcmVhID0ge3ZhbHVlOiAwfTtcblxuICAvKiBkZS1vZmZzZXQgKi9cbiAgcC54ID0gKHAueCAtIHRoaXMueDApIC8gdGhpcy5hO1xuICBwLnkgPSAocC55IC0gdGhpcy55MCkgLyB0aGlzLmE7XG5cbiAgLyogQ29udmVydCB0aGUgaW5wdXQgeCwgeSB0byB0aGUgbXUgYW5kIG51IGFuZ2xlcyBhcyB1c2VkIGJ5IFFTQy5cbiAgICogVGhpcyBkZXBlbmRzIG9uIHRoZSBhcmVhIG9mIHRoZSBjdWJlIGZhY2UuICovXG4gIG51ID0gTWF0aC5hdGFuKE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpKTtcbiAgbXUgPSBNYXRoLmF0YW4yKHAueSwgcC54KTtcbiAgaWYgKHAueCA+PSAwLjAgJiYgcC54ID49IE1hdGguYWJzKHAueSkpIHtcbiAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMDtcbiAgfSBlbHNlIGlmIChwLnkgPj0gMC4wICYmIHAueSA+PSBNYXRoLmFicyhwLngpKSB7XG4gICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzE7XG4gICAgbXUgLT0gSEFMRl9QSTtcbiAgfSBlbHNlIGlmIChwLnggPCAwLjAgJiYgLXAueCA+PSBNYXRoLmFicyhwLnkpKSB7XG4gICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzI7XG4gICAgbXUgPSAobXUgPCAwLjAgPyBtdSArIFNQSSA6IG11IC0gU1BJKTtcbiAgfSBlbHNlIHtcbiAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMztcbiAgICBtdSArPSBIQUxGX1BJO1xuICB9XG5cbiAgLyogQ29tcHV0ZSBwaGkgYW5kIHRoZXRhIGZvciB0aGUgYXJlYSBvZiBkZWZpbml0aW9uLlxuICAgKiBUaGUgaW52ZXJzZSBwcm9qZWN0aW9uIGlzIG5vdCBkZXNjcmliZWQgaW4gdGhlIG9yaWdpbmFsIHBhcGVyLCBidXQgc29tZVxuICAgKiBnb29kIGhpbnRzIGNhbiBiZSBmb3VuZCBoZXJlIChhcyBvZiAyMDExLTEyLTE0KTpcbiAgICogaHR0cDovL2ZpdHMuZ3NmYy5uYXNhLmdvdi9maXRzYml0cy9zYWYuOTMvc2FmLjkzMDJcbiAgICogKHNlYXJjaCBmb3IgXCJNZXNzYWdlLUlkOiA8OTMwMjE4MTc1OS5BQTI1NDc3IGF0IGZpdHMuY3YubnJhby5lZHU+XCIpICovXG4gIHQgPSAoU1BJIC8gMTIpICogTWF0aC50YW4obXUpO1xuICB0YW50aGV0YSA9IE1hdGguc2luKHQpIC8gKE1hdGguY29zKHQpIC0gKDEgLyBNYXRoLnNxcnQoMikpKTtcbiAgdGhldGEgPSBNYXRoLmF0YW4odGFudGhldGEpO1xuICBjb3NtdSA9IE1hdGguY29zKG11KTtcbiAgdGFubnUgPSBNYXRoLnRhbihudSk7XG4gIGNvc3BoaSA9IDEgLSBjb3NtdSAqIGNvc211ICogdGFubnUgKiB0YW5udSAqICgxIC0gTWF0aC5jb3MoTWF0aC5hdGFuKDEgLyBNYXRoLmNvcyh0aGV0YSkpKSk7XG4gIGlmIChjb3NwaGkgPCAtMSkge1xuICAgIGNvc3BoaSA9IC0xO1xuICB9IGVsc2UgaWYgKGNvc3BoaSA+ICsxKSB7XG4gICAgY29zcGhpID0gKzE7XG4gIH1cblxuICAvKiBBcHBseSB0aGUgcmVzdWx0IHRvIHRoZSByZWFsIGFyZWEgb24gdGhlIGN1YmUgZmFjZS5cbiAgICogRm9yIHRoZSB0b3AgYW5kIGJvdHRvbSBmYWNlLCB3ZSBjYW4gY29tcHV0ZSBwaGkgYW5kIGxhbSBkaXJlY3RseS5cbiAgICogRm9yIHRoZSBvdGhlciBmYWNlcywgd2UgbXVzdCB1c2UgdW5pdCBzcGhlcmUgY2FydGVzaWFuIGNvb3JkaW5hdGVzXG4gICAqIGFzIGFuIGludGVybWVkaWF0ZSBzdGVwLiAqL1xuICBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uVE9QKSB7XG4gICAgcGhpID0gTWF0aC5hY29zKGNvc3BoaSk7XG4gICAgbHAucGhpID0gSEFMRl9QSSAtIHBoaTtcbiAgICBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMCkge1xuICAgICAgbHAubGFtID0gdGhldGEgKyBIQUxGX1BJO1xuICAgIH0gZWxzZSBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMSkge1xuICAgICAgbHAubGFtID0gKHRoZXRhIDwgMC4wID8gdGhldGEgKyBTUEkgOiB0aGV0YSAtIFNQSSk7XG4gICAgfSBlbHNlIGlmIChhcmVhLnZhbHVlID09PSBBUkVBX0VOVU0uQVJFQV8yKSB7XG4gICAgICBscC5sYW0gPSB0aGV0YSAtIEhBTEZfUEk7XG4gICAgfSBlbHNlIC8qIGFyZWEudmFsdWUgPT0gQVJFQV9FTlVNLkFSRUFfMyAqLyB7XG4gICAgICBscC5sYW0gPSB0aGV0YTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uQk9UVE9NKSB7XG4gICAgcGhpID0gTWF0aC5hY29zKGNvc3BoaSk7XG4gICAgbHAucGhpID0gcGhpIC0gSEFMRl9QSTtcbiAgICBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMCkge1xuICAgICAgbHAubGFtID0gLXRoZXRhICsgSEFMRl9QSTtcbiAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzEpIHtcbiAgICAgIGxwLmxhbSA9IC10aGV0YTtcbiAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzIpIHtcbiAgICAgIGxwLmxhbSA9IC10aGV0YSAtIEhBTEZfUEk7XG4gICAgfSBlbHNlIC8qIGFyZWEudmFsdWUgPT0gQVJFQV9FTlVNLkFSRUFfMyAqLyB7XG4gICAgICBscC5sYW0gPSAodGhldGEgPCAwLjAgPyAtdGhldGEgLSBTUEkgOiAtdGhldGEgKyBTUEkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvKiBDb21wdXRlIHBoaSBhbmQgbGFtIHZpYSBjYXJ0ZXNpYW4gdW5pdCBzcGhlcmUgY29vcmRpbmF0ZXMuICovXG4gICAgdmFyIHEsIHIsIHM7XG4gICAgcSA9IGNvc3BoaTtcbiAgICB0ID0gcSAqIHE7XG4gICAgaWYgKHQgPj0gMSkge1xuICAgICAgcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBNYXRoLnNxcnQoMSAtIHQpICogTWF0aC5zaW4odGhldGEpO1xuICAgIH1cbiAgICB0ICs9IHMgKiBzO1xuICAgIGlmICh0ID49IDEpIHtcbiAgICAgIHIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gTWF0aC5zcXJ0KDEgLSB0KTtcbiAgICB9XG4gICAgLyogUm90YXRlIHEscixzIGludG8gdGhlIGNvcnJlY3QgYXJlYS4gKi9cbiAgICBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMSkge1xuICAgICAgdCA9IHI7XG4gICAgICByID0gLXM7XG4gICAgICBzID0gdDtcbiAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzIpIHtcbiAgICAgIHIgPSAtcjtcbiAgICAgIHMgPSAtcztcbiAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzMpIHtcbiAgICAgIHQgPSByO1xuICAgICAgciA9IHM7XG4gICAgICBzID0gLXQ7XG4gICAgfVxuICAgIC8qIFJvdGF0ZSBxLHIscyBpbnRvIHRoZSBjb3JyZWN0IGN1YmUgZmFjZS4gKi9cbiAgICBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uUklHSFQpIHtcbiAgICAgIHQgPSBxO1xuICAgICAgcSA9IC1yO1xuICAgICAgciA9IHQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5CQUNLKSB7XG4gICAgICBxID0gLXE7XG4gICAgICByID0gLXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5MRUZUKSB7XG4gICAgICB0ID0gcTtcbiAgICAgIHEgPSByO1xuICAgICAgciA9IC10O1xuICAgIH1cbiAgICAvKiBOb3cgY29tcHV0ZSBwaGkgYW5kIGxhbSBmcm9tIHRoZSB1bml0IHNwaGVyZSBjb29yZGluYXRlcy4gKi9cbiAgICBscC5waGkgPSBNYXRoLmFjb3MoLXMpIC0gSEFMRl9QSTtcbiAgICBscC5sYW0gPSBNYXRoLmF0YW4yKHIsIHEpO1xuICAgIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5SSUdIVCkge1xuICAgICAgbHAubGFtID0gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obHAubGFtLCAtSEFMRl9QSSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5CQUNLKSB7XG4gICAgICBscC5sYW0gPSBxc2Nfc2hpZnRfbG9uX29yaWdpbihscC5sYW0sIC1TUEkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uTEVGVCkge1xuICAgICAgbHAubGFtID0gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obHAubGFtLCArSEFMRl9QSSk7XG4gICAgfVxuICB9XG5cbiAgLyogQXBwbHkgdGhlIHNoaWZ0IGZyb20gdGhlIHNwaGVyZSB0byB0aGUgZWxsaXBzb2lkIGFzIGRlc2NyaWJlZFxuICAgKiBpbiBbTEsxMl0uICovXG4gIGlmICh0aGlzLmVzICE9PSAwKSB7XG4gICAgdmFyIGludmVydF9zaWduO1xuICAgIHZhciB0YW5waGksIHhhO1xuICAgIGludmVydF9zaWduID0gKGxwLnBoaSA8IDAgPyAxIDogMCk7XG4gICAgdGFucGhpID0gTWF0aC50YW4obHAucGhpKTtcbiAgICB4YSA9IHRoaXMuYiAvIE1hdGguc3FydCh0YW5waGkgKiB0YW5waGkgKyB0aGlzLm9uZV9taW51c19mX3NxdWFyZWQpO1xuICAgIGxwLnBoaSA9IE1hdGguYXRhbihNYXRoLnNxcnQodGhpcy5hICogdGhpcy5hIC0geGEgKiB4YSkgLyAodGhpcy5vbmVfbWludXNfZiAqIHhhKSk7XG4gICAgaWYgKGludmVydF9zaWduKSB7XG4gICAgICBscC5waGkgPSAtbHAucGhpO1xuICAgIH1cbiAgfVxuXG4gIGxwLmxhbSArPSB0aGlzLmxvbmcwO1xuICBwLnggPSBscC5sYW07XG4gIHAueSA9IGxwLnBoaTtcbiAgcmV0dXJuIHA7XG59XG5cbi8qIEhlbHBlciBmdW5jdGlvbiBmb3IgZm9yd2FyZCBwcm9qZWN0aW9uOiBjb21wdXRlIHRoZSB0aGV0YSBhbmdsZVxuICogYW5kIGRldGVybWluZSB0aGUgYXJlYSBudW1iZXIuICovXG5mdW5jdGlvbiBxc2NfZndkX2VxdWF0X2ZhY2VfdGhldGEocGhpLCB5LCB4LCBhcmVhKSB7XG4gIHZhciB0aGV0YTtcbiAgaWYgKHBoaSA8IEVQU0xOKSB7XG4gICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzA7XG4gICAgdGhldGEgPSAwLjA7XG4gIH0gZWxzZSB7XG4gICAgdGhldGEgPSBNYXRoLmF0YW4yKHksIHgpO1xuICAgIGlmIChNYXRoLmFicyh0aGV0YSkgPD0gRk9SVFBJKSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMDtcbiAgICB9IGVsc2UgaWYgKHRoZXRhID4gRk9SVFBJICYmIHRoZXRhIDw9IEhBTEZfUEkgKyBGT1JUUEkpIHtcbiAgICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8xO1xuICAgICAgdGhldGEgLT0gSEFMRl9QSTtcbiAgICB9IGVsc2UgaWYgKHRoZXRhID4gSEFMRl9QSSArIEZPUlRQSSB8fCB0aGV0YSA8PSAtKEhBTEZfUEkgKyBGT1JUUEkpKSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMjtcbiAgICAgIHRoZXRhID0gKHRoZXRhID49IDAuMCA/IHRoZXRhIC0gU1BJIDogdGhldGEgKyBTUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMztcbiAgICAgIHRoZXRhICs9IEhBTEZfUEk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGV0YTtcbn1cblxuLyogSGVscGVyIGZ1bmN0aW9uOiBzaGlmdCB0aGUgbG9uZ2l0dWRlLiAqL1xuZnVuY3Rpb24gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obG9uLCBvZmZzZXQpIHtcbiAgdmFyIHNsb24gPSBsb24gKyBvZmZzZXQ7XG4gIGlmIChzbG9uIDwgLVNQSSkge1xuICAgIHNsb24gKz0gVFdPX1BJO1xuICB9IGVsc2UgaWYgKHNsb24gPiArU1BJKSB7XG4gICAgc2xvbiAtPSBUV09fUEk7XG4gIH1cbiAgcmV0dXJuIHNsb247XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJRdWFkcmlsYXRlcmFsaXplZCBTcGhlcmljYWwgQ3ViZVwiLCBcIlF1YWRyaWxhdGVyYWxpemVkX1NwaGVyaWNhbF9DdWJlXCIsIFwicXNjXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG5cbiIsIi8vIFJvYmluc29uIHByb2plY3Rpb25cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9PU0dlby9wcm9qLjQvYmxvYi9tYXN0ZXIvc3JjL1BKX3JvYmluLmNcbi8vIFBvbHlub21pYWwgY29lZmljaWVudHMgZnJvbSBodHRwOi8vYXJ0aWNsZS5nbWFuZS5vcmcvZ21hbmUuY29tcC5naXMucHJvai00LmRldmVsLzYwMzlcblxuaW1wb3J0IHtIQUxGX1BJLCBEMlIsIFIyRCwgRVBTTE59IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuXG52YXIgQ09FRlNfWCA9IFtcbiAgICBbMS4wMDAwLCAyLjIxOTllLTE3LCAtNy4xNTUxNWUtMDUsIDMuMTEwM2UtMDZdLFxuICAgIFswLjk5ODYsIC0wLjAwMDQ4MjI0MywgLTIuNDg5N2UtMDUsIC0xLjMzMDllLTA2XSxcbiAgICBbMC45OTU0LCAtMC4wMDA4MzEwMywgLTQuNDg2MDVlLTA1LCAtOS44NjcwMWUtMDddLFxuICAgIFswLjk5MDAsIC0wLjAwMTM1MzY0LCAtNS45NjYxZS0wNSwgMy42Nzc3ZS0wNl0sXG4gICAgWzAuOTgyMiwgLTAuMDAxNjc0NDIsIC00LjQ5NTQ3ZS0wNiwgLTUuNzI0MTFlLTA2XSxcbiAgICBbMC45NzMwLCAtMC4wMDIxNDg2OCwgLTkuMDM1NzFlLTA1LCAxLjg3MzZlLTA4XSxcbiAgICBbMC45NjAwLCAtMC4wMDMwNTA4NSwgLTkuMDA3NjFlLTA1LCAxLjY0OTE3ZS0wNl0sXG4gICAgWzAuOTQyNywgLTAuMDAzODI3OTIsIC02LjUzMzg2ZS0wNSwgLTIuNjE1NGUtMDZdLFxuICAgIFswLjkyMTYsIC0wLjAwNDY3NzQ2LCAtMC4wMDAxMDQ1NywgNC44MTI0M2UtMDZdLFxuICAgIFswLjg5NjIsIC0wLjAwNTM2MjIzLCAtMy4yMzgzMWUtMDUsIC01LjQzNDMyZS0wNl0sXG4gICAgWzAuODY3OSwgLTAuMDA2MDkzNjMsIC0wLjAwMDExMzg5OCwgMy4zMjQ4NGUtMDZdLFxuICAgIFswLjgzNTAsIC0wLjAwNjk4MzI1LCAtNi40MDI1M2UtMDUsIDkuMzQ5NTllLTA3XSxcbiAgICBbMC43OTg2LCAtMC4wMDc1NTMzOCwgLTUuMDAwMDllLTA1LCA5LjM1MzI0ZS0wN10sXG4gICAgWzAuNzU5NywgLTAuMDA3OTgzMjQsIC0zLjU5NzFlLTA1LCAtMi4yNzYyNmUtMDZdLFxuICAgIFswLjcxODYsIC0wLjAwODUxMzY3LCAtNy4wMTE0OWUtMDUsIC04LjYzMDNlLTA2XSxcbiAgICBbMC42NzMyLCAtMC4wMDk4NjIwOSwgLTAuMDAwMTk5NTY5LCAxLjkxOTc0ZS0wNV0sXG4gICAgWzAuNjIxMywgLTAuMDEwNDE4LCA4LjgzOTIzZS0wNSwgNi4yNDA1MWUtMDZdLFxuICAgIFswLjU3MjIsIC0wLjAwOTA2NjAxLCAwLjAwMDE4MiwgNi4yNDA1MWUtMDZdLFxuICAgIFswLjUzMjIsIC0wLjAwNjc3Nzk3LCAwLjAwMDI3NTYwOCwgNi4yNDA1MWUtMDZdXG5dO1xuXG52YXIgQ09FRlNfWSA9IFtcbiAgICBbLTUuMjA0MTdlLTE4LCAwLjAxMjQsIDEuMjE0MzFlLTE4LCAtOC40NTI4NGUtMTFdLFxuICAgIFswLjA2MjAsIDAuMDEyNCwgLTEuMjY3OTNlLTA5LCA0LjIyNjQyZS0xMF0sXG4gICAgWzAuMTI0MCwgMC4wMTI0LCA1LjA3MTcxZS0wOSwgLTEuNjA2MDRlLTA5XSxcbiAgICBbMC4xODYwLCAwLjAxMjM5OTksIC0xLjkwMTg5ZS0wOCwgNi4wMDE1MmUtMDldLFxuICAgIFswLjI0ODAsIDAuMDEyNDAwMiwgNy4xMDAzOWUtMDgsIC0yLjI0ZS0wOF0sXG4gICAgWzAuMzEwMCwgMC4wMTIzOTkyLCAtMi42NDk5N2UtMDcsIDguMzU5ODZlLTA4XSxcbiAgICBbMC4zNzIwLCAwLjAxMjQwMjksIDkuODg5ODNlLTA3LCAtMy4xMTk5NGUtMDddLFxuICAgIFswLjQzNDAsIDAuMDEyMzg5MywgLTMuNjkwOTNlLTA2LCAtNC4zNTYyMWUtMDddLFxuICAgIFswLjQ5NTgsIDAuMDEyMzE5OCwgLTEuMDIyNTJlLTA1LCAtMy40NTUyM2UtMDddLFxuICAgIFswLjU1NzEsIDAuMDEyMTkxNiwgLTEuNTQwODFlLTA1LCAtNS44MjI4OGUtMDddLFxuICAgIFswLjYxNzYsIDAuMDExOTkzOCwgLTIuNDE0MjRlLTA1LCAtNS4yNTMyN2UtMDddLFxuICAgIFswLjY3NjksIDAuMDExNzEzLCAtMy4yMDIyM2UtMDUsIC01LjE2NDA1ZS0wN10sXG4gICAgWzAuNzM0NiwgMC4wMTEzNTQxLCAtMy45NzY4NGUtMDUsIC02LjA5MDUyZS0wN10sXG4gICAgWzAuNzkwMywgMC4wMTA5MTA3LCAtNC44OTA0MmUtMDUsIC0xLjA0NzM5ZS0wNl0sXG4gICAgWzAuODQzNSwgMC4wMTAzNDMxLCAtNi40NjE1ZS0wNSwgLTEuNDAzNzRlLTA5XSxcbiAgICBbMC44OTM2LCAwLjAwOTY5Njg2LCAtNi40NjM2ZS0wNSwgLTguNTQ3ZS0wNl0sXG4gICAgWzAuOTM5NCwgMC4wMDg0MDk0NywgLTAuMDAwMTkyODQxLCAtNC4yMTA2ZS0wNl0sXG4gICAgWzAuOTc2MSwgMC4wMDYxNjUyNywgLTAuMDAwMjU2LCAtNC4yMTA2ZS0wNl0sXG4gICAgWzEuMDAwMCwgMC4wMDMyODk0NywgLTAuMDAwMzE5MTU5LCAtNC4yMTA2ZS0wNl1cbl07XG5cbnZhciBGWEMgPSAwLjg0ODc7XG52YXIgRllDID0gMS4zNTIzO1xudmFyIEMxID0gUjJELzU7IC8vIHJhZCB0byA1LWRlZ3JlZSBpbnRlcnZhbFxudmFyIFJDMSA9IDEvQzE7XG52YXIgTk9ERVMgPSAxODtcblxudmFyIHBvbHkzX3ZhbCA9IGZ1bmN0aW9uKGNvZWZzLCB4KSB7XG4gICAgcmV0dXJuIGNvZWZzWzBdICsgeCAqIChjb2Vmc1sxXSArIHggKiAoY29lZnNbMl0gKyB4ICogY29lZnNbM10pKTtcbn07XG5cbnZhciBwb2x5M19kZXIgPSBmdW5jdGlvbihjb2VmcywgeCkge1xuICAgIHJldHVybiBjb2Vmc1sxXSArIHggKiAoMiAqIGNvZWZzWzJdICsgeCAqIDMgKiBjb2Vmc1szXSk7XG59O1xuXG5mdW5jdGlvbiBuZXd0b25fcmFwc2hvbihmX2RmLCBzdGFydCwgbWF4X2VyciwgaXRlcnMpIHtcbiAgICB2YXIgeCA9IHN0YXJ0O1xuICAgIGZvciAoOyBpdGVyczsgLS1pdGVycykge1xuICAgICAgICB2YXIgdXBkID0gZl9kZih4KTtcbiAgICAgICAgeCAtPSB1cGQ7XG4gICAgICAgIGlmIChNYXRoLmFicyh1cGQpIDwgbWF4X2Vycikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMueDAgPSB0aGlzLngwIHx8IDA7XG4gICAgdGhpcy55MCA9IHRoaXMueTAgfHwgMDtcbiAgICB0aGlzLmxvbmcwID0gdGhpcy5sb25nMCB8fCAwO1xuICAgIHRoaXMuZXMgPSAwO1xuICAgIHRoaXMudGl0bGUgPSB0aGlzLnRpdGxlIHx8IFwiUm9iaW5zb25cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQobGwpIHtcbiAgICB2YXIgbG9uID0gYWRqdXN0X2xvbihsbC54IC0gdGhpcy5sb25nMCk7XG5cbiAgICB2YXIgZHBoaSA9IE1hdGguYWJzKGxsLnkpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vcihkcGhpICogQzEpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2UgaWYgKGkgPj0gTk9ERVMpIHtcbiAgICAgICAgaSA9IE5PREVTIC0gMTtcbiAgICB9XG4gICAgZHBoaSA9IFIyRCAqIChkcGhpIC0gUkMxICogaSk7XG4gICAgdmFyIHh5ID0ge1xuICAgICAgICB4OiBwb2x5M192YWwoQ09FRlNfWFtpXSwgZHBoaSkgKiBsb24sXG4gICAgICAgIHk6IHBvbHkzX3ZhbChDT0VGU19ZW2ldLCBkcGhpKVxuICAgIH07XG4gICAgaWYgKGxsLnkgPCAwKSB7XG4gICAgICAgIHh5LnkgPSAteHkueTtcbiAgICB9XG5cbiAgICB4eS54ID0geHkueCAqIHRoaXMuYSAqIEZYQyArIHRoaXMueDA7XG4gICAgeHkueSA9IHh5LnkgKiB0aGlzLmEgKiBGWUMgKyB0aGlzLnkwO1xuICAgIHJldHVybiB4eTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UoeHkpIHtcbiAgICB2YXIgbGwgPSB7XG4gICAgICAgIHg6ICh4eS54IC0gdGhpcy54MCkgLyAodGhpcy5hICogRlhDKSxcbiAgICAgICAgeTogTWF0aC5hYnMoeHkueSAtIHRoaXMueTApIC8gKHRoaXMuYSAqIEZZQylcbiAgICB9O1xuXG4gICAgaWYgKGxsLnkgPj0gMSkgeyAvLyBwYXRob2xvZ2ljIGNhc2VcbiAgICAgICAgbGwueCAvPSBDT0VGU19YW05PREVTXVswXTtcbiAgICAgICAgbGwueSA9IHh5LnkgPCAwID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpbmQgdGFibGUgaW50ZXJ2YWxcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGxsLnkgKiBOT0RFUyk7XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA+PSBOT0RFUykge1xuICAgICAgICAgICAgaSA9IE5PREVTIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoQ09FRlNfWVtpXVswXSA+IGxsLnkpIHtcbiAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKENPRUZTX1lbaSsxXVswXSA8PSBsbC55KSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBpbiA1IGRlZ3JlZSBpbnRlcnZhbFxuICAgICAgICB2YXIgY29lZnMgPSBDT0VGU19ZW2ldO1xuICAgICAgICB2YXIgdCA9IDUgKiAobGwueSAtIGNvZWZzWzBdKSAvIChDT0VGU19ZW2krMV1bMF0gLSBjb2Vmc1swXSk7XG4gICAgICAgIC8vIGZpbmQgdCBzbyB0aGF0IHBvbHkzX3ZhbChjb2VmcywgdCkgPSBsbC55XG4gICAgICAgIHQgPSBuZXd0b25fcmFwc2hvbihmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICByZXR1cm4gKHBvbHkzX3ZhbChjb2VmcywgeCkgLSBsbC55KSAvIHBvbHkzX2Rlcihjb2VmcywgeCk7XG4gICAgICAgIH0sIHQsIEVQU0xOLCAxMDApO1xuXG4gICAgICAgIGxsLnggLz0gcG9seTNfdmFsKENPRUZTX1hbaV0sIHQpO1xuICAgICAgICBsbC55ID0gKDUgKiBpICsgdCkgKiBEMlI7XG4gICAgICAgIGlmICh4eS55IDwgMCkge1xuICAgICAgICAgICAgbGwueSA9IC1sbC55O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGwueCA9IGFkanVzdF9sb24obGwueCArIHRoaXMubG9uZzApO1xuICAgIHJldHVybiBsbDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIlJvYmluc29uXCIsIFwicm9iaW5cIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCB7XG4gICAgZ2VvZGV0aWNUb0dlb2NlbnRyaWMsXG4gICAgZ2VvY2VudHJpY1RvR2VvZGV0aWNcbn0gZnJvbSAnLi4vZGF0dW1VdGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMubmFtZSA9ICdnZW9jZW50JztcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gICAgdmFyIHBvaW50ID0gZ2VvZGV0aWNUb0dlb2NlbnRyaWMocCwgdGhpcy5lcywgdGhpcy5hKTtcbiAgICByZXR1cm4gcG9pbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgICB2YXIgcG9pbnQgPSBnZW9jZW50cmljVG9HZW9kZXRpYyhwLCB0aGlzLmVzLCB0aGlzLmEsIHRoaXMuYik7XG4gICAgcmV0dXJuIHBvaW50O1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiR2VvY2VudHJpY1wiLCAnZ2VvY2VudHJpYycsIFwiZ2VvY2VudFwiLCBcIkdlb2NlbnRcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdDogaW5pdCxcbiAgICBmb3J3YXJkOiBmb3J3YXJkLFxuICAgIGludmVyc2U6IGludmVyc2UsXG4gICAgbmFtZXM6IG5hbWVzXG59OyIsIlxudmFyIG1vZGUgPSB7XG4gIE5fUE9MRTogMCxcbiAgU19QT0xFOiAxLFxuICBFUVVJVDogMixcbiAgT0JMSVE6IDNcbn07XG5cbmltcG9ydCB7IEQyUiwgSEFMRl9QSSwgRVBTTE4gfSBmcm9tIFwiLi4vY29uc3RhbnRzL3ZhbHVlc1wiO1xuaW1wb3J0IGh5cG90IGZyb20gXCIuLi9jb21tb24vaHlwb3RcIjtcblxudmFyIHBhcmFtcyA9IHtcbiAgaDogICAgIHsgZGVmOiAxMDAwMDAsIG51bTogdHJ1ZSB9LCAgICAgICAgICAgLy8gZGVmYXVsdCBpcyBLYXJtYW4gbGluZSwgbm8gZGVmYXVsdCBpbiBQUk9KLjdcbiAgYXppOiAgIHsgZGVmOiAwLCBudW06IHRydWUsIGRlZ3JlZXM6IHRydWUgfSwgLy8gZGVmYXVsdCBpcyBOb3J0aFxuICB0aWx0OiAgeyBkZWY6IDAsIG51bTogdHJ1ZSwgZGVncmVlczogdHJ1ZSB9LCAvLyBkZWZhdWx0IGlzIE5hZGlyXG4gIGxvbmcwOiB7IGRlZjogMCwgbnVtOiB0cnVlIH0sICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgR3JlZW53aWNoLCBjb252ZXJzaW9uIHRvIHJhZCBpcyBhdXRvbWF0aWNcbiAgbGF0MDogIHsgZGVmOiAwLCBudW06IHRydWUgfSAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBpcyBFcXVhdG9yLCBjb252ZXJzaW9uIHRvIHJhZCBpcyBhdXRvbWF0aWNcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICBpZiAodHlwZW9mIHRoaXNbcF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXNbcF0gPSBwYXJhbXNbcF0uZGVmO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zW3BdLm51bSAmJiBpc05hTih0aGlzW3BdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgdmFsdWUsIG11c3QgYmUgbnVtZXJpYyBcIiArIHAgKyBcIiA9IFwiICsgdGhpc1twXSk7XG4gICAgfSBlbHNlIGlmIChwYXJhbXNbcF0ubnVtKSB7XG4gICAgICB0aGlzW3BdID0gcGFyc2VGbG9hdCh0aGlzW3BdKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtc1twXS5kZWdyZWVzKSB7XG4gICAgICB0aGlzW3BdID0gdGhpc1twXSAqIEQyUjtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgaWYgKE1hdGguYWJzKChNYXRoLmFicyh0aGlzLmxhdDApIC0gSEFMRl9QSSkpIDwgRVBTTE4pIHtcbiAgICB0aGlzLm1vZGUgPSB0aGlzLmxhdDAgPCAwID8gbW9kZS5TX1BPTEUgOiBtb2RlLk5fUE9MRTtcbiAgfSBlbHNlIGlmIChNYXRoLmFicyh0aGlzLmxhdDApIDwgRVBTTE4pIHtcbiAgICB0aGlzLm1vZGUgPSBtb2RlLkVRVUlUO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubW9kZSA9IG1vZGUuT0JMSVE7XG4gICAgdGhpcy5zaW5waDAgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICAgIHRoaXMuY29zcGgwID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgfVxuXG4gIHRoaXMucG4xID0gdGhpcy5oIC8gdGhpcy5hOyAgLy8gTm9ybWFsaXplIHJlbGF0aXZlIHRvIHRoZSBFYXJ0aCdzIHJhZGl1c1xuXG4gIGlmICh0aGlzLnBuMSA8PSAwIHx8IHRoaXMucG4xID4gMWUxMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaGVpZ2h0XCIpO1xuICB9XG4gIFxuICB0aGlzLnAgPSAxICsgdGhpcy5wbjE7XG4gIHRoaXMucnAgPSAxIC8gdGhpcy5wO1xuICB0aGlzLmgxID0gMSAvIHRoaXMucG4xO1xuICB0aGlzLnBmYWN0ID0gKHRoaXMucCArIDEpICogdGhpcy5oMTtcbiAgdGhpcy5lcyA9IDA7XG5cbiAgdmFyIG9tZWdhID0gdGhpcy50aWx0O1xuICB2YXIgZ2FtbWEgPSB0aGlzLmF6aTtcbiAgdGhpcy5jZyA9IE1hdGguY29zKGdhbW1hKTtcbiAgdGhpcy5zZyA9IE1hdGguc2luKGdhbW1hKTtcbiAgdGhpcy5jdyA9IE1hdGguY29zKG9tZWdhKTtcbiAgdGhpcy5zdyA9IE1hdGguc2luKG9tZWdhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuICBwLnggLT0gdGhpcy5sb25nMDtcbiAgdmFyIHNpbnBoaSA9IE1hdGguc2luKHAueSk7XG4gIHZhciBjb3NwaGkgPSBNYXRoLmNvcyhwLnkpO1xuICB2YXIgY29zbGFtID0gTWF0aC5jb3MocC54KTtcbiAgdmFyIHgsIHk7XG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBtb2RlLk9CTElROlxuICAgICAgeSA9IHRoaXMuc2lucGgwICogc2lucGhpICsgdGhpcy5jb3NwaDAgKiBjb3NwaGkgKiBjb3NsYW07XG4gICAgICBicmVhaztcbiAgICBjYXNlIG1vZGUuRVFVSVQ6XG4gICAgICB5ID0gY29zcGhpICogY29zbGFtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBtb2RlLlNfUE9MRTpcbiAgICAgIHkgPSAtc2lucGhpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBtb2RlLk5fUE9MRTpcbiAgICAgIHkgPSBzaW5waGk7XG4gICAgICBicmVhaztcbiAgfVxuICB5ID0gdGhpcy5wbjEgLyAodGhpcy5wIC0geSk7XG4gIHggPSB5ICogY29zcGhpICogTWF0aC5zaW4ocC54KTtcblxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgbW9kZS5PQkxJUTpcbiAgICAgIHkgKj0gdGhpcy5jb3NwaDAgKiBzaW5waGkgLSB0aGlzLnNpbnBoMCAqIGNvc3BoaSAqIGNvc2xhbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgbW9kZS5FUVVJVDpcbiAgICAgIHkgKj0gc2lucGhpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBtb2RlLk5fUE9MRTpcbiAgICAgIHkgKj0gLShjb3NwaGkgKiBjb3NsYW0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBtb2RlLlNfUE9MRTpcbiAgICAgIHkgKj0gY29zcGhpICogY29zbGFtO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBUaWx0IFxuICB2YXIgeXQsIGJhO1xuICB5dCA9IHkgKiB0aGlzLmNnICsgeCAqIHRoaXMuc2c7XG4gIGJhID0gMSAvICh5dCAqIHRoaXMuc3cgKiB0aGlzLmgxICsgdGhpcy5jdyk7XG4gIHggPSAoeCAqIHRoaXMuY2cgLSB5ICogdGhpcy5zZykgKiB0aGlzLmN3ICogYmE7XG4gIHkgPSB5dCAqIGJhO1xuXG4gIHAueCA9IHggKiB0aGlzLmE7XG4gIHAueSA9IHkgKiB0aGlzLmE7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHAueCAvPSB0aGlzLmE7XG4gIHAueSAvPSB0aGlzLmE7XG4gIHZhciByID0geyB4OiBwLngsIHk6IHAueSB9O1xuXG4gIC8vIFVuLVRpbHRcbiAgdmFyIGJtLCBicSwgeXQ7XG4gIHl0ID0gMSAvICh0aGlzLnBuMSAtIHAueSAqIHRoaXMuc3cpO1xuICBibSA9IHRoaXMucG4xICogcC54ICogeXQ7XG4gIGJxID0gdGhpcy5wbjEgKiBwLnkgKiB0aGlzLmN3ICogeXQ7XG4gIHAueCA9IGJtICogdGhpcy5jZyArIGJxICogdGhpcy5zZztcbiAgcC55ID0gYnEgKiB0aGlzLmNnIC0gYm0gKiB0aGlzLnNnO1xuXG4gIHZhciByaCA9IGh5cG90KHAueCwgcC55KTtcbiAgaWYgKE1hdGguYWJzKHJoKSA8IEVQU0xOKSB7XG4gICAgci54ID0gMDtcbiAgICByLnkgPSBwLnk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvc3osIHNpbno7XG4gICAgc2lueiA9IDEgLSByaCAqIHJoICogdGhpcy5wZmFjdDtcbiAgICBzaW56ID0gKHRoaXMucCAtIE1hdGguc3FydChzaW56KSkgLyAodGhpcy5wbjEgLyByaCArIHJoIC8gdGhpcy5wbjEpO1xuICAgIGNvc3ogPSBNYXRoLnNxcnQoMSAtIHNpbnogKiBzaW56KTtcbiAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgY2FzZSBtb2RlLk9CTElROlxuICAgICAgICByLnkgPSBNYXRoLmFzaW4oY29zeiAqIHRoaXMuc2lucGgwICsgcC55ICogc2lueiAqIHRoaXMuY29zcGgwIC8gcmgpO1xuICAgICAgICBwLnkgPSAoY29zeiAtIHRoaXMuc2lucGgwICogTWF0aC5zaW4oci55KSkgKiByaDtcbiAgICAgICAgcC54ICo9IHNpbnogKiB0aGlzLmNvc3BoMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG1vZGUuRVFVSVQ6XG4gICAgICAgIHIueSA9IE1hdGguYXNpbihwLnkgKiBzaW56IC8gcmgpO1xuICAgICAgICBwLnkgPSBjb3N6ICogcmg7XG4gICAgICAgIHAueCAqPSBzaW56O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbW9kZS5OX1BPTEU6XG4gICAgICAgIHIueSA9IE1hdGguYXNpbihjb3N6KTtcbiAgICAgICAgcC55ID0gLXAueTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG1vZGUuU19QT0xFOlxuICAgICAgICByLnkgPSAtTWF0aC5hc2luKGNvc3opO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgci54ID0gTWF0aC5hdGFuMihwLngsIHAueSk7XG4gIH1cblxuICBwLnggPSByLnggKyB0aGlzLmxvbmcwO1xuICBwLnkgPSByLnk7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiVGlsdGVkX1BlcnNwZWN0aXZlXCIsIFwidHBlcnNcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCBoeXBvdCBmcm9tICcuLi9jb21tb24vaHlwb3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLmZsaXBfYXhpcyA9ICh0aGlzLnN3ZWVwID09PSAneCcgPyAxIDogMCk7XG4gICAgdGhpcy5oID0gTnVtYmVyKHRoaXMuaCk7XG4gICAgdGhpcy5yYWRpdXNfZ18xID0gdGhpcy5oIC8gdGhpcy5hO1xuXG4gICAgaWYgKHRoaXMucmFkaXVzX2dfMSA8PSAwIHx8IHRoaXMucmFkaXVzX2dfMSA+IDFlMTApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yYWRpdXNfZyA9IDEuMCArIHRoaXMucmFkaXVzX2dfMTtcbiAgICB0aGlzLkMgPSB0aGlzLnJhZGl1c19nICogdGhpcy5yYWRpdXNfZyAtIDEuMDtcblxuICAgIGlmICh0aGlzLmVzICE9PSAwLjApIHtcbiAgICAgICAgdmFyIG9uZV9lcyA9IDEuMCAtIHRoaXMuZXM7XG4gICAgICAgIHZhciByb25lX2VzID0gMSAvIG9uZV9lcztcblxuICAgICAgICB0aGlzLnJhZGl1c19wID0gTWF0aC5zcXJ0KG9uZV9lcyk7XG4gICAgICAgIHRoaXMucmFkaXVzX3AyID0gb25lX2VzO1xuICAgICAgICB0aGlzLnJhZGl1c19wX2ludjIgPSByb25lX2VzO1xuXG4gICAgICAgIHRoaXMuc2hhcGUgPSAnZWxsaXBzZSc7IC8vIFVzZSBhcyBhIGNvbmRpdGlvbiBpbiB0aGUgZm9yd2FyZCBhbmQgaW52ZXJzZSBmdW5jdGlvbnMuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWRpdXNfcCA9IDEuMDtcbiAgICAgICAgdGhpcy5yYWRpdXNfcDIgPSAxLjA7XG4gICAgICAgIHRoaXMucmFkaXVzX3BfaW52MiA9IDEuMDtcblxuICAgICAgICB0aGlzLnNoYXBlID0gJ3NwaGVyZSc7ICAvLyBVc2UgYXMgYSBjb25kaXRpb24gaW4gdGhlIGZvcndhcmQgYW5kIGludmVyc2UgZnVuY3Rpb25zLlxuICAgIH1cblxuICAgIGlmICghdGhpcy50aXRsZSkge1xuICAgICAgICB0aGlzLnRpdGxlID0gXCJHZW9zdGF0aW9uYXJ5IFNhdGVsbGl0ZSBWaWV3XCI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgICB2YXIgbG9uID0gcC54O1xuICAgIHZhciBsYXQgPSBwLnk7XG4gICAgdmFyIHRtcCwgdl94LCB2X3ksIHZfejtcbiAgICBsb24gPSBsb24gLSB0aGlzLmxvbmcwO1xuXG4gICAgaWYgKHRoaXMuc2hhcGUgPT09ICdlbGxpcHNlJykge1xuICAgICAgICBsYXQgPSBNYXRoLmF0YW4odGhpcy5yYWRpdXNfcDIgKiBNYXRoLnRhbihsYXQpKTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJhZGl1c19wIC8gaHlwb3QodGhpcy5yYWRpdXNfcCAqIE1hdGguY29zKGxhdCksIE1hdGguc2luKGxhdCkpO1xuXG4gICAgICAgIHZfeCA9IHIgKiBNYXRoLmNvcyhsb24pICogTWF0aC5jb3MobGF0KTtcbiAgICAgICAgdl95ID0gciAqIE1hdGguc2luKGxvbikgKiBNYXRoLmNvcyhsYXQpO1xuICAgICAgICB2X3ogPSByICogTWF0aC5zaW4obGF0KTtcblxuICAgICAgICBpZiAoKCh0aGlzLnJhZGl1c19nIC0gdl94KSAqIHZfeCAtIHZfeSAqIHZfeSAtIHZfeiAqIHZfeiAqIHRoaXMucmFkaXVzX3BfaW52MikgPCAwLjApIHtcbiAgICAgICAgICAgIHAueCA9IE51bWJlci5OYU47XG4gICAgICAgICAgICBwLnkgPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgPSB0aGlzLnJhZGl1c19nIC0gdl94O1xuICAgICAgICBpZiAodGhpcy5mbGlwX2F4aXMpIHtcbiAgICAgICAgICAgIHAueCA9IHRoaXMucmFkaXVzX2dfMSAqIE1hdGguYXRhbih2X3kgLyBoeXBvdCh2X3osIHRtcCkpO1xuICAgICAgICAgICAgcC55ID0gdGhpcy5yYWRpdXNfZ18xICogTWF0aC5hdGFuKHZfeiAvIHRtcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwLnggPSB0aGlzLnJhZGl1c19nXzEgKiBNYXRoLmF0YW4odl95IC8gdG1wKTtcbiAgICAgICAgICAgIHAueSA9IHRoaXMucmFkaXVzX2dfMSAqIE1hdGguYXRhbih2X3ogLyBoeXBvdCh2X3ksIHRtcCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnNoYXBlID09PSAnc3BoZXJlJykge1xuICAgICAgICB0bXAgPSBNYXRoLmNvcyhsYXQpO1xuICAgICAgICB2X3ggPSBNYXRoLmNvcyhsb24pICogdG1wO1xuICAgICAgICB2X3kgPSBNYXRoLnNpbihsb24pICogdG1wO1xuICAgICAgICB2X3ogPSBNYXRoLnNpbihsYXQpO1xuICAgICAgICB0bXAgPSB0aGlzLnJhZGl1c19nIC0gdl94O1xuXG4gICAgICAgIGlmICh0aGlzLmZsaXBfYXhpcykge1xuICAgICAgICAgICAgcC54ID0gdGhpcy5yYWRpdXNfZ18xICogTWF0aC5hdGFuKHZfeSAvIGh5cG90KHZfeiwgdG1wKSk7XG4gICAgICAgICAgICBwLnkgPSB0aGlzLnJhZGl1c19nXzEgKiBNYXRoLmF0YW4odl96IC8gdG1wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAueCA9IHRoaXMucmFkaXVzX2dfMSAqIE1hdGguYXRhbih2X3kgLyB0bXApO1xuICAgICAgICAgICAgcC55ID0gdGhpcy5yYWRpdXNfZ18xICogTWF0aC5hdGFuKHZfeiAvIGh5cG90KHZfeSwgdG1wKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcC54ID0gcC54ICogdGhpcy5hO1xuICAgIHAueSA9IHAueSAqIHRoaXMuYTtcbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gICAgdmFyIHZfeCA9IC0xLjA7XG4gICAgdmFyIHZfeSA9IDAuMDtcbiAgICB2YXIgdl96ID0gMC4wO1xuICAgIHZhciBhLCBiLCBkZXQsIGs7XG5cbiAgICBwLnggPSBwLnggLyB0aGlzLmE7XG4gICAgcC55ID0gcC55IC8gdGhpcy5hO1xuXG4gICAgaWYgKHRoaXMuc2hhcGUgPT09ICdlbGxpcHNlJykge1xuICAgICAgICBpZiAodGhpcy5mbGlwX2F4aXMpIHtcbiAgICAgICAgICAgIHZfeiA9IE1hdGgudGFuKHAueSAvIHRoaXMucmFkaXVzX2dfMSk7XG4gICAgICAgICAgICB2X3kgPSBNYXRoLnRhbihwLnggLyB0aGlzLnJhZGl1c19nXzEpICogaHlwb3QoMS4wLCB2X3opO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdl95ID0gTWF0aC50YW4ocC54IC8gdGhpcy5yYWRpdXNfZ18xKTtcbiAgICAgICAgICAgIHZfeiA9IE1hdGgudGFuKHAueSAvIHRoaXMucmFkaXVzX2dfMSkgKiBoeXBvdCgxLjAsIHZfeSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdl96cCA9IHZfeiAvIHRoaXMucmFkaXVzX3A7XG4gICAgICAgIGEgPSB2X3kgKiB2X3kgKyB2X3pwICogdl96cCArIHZfeCAqIHZfeDtcbiAgICAgICAgYiA9IDIgKiB0aGlzLnJhZGl1c19nICogdl94O1xuICAgICAgICBkZXQgPSAoYiAqIGIpIC0gNCAqIGEgKiB0aGlzLkM7XG5cbiAgICAgICAgaWYgKGRldCA8IDAuMCkge1xuICAgICAgICAgICAgcC54ID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIHAueSA9IE51bWJlci5OYU47XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGsgPSAoLWIgLSBNYXRoLnNxcnQoZGV0KSkgLyAoMi4wICogYSk7XG4gICAgICAgIHZfeCA9IHRoaXMucmFkaXVzX2cgKyBrICogdl94O1xuICAgICAgICB2X3kgKj0gaztcbiAgICAgICAgdl96ICo9IGs7XG5cbiAgICAgICAgcC54ID0gTWF0aC5hdGFuMih2X3ksIHZfeCk7XG4gICAgICAgIHAueSA9IE1hdGguYXRhbih2X3ogKiBNYXRoLmNvcyhwLngpIC8gdl94KTtcbiAgICAgICAgcC55ID0gTWF0aC5hdGFuKHRoaXMucmFkaXVzX3BfaW52MiAqIE1hdGgudGFuKHAueSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zaGFwZSA9PT0gJ3NwaGVyZScpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxpcF9heGlzKSB7XG4gICAgICAgICAgICB2X3ogPSBNYXRoLnRhbihwLnkgLyB0aGlzLnJhZGl1c19nXzEpO1xuICAgICAgICAgICAgdl95ID0gTWF0aC50YW4ocC54IC8gdGhpcy5yYWRpdXNfZ18xKSAqIE1hdGguc3FydCgxLjAgKyB2X3ogKiB2X3opO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdl95ID0gTWF0aC50YW4ocC54IC8gdGhpcy5yYWRpdXNfZ18xKTtcbiAgICAgICAgICAgIHZfeiA9IE1hdGgudGFuKHAueSAvIHRoaXMucmFkaXVzX2dfMSkgKiBNYXRoLnNxcnQoMS4wICsgdl95ICogdl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGEgPSB2X3kgKiB2X3kgKyB2X3ogKiB2X3ogKyB2X3ggKiB2X3g7XG4gICAgICAgIGIgPSAyICogdGhpcy5yYWRpdXNfZyAqIHZfeDtcbiAgICAgICAgZGV0ID0gKGIgKiBiKSAtIDQgKiBhICogdGhpcy5DO1xuICAgICAgICBpZiAoZGV0IDwgMC4wKSB7XG4gICAgICAgICAgICBwLnggPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgcC55ID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgayA9ICgtYiAtIE1hdGguc3FydChkZXQpKSAvICgyLjAgKiBhKTtcbiAgICAgICAgdl94ID0gdGhpcy5yYWRpdXNfZyArIGsgKiB2X3g7XG4gICAgICAgIHZfeSAqPSBrO1xuICAgICAgICB2X3ogKj0gaztcblxuICAgICAgICBwLnggPSBNYXRoLmF0YW4yKHZfeSwgdl94KTtcbiAgICAgICAgcC55ID0gTWF0aC5hdGFuKHZfeiAqIE1hdGguY29zKHAueCkgLyB2X3gpO1xuICAgIH1cbiAgICBwLnggPSBwLnggKyB0aGlzLmxvbmcwO1xuICAgIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiR2Vvc3RhdGlvbmFyeSBTYXRlbGxpdGUgVmlld1wiLCBcIkdlb3N0YXRpb25hcnlfU2F0ZWxsaXRlXCIsIFwiZ2Vvc1wiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBpbml0OiBpbml0LFxuICAgIGZvcndhcmQ6IGZvcndhcmQsXG4gICAgaW52ZXJzZTogaW52ZXJzZSxcbiAgICBuYW1lczogbmFtZXMsXG59O1xuXG4iLCJpbXBvcnQgdG1lcmMgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvdG1lcmMnO1xuaW1wb3J0IGV0bWVyYyBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9ldG1lcmMnO1xuaW1wb3J0IHV0bSBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy91dG0nO1xuaW1wb3J0IHN0ZXJlYSBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9zdGVyZWEnO1xuaW1wb3J0IHN0ZXJlIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL3N0ZXJlJztcbmltcG9ydCBzb21lcmMgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvc29tZXJjJztcbmltcG9ydCBvbWVyYyBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9vbWVyYyc7XG5pbXBvcnQgbGNjIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL2xjYyc7XG5pbXBvcnQga3JvdmFrIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL2tyb3Zhayc7XG5pbXBvcnQgY2FzcyBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9jYXNzJztcbmltcG9ydCBsYWVhIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL2xhZWEnO1xuaW1wb3J0IGFlYSBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9hZWEnO1xuaW1wb3J0IGdub20gZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvZ25vbSc7XG5pbXBvcnQgY2VhIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL2NlYSc7XG5pbXBvcnQgZXFjIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL2VxYyc7XG5pbXBvcnQgcG9seSBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9wb2x5JztcbmltcG9ydCBuem1nIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL256bWcnO1xuaW1wb3J0IG1pbGwgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvbWlsbCc7XG5pbXBvcnQgc2ludSBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9zaW51JztcbmltcG9ydCBtb2xsIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL21vbGwnO1xuaW1wb3J0IGVxZGMgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvZXFkYyc7XG5pbXBvcnQgdmFuZGcgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvdmFuZGcnO1xuaW1wb3J0IGFlcWQgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvYWVxZCc7XG5pbXBvcnQgb3J0aG8gZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvb3J0aG8nO1xuaW1wb3J0IHFzYyBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9xc2MnO1xuaW1wb3J0IHJvYmluIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL3JvYmluJztcbmltcG9ydCBnZW9jZW50IGZyb20gJy4vbGliL3Byb2plY3Rpb25zL2dlb2NlbnQnO1xuaW1wb3J0IHRwZXJzIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL3RwZXJzJztcbmltcG9ydCBnZW9zIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL2dlb3MnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocHJvajQpe1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZCh0bWVyYyk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGV0bWVyYyk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKHV0bSk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKHN0ZXJlYSk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKHN0ZXJlKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoc29tZXJjKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQob21lcmMpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChsY2MpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChrcm92YWspO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChjYXNzKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQobGFlYSk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGFlYSk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGdub20pO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChjZWEpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChlcWMpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChwb2x5KTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQobnptZyk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKG1pbGwpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChzaW51KTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQobW9sbCk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGVxZGMpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZCh2YW5kZyk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGFlcWQpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChvcnRobyk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKHFzYyk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKHJvYmluKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoZ2VvY2VudCk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKHRwZXJzKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoZ2Vvcyk7XG59IiwiaW1wb3J0IHByb2o0IGZyb20gJy4vY29yZSc7XG5pbXBvcnQgUHJvaiBmcm9tIFwiLi9Qcm9qXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4vUG9pbnRcIjtcbmltcG9ydCBjb21tb24gZnJvbSBcIi4vY29tbW9uL3RvUG9pbnRcIjtcbmltcG9ydCBkZWZzIGZyb20gXCIuL2RlZnNcIjtcbmltcG9ydCBuYWRncmlkIGZyb20gXCIuL25hZGdyaWRcIjtcbmltcG9ydCB0cmFuc2Zvcm0gZnJvbSBcIi4vdHJhbnNmb3JtXCI7XG5pbXBvcnQgbWdycyBmcm9tIFwibWdyc1wiO1xuaW1wb3J0IGluY2x1ZGVkUHJvamVjdGlvbnMgZnJvbSBcIi4uL3Byb2pzXCI7XG5cbnByb2o0LmRlZmF1bHREYXR1bSA9ICdXR1M4NCc7IC8vZGVmYXVsdCBkYXR1bVxucHJvajQuUHJvaiA9IFByb2o7XG5wcm9qNC5XR1M4NCA9IG5ldyBwcm9qNC5Qcm9qKCdXR1M4NCcpO1xucHJvajQuUG9pbnQgPSBQb2ludDtcbnByb2o0LnRvUG9pbnQgPSBjb21tb247XG5wcm9qNC5kZWZzID0gZGVmcztcbnByb2o0Lm5hZGdyaWQgPSBuYWRncmlkO1xucHJvajQudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xucHJvajQubWdycyA9IG1ncnM7XG5wcm9qNC52ZXJzaW9uID0gJ19fVkVSU0lPTl9fJztcbmluY2x1ZGVkUHJvamVjdGlvbnMocHJvajQpO1xuZXhwb3J0IGRlZmF1bHQgcHJvajQ7XG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xyXG4vKipcclxuICogSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0XHJcbiAqL1xyXG5pbXBvcnQgTCBmcm9tICdsZWFmbGV0JztcclxuaW1wb3J0IHByb2o0IGZyb20gJ3Byb2o0JztcclxuXHJcbndpbmRvdy5wcm9qNCA9IHByb2o0O1xyXG53aW5kb3cuUHJvajRqcyA9IHByb2o0O1xyXG5MLlByb2ogPSBMLlByb2ogfHwge307XHJcblxyXG5MLlByb2ouX2lzUHJvajRPYmogPSBmdW5jdGlvbihhKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGEuaW52ZXJzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGEuZm9yd2FyZCAhPT0gJ3VuZGVmaW5lZCc7XHJcbn07XHJcblxyXG4vKipcclxuICogQGNsYXNzIEwuUHJvai5Qcm9qZWN0aW9uXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc2Rlc2MgUHJvaiDmipXlvbHlrprkuYnnsbvjgIJcclxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBQcm9qZWN0aW9uXHJcbiAqIEBleHRlbmRzIHtMLkNsYXNzfVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSAtIHByb2ogc3JzQ29kZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmIC0g5oqV5b2x55qEIHByb2o0IOWumuS5ieOAgntAbGluayBb6K+m57uGXXtodHRwczovL2ljbGllbnQuc3VwZXJtYXAuaW8vd2ViL2ludHJvZHVjdGlvbi9sZWFmbGV0RGV2ZWxvcC5odG1sI3Byb2plY3Rpb259fVxyXG4gKiBAcGFyYW0ge0wuQm91bmRzfSBib3VuZHMgLSAg5oqV5b2x6IyD5Zu05Y+C5pWwXHJcbiAqL1xyXG5MLlByb2ouUHJvamVjdGlvbiA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvZGUsIGRlZiwgYm91bmRzLCB3cmFwTG5nKSB7XHJcbiAgICAgICAgdmFyIGlzUDQgPSBMLlByb2ouX2lzUHJvajRPYmooY29kZSk7XHJcbiAgICAgICAgdGhpcy5fcHJvaiA9IGlzUDQgPyBjb2RlIDogdGhpcy5fcHJvakZyb21Db2RlRGVmKGNvZGUsIGRlZik7XHJcbiAgICAgICAgdmFyIGJvdW5kc09wdGlvbiA9IGJvdW5kcztcclxuICAgICAgICBpZiAoTC5VdGlsLmlzQXJyYXkoYm91bmRzKSkge1xyXG4gICAgICAgICAgICBib3VuZHNPcHRpb24gPSBMLmJvdW5kcyhib3VuZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJvdW5kcyA9IGlzUDQgPyBkZWYgOiBib3VuZHNPcHRpb247XHJcbiAgICAgICAgdGhpcy53cmFwTG5nID0gd3JhcExuZztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gTC5Qcm9qLlByb2plY3Rpb24ucHJvdG90eXBlLnByb2plY3RcclxuICAgICAqIEBkZXNjcmlwdGlvbiDpgJrov4flnLDnkIblnZDmoIflvpfliLDmipXlvbHlnZDmoIfjgIJcclxuICAgICAqIEBwYXJhbSAge0wuTGF0bG5nfSBsYXRsbmcgLSAg57uP57qs5bqm5Z2Q5qCH44CCXHJcbiAgICAgKiBAcmV0dXJucyB7TC5Qb2ludH0g6L+U5Zue5oqV5b2x5Z2Q5qCH54K544CCXHJcbiAgICAgKi9cclxuICAgIHByb2plY3Q6IGZ1bmN0aW9uKGxhdGxuZykge1xyXG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuX3Byb2ouZm9yd2FyZChbbGF0bG5nLmxuZywgbGF0bG5nLmxhdF0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgTC5Qb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBMLlByb2ouUHJvamVjdGlvbi5wcm90b3R5cGUudW5wcm9qZWN0XHJcbiAgICAgKiBAZGVzY3JpcHRpb24g6YCa6L+H5oqV5b2x5Z2Q5qCH5b6X5Yiw5Zyw55CG5Z2Q5qCH44CCXHJcbiAgICAgKiBAcGFyYW0ge0wuUG9pbnR9IHBvaW50IC0g5Z2Q5qCH54K544CCXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdW5ib3VuZGVkIC0g5Z2Q5qCH54K56auY56iL5YC8562J44CCXHJcbiAgICAgKiBAcmV0dXJucyB7TC5MYXRMbmd9IOi/lOWbnue7j+e6rOW6puWdkOagh1xyXG4gICAgICovXHJcbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKHBvaW50LCB6b29tKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYm91bmRzICYmICF0aGlzLndyYXBMbmcpIHtcclxuICAgICAgICAgICAgcG9pbnQueCA9XHJcbiAgICAgICAgICAgICAgICBwb2ludC54IDwgdGhpcy5ib3VuZHMubWluLnhcclxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuYm91bmRzLm1pbi54XHJcbiAgICAgICAgICAgICAgICAgICAgOiBwb2ludC54ID4gdGhpcy5ib3VuZHMubWF4LnhcclxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuYm91bmRzLm1heC54XHJcbiAgICAgICAgICAgICAgICAgICAgOiBwb2ludC54O1xyXG4gICAgICAgICAgICBwb2ludC55ID1cclxuICAgICAgICAgICAgICAgIHBvaW50LnkgPCB0aGlzLmJvdW5kcy5taW4ueVxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5ib3VuZHMubWluLnlcclxuICAgICAgICAgICAgICAgICAgICA6IHBvaW50LnkgPiB0aGlzLmJvdW5kcy5tYXgueVxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5ib3VuZHMubWF4LnlcclxuICAgICAgICAgICAgICAgICAgICA6IHBvaW50Lnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb2ludDIgPSB0aGlzLl9wcm9qLmludmVyc2UoW3BvaW50LngsIHBvaW50LnldKTtcclxuICAgICAgICByZXR1cm4gbmV3IEwuTGF0TG5nKHBvaW50MlsxXSwgcG9pbnQyWzBdLCB6b29tKTtcclxuICAgIH0sXHJcblxyXG4gICAgX3Byb2pGcm9tQ29kZURlZjogZnVuY3Rpb24oY29kZSwgZGVmKSB7XHJcbiAgICAgICAgaWYgKGRlZikge1xyXG4gICAgICAgICAgICBwcm9qNC5kZWZzKGNvZGUsIGRlZik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwcm9qNC5kZWZzW2NvZGVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIHVybiA9IGNvZGUuc3BsaXQoJzonKTtcclxuICAgICAgICAgICAgaWYgKHVybi5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gdXJuW3Vybi5sZW5ndGggLSAzXSArICc6JyArIHVyblt1cm4ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2o0LmRlZnNbY29kZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ05vIHByb2plY3Rpb24gZGVmaW5pdGlvbiBmb3IgY29kZSAnICsgY29kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHByb2o0KGNvZGUpO1xyXG4gICAgfSxcclxuICAgIGdldFVuaXRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvai5vUHJvai51bml0cyB8fCAnZGVncmVlcyc7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBDUlNcclxuICogQGFsaWFzY2xhc3MgUHJvai5DUlNcclxuICogQGRlcHJlY2F0ZWRjbGFzcyBMLlByb2ouQ1JTXHJcbiAqIEBkZXByZWNhdGVkY2xhc3NpbnN0YW5jZSBMLnN1cGVybWFwLlByb2ouY3JzXHJcbiAqIEBjbGFzc2Rlc2Mg5Z+65LqOIFByb2o0IOWdkOagh+ezu+e7n+aJqeWxleexu+OAglxyXG4gKiDkuLrorqHnrpfnuqfliKvvvIxgb3B0aW9ucy5zY2FsZXNgIGBvcHRpb25zLnNjYWxlRGVub21pbmF0b3JzYCBgb3B0aW9ucy5yZXNvbHV0aW9uc2AgYG9wdGlvbnMuYm91bmRzYCDlv4XpobvmjIflrprkuIDkuKrvvIzlhYjlkI7pobrluo/lt7LmjInkvJjlhYjnuqfmjpLliJfjgIJcclxuICog5b2T5oyH5a6aYG9wdGlvbnMuYm91bmRzYCDml7bvvIznrKwgMCDnuqfkuLrkuIDlvKAgMjU2IOWIh+eJh+WMheWQq+aVtOS4qiBib3VuZHPvvIzljbNgTWF0aC5tYXgoYm91bmRzLmdldFNpemUoKS54LCBib3VuZHMuZ2V0U2l6ZSgpLnkpLzI1NmAg44CCXHJcbiAqIOS4uuS/neivgeWIh+eJh+ihjOWIl+WPt+ato+ehru+8jGBvcHRpb25zLm9yaWdpbmAgYG9wdGlvbnMuYm91bmRzYCDlv4XpobvmjIflrprkuIDkuKrjgIJcclxuICog5b2T5oyH5a6aYG9wdGlvbnMuYm91bmRzYCDml7bvvIzliIfniYfljp/ngrnkuLogYm91bmRzIOeahOW3puS4iuinkuOAglxyXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIFByb2plY3Rpb25cclxuICogQGV4dGVuZHMge0wuQ2xhc3N9XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcnNDb2RlIC0gcHJvaiBzcnNDb2Rl44CCXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0g5Y+C5pWw44CCXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmRlZiAtIOaKleW9seeahHByb2o05a6a5LmJ44CCW+ivpue7hl17QGxpbmsgaHR0cHM6Ly9pY2xpZW50LnN1cGVybWFwLmlvL3dlYi9pbnRyb2R1Y3Rpb24vbGVhZmxldERldmVsb3AuaHRtbCNtdWx0aVByb2plY3Rpb259XHJcbiAqIEBwYXJhbSB7KEFycmF5LjxudW1iZXI+fEwuUG9pbnQpfSBbb3B0aW9ucy5vcmlnaW5dIC0g5Y6f54K544CCXHJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHRpb25zLnNjYWxlc10gLSDmr5TkvovlsLrmlbDnu4TjgIJcclxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW29wdGlvbnMuc2NhbGVEZW5vbWluYXRvcnNdIC0g5q+U5L6L5bC65YiG5q+N5pWw57uE44CCXHJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHRpb25zLnJlc29sdXRpb25zXSAtIOWIhui+qOeOh+aVsOe7hOOAglxyXG4gKiBAcGFyYW0geyhBcnJheS48bnVtYmVyPnxMLkJvdW5kcyl9IFtvcHRpb25zLmJvdW5kc10gLSDojIPlm7TjgIJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRwaT05Nl0gLSBkcGnjgIJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndyYXBMbmddIC0g5a6a5LmJ57uP5bqm77yI5rC05bmz77yJ5Z2Q5qCH6L205piv5ZCm5Zyo57uZ5a6a6IyD5Zu05YaF546v57uV44CC5aSn5aSa5pWw5oOF5Ya15LiL6buY6K6k5Li6Wy0xODDvvIwxODBd44CCXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgIHZhciBjcnMgPW5ldyBDUlMoXCJFUFNHOjQzMjZcIix7XHJcbiAqICAgICAgICAgIG9yaWdpbjogWy0xODAsOTBdLFxyXG4gKiAgICAgICAgICBzY2FsZURlbm9taW5hdG9yczogWzIwMDAsMTAwMCw1MDAsMjAwLDEwMCw1MCwyMCwxMF0sXHJcbiAqICAgIH0pO1xyXG4gKiAgICB2YXIgbWFwPUwubWFwKCdtYXAnLCB7XHJcbiAqICAgICAgIGNyczogY3JzXHJcbiAqICAgICAgLi4uXHJcbiAqICAgIH0pXHJcbiAqIEB1c2FnZVxyXG4gKi9cclxuZXhwb3J0IHZhciBDUlMgPSBMLkNsYXNzLmV4dGVuZCh7XHJcbiAgICBpbmNsdWRlczogTC5DUlMsXHJcblxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAgIHRyYW5zZm9ybWF0aW9uOiBuZXcgTC5UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMClcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oc3JzQ29kZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBjb2RlLCBwcm9qLCBkZWY7XHJcblxyXG4gICAgICAgIGlmIChMLlByb2ouX2lzUHJvajRPYmooc3JzQ29kZSkpIHtcclxuICAgICAgICAgICAgcHJvaiA9IHNyc0NvZGU7XHJcbiAgICAgICAgICAgIGNvZGUgPSBwcm9qLnNyc0NvZGU7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uID0gbmV3IEwuUHJvai5Qcm9qZWN0aW9uKHByb2osIG9wdGlvbnMuYm91bmRzLG9wdGlvbnMud3JhcExuZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29kZSA9IHNyc0NvZGU7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zLmRlZiB8fCAnJztcclxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uID0gbmV3IEwuUHJvai5Qcm9qZWN0aW9uKGNvZGUsIGRlZiwgb3B0aW9ucy5ib3VuZHMsb3B0aW9ucy53cmFwTG5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud3JhcExuZykge1xyXG4gICAgICAgICAgICB0aGlzLndyYXBMbmcgPSB0aGlzLm9wdGlvbnMud3JhcExuZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uID0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybWF0aW9uO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5kcGkgPSB0aGlzLm9wdGlvbnMuZHBpIHx8IDk2O1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5ib3VuZHMgPSBMLmJvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub3JpZ2luICYmIHRoaXMub3B0aW9ucy5ib3VuZHMpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWdpbiA9IFt0aGlzLm9wdGlvbnMuYm91bmRzLm1pbi54LCB0aGlzLm9wdGlvbnMuYm91bmRzLm1heC55XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcmlnaW4pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcmlnaW4gaW5zdGFuY2VvZiBMLlBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZ2luID0gW3RoaXMub3B0aW9ucy5vcmlnaW4ueCwgdGhpcy5vcHRpb25zLm9yaWdpbi55XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uID0gbmV3IEwuVHJhbnNmb3JtYXRpb24oMSwgLXRoaXMub3B0aW9ucy5vcmlnaW5bMF0sIC0xLCB0aGlzLm9wdGlvbnMub3JpZ2luWzFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NhbGVzICYmIHRoaXMub3B0aW9ucy5zY2FsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlcyA9IHRoaXMub3B0aW9ucy5zY2FsZXM7XHJcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlcyA9IHRoaXMuX3RvUHJvajRTY2FsZXModGhpcy5vcHRpb25zLnNjYWxlcywgdGhpcy5vcHRpb25zLmRwaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2NhbGVEZW5vbWluYXRvcnMgJiYgdGhpcy5vcHRpb25zLnNjYWxlRGVub21pbmF0b3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMuc2NhbGVEZW5vbWluYXRvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVzW2ldID0gMSAvIHRoaXMub3B0aW9ucy5zY2FsZURlbm9taW5hdG9yc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZXMgPSB0aGlzLl90b1Byb2o0U2NhbGVzKHRoaXMuc2NhbGVzLCB0aGlzLm9wdGlvbnMuZHBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5yZXNvbHV0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjYWxlc1tpXSA9IDEgLyB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2NhbGVzID0gdGhpcy5fZ2V0RGVmYXVsdFByb2o0U2NhbGVzQnlCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlY3RpZnkoKTtcclxuICAgICAgICB0aGlzLmluZmluaXRlID0gIXRoaXMub3B0aW9ucy5ib3VuZHM7XHJcbiAgICB9LFxyXG4gICAgX3JlY3RpZnk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zY2FsZXMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc29sdXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdXRpb25zID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdXRpb25zID0gdGhpcy5fcHJvajRTY2FsZXNUb1Jlc29sdXRpb25zKHRoaXMuX3NjYWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNjYWxlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yZXNvbHV0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZUQgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdXRpb25zW2ldICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRwaSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgxIC8gMC4wMjU0KSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldE1ldGVyUGVyTWFwVW5pdCh0aGlzLnByb2plY3Rpb24uZ2V0VW5pdHMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZXNbaV0gPSAxLjAgLyBzY2FsZUQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gQ1JTLnByb3RvdHlwZS5zY2FsZVxyXG4gICAgICogQGRlc2NyaXB0aW9uIOmAmui/h+e8qeaUvue6p+WIq+iOt+WPluavlOS+i+WwuuWAvOOAglxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSDnvKnmlL7nuqfliKvjgIJcclxuICAgICAqIEByZXR1cm5zIOavlOS+i+WwuuWAvOOAglxyXG4gICAgICovXHJcbiAgICBzY2FsZTogZnVuY3Rpb24oem9vbSkge1xyXG4gICAgICAgIHZhciBpWm9vbSA9IE1hdGguZmxvb3Ioem9vbSksXHJcbiAgICAgICAgICAgIGJhc2VTY2FsZSxcclxuICAgICAgICAgICAgbmV4dFNjYWxlLFxyXG4gICAgICAgICAgICBzY2FsZURpZmYsXHJcbiAgICAgICAgICAgIHpEaWZmO1xyXG4gICAgICAgIGlmICh6b29tID09PSBpWm9vbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVzW3pvb21dO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vbi1pbnRlZ2VyIHpvb20sIGludGVycG9sYXRlXHJcbiAgICAgICAgICAgIGJhc2VTY2FsZSA9IHRoaXMuX3NjYWxlc1tpWm9vbV07XHJcbiAgICAgICAgICAgIG5leHRTY2FsZSA9IHRoaXMuX3NjYWxlc1tpWm9vbSArIDFdO1xyXG4gICAgICAgICAgICBzY2FsZURpZmYgPSBuZXh0U2NhbGUgLSBiYXNlU2NhbGU7XHJcbiAgICAgICAgICAgIHpEaWZmID0gem9vbSAtIGlab29tO1xyXG4gICAgICAgICAgICByZXR1cm4gYmFzZVNjYWxlICsgc2NhbGVEaWZmICogekRpZmY7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBDUlMucHJvdG90eXBlLnpvb21cclxuICAgICAqIEBkZXNjcmlwdGlvbiDmoLnmja7mr5TkvovlsLrov5Tlm57nvKnmlL7nuqfliKvjgIJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIOavlOS+i+WwuuOAglxyXG4gICAgICogQHJldHVybnMge251bWJlcn0g57yp5pS+57qn5Yir44CCXHJcbiAgICAgKi9cclxuICAgIHpvb206IGZ1bmN0aW9uKHNjYWxlKSB7XHJcbiAgICAgICAgLy8gRmluZCBjbG9zZXN0IG51bWJlciBpbiB0aGlzLl9zY2FsZXMsIGRvd25cclxuICAgICAgICB2YXIgZG93blNjYWxlID0gdGhpcy5fY2xvc2VzdEVsZW1lbnQodGhpcy5fc2NhbGVzLCBzY2FsZSksXHJcbiAgICAgICAgICAgIGRvd25ab29tID0gdGhpcy5fc2NhbGVzLmluZGV4T2YoZG93blNjYWxlKSxcclxuICAgICAgICAgICAgbmV4dFNjYWxlLFxyXG4gICAgICAgICAgICBuZXh0Wm9vbSxcclxuICAgICAgICAgICAgc2NhbGVEaWZmO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHNjYWxlIGlzIGRvd25TY2FsZSA9PiByZXR1cm4gYXJyYXkgaW5kZXhcclxuICAgICAgICBpZiAoIWRvd25TY2FsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNjYWxlID09PSBkb3duU2NhbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvd25ab29tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbnRlcnBvbGF0ZVxyXG4gICAgICAgIG5leHRab29tID0gZG93blpvb20gKyAxO1xyXG4gICAgICAgIG5leHRTY2FsZSA9IHRoaXMuX3NjYWxlc1tuZXh0Wm9vbV07XHJcbiAgICAgICAgaWYgKG5leHRTY2FsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb3duWm9vbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2NhbGVEaWZmID0gbmV4dFNjYWxlIC0gZG93blNjYWxlO1xyXG4gICAgICAgIHJldHVybiAoc2NhbGUgLSBkb3duU2NhbGUpIC8gc2NhbGVEaWZmICsgZG93blpvb207XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlOiBMLkNSUy5FYXJ0aC5kaXN0YW5jZSxcclxuXHJcbiAgICBSOiBMLkNSUy5FYXJ0aC5SLFxyXG5cclxuICAgIC8qIEdldCB0aGUgY2xvc2VzdCBsb3dlc3QgZWxlbWVudCBpbiBhbiBhcnJheSAqL1xyXG4gICAgX2Nsb3Nlc3RFbGVtZW50OiBmdW5jdGlvbihhcnJheSwgZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBsb3c7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgaS0tOyApIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5W2ldIDw9IGVsZW1lbnQgJiYgKGxvdyA9PT0gdW5kZWZpbmVkIHx8IGxvdyA8IGFycmF5W2ldKSkge1xyXG4gICAgICAgICAgICAgICAgbG93ID0gYXJyYXlbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvdztcclxuICAgIH0sXHJcbiAgICBfcHJvajRTY2FsZXNUb1Jlc29sdXRpb25zKF9zY2FsZXMpIHtcclxuICAgICAgICB2YXIgcmVzb2x1dGlvbnMgPSBbXTtcclxuICAgICAgICBpZiAoIV9zY2FsZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdXRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9zY2FsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzb2x1dGlvbnNbaV0gPSAxLjAgLyBfc2NhbGVzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbnM7XHJcbiAgICB9LFxyXG4gICAgX3RvUHJvajRTY2FsZXM6IGZ1bmN0aW9uKHNjYWxlcywgZHBpKSB7XHJcbiAgICAgICAgdmFyIHByb2o0U2NhbGVzID0gW107XHJcbiAgICAgICAgaWYgKCFzY2FsZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb2o0U2NhbGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjYWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMucHJvamVjdGlvbiA/IHRoaXMuX2dldE1ldGVyUGVyTWFwVW5pdCh0aGlzLnByb2plY3Rpb24uZ2V0VW5pdHMoKSkgOiAxO1xyXG4gICAgICAgICAgICBwcm9qNFNjYWxlc1tpXSA9IDEgLyAoMC4wMjU0IC8gKChkcGkgfHwgOTYpICogc2NhbGVzW2ldKSAvIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvajRTY2FsZXM7XHJcbiAgICB9LFxyXG4gICAgX2dldE1ldGVyUGVyTWFwVW5pdDogZnVuY3Rpb24obWFwVW5pdCkge1xyXG4gICAgICAgIHZhciBlYXJjaFJhZGl1c0luTWV0ZXJzID0gNjM3ODEzNztcclxuICAgICAgICB2YXIgbWV0ZXJQZXJNYXBVbml0ID0gMTtcclxuICAgICAgICBpZiAobWFwVW5pdCA9PT0gJ21ldGVyJykge1xyXG4gICAgICAgICAgICBtZXRlclBlck1hcFVuaXQgPSAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWFwVW5pdCA9PT0gJ2RlZ3JlZXMnKSB7XHJcbiAgICAgICAgICAgIC8vIOavj+W6puihqOekuuWkmuWwkeexs+OAglxyXG4gICAgICAgICAgICBtZXRlclBlck1hcFVuaXQgPSAoTWF0aC5QSSAqIDIgKiBlYXJjaFJhZGl1c0luTWV0ZXJzKSAvIDM2MDtcclxuICAgICAgICB9IGVsc2UgaWYgKG1hcFVuaXQgPT09ICdraWxvbWV0ZXInKSB7XHJcbiAgICAgICAgICAgIG1ldGVyUGVyTWFwVW5pdCA9IDEuMGUtMztcclxuICAgICAgICB9IGVsc2UgaWYgKG1hcFVuaXQgPT09ICdpbmNoJykge1xyXG4gICAgICAgICAgICBtZXRlclBlck1hcFVuaXQgPSAxIC8gMi41Mzk5OTk5OTE4ZS0yO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWFwVW5pdCA9PT0gJ2ZlZXQnKSB7XHJcbiAgICAgICAgICAgIG1ldGVyUGVyTWFwVW5pdCA9IDAuMzA0ODtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1ldGVyUGVyTWFwVW5pdDtcclxuICAgIH0sXHJcbiAgICBfZ2V0RGVmYXVsdFByb2o0U2NhbGVzQnlCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcykge1xyXG4gICAgICAgIGlmICghYm91bmRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJvdW5kc1NpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHZhciBleHRlbmRzU2l6ZSA9IE1hdGgubWF4KGJvdW5kc1NpemUueCwgYm91bmRzU2l6ZS55KTtcclxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGV4dGVuZHNTaXplIC8gMjU2O1xyXG4gICAgICAgIHZhciBzY2FsZXMgPSBbXTtcclxuICAgICAgICB2YXIgbWF4Wm9vbSA9IDIzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4Wm9vbTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNjYWxlc1tpXSA9IE1hdGgucG93KDIsIGkpIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlcztcclxuICAgIH1cclxufSk7XHJcbmV4cG9ydCB2YXIgY3JzID0gZnVuY3Rpb24oc3JzQ29kZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBDUlMoc3JzQ29kZSwgb3B0aW9ucyk7XHJcbn07XHJcblxyXG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xyXG4vKipcclxuICogQGVudW0gYXR0cmlidXRpb25cclxuICogQGRlc2NyaXB0aW9uIOeJiOadg+ebuOWFs+mFjee9ruOAglxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmxldCBBdHRyaWJ1dGlvbnMgPSB7XHJcblxyXG4gICAgUHJlZml4OiBgPGEgaHJlZj0naHR0cHM6Ly9sZWFmbGV0anMuY29tJyB0aXRsZT0nQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzJz5MZWFmbGV0PC9hPlxyXG4gICAgICAgICAgICAgICAgd2l0aCA8c3Bhbj7CqSA8YSBocmVmPSdodHRwczovL2ljbGllbnQuc3VwZXJtYXAuaW8nIHRpdGxlPSdTdXBlck1hcCBpQ2xpZW50JyB0YXJnZXQ9J19ibGFuayc+U3VwZXJNYXAgaUNsaWVudDwvYT48L3NwYW4+YCxcclxuXHJcbiAgICBDb21tb246IHtcclxuICAgICAgICBhdHRyaWJ1dGlvbjogYE1hcCBEYXRhIDxzcGFuPsKpIDxhIGhyZWY9J2h0dHA6Ly9zdXBwb3J0LnN1cGVybWFwLmNvbS5jbi9wcm9kdWN0L2lTZXJ2ZXIuYXNweCcgdGl0bGU9J1N1cGVyTWFwIGlTZXJ2ZXInIHRhcmdldD0nX2JsYW5rJz5TdXBlck1hcCBpU2VydmVyPC9hPjwvc3Bhbj5gXHJcbiAgICB9LFxyXG5cclxuICAgIE9ubGluZToge1xyXG4gICAgICAgIGF0dHJpYnV0aW9uOiBgTWFwIERhdGEgPHNwYW4+wqkgPGEgaHJlZj0naHR0cHM6Ly93d3cuc3VwZXJtYXBvbC5jb20nIHRpdGxlPSdTdXBlck1hcCBPbmxpbmUnIHRhcmdldD0nX2JsYW5rJz5TdXBlck1hcCBPbmxpbmU8L2E+PC9zcGFuPmBcclxuICAgIH0sXHJcblxyXG4gICAgRUNoYXJ0czoge1xyXG4gICAgICAgIGF0dHJpYnV0aW9uOiBgwqkgMjAxOCDnmb7luqYgRUNoYXJ0c2BcclxuICAgIH0sXHJcblxyXG4gICAgTWFwVjoge1xyXG4gICAgICAgIGF0dHJpYnV0aW9uOiBgwqkgMjAxOCDnmb7luqYgTWFwViBgXHJcbiAgICB9LFxyXG5cclxuICAgIFR1cmY6IHtcclxuICAgICAgICBhdHRyaWJ1dGlvbjogYDxzcGFuPsKpIDxhIGhyZWY9J2h0dHBzOi8vdHVyZmpzLm9yZy8nIHRpdGxlPSd0dXJmanMnIHRhcmdldD0nX2JsYW5rJz50dXJmanM8L2E+PC9zcGFuPmBcclxuICAgIH0sXHJcblxyXG4gICAgQmFpZHU6IHtcclxuICAgICAgICBhdHRyaWJ1dGlvbjogYE1hcCBEYXRhIMKpIDIwMTggQmFpZHUgLSBHUygyMDE2KTIwODnlj7cgLSBEYXRhIMKpIOmVv+WcsOS4h+aWuWBcclxuICAgIH0sXHJcblxyXG4gICAgQ2xvdWQ6IHtcclxuICAgICAgICBhdHRyaWJ1dGlvbjogYE1hcCBEYXRhIMKpMjAxNCBTdXBlck1hcCAtIEdTKDIwMTQpNjA3MOWPty1kYXRhwqlOYXZpbmZvYFxyXG4gICAgfSxcclxuXHJcbiAgICBUaWFuZGl0dToge1xyXG4gICAgICAgIGF0dHJpYnV0aW9uOiBgTWFwIERhdGEgPGEgaHJlZj0naHR0cHM6Ly93d3cudGlhbmRpdHUuZ292LmNuJyB0YXJnZXQ9J19ibGFuayc+PGltZyBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3R0b206MnB4O29wYWNpdHk6MTsnIHNyYz0naHR0cHM6Ly9hcGkudGlhbmRpdHUuZ292LmNuL2ltZy9tYXAvbG9nby5wbmcnIHdpZHRoPSc1M3B4JyBoZWlnaHQ9JzIycHgnIG9wYWNpdHk9JzAnPjwvYT5gXHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBdHRyaWJ1dGlvbnMiLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xyXG5pbXBvcnQgTCBmcm9tIFwibGVhZmxldFwiO1xyXG5pbXBvcnQgJy4vUHJvajRMZWFmbGV0JztcclxuaW1wb3J0IEF0dHJpYnV0aW9ucyBmcm9tICcuL0F0dHJpYnV0aW9ucyc7XHJcblxyXG5MLkNvbnRyb2wuQXR0cmlidXRpb24uaW5jbHVkZSh7XHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcbiAgICAgICAgcHJlZml4OiBBdHRyaWJ1dGlvbnMuUHJlZml4XHJcbiAgICB9XHJcbn0pO1xyXG5MLk1hcC5pbmNsdWRlKHtcclxuICAgIC8qXHJcbiAgICAgKiDojrflj5bnsr7noa7nmoTlg4/ntKDlnZDmoIcuXHJcbiAgICAgKiDlvZPpnIDopoHnu5jliLbmr5TovoPlubPmu5HnmoTmm7Lnur/nmoTml7blgJnlj6/osIPnlKjmraTmlrnms5Xku6Pmm79sYXRMbmdUb0NvbnRhaW5lclBvaW50XHJcbiAgICAgKiBAcGFyYW0gbGF0bG5nXHJcbiAgICAgKi9cclxuICAgIGxhdExuZ1RvQWNjdXJhdGVDb250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gICAgICAgIHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdChMLmxhdExuZyhsYXRsbmcpKTtcclxuICAgICAgICB2YXIgbGF5ZXJQb2ludCA9IHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG4gICAgICAgIHJldHVybiBMLnBvaW50KGxheWVyUG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG4gICAgfVxyXG59KTtcclxud3JhcFRvR2VvSlNPTihbTC5Qb2x5bGluZSwgTC5Qb2x5Z29uLCBMLk1hcmtlciwgTC5DaXJjbGVNYXJrZXIsIEwuQ2lyY2xlLCBMLkxheWVyR3JvdXBdKTtcclxuXHJcbmZ1bmN0aW9uIHdyYXBUb0dlb0pTT04ob2JqQ2xhc3NBcnJheSkge1xyXG4gICAgb2JqQ2xhc3NBcnJheS5tYXAoKG9iakNsYXNzKSA9PiB7XHJcbiAgICAgICAgb2JqQ2xhc3MuZGVmYXVsdEZ1bmN0aW9uID0gb2JqQ2xhc3MucHJvdG90eXBlLnRvR2VvSlNPTjtcclxuICAgICAgICBvYmpDbGFzcy5pbmNsdWRlKHtcclxuICAgICAgICAgICAgdG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqQ2xhc3MuZGVmYXVsdEZ1bmN0aW9uLmNhbGwodGhpcywgcHJlY2lzaW9uIHx8IDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIG9iakNsYXNzO1xyXG4gICAgfSlcclxuXHJcbn0iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG4gaW1wb3J0IHtVdGlsfSBmcm9tICcuL1V0aWwnO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpbmhlcml0XG4gKiBAZGVzY3JpcHRpb24g6Zmk5LqGIEMg5ZKMIFAg5Lik5Liq5b+F6KaB5Y+C5pWw5aSW77yM5Y+v5Lul5Lyg6YCS5Lu75oSP5pWw6YeP55qE5a+56LGh77yM6L+Z5Lqb5a+56LGh6YO95bCG57un5om/Q+OAglxuICogQHBhcmFtIHtPYmplY3R9IEMgLSDnu6fmib/nmoTnsbvjgIJcbiAqIEBwYXJhbSB7T2JqZWN0fSBQIC0g6KKr57un5om/55qE54i257G744CCXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgdmFyIGluaGVyaXRFeHQgPSBmdW5jdGlvbiAoQywgUCkge1xuICAgIHZhciBGID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgRi5wcm90b3R5cGUgPSBQLnByb3RvdHlwZTtcbiAgICBDLnByb3RvdHlwZSA9IG5ldyBGO1xuICAgIHZhciBpLCBsLCBvO1xuICAgIGZvciAoaSA9IDIsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG8gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgbyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvID0gby5wcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5leHRlbmQoQy5wcm90b3R5cGUsIG8pO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBAZnVuY3Rpb24gbWl4aW5FeHRcbiAqIEBkZXNjcmlwdGlvbiDlrp7njrDlpJrph43nu6fmib/jgIJcbiAqIEBwYXJhbSB7Q2xhc3N8T2JqZWN0fSAuLi5taXhpbnMgLSDnu6fmib/nmoTnsbvjgIJcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCB2YXIgbWl4aW5FeHQgPSBmdW5jdGlvbiAoLi4ubWl4aW5zKSB7XG5cbiAgICBjbGFzcyBNaXgge1xuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbWl4aW5zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvcHlQcm9wZXJ0aWVzKHRoaXMsIG5ldyBtaXhpbnNbaW5kZXhdKG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBtaXhpbnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBtaXhpbiA9IG1peGluc1tpbmRleF07XG4gICAgICAgIGNvcHlQcm9wZXJ0aWVzKE1peCwgbWl4aW4pO1xuICAgICAgICBjb3B5UHJvcGVydGllcyhNaXgucHJvdG90eXBlLCBtaXhpbi5wcm90b3R5cGUpO1xuICAgICAgICBjb3B5UHJvcGVydGllcyhNaXgucHJvdG90eXBlLCBuZXcgbWl4aW4oKSk7XG4gICAgfVxuICAgIHJldHVybiBNaXg7XG5cbiAgICBmdW5jdGlvbiBjb3B5UHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZSk7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgb3duS2V5cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBvd25LZXlzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwiY29uc3RydWN0b3JcIlxuICAgICAgICAgICAgICAgICYmIGtleSAhPT0gXCJwcm90b3R5cGVcIlxuICAgICAgICAgICAgICAgICYmIGtleSAhPT0gXCJuYW1lXCIgJiYga2V5ICE9PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93W1wiQWN0aXZlWE9iamVjdFwiXSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MgfHwge30pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbmFtZSBTdHJpbmdcbiAqIEBuYW1lc3BhY2VcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgVXRpbFxuICogQGRlc2NyaXB0aW9uIOWtl+espuS4suaTjeS9nOeahOS4gOezu+WIl+W4uOeUqOaJqeWxleWHveaVsOOAglxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IHZhciBTdHJpbmdFeHQgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU3RyaW5nRXh0LnN0YXJ0c1dpdGhcbiAgICAgKiBAZGVzY3JpcHRpb24g5Yik5pat55uu5qCH5a2X56ym5Liy5piv5ZCm5Lul5oyH5a6a55qE5a2Q5a2X56ym5Liy5byA5aS044CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIOebruagh+Wtl+espuS4suOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWIgLSDmn6Xmib7nmoTlrZDlrZfnrKbkuLLjgIJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0g55uu5qCH5a2X56ym5Liy5Lul5oyH5a6a55qE5a2Q5a2X56ym5Liy5byA5aS077yM5YiZ6L+U5ZueIHRydWXvvJvlkKbliJnov5Tlm54gZmFsc2XjgIJcbiAgICAgKi9cbiAgICBzdGFydHNXaXRoOiBmdW5jdGlvbiAoc3RyLCBzdWIpIHtcbiAgICAgICAgcmV0dXJuIChzdHIuaW5kZXhPZihzdWIpID09IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU3RyaW5nRXh0LmNvbnRhaW5zXG4gICAgICogQGRlc2NyaXB0aW9uIOWIpOaWreebruagh+Wtl+espuS4suaYr+WQpuWMheWQq+aMh+WumueahOWtkOWtl+espuS4suOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSDnm67moIflrZfnrKbkuLLjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViIC0g5p+l5om+55qE5a2Q5a2X56ym5Liy44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IOebruagh+Wtl+espuS4suS4reWMheWQq+aMh+WumueahOWtkOWtl+espuS4su+8jOWImei/lOWbniB0cnVl77yb5ZCm5YiZ6L+U5ZueIGZhbHNl44CCXG4gICAgICovXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uIChzdHIsIHN1Yikge1xuICAgICAgICByZXR1cm4gKHN0ci5pbmRleE9mKHN1YikgIT0gLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU3RyaW5nRXh0LnRyaW1cbiAgICAgKiBAZGVzY3JpcHRpb24g5Yig6Zmk5LiA5Liq5a2X56ym5Liy55qE5byA5aS05ZKM57uT5bC+5aSE55qE5omA5pyJ56m655m95a2X56ym44CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIO+8iOWPr+iDve+8ieWtmOWcqOepuueZveWtl+espuWhq+WhnueahOWtl+espuS4suOAglxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOWIoOmZpOW8gOWktOWSjOe7k+WwvuWkhOepuueZveWtl+espuWQjueahOWtl+espuS4suOAglxuICAgICAqL1xuICAgIHRyaW06IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFN0cmluZ0V4dC5jYW1lbGl6ZVxuICAgICAqIEBkZXNjcmlwdGlvbiDpqobpqbzlvI8oXCItXCIp6L+e5a2X56ym55qE5a2X56ym5Liy5aSE55CG44CCXG4gICAgICog5L6L5aaC77yaXCJjaGlja2VuLWhlYWRcIiBiZWNvbWVzIFwiY2hpY2tlbkhlYWRcIixcbiAgICAgKiAgICAgICBcIi1jaGlja2VuLWhlYWRcIiBiZWNvbWVzIFwiQ2hpY2tlbkhlYWRcIuOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSDopoHlpITnkIbnmoTlrZfnrKbkuLLvvIzljp/lp4vlhoXlrrnkuI3lupTooqvkv67mlLnjgIJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNhbWVsaXplOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBvU3RyaW5nTGlzdCA9IHN0ci5zcGxpdCgnLScpO1xuICAgICAgICB2YXIgY2FtZWxpemVkU3RyaW5nID0gb1N0cmluZ0xpc3RbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBvU3RyaW5nTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHMgPSBvU3RyaW5nTGlzdFtpXTtcbiAgICAgICAgICAgIGNhbWVsaXplZFN0cmluZyArPSBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbWVsaXplZFN0cmluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFN0cmluZ0V4dC5mb3JtYXRcbiAgICAgKiBAZGVzY3JpcHRpb24g5o+Q5L6b5bimICR7dG9rZW59IOagh+iusOeahOWtl+espuS4siwg6L+U5ZueIGNvbnRleHQg5a+56LGh5bGe5oCn5Lit5oyH5a6a5qCH6K6w55qE5bGe5oCn5YC844CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiDnpLrkvovvvJpcbiAgICAgKiAoY29kZSlcbiAgICAgKiAx44CBdGVtcGxhdGUgPSBcIiR7dmFsdWUsZ2V0VmFsdWV9XCI7XG4gICAgICogICAgICAgICBjb250ZXh0ID0ge3ZhbHVlOiB7Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCxhcmd1bWVudCk7fX19O1xuICAgICAqICAgICAgICAgYXJncyA9IFsyLDIzLDEyLDM2LDIxXTtcbiAgICAgKiAgICAgICDov5Tlm57lgLw6MzZcbiAgICAgKiAoZW5kKVxuICAgICAqIOekuuS+izpcbiAgICAgKiAoY29kZSlcbiAgICAgKiAy44CBdGVtcGxhdGUgPSBcIiQke3t2YWx1ZSxnZXRWYWx1ZX19XCI7XG4gICAgICogICAgICAgICBjb250ZXh0ID0ge3ZhbHVlOiB7Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCxhcmd1bWVudCk7fX19O1xuICAgICAqICAgICAgICAgYXJncyA9IFsyLDIzLDEyLDM2LDIxXTtcbiAgICAgKiAgICAgICDov5Tlm57lgLw6XCIkezM2fVwiXG4gICAgICogKGVuZClcbiAgICAgKiDnpLrkvos6XG4gICAgICogKGNvZGUpXG4gICAgICogM+OAgXRlbXBsYXRlID0gXCIke2EsYn1cIjtcbiAgICAgKiAgICAgICAgIGNvbnRleHQgPSB7YToge2I6XCJmb3JtYXRcIn19O1xuICAgICAqICAgICAgICAgYXJncyA9IG51bGw7XG4gICAgICogICAgICAg6L+U5Zue5YC8OlwiZm9ybWF0XCJcbiAgICAgKiAoZW5kKVxuICAgICAqIOekuuS+izpcbiAgICAgKiAoY29kZSlcbiAgICAgKiAz44CBdGVtcGxhdGUgPSBcIiR7YSxifVwiO1xuICAgICAqICAgICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgICogICAgICAgICBhcmdzID0gbnVsbDtcbiAgICAgKiAgICAgICDov5Tlm57lgLw6XCIke2EuYn1cIlxuICAgICAqIChlbmQpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIC0g5bim5qCH6K6w55qE5a2X56ym5Liy5bCG6KaB6KKr5pu/5o2i44CC5Y+C5pWwIHRlbXBsYXRlIOagvOW8j+S4ulwiJHt0b2tlbn1cIu+8jOatpOWkhOeahCB0b2tlbiDmoIforrDkvJrmm7/mjaLkuLogY29udGV4dFtcInRva2VuXCJdIOWxnuaAp+eahOWAvOOAglxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD13aW5kb3ddIC0g5bim5pyJ5bGe5oCn55qE5Y+v6YCJ5a+56LGh55qE5bGe5oCn55So5LqO5Yy56YWN5qC85byP5YyW5a2X56ym5Liy5Lit55qE5qCH6K6w44CC5aaC5p6c6K+l5Y+C5pWw5Li656m677yM5bCG5L2/55SoIHdpbmRvdyDlr7nosaHjgIJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbYXJnc10gLSDlj6/pgInlj4LmlbDkvKDpgJLnu5nlnKggY29udGV4dCDlr7nosaHkuIrmib7liLDnmoTlh73mlbDjgIJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSDku44gY29udGV4dCDlr7nosaHlsZ7mgKfkuK3mm7/mjaLlrZfnrKbkuLLmoIforrDkvY3nmoTlrZfnrKbkuLLjgIJcbiAgICAgKi9cbiAgICBmb3JtYXQ6IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgY29udGV4dCwgYXJncykge1xuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB3aW5kb3c7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGFtcGxlIG1hdGNoaW5nOlxuICAgICAgICAvLyBzdHIgICA9ICR7Zm9vLmJhcn1cbiAgICAgICAgLy8gbWF0Y2ggPSBmb28uYmFyXG4gICAgICAgIHZhciByZXBsYWNlciA9IGZ1bmN0aW9uIChzdHIsIG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc3Vicy4gRXhhbXBsZTogJHthLmIuY31cbiAgICAgICAgICAgIC8vIDAgLT4gcmVwbGFjZW1lbnQgPSBjb250ZXh0W2FdO1xuICAgICAgICAgICAgLy8gMSAtPiByZXBsYWNlbWVudCA9IGNvbnRleHRbYV1bYl07XG4gICAgICAgICAgICAvLyAyIC0+IHJlcGxhY2VtZW50ID0gY29udGV4dFthXVtiXVtjXTtcbiAgICAgICAgICAgIHZhciBzdWJzID0gbWF0Y2guc3BsaXQoL1xcLisvKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnRbc3Vic1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gYXJncyA/XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LmFwcGx5KG51bGwsIGFyZ3MpIDpcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgcmVwbGFjZW1lbnQgaXMgdW5kZWZpbmVkLCByZXR1cm4gdGhlIHN0cmluZyAndW5kZWZpbmVkJy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBhIGJ1Z3MgaW4gYnJvd3NlcnMgbm90IHByb3Blcmx5XG4gICAgICAgICAgICAvLyBkZWFsaW5nIHdpdGggbm9uLXBhcnRpY2lwYXRpbmcgZ3JvdXBzIGluIHJlZ3VsYXIgZXhwcmVzc2lvbnM6XG4gICAgICAgICAgICAvLyBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvbnBjZy1qYXZhc2NyaXB0XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VtZW50ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoU3RyaW5nRXh0LnRva2VuUmVnRXgsIHJlcGxhY2VyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7UmVnRXhwfSBbU3RyaW5nRXh0LnRva2VuUmVnRXhdXG4gICAgICogQGRlc2NyaXB0aW9uIOWvu+aJvuW4piB0b2tlbiDnmoTlrZfnrKbkuLLvvIzpu5jorqTkuLogdG9rZW5SZWdFeD0vXFwkXFx7KFtcXHcuXSs/KVxcfS9n44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBFeGFtcGxlczogJHthfSwgJHthLmIuY30sICR7YS1ifSwgJHs1fVxuICAgICAqL1xuICAgIHRva2VuUmVnRXg6IC9cXCRcXHsoW1xcdy5dKz8pXFx9L2csXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IFtTdHJpbmdFeHQubnVtYmVyUmVnRXhdXG4gICAgICogQGRlc2NyaXB0aW9uIOWIpOaWreS4gOS4quWtl+espuS4suaYr+WQpuWPquWMheWQq+S4gOS4quaVsOWAvO+8jOm7mOiupOS4uiBudW1iZXJSZWdFeD0vXihbKy1dPykoPz1cXGR8XFwuXFxkKVxcZCooXFwuXFxkKik/KFtFZV0oWystXT9cXGQrKSk/JC/jgIJcbiAgICAgKi9cbiAgICBudW1iZXJSZWdFeDogL14oWystXT8pKD89XFxkfFxcLlxcZClcXGQqKFxcLlxcZCopPyhbRWVdKFsrLV0/XFxkKykpPyQvLFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFN0cmluZ0V4dC5pc051bWVyaWNcbiAgICAgKiBAZGVzY3JpcHRpb24g5Yik5pat5LiA5Liq5a2X56ym5Liy5piv5ZCm5Y+q5YyF5ZCr5LiA5Liq5pWw5YC844CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAoY29kZSlcbiAgICAgKiBTdHJpbmdFeHQuaXNOdW1lcmljKFwiNi4wMmUyM1wiKSAvLyB0cnVlXG4gICAgICogU3RyaW5nRXh0LmlzTnVtZXJpYyhcIjEyIGRvemVuXCIpIC8vIGZhbHNlXG4gICAgICogU3RyaW5nRXh0LmlzTnVtZXJpYyhcIjRcIikgLy8gdHJ1ZVxuICAgICAqIFN0cmluZ0V4dC5pc051bWVyaWMoXCIgNCBcIikgLy8gZmFsc2VcbiAgICAgKiAoZW5kKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDlrZfnrKbkuLLljIXlkKvllK/kuIDnmoTmlbDlgLzvvIzov5Tlm54gdHJ1Ze+8m+WQpuWImei/lOWbniBmYWxzZeOAglxuICAgICAqL1xuICAgIGlzTnVtZXJpYzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmdFeHQubnVtYmVyUmVnRXgudGVzdCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBTdHJpbmdFeHQubnVtZXJpY0lmXG4gICAgICogQGRlc2NyaXB0aW9uIOaKiuS4gOS4queci+S8vOaVsOWAvOWei+eahOWtl+espuS4sui9rOWMluS4uuS4gOS4quaVsOWAvOOAglxuICAgICAqIEByZXR1cm5zIHsobnVtYmVyfHN0cmluZyl9IOWmguaenOiDvei9rOaNouS4uuaVsOWAvOWImei/lOWbnuaVsOWAvO+8jOWQpuWImei/lOWbnuWtl+espuS4suacrOi6q+OAglxuICAgICAqL1xuICAgIG51bWVyaWNJZjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmdFeHQuaXNOdW1lcmljKHZhbHVlKSA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIEBuYW1lIE51bWJlclxuICogQG5hbWVzcGFjZVxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBVdGlsXG4gKiBAZGVzY3JpcHRpb24g5pWw5YC85pON5L2c55qE5LiA57O75YiX5bi455So5omp5bGV5Ye95pWw44CCXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgdmFyIE51bWJlckV4dCA9IHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gW051bWJlckV4dC5kZWNpbWFsU2VwYXJhdG9yPScuJ11cbiAgICAgKiBAZGVzY3JpcHRpb24g5qC85byP5YyW5pWw5a2X5pe26buY6K6k55qE5bCP5pWw54K55YiG6ZqU56ym44CCXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgZGVjaW1hbFNlcGFyYXRvcjogXCIuXCIsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IFtOdW1iZXJFeHQudGhvdXNhbmRzU2VwYXJhdG9yPScsJ11cbiAgICAgKiBAZGVzY3JpcHRpb24g5qC85byP5YyW5pWw5a2X5pe26buY6K6k55qE5Y2D5L2N5YiG6ZqU56ym44CCXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgdGhvdXNhbmRzU2VwYXJhdG9yOiBcIixcIixcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBOdW1iZXJFeHQubGltaXRTaWdEaWdzXG4gICAgICogQGRlc2NyaXB0aW9uIOmZkOWItua1rueCueaVsOeahOacieaViOaVsOWtl+S9jeaVsOOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW0gLSDmta7ngrnmlbDjgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnIC0g5pyJ5pWI5L2N5pWw44CCXG4gICAgICogQHJldHVybnMge251bWJlcn0g5bCG5pWw5a2X5Zub6IiN5LqU5YWl5Yiw5oyH5a6a5pWw6YeP55qE5pyJ5pWI5L2N5pWw44CCXG4gICAgICovXG4gICAgbGltaXRTaWdEaWdzOiBmdW5jdGlvbiAobnVtLCBzaWcpIHtcbiAgICAgICAgdmFyIGZpZyA9IDA7XG4gICAgICAgIGlmIChzaWcgPiAwKSB7XG4gICAgICAgICAgICBmaWcgPSBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbihzaWcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gTnVtYmVyRXh0LmZvcm1hdFxuICAgICAqIEBkZXNjcmlwdGlvbiDmlbDlrZfmoLzlvI/ljJbovpPlh7rjgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIC0g5pWw5a2X44CCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWM9MF0gIC0g5pWw5a2X55qE5bCP5pWw6YOo5YiG5Zub6IiN5LqU5YWl5Yiw5oyH5a6a55qE5L2N5pWw44CC6K6+572u5Li6IG51bGwg5YC85pe25bCP5pWw6YOo5YiG5LiN5Y+Y44CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0c2VwPScsJ10gLSDljYPkvY3liIbpmpTnrKbjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RzZXA9Jy4nXSAtIOWwj+aVsOeCueWIhumalOespuOAglxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOaVsOWtl+agvOW8j+WMluWQjueahOWtl+espuS4suOAglxuICAgICAqL1xuICAgIGZvcm1hdDogZnVuY3Rpb24gKG51bSwgZGVjLCB0c2VwLCBkc2VwKSB7XG4gICAgICAgIGRlYyA9ICh0eXBlb2YgZGVjICE9IFwidW5kZWZpbmVkXCIpID8gZGVjIDogMDtcbiAgICAgICAgdHNlcCA9ICh0eXBlb2YgdHNlcCAhPSBcInVuZGVmaW5lZFwiKSA/IHRzZXAgOlxuICAgICAgICBOdW1iZXJFeHQudGhvdXNhbmRzU2VwYXJhdG9yO1xuICAgICAgICBkc2VwID0gKHR5cGVvZiBkc2VwICE9IFwidW5kZWZpbmVkXCIpID8gZHNlcCA6XG4gICAgICAgIE51bWJlckV4dC5kZWNpbWFsU2VwYXJhdG9yO1xuXG4gICAgICAgIGlmIChkZWMgIT0gbnVsbCkge1xuICAgICAgICAgICAgbnVtID0gcGFyc2VGbG9hdChudW0udG9GaXhlZChkZWMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0cyA9IG51bS50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSAmJiBkZWMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaW50ZWdlciB3aGVyZSB3ZSBkbyBub3Qgd2FudCB0byB0b3VjaCB0aGUgZGVjaW1hbHNcbiAgICAgICAgICAgIGRlYyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW50ZWdlciA9IHBhcnRzWzBdO1xuICAgICAgICBpZiAodHNlcCkge1xuICAgICAgICAgICAgdmFyIHRob3VzYW5kcyA9IC8oLT9bMC05XSspKFswLTldezN9KS87XG4gICAgICAgICAgICB3aGlsZSAodGhvdXNhbmRzLnRlc3QoaW50ZWdlcikpIHtcbiAgICAgICAgICAgICAgICBpbnRlZ2VyID0gaW50ZWdlci5yZXBsYWNlKHRob3VzYW5kcywgXCIkMVwiICsgdHNlcCArIFwiJDJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyO1xuICAgICAgICBpZiAoZGVjID09IDApIHtcbiAgICAgICAgICAgIHN0ciA9IGludGVnZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVtID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdIDogXCIwXCI7XG4gICAgICAgICAgICBpZiAoZGVjICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZW0gPSByZW0gKyBuZXcgQXJyYXkoZGVjIC0gcmVtLmxlbmd0aCArIDEpLmpvaW4oXCIwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gaW50ZWdlciArIGRzZXAgKyByZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuXG5pZiAoIU51bWJlci5wcm90b3R5cGUubGltaXRTaWdEaWdzKSB7XG4gICAgLyoqXG4gICAgICogQVBJTWV0aG9kOiBOdW1iZXIubGltaXRTaWdEaWdzXG4gICAgICog6ZmQ5Yi25rWu54K55pWw55qE5pyJ5pWI5pWw5a2X5L2N5pWwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWcgLeacieaViOS9jeaVsOOAglxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IOWwhuaVsOWtl+Wbm+iIjeS6lOWFpeWIsOaMh+WumuaVsOmHj+eahOacieaViOS9jeaVsOOAglxuICAgICAqICAgICAgICAgICDlpoLmnpzkvKDlhaXlgLwg5Li6IG51bGzjgIEw44CB5oiW6ICF5piv6LSf5pWwLCDov5Tlm57lgLwgMOOAglxuICAgICAqL1xuICAgIE51bWJlci5wcm90b3R5cGUubGltaXRTaWdEaWdzID0gZnVuY3Rpb24gKHNpZykge1xuICAgICAgICByZXR1cm4gTnVtYmVyRXh0LmxpbWl0U2lnRGlncyh0aGlzLCBzaWcpO1xuICAgIH07XG59XG5cbi8qKlxuICogQG5hbWUgRnVuY3Rpb25cbiAqIEBuYW1lc3BhY2VcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgVXRpbFxuICogQGRlc2NyaXB0aW9uIOWHveaVsOaTjeS9nOeahOS4gOezu+WIl+W4uOeUqOaJqeWxleWHveaVsOOAglxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IHZhciBGdW5jdGlvbkV4dCA9IHtcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRnVuY3Rpb25FeHQuYmluZFxuICAgICAqIEBkZXNjcmlwdGlvbiDnu5Hlrprlh73mlbDliLDlr7nosaHjgILmlrnkvr/liJvlu7ogdGhpcyDnmoTkvZznlKjln5/jgIJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0g6L6T5YWl5Ye95pWw44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIOWvueixoee7keWumuWIsOi+k+WFpeWHveaVsO+8iOS9nOS4uui+k+WFpeWHveaVsOeahCB0aGlzIOWvueixoe+8ieOAglxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gb2JqZWN0IOWPguaVsOS9nOS4uiBmdW5jIOWHveaVsOeahCB0aGlzIOWvueixoeOAglxuICAgICAqL1xuICAgIGJpbmQ6IGZ1bmN0aW9uIChmdW5jLCBvYmplY3QpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgcmVmZXJlbmNlIHRvIGFsbCBhcmd1bWVudHMgcGFzdCB0aGUgc2Vjb25kIG9uZVxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMsIFsyXSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBQdXNoIG9uIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBmcm9tIHRoZSBhY3R1YWwgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIC8vIFRoZXNlIHdpbGwgY29tZSBhZnRlciB0aG9zZSBzZW50IHRvIHRoZSBiaW5kIGNhbGwuXG4gICAgICAgICAgICB2YXIgbmV3QXJncyA9IGFyZ3MuY29uY2F0KFxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMsIFswXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIG5ld0FyZ3MpO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRnVuY3Rpb25FeHQuYmluZEFzRXZlbnRMaXN0ZW5lclxuICAgICAqIEBkZXNjcmlwdGlvbiDnu5Hlrprlh73mlbDliLDlr7nosaHvvIzlnKjosIPnlKjor6Xlh73mlbDml7bphY3nva7lubbkvb/nlKjkuovku7blr7nosaHkvZzkuLrnrKzkuIDkuKrlj4LmlbDjgIJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0g55So5LqO55uR5ZCs5LqL5Lu255qE5Ye95pWw44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIHRoaXMg5a+56LGh55qE5byV55So44CCXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGJpbmRBc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChmdW5jLCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChvYmplY3QsIGV2ZW50IHx8IHdpbmRvdy5ldmVudCk7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBGdW5jdGlvbkV4dC5GYWxzZVxuICAgICAqIEBkZXNjcmlwdGlvbiDor6Xlh73mlbDku4Xku4Xov5Tlm54gZmFsc2XjgILor6Xlh73mlbDkuLvopoHmmK/pgb/lhY3lnKggSUU4IOS7peS4i+a1j+iniOS4rSBET00g5LqL5Lu25Y+l5p+E55qE5Yy/5ZCN5Ye95pWw6Zeu6aKY44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkb2N1bWVudC5vbmNsaWNrID0gRnVuY3Rpb25FeHQuRmFsc2U7XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgRmFsc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRnVuY3Rpb25FeHQuVHJ1ZVxuICAgICAqIEBkZXNjcmlwdGlvbiDor6Xlh73mlbDku4Xku4Xov5Tlm54gdHJ1ZeOAguivpeWHveaVsOS4u+imgeaYr+mBv+WFjeWcqCBJRTgg5Lul5LiL5rWP6KeI5LitIERPTSDkuovku7blj6Xmn4TnmoTljL/lkI3lh73mlbDpl67popjjgIJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRvY3VtZW50Lm9uY2xpY2sgPSBGdW5jdGlvbkV4dC5UcnVlO1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRydWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBGdW5jdGlvbkV4dC5Wb2lkXG4gICAgICogQGRlc2NyaXB0aW9uIOWPr+mHjeeUqOWHveaVsO+8jOS7heS7hei/lOWbniBcInVuZGVmaW5lZFwi44CCXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBWb2lkOiBmdW5jdGlvbiAoKSB7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIEBuYW1lIEFycmF5XG4gKiBAbmFtZXNwYWNlXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIFV0aWxcbiAqIEBkZXNjcmlwdGlvbiDmlbDnu4Tmk43kvZznmoTkuIDns7vliJfluLjnlKjmianlsZXlh73mlbDjgIJcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCB2YXIgQXJyYXlFeHQgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQXJyYXlFeHQuZmlsdGVyXG4gICAgICogQGRlc2NyaXB0aW9uIOi/h+a7pOaVsOe7hO+8jOaPkOS+m+S6hiBFQ01BLTI2MiDmoIflh4bkuK0gQXJyYXkucHJvdG90eXBlLmZpbHRlciDlh73mlbDnmoTmianlsZXjgILor6bop4HvvJp7QGxpbmsgaHR0cDovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXJ9XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSDopoHov4fmu6TnmoTmlbDnu4TjgIJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIOaVsOe7hOS4reeahOavj+S4gOS4quWFg+e0oOiwg+eUqOivpeWHveaVsOOAgjwvYnI+XG4gICAgICogICAgIOWmguaenOWHveaVsOeahOi/lOWbnuWAvOS4uiB0cnVl77yM6K+l5YWD57Sg5bCG5YyF5ZCr5Zyo6L+U5Zue55qE5pWw57uE5Lit44CC6K+l5Ye95pWw5pyJ5LiJ5Liq5Y+C5pWwOiDmlbDnu4TkuK3nmoTlhYPntKDvvIzlhYPntKDnmoTntKLlvJXvvIzmlbDnu4Toh6rouqvjgII8L2JyPlxuICAgICAqICAgICDlpoLmnpzorr7nva7kuoblj6/pgInlj4LmlbAgY2FsbGVy77yM5Zyo6LCD55SoIGNhbGxiYWNrIOaXtu+8jOS9v+eUqOWPr+mAieWPguaVsCBjYWxsZXIg6K6+572u5Li6IGNhbGxiYWNrIOeahOWPguaVsOOAgjwvYnI+XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsZXJdIC0g5Zyo6LCD55SoIGNhbGxiYWNrIOaXtu+8jOS9v+eUqOWPguaVsCBjYWxsZXIg6K6+572u5Li6IGNhbGxiYWNrIOeahOWPguaVsOOAglxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY2FsbGJhY2sg5Ye95pWw6L+U5ZueIHRydWUg5pe255qE5YWD57Sg5bCG5L2c5Li66L+U5Zue5pWw57uE5Lit55qE5YWD57Sg44CCXG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAoYXJyYXksIGNhbGxiYWNrLCBjYWxsZXIpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gW107XG4gICAgICAgIGlmIChBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IGFycmF5LmZpbHRlcihjYWxsYmFjaywgY2FsbGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBhcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGNhbGxlciwgdmFsLCBpLCBhcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG59O1xuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBwcm9ncmFtIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xuLy8gaW1wb3J0IHtXS1R9IGZyb20gJy4uL2Zvcm1hdC9XS1QnO1xuLy8gaW1wb3J0IHtWZWN0b3J9IGZyb20gJy4vVmVjdG9yJztcbmltcG9ydCB7VXRpbH0gZnJvbSAnLi9VdGlsJztcblxuLyoqXG4gKiBAY2xhc3MgR2VvbWV0cnlcbiAqIEBkZXByZWNhdGVkY2xhc3MgU3VwZXJNYXAuR2VvbWV0cnlcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgR2VvbWV0cnlcbiAqIEBjbGFzc2Rlc2Mg5Yeg5L2V5a+56LGh57G777yM5o+P6L+w5Zyw55CG5a+56LGh55qE5Yeg5L2V5Zu+5b2i44CCXG4gKiBAdXNhZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIEdlb21ldHJ5IHtcblxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuQ0xBU1NfTkFNRSA9IFwiU3VwZXJNYXAuR2VvbWV0cnlcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gR2VvbWV0cnkucHJvdG90eXBlLmlkXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiAg5Yeg5L2V5a+56LGh55qE5ZSv5LiA5qCH56S656ym44CCXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gVXRpbC5jcmVhdGVVbmlxdWVJRCh0aGlzLkNMQVNTX05BTUUgKyBcIl9cIik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0dlb21ldHJ5fSBHZW9tZXRyeS5wcm90b3R5cGUucGFyZW50XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDniLbnsbvlh6DkvZXlr7nosaHjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm91bmRzfSBHZW9tZXRyeS5wcm90b3R5cGUuYm91bmRzXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDlh6DkvZXlr7nosaHnmoTojIPlm7TjgIJcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBHZW9tZXRyeS5wcm90b3R5cGUuU1JJRFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5oqV5b2x5Z2Q5qCH5Y+C5pWw44CC6YCa6L+H6K+l5Y+C5pWw77yM5pyN5Yqh5Zmo5Yik5patIEdlb21ldHJ5IOWvueixoeeahOWdkOagh+WPguiAg+ezu+aYr+WQpuS4juaVsOaNrumbhuebuOWQjO+8jOWmguaenOS4jeWQjO+8jOWImeWcqOaVsOaNruWFpeW6k+WJjei/m+ihjOaKleW9seWPmOaNouOAglxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgZ2VvbWV0cnk9IG5ldyBHZW9tZXRyeSgpO1xuICAgICAgICAgKiBnZW9tZXRyeS4gU1JJRD00MzI2O1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5TUklEID0gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeS5wcm90b3R5cGUuZGVzdHJveVxuICAgICAqIEBkZXNjcmlwdGlvbiDop6PmnoQgR2VvbWV0cnkg57G777yM6YeK5pS+6LWE5rqQ44CCXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5TUklEID0gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmVcbiAgICAgKiBAZGVzY3JpcHRpb24g5YWL6ZqG5Yeg5L2V5Zu+5b2i44CC5YWL6ZqG55qE5Yeg5L2V5Zu+5b2i5LiN6K6+572u6Z2e5qCH5YeG55qE5bGe5oCn44CCXG4gICAgICogQHJldHVybnMge0dlb21ldHJ5fSDlhYvpmobnmoTlh6DkvZXlm77lvaLjgIJcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW9tZXRyeSgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5LnByb3RvdHlwZS5zZXRCb3VuZHNcbiAgICAgKiBAZGVzY3JpcHRpb24g6K6+572u5Yeg5L2V5a+56LGh55qEIGJvdW5kc+OAglxuICAgICAqIEBwYXJhbSB7Qm91bmRzfSBib3VuZHMgLSDojIPlm7TjgIJcbiAgICAgKi9cbiAgICBzZXRCb3VuZHMoYm91bmRzKSB7XG4gICAgICAgIGlmIChib3VuZHMpIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0gYm91bmRzLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeS5wcm90b3R5cGUuY2xlYXJCb3VuZHNcbiAgICAgKiBAZGVzY3JpcHRpb24g5riF6Zmk5Yeg5L2V5a+56LGh55qEIGJvdW5kc+OAglxuICAgICAqIOWmguaenOivpeWvueixoeacieeItuexu++8jOS5n+S8mua4hemZpOeItuexu+WHoOS9leWvueixoeeahCBib3VuZHPjgIJcbiAgICAgKi9cbiAgICBjbGVhckJvdW5kcygpIHtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNsZWFyQm91bmRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeS5wcm90b3R5cGUuZXh0ZW5kQm91bmRzXG4gICAgICogQGRlc2NyaXB0aW9uIOaJqeWxleeOsOaciei+ueeVjOS7peWMheWQq+aWsOi+ueeVjOOAguWmguaenOWwmuacquiuvue9ruWHoOS9lei+ueeVjO+8jOWImeiuvue9ruaWsOi+ueeVjOOAglxuICAgICAqIEBwYXJhbSB7Qm91bmRzfSBuZXdCb3VuZHMgLSDlh6DkvZXlr7nosaHnmoQgYm91bmRz44CCXG4gICAgICovXG4gICAgZXh0ZW5kQm91bmRzKG5ld0JvdW5kcykge1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRzKG5ld0JvdW5kcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcy5leHRlbmQobmV3Qm91bmRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5LnByb3RvdHlwZS5nZXRCb3VuZHNcbiAgICAgKiBAZGVzY3JpcHRpb24g6I635b6X5Yeg5L2V5Zu+5b2i55qE6L6555WM44CC5aaC5p6c5rKh5pyJ6K6+572u6L6555WM77yM5Y+v6YCa6L+H6K6h566X6I635b6X44CCXG4gICAgICogQHJldHVybnMge0JvdW5kc30g5Yeg5L2V5a+56LGh55qE6L6555WM44CCXG4gICAgICovXG4gICAgZ2V0Qm91bmRzKCkge1xuICAgICAgICBpZiAodGhpcy5ib3VuZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHM7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnkucHJvdG90eXBlLmNhbGN1bGF0ZUJvdW5kc1xuICAgICAqIEBkZXNjcmlwdGlvbiDph43mlrDorqHnrpflh6DkvZXlm77lvaLnmoTovrnnlYzvvIjpnIDopoHlnKjlrZDnsbvkuK3lrp7njrDmraTmlrnms5XvvInjgIJcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAgICAgICAgLy9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnkucHJvdG90eXBlLmdldFZlcnRpY2VzXG4gICAgICogQGRlc2NyaXB0aW9uIOi/lOWbnuWHoOS9leWbvuW9oueahOaJgOaciemhtueCueeahOWIl+ihqO+8iOmcgOimgeWcqOWtkOexu+S4reWunueOsOatpOaWueazle+8ieOAglxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vZGVzXSAtIOWmguaenOaYryB0cnVl77yM57q/5YiZ5Y+q6L+U5Zue57q/55qE5pyr56uv54K577yM5aaC5p6cIGZhbHNl77yM5LuF5LuF6L+U5Zue6aG254K577yM5aaC5p6c5rKh5pyJ6K6+572u77yM5YiZ6L+U5Zue6aG254K544CCXG4gICAgICogQHJldHVybnMge0FycmF5fSDlh6DkvZXlm77lvaLnmoTpobbngrnliJfooajjgIJcbiAgICAgKi9cbiAgICBnZXRWZXJ0aWNlcyhub2RlcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5LnByb3RvdHlwZS5nZXRBcmVhXG4gICAgICogQGRlc2NyaXB0aW9uIOiuoeeul+WHoOS9leWvueixoeeahOmdouenryDvvIzmraTmlrnms5XpnIDopoHlnKjlrZDnsbvkuK3lrprkuYnjgIJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSDorqHnrpflkI7nmoTlr7nosaHpnaLnp6/jgIJcbiAgICAgKi9cbiAgICBnZXRBcmVhKCkge1xuICAgICAgICAvL3RvIGJlIG92ZXJyaWRkZW4gYnkgZ2VvbWV0cmllcyB0aGF0IGFjdHVhbGx5IGhhdmUgYW4gYXJlYVxuICAgICAgICAvL1xuICAgICAgICByZXR1cm4gMC4wO1xuICAgIH1cblxuXG4gICAgLy8gLyoqXG4gICAgLy8gICogQGZ1bmN0aW9uIEdlb21ldHJ5LnByb3RvdHlwZS50b1N0cmluZ1xuICAgIC8vICAqIEBkZXNjcmlwdGlvbiDov5Tlm55nZW9tZXRyeeWvueixoeeahOWtl+espuS4suihqOi/sO+8jOmcgOimgeW8leWFpXtAbGluayBXS1RGb3JtYXR944CC5q2k5pa55rOV5Y+q6IO95Zyo5a2Q57G75a6e546w77yM5Zyo54i257G75L2/55So5Lya5oql6ZSZ44CCXG4gICAgLy8gICogQHJldHVybnMge3N0cmluZ30gZ2VvbWV0cnnlr7nosaHnmoTlrZfnrKbkuLLooajov7AoV2VsbC1Lbm93biBUZXh0KVxuICAgIC8vICAqL1xuICAgIC8vIHRvU3RyaW5nKCkge1xuICAgIC8vIHZhciBzdHJpbmc7XG4gICAgLy8gaWYgKFdLVCkge1xuICAgIC8vICAgICB2YXIgd2t0ID0gbmV3IFdLVCgpO1xuICAgIC8vICAgICBzdHJpbmcgPSB3a3Qud3JpdGUobmV3IFZlY3Rvcih0aGlzKSk7XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgICAgc3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpO1xuICAgIC8vIH1cbiAgICAvLyByZXR1cm4gc3RyaW5nO1xuICAgIC8vIH1cbn1cbiIsIi8qIENvcHlyaWdodMKpIDIwMDAgLSAyMDIyIFN1cGVyTWFwIFNvZnR3YXJlIENvLkx0ZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cbmltcG9ydCB7IFN0cmluZ0V4dCB9IGZyb20gJy4vQmFzZVR5cGVzJztcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi9HZW9tZXRyeSc7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIOa1j+iniOWZqOWQjeensO+8jOS+nei1luS6jiB1c2VyQWdlbnQg5bGe5oCn77yMQlJPV1NFUl9OQU1FIOWPr+S7peaYr+epuu+8jOaIluiAheS7peS4i+a1j+iniOWZqO+8mlxuICogICAgICogXCJvcGVyYVwiIC0tIE9wZXJhXG4gKiAgICAgKiBcIm1zaWVcIiAgLS0gSW50ZXJuZXQgRXhwbG9yZXJcbiAqICAgICAqIFwic2FmYXJpXCIgLS0gU2FmYXJpXG4gKiAgICAgKiBcImZpcmVmb3hcIiAtLSBGaXJlZm94XG4gKiAgICAgKiBcIm1vemlsbGFcIiAtLSBNb3ppbGxhXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAY29uc3RhbnQge09iamVjdH1cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5Ccm93c2VyLm5hbWU7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBCcm93c2VyIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEJyb3dzZXIubmFtZTtcbiAqIGBgYFxuICovXG5jb25zdCBCcm93c2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5hbWUgPSAnJyxcbiAgICB2ZXJzaW9uID0gJycsXG4gICAgZGV2aWNlID0gJ3BjJyxcbiAgICB1YU1hdGNoO1xuICAvL+S7peS4i+i/m+ihjOa1i+ivlVxuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIGlmICh1YS5pbmRleE9mKCdtc2llJykgPiAtMSB8fCAodWEuaW5kZXhPZigndHJpZGVudCcpID4gLTEgJiYgdWEuaW5kZXhPZigncnYnKSA+IC0xKSkge1xuICAgIG5hbWUgPSAnbXNpZSc7XG4gICAgdWFNYXRjaCA9IHVhLm1hdGNoKC9tc2llIChbXFxkLl0rKS8pIHx8IHVhLm1hdGNoKC9ydjooW1xcZC5dKykvKTtcbiAgfSBlbHNlIGlmICh1YS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKSB7XG4gICAgbmFtZSA9ICdjaHJvbWUnO1xuICAgIHVhTWF0Y2ggPSB1YS5tYXRjaCgvY2hyb21lXFwvKFtcXGQuXSspLyk7XG4gIH0gZWxzZSBpZiAodWEuaW5kZXhPZignZmlyZWZveCcpID4gLTEpIHtcbiAgICBuYW1lID0gJ2ZpcmVmb3gnO1xuICAgIHVhTWF0Y2ggPSB1YS5tYXRjaCgvZmlyZWZveFxcLyhbXFxkLl0rKS8pO1xuICB9IGVsc2UgaWYgKHVhLmluZGV4T2YoJ29wZXJhJykgPiAtMSkge1xuICAgIG5hbWUgPSAnb3BlcmEnO1xuICAgIHVhTWF0Y2ggPSB1YS5tYXRjaCgvdmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICB9IGVsc2UgaWYgKHVhLmluZGV4T2YoJ3NhZmFyaScpID4gLTEpIHtcbiAgICBuYW1lID0gJ3NhZmFyaSc7XG4gICAgdWFNYXRjaCA9IHVhLm1hdGNoKC92ZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gIH1cbiAgdmVyc2lvbiA9IHVhTWF0Y2ggPyB1YU1hdGNoWzFdIDogJyc7XG5cbiAgaWYgKHVhLmluZGV4T2YoJ2lwYWQnKSA+IC0xIHx8IHVhLmluZGV4T2YoJ2lwb2QnKSA+IC0xIHx8IHVhLmluZGV4T2YoJ2lwaG9uZScpID4gLTEpIHtcbiAgICBkZXZpY2UgPSAnYXBwbGUnO1xuICB9IGVsc2UgaWYgKHVhLmluZGV4T2YoJ2FuZHJvaWQnKSA+IC0xKSB7XG4gICAgdWFNYXRjaCA9IHVhLm1hdGNoKC92ZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gICAgdmVyc2lvbiA9IHVhTWF0Y2ggPyB1YU1hdGNoWzFdIDogJyc7XG4gICAgZGV2aWNlID0gJ2FuZHJvaWQnO1xuICB9XG4gIHJldHVybiB7IG5hbWU6IG5hbWUsIHZlcnNpb246IHZlcnNpb24sIGRldmljZTogZGV2aWNlIH07XG59KSgpO1xuXG5jb25zdCBpc1N1cHBvcnRDYW52YXMgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2hlY2tSZXMgPSB0cnVlLFxuICAgIGJyb3ogPSBCcm93c2VyO1xuICBpZiAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCkge1xuICAgIGlmIChicm96Lm5hbWUgPT09ICdmaXJlZm94JyAmJiBwYXJzZUZsb2F0KGJyb3oudmVyc2lvbikgPCA1KSB7XG4gICAgICBjaGVja1JlcyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYnJvei5uYW1lID09PSAnc2FmYXJpJyAmJiBwYXJzZUZsb2F0KGJyb3oudmVyc2lvbikgPCA0KSB7XG4gICAgICBjaGVja1JlcyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYnJvei5uYW1lID09PSAnb3BlcmEnICYmIHBhcnNlRmxvYXQoYnJvei52ZXJzaW9uKSA8IDEwKSB7XG4gICAgICBjaGVja1JlcyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYnJvei5uYW1lID09PSAnbXNpZScgJiYgcGFyc2VGbG9hdChicm96LnZlcnNpb24pIDwgOSkge1xuICAgICAgY2hlY2tSZXMgPSBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tSZXMgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2hlY2tSZXM7XG59KSgpO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiDlpoLmnpwgdXNlckFnZW50IOaNleiOt+WIsOa1j+iniOWZqOS9v+eUqOeahOaYryBHZWNrbyDlvJXmk47liJnov5Tlm54gdHJ1ZeOAglxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBJU19HRUNLTyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHVhLmluZGV4T2YoJ3dlYmtpdCcpID09PSAtMSAmJiB1YS5pbmRleE9mKCdnZWNrbycpICE9PSAtMTtcbn0pKCk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICogQGRlc2NyaXB0aW9uIOWIhui+qOeOh+S4juavlOS+i+WwuuS5i+mXtOi9rOaNoueahOW4uOmHj+OAglxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgRE9UU19QRVJfSU5DSCA9IDk2O1xuXG4vKipcbiAqIEBuYW1lIENvbW1vblV0aWxcbiAqIEBuYW1lc3BhY2VcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgVXRpbFxuICogQGRlc2NyaXB0aW9uIGNvbW1vbiDlt6XlhbfnsbvjgIJcbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5Db21tb25VdGlsLmdldEVsZW1lbnQoKTtcbiAqXG4gKiAgIC8vIOW8g+eUqOeahOWGmeazlVxuICogICBjb25zdCByZXN1bHQgPSBTdXBlck1hcC5VdGlsLmdldEVsZW1lbnQoKTtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqXG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBDb21tb25VdGlsIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IENvbW1vblV0aWwuZ2V0RWxlbWVudCgpO1xuICogYGBgXG4gKi9cblxuY29uc3QgVXRpbCA9IHtcbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDlpI3liLbmupDlr7nosaHnmoTmiYDmnInlsZ7mgKfliLDnm67moIflr7nosaHkuIrvvIzmupDlr7nosaHkuIrnmoTmsqHmnInlrprkuYnnmoTlsZ7mgKflnKjnm67moIflr7nosaHkuIrkuZ/kuI3kvJrooqvorr7nva7jgIJcbiAgICogQGV4YW1wbGVcbiAgICog6KaB5aSN5Yi2IFNpemUg5a+56LGh55qE5omA5pyJ5bGe5oCn5Yiw6Ieq5a6a5LmJ5a+56LGh5LiK77yM5L2/55So5pa55rOV5aaC5LiLOlxuICAgKiAgICAgdmFyIHNpemUgPSBuZXcgU2l6ZSgxMDAsIDEwMCk7XG4gICAqICAgICB2YXIgb2JqID0ge33vvJtcbiAgICogICAgIENvbW1vblV0aWwuZXh0ZW5kKG9iaiwgc2l6ZSk7XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdGluYXRpb25dIC0g55uu5qCH5a+56LGh44CCXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgLSDmupDlr7nosaHvvIzlhbblsZ7mgKflsIbooqvorr7nva7liLDnm67moIflr7nosaHkuIrjgIJcbiAgICogQHJldHVybnMge09iamVjdH0g55uu5qCH5a+56LGh44CCXG4gICAqL1xuXG4gIGV4dGVuZDogZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICBkZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uIHx8IHt9O1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSUUgZG9lc24ndCBpbmNsdWRlIHRoZSB0b1N0cmluZyBwcm9wZXJ0eSB3aGVuIGl0ZXJhdGluZyBvdmVyIGFuIG9iamVjdCdzXG4gICAgICAgKiBwcm9wZXJ0aWVzIHdpdGggdGhlIGZvcihwcm9wZXJ0eSBpbiBvYmplY3QpIHN5bnRheC4gIEV4cGxpY2l0bHkgY2hlY2sgaWZcbiAgICAgICAqIHRoZSBzb3VyY2UgaGFzIGl0cyBvd24gdG9TdHJpbmcgcHJvcGVydHkuXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgICAqIEZGL1dpbmRvd3MgPCAyLjAuMC4xMyByZXBvcnRzIFwiSWxsZWdhbCBvcGVyYXRpb24gb24gV3JhcHBlZE5hdGl2ZVxuICAgICAgICogcHJvdG90eXBlIG9iamVjdFwiIHdoZW4gY2FsbGluZyBoYXdPd25Qcm9wZXJ0eSBpZiB0aGUgc291cmNlIG9iamVjdFxuICAgICAgICogaXMgYW4gaW5zdGFuY2Ugb2Ygd2luZG93LkV2ZW50LlxuICAgICAgICovXG5cbiAgICAgIHZhciBzb3VyY2VJc0V2dCA9IHR5cGVvZiB3aW5kb3cuRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgc291cmNlIGluc3RhbmNlb2Ygd2luZG93LkV2ZW50O1xuXG4gICAgICBpZiAoIXNvdXJjZUlzRXZ0ICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eSAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgZGVzdGluYXRpb24udG9TdHJpbmcgPSBzb3VyY2UudG9TdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgfSxcbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDlr7nosaHmi7fotJ3jgIJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXNdIC0g55uu5qCH5a+56LGh44CCXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb2MgLSDmupDlr7nosaHjgIJcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uIChkZXMsIHNvYykge1xuICAgIGRlcyA9IGRlcyB8fCB7fTtcbiAgICB2YXIgdjtcbiAgICBpZiAoc29jKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGRlcykge1xuICAgICAgICB2ID0gc29jW3BdO1xuICAgICAgICBpZiAodHlwZW9mIHYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZGVzW3BdID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDplIDmr4Hlr7nosaHvvIzlsIblhbblsZ7mgKfnva7nqbrjgIJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmpdIC0g55uu5qCH5a+56LGh44CCXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24gKG9iaikge1xuICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICBpZiAodHlwZW9mIG9ialtwXSA9PT0gJ29iamVjdCcgJiYgb2JqW3BdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIG9ialtwXSkge1xuICAgICAgICAgICAgaWYgKG9ialtwXVtpXS5kZXN0cm95KSB7XG4gICAgICAgICAgICAgIG9ialtwXVtpXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ialtwXS5sZW5ndGggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpbcF0gPT09ICdvYmplY3QnICYmIG9ialtwXSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmpbcF0uZGVzdHJveSkge1xuICAgICAgICAgICAgb2JqW3BdLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqW3BdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDojrflj5YgSFRNTCDlhYPntKDmlbDnu4TjgIJcbiAgICogQHJldHVybnMge0FycmF5LjxIVE1MRWxlbWVudD59IEhUTUwg5YWD57Sg5pWw57uE44CCXG4gICAqL1xuICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiBpbnN0YW5jZSBvZiDnmoTot6jmtY/op4jlmajlrp7njrDjgIJcbiAgICogQHBhcmFtIHtPYmplY3R9IG8gLSDlr7nosaHjgIJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IOaYr+WQpuaYr+mhtemdouWFg+e0oOOAglxuICAgKi9cbiAgaXNFbGVtZW50OiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiAhIShvICYmIG8ubm9kZVR5cGUgPT09IDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgQ29tbW9uVXRpbFxuICAgKiBAZGVzY3JpcHRpb24g5Yik5pat5LiA5Liq5a+56LGh5piv5ZCm5piv5pWw57uE44CCXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhIC0g5a+56LGh44CCXG4gICAqIEByZXR1cm5zIHtib29sZWFufSDmmK/lkKbmmK/mlbDnu4TjgIJcbiAgICovXG4gIGlzQXJyYXk6IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfSxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOS7juaVsOe7hOS4reWIoOmZpOafkOS4gOmhueOAglxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIOaVsOe7hOOAglxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIOaVsOe7hOS4reimgeWIoOmZpOeahOS4gOmhueOAglxuICAgKiBAcmV0dXJucyB7QXJyYXl9IOaJp+ihjOWIoOmZpOaTjeS9nOWQjueahOaVsOe7hOOAglxuICAgKi9cbiAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKGFycmF5LCBpdGVtKSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICAvL2JyZWFrO21vcmUgdGhhbiBvbmNlPz9cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgQ29tbW9uVXRpbFxuICAgKiBAZGVzY3JpcHRpb24g6I635Y+W5p+Q5a+56LGh5Zyo5pWw57uE5Lit55qE57Si5byV5YC844CCXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGFycmF5IC0g5pWw57uE44CCXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSDlr7nosaHjgIJcbiAgICogQHJldHVybnMge251bWJlcn0g5p+Q5a+56LGh5Zyo5pWw57uE5Lit55qE57Si5byV5YC844CCXG4gICAqL1xuICBpbmRleE9mOiBmdW5jdGlvbiAoYXJyYXksIG9iaikge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVzZSB0aGUgYnVpbGQtaW4gZnVuY3Rpb24gaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHR5cGVvZiBhcnJheS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKG9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDkv67mlLnmn5AgRE9NIOWFg+e0oOeahOiuuOWkmuWxnuaAp+OAglxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0g5b6F5L+u5pS555qEIERPTSDlhYPntKDjgIJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtpZF0gLSBET00g5YWD57Sg55qEIElE44CCXG4gICAqIEBwYXJhbSB7UGl4ZWx9IFtweF0gLSBET00g5YWD57Sg55qEIHN0eWxlIOWxnuaAp+eahCBsZWZ0IOWSjCB0b3Ag5bGe5oCn44CCXG4gICAqIEBwYXJhbSB7U2l6ZX0gW3N6XSAtIERPTSDlhYPntKDnmoQgd2lkdGgg5ZKMIGhlaWdodCDlsZ7mgKfjgIJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwb3NpdGlvbl0gLSBET00g5YWD57Sg55qEIHBvc2l0aW9uIOWxnuaAp+OAglxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2JvcmRlcl0gLSBET00g5YWD57Sg55qEIHN0eWxlIOWxnuaAp+eahCBib3JkZXIg5bGe5oCn44CCXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3ZlcmZsb3ddIC0gRE9NIOWFg+e0oOeahCBzdHlsZSDlsZ7mgKfnmoQgb3ZlcmZsb3cg5bGe5oCn44CCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3BhY2l0eV0gLSDkuI3pgI/mmI7luqblgLzjgILlj5blgLzojIPlm7TkuLooMC4wIC0gMS4wKeOAglxuICAgKi9cbiAgbW9kaWZ5RE9NRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIGlkLCBweCwgc3osIHBvc2l0aW9uLCBib3JkZXIsIG92ZXJmbG93LCBvcGFjaXR5KSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICBlbGVtZW50LmlkID0gaWQ7XG4gICAgfVxuICAgIGlmIChweCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gcHgueCArICdweCc7XG4gICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IHB4LnkgKyAncHgnO1xuICAgIH1cbiAgICBpZiAoc3opIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBzei53ICsgJ3B4JztcbiAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gc3ouaCArICdweCc7XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICBpZiAoYm9yZGVyKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmJvcmRlciA9IGJvcmRlcjtcbiAgICB9XG4gICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuICAgIGlmIChwYXJzZUZsb2F0KG9wYWNpdHkpID49IDAuMCAmJiBwYXJzZUZsb2F0KG9wYWNpdHkpIDwgMS4wKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmZpbHRlciA9ICdhbHBoYShvcGFjaXR5PScgKyBvcGFjaXR5ICogMTAwICsgJyknO1xuICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlRmxvYXQob3BhY2l0eSkgPT09IDEuMCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5maWx0ZXIgPSAnJztcbiAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOavlOi+g+S4pOS4quWvueixoeW5tuWQiOW5tuOAglxuICAgKiBAcGFyYW0ge09iamVjdH0gW3RvXSAtIOebruagh+WvueixoeOAglxuICAgKiBAcGFyYW0ge09iamVjdH0gZnJvbSAtIOa6kOWvueixoeOAglxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSDov5Tlm57lkIjlubblkI7nmoTlr7nosaHjgIJcbiAgICovXG4gIGFwcGx5RGVmYXVsdHM6IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIHRvID0gdG8gfHwge307XG4gICAgLypcbiAgICAgKiBGRi9XaW5kb3dzIDwgMi4wLjAuMTMgcmVwb3J0cyBcIklsbGVnYWwgb3BlcmF0aW9uIG9uIFdyYXBwZWROYXRpdmVcbiAgICAgKiBwcm90b3R5cGUgb2JqZWN0XCIgd2hlbiBjYWxsaW5nIGhhd093blByb3BlcnR5IGlmIHRoZSBzb3VyY2Ugb2JqZWN0IGlzIGFuXG4gICAgICogaW5zdGFuY2Ugb2Ygd2luZG93LkV2ZW50LlxuICAgICAqL1xuICAgIHZhciBmcm9tSXNFdnQgPSB0eXBlb2Ygd2luZG93LkV2ZW50ID09PSAnZnVuY3Rpb24nICYmIGZyb20gaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnQ7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKFxuICAgICAgICB0b1trZXldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKCFmcm9tSXNFdnQgJiYgZnJvbS5oYXNPd25Qcm9wZXJ0eSAmJiBmcm9tLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICApIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSUUgZG9lc24ndCBpbmNsdWRlIHRoZSB0b1N0cmluZyBwcm9wZXJ0eSB3aGVuIGl0ZXJhdGluZyBvdmVyIGFuIG9iamVjdCdzXG4gICAgICogcHJvcGVydGllcyB3aXRoIHRoZSBmb3IocHJvcGVydHkgaW4gb2JqZWN0KSBzeW50YXguICBFeHBsaWNpdGx5IGNoZWNrIGlmXG4gICAgICogdGhlIHNvdXJjZSBoYXMgaXRzIG93biB0b1N0cmluZyBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBpZiAoXG4gICAgICAhZnJvbUlzRXZ0ICYmXG4gICAgICBmcm9tICYmXG4gICAgICBmcm9tLmhhc093blByb3BlcnR5ICYmXG4gICAgICBmcm9tLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpICYmXG4gICAgICAhdG8uaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJylcbiAgICApIHtcbiAgICAgIHRvLnRvU3RyaW5nID0gZnJvbS50b1N0cmluZztcbiAgICB9XG5cbiAgICByZXR1cm4gdG87XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDlsIblj4LmlbDlr7nosaHovazmjaLkuLogSFRUUCDnmoQgR0VUIOivt+axguS4reeahOWPguaVsOWtl+espuS4suOAguS+i+Wmgu+8mlwia2V5MT12YWx1ZTEma2V5Mj12YWx1ZTIma2V5Mz12YWx1ZTNcIuOAglxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0g5Y+C5pWw5a+56LGh44CCXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEhUVFAg55qEIEdFVCDor7fmsYLkuK3nmoTlj4LmlbDlrZfnrKbkuLLjgIJcbiAgICovXG4gIGdldFBhcmFtZXRlclN0cmluZzogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbXNBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGVuY29kZWRWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgZW5jb2RlZFZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogdmFsdWUgaXMgYSBzdHJpbmc7IHNpbXBseSBlbmNvZGUgKi9cbiAgICAgICAgICBlbmNvZGVkVmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtc0FycmF5LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXNBcnJheS5qb2luKCcmJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDnu5kgVVJMIOi/veWKoOafpeivouWPguaVsOOAglxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0g5b6F6L+95Yqg5Y+C5pWw55qEIFVSTCDlrZfnrKbkuLLjgIJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtU3RyIC0g5b6F6L+95Yqg55qE5p+l6K+i5Y+C5pWw44CCXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IOaWsOeahCBVUkzjgIJcbiAgICovXG4gIHVybEFwcGVuZDogZnVuY3Rpb24gKHVybCwgcGFyYW1TdHIpIHtcbiAgICB2YXIgbmV3VXJsID0gdXJsO1xuICAgIGlmIChwYXJhbVN0cikge1xuICAgICAgaWYgKHBhcmFtU3RyLmluZGV4T2YoJz8nKSA9PT0gMCkge1xuICAgICAgICBwYXJhbVN0ciA9IHBhcmFtU3RyLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJ0cyA9ICh1cmwgKyAnICcpLnNwbGl0KC9bPyZdLyk7XG4gICAgICBuZXdVcmwgKz0gcGFydHMucG9wKCkgPT09ICcgJyA/IHBhcmFtU3RyIDogcGFydHMubGVuZ3RoID8gJyYnICsgcGFyYW1TdHIgOiAnPycgKyBwYXJhbVN0cjtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1VybDtcbiAgfSxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOe7mSBVUkwg6L+95YqgIHBhdGgg5Y+C5pWw44CCXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSDlvoXov73liqDlj4LmlbDnmoQgVVJMIOWtl+espuS4suOAglxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1TdHIgLSDlvoXov73liqDnmoRwYXRo5Y+C5pWw44CCXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IOaWsOeahCBVUkzjgIJcbiAgICovXG4gIHVybFBhdGhBcHBlbmQ6IGZ1bmN0aW9uICh1cmwsIHBhdGhTdHIpIHtcbiAgICBsZXQgbmV3VXJsID0gdXJsO1xuICAgIGlmICghcGF0aFN0cikge1xuICAgICAgcmV0dXJuIG5ld1VybDtcbiAgICB9XG4gICAgaWYgKHBhdGhTdHIuaW5kZXhPZignLycpID09PSAwKSB7XG4gICAgICBwYXRoU3RyID0gcGF0aFN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgaWYgKHBhcnRzWzBdLmluZGV4T2YoJy8nLCBwYXJ0c1swXS5sZW5ndGggLSAxKSA8IDApIHtcbiAgICAgIHBhcnRzWzBdICs9ICcvJztcbiAgICB9XG4gICAgbmV3VXJsID0gYCR7cGFydHNbMF19JHtwYXRoU3RyfSR7cGFydHMubGVuZ3RoID4gMSA/IGA/JHtwYXJ0c1sxXX1gIDogJyd9YDtcbiAgICByZXR1cm4gbmV3VXJsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgQ29tbW9uVXRpbFxuICAgKiBAZGVzY3JpcHRpb24g5Li65LqG6YG/5YWN5rWu54K557K+5bqm6ZSZ6K+v6ICM5L+d55WZ55qE5pyJ5pWI5L2N5pWw44CCXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDE0XG4gICAqL1xuICBERUZBVUxUX1BSRUNJU0lPTjogMTQsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDlsIblrZfnrKbkuLLku6XmjqXov5HnmoTnsr7luqbovazmjaLkuLrmlbDlrZfjgIJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG51bWJlciAtIOWtl+espuS4suOAglxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0xNF0gLSDnsr7luqbjgIJcbiAgICogQHJldHVybnMge251bWJlcn0g6L2s5YyW5ZCO55qE5pWw5a2X44CCXG4gICAqL1xuICB0b0Zsb2F0OiBmdW5jdGlvbiAobnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICBpZiAocHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgIHByZWNpc2lvbiA9IFV0aWwuREVGQVVMVF9QUkVDSVNJT047XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbnVtYmVyICE9PSAnbnVtYmVyJykge1xuICAgICAgbnVtYmVyID0gcGFyc2VGbG9hdChudW1iZXIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSAwID8gbnVtYmVyIDogcGFyc2VGbG9hdChudW1iZXIudG9QcmVjaXNpb24ocHJlY2lzaW9uKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDop5LluqbovazlvKfluqbjgIJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSDop5LluqbjgIJcbiAgICogQHJldHVybnMge251bWJlcn0g6L2s5YyW5ZCO55qE5byn5bqm44CCXG4gICAqL1xuICByYWQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuICh4ICogTWF0aC5QSSkgLyAxODA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDku44gVVJMIOWtl+espuS4suS4reino+aekOWHuuWPguaVsOWvueixoeOAglxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJM44CCXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IOino+aekOWHuueahOWPguaVsOWvueixoeOAglxuICAgKi9cbiAgZ2V0UGFyYW1ldGVyczogZnVuY3Rpb24gKHVybCkge1xuICAgIC8vIGlmIG5vIHVybCBzcGVjaWZpZWQsIHRha2UgaXQgZnJvbSB0aGUgbG9jYXRpb24gYmFyXG4gICAgdXJsID0gdXJsID09PSBudWxsIHx8IHVybCA9PT0gdW5kZWZpbmVkID8gd2luZG93LmxvY2F0aW9uLmhyZWYgOiB1cmw7XG5cbiAgICAvL3BhcnNlIG91dCBwYXJhbWV0ZXJzIHBvcnRpb24gb2YgdXJsIHN0cmluZ1xuICAgIHZhciBwYXJhbXNTdHJpbmcgPSAnJztcbiAgICBpZiAoU3RyaW5nRXh0LmNvbnRhaW5zKHVybCwgJz8nKSkge1xuICAgICAgdmFyIHN0YXJ0ID0gdXJsLmluZGV4T2YoJz8nKSArIDE7XG4gICAgICB2YXIgZW5kID0gU3RyaW5nRXh0LmNvbnRhaW5zKHVybCwgJyMnKSA/IHVybC5pbmRleE9mKCcjJykgOiB1cmwubGVuZ3RoO1xuICAgICAgcGFyYW1zU3RyaW5nID0gdXJsLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1ldGVycyA9IHt9O1xuICAgIHZhciBwYWlycyA9IHBhcmFtc1N0cmluZy5zcGxpdCgvWyY7XS8pO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdmFyIGtleVZhbHVlID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIGlmIChrZXlWYWx1ZVswXSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5VmFsdWVbMF07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGtleSA9IHVuZXNjYXBlKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWluZyBsaWJlcmFsIGJ5IHJlcGxhY2luZyBcIitcIiB3aXRoIFwiIFwiXG4gICAgICAgIHZhciB2YWx1ZSA9IChrZXlWYWx1ZVsxXSB8fCAnJykucmVwbGFjZSgvXFwrL2csICcgJyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHZhbHVlID0gdW5lc2NhcGUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9sbG93IE9HQyBjb252ZW50aW9uIG9mIGNvbW1hIGRlbGltaXRlZCB2YWx1ZXNcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnLCcpO1xuXG4gICAgICAgIC8vaWYgdGhlcmUncyBvbmx5IG9uZSB2YWx1ZSwgZG8gbm90IHJldHVybiBhcyBhcnJheVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1ldGVyc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgQ29tbW9uVXRpbFxuICAgKiBAZGVzY3JpcHRpb24g5LiN5pat6YCS5aKe6K6h5pWw5Y+Y6YeP77yM55So5LqO55Sf5oiQ5ZSv5LiAIElE44CCXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGxhc3RTZXFJRDogMCxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOWIm+W7uuWUr+S4gCBJRCDlgLzjgIJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdIC0g5YmN57yA44CCXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IOWUr+S4gOeahCBJRCDlgLzjgIJcbiAgICovXG4gIGNyZWF0ZVVuaXF1ZUlEOiBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICBwcmVmaXggPSAnaWRfJztcbiAgICB9XG4gICAgVXRpbC5sYXN0U2VxSUQgKz0gMTtcbiAgICByZXR1cm4gcHJlZml4ICsgVXRpbC5sYXN0U2VxSUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDliKTmlq3lubbovazljJbmr5TkvovlsLrjgIJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0g5q+U5L6L5bC644CCXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IOato+W4uOeahCBzY2FsZSDlgLzjgIJcbiAgICovXG4gIG5vcm1hbGl6ZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICB2YXIgbm9ybVNjYWxlID0gc2NhbGUgPiAxLjAgPyAxLjAgLyBzY2FsZSA6IHNjYWxlO1xuICAgIHJldHVybiBub3JtU2NhbGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDmr5TkvovlsLrovazliIbovqjnjofjgIJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0g5q+U5L6L5bC644CCXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9J2RlZ3JlZXMnXSAtIOavlOS+i+WwuuWNleS9jeOAglxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSDovazljJblkI7nmoTliIbovqjnjofjgIJcbiAgICovXG4gIGdldFJlc29sdXRpb25Gcm9tU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdW5pdHMpIHtcbiAgICB2YXIgcmVzb2x1dGlvbjtcbiAgICBpZiAoc2NhbGUpIHtcbiAgICAgIGlmICh1bml0cyA9PSBudWxsKSB7XG4gICAgICAgIHVuaXRzID0gJ2RlZ3JlZXMnO1xuICAgICAgfVxuICAgICAgdmFyIG5vcm1TY2FsZSA9IFV0aWwubm9ybWFsaXplU2NhbGUoc2NhbGUpO1xuICAgICAgcmVzb2x1dGlvbiA9IDEgLyAobm9ybVNjYWxlICogSU5DSEVTX1BFUl9VTklUW3VuaXRzXSAqIERPVFNfUEVSX0lOQ0gpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOWIhui+qOeOh+i9rOavlOS+i+WwuuOAglxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiAtIOWIhui+qOeOh+OAglxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPSdkZWdyZWVzJ10gLSDliIbovqjnjofljZXkvY3jgIJcbiAgICogQHJldHVybnMge251bWJlcn0g6L2s5YyW5ZCO55qE5q+U5L6L5bC644CCXG4gICAqL1xuICBnZXRTY2FsZUZyb21SZXNvbHV0aW9uOiBmdW5jdGlvbiAocmVzb2x1dGlvbiwgdW5pdHMpIHtcbiAgICBpZiAodW5pdHMgPT0gbnVsbCkge1xuICAgICAgdW5pdHMgPSAnZGVncmVlcyc7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gcmVzb2x1dGlvbiAqIElOQ0hFU19QRVJfVU5JVFt1bml0c10gKiBET1RTX1BFUl9JTkNIO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfSxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOiOt+WPlua1j+iniOWZqOebuOWFs+S/oeaBr+OAguaUr+aMgeeahOa1j+iniOWZqOWMheaLrO+8mk9wZXJh77yMSW50ZXJuZXQgRXhwbG9yZXLvvIxTYWZhcmnvvIxGaXJlZm9444CCXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IOa1j+iniOWZqOWQjeensOOAgeeJiOacrOOAgeiuvuWkh+WQjeensOOAguWvueW6lOeahOWxnuaAp+WIhuWIq+S4uiBuYW1lLCB2ZXJzaW9uLCBkZXZpY2XjgIJcbiAgICovXG4gIGdldEJyb3dzZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQnJvd3NlcjtcbiAgfSxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOa1j+iniOWZqOaYr+WQpuaUr+aMgSBDYW52YXPjgIJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IOW9k+WJjea1j+iniOWZqOaYr+WQpuaUr+aMgSBIVE1MNSBDYW52YXPjgIJcbiAgICovXG4gIGlzU3VwcG9ydENhbnZhcyxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOWIpOaWre+8m+a1j+iniOWZqOaYr+WQpuaUr+aMgSBDYW52YXPjgIJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IOW9k+WJjea1j+iniOWZqOaYr+WQpuaUr+aMgSBIVE1MNSBDYW52YXMg44CCXG4gICAqL1xuICBzdXBwb3J0Q2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFV0aWwuaXNTdXBwb3J0Q2FudmFzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgQ29tbW9uVXRpbFxuICAgKiBAZGVzY3JpcHRpb24g5Yik5pat5LiA5LiqIFVSTCDor7fmsYLmmK/lkKblnKjlvZPliY3ln5/kuK3jgIJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFVSTCDor7fmsYLlrZfnrKbkuLLjgIJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFVSTCDor7fmsYLmmK/lkKblnKjlvZPliY3ln5/kuK3jgIJcbiAgICovXG4gIGlzSW5UaGVTYW1lRG9tYWluOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSB1cmwuaW5kZXhPZignLy8nKTtcbiAgICB2YXIgZG9jdW1lbnRVcmwgPSBkb2N1bWVudC5sb2NhdGlvbi50b1N0cmluZygpO1xuICAgIHZhciBkb2N1bWVudEluZGV4ID0gZG9jdW1lbnRVcmwuaW5kZXhPZignLy8nKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByb3RvY29sO1xuICAgICAgdmFyIHN1YnN0cmluZyA9IChwcm90b2NvbCA9IHVybC5zdWJzdHJpbmcoMCwgaW5kZXgpKTtcbiAgICAgIHZhciBkb2N1bWVudFN1YlN0cmluZyA9IGRvY3VtZW50VXJsLnN1YnN0cmluZyhkb2N1bWVudEluZGV4ICsgMik7XG4gICAgICBkb2N1bWVudEluZGV4ID0gZG9jdW1lbnRTdWJTdHJpbmcuaW5kZXhPZignLycpO1xuICAgICAgdmFyIGRvY3VtZW50UG9ydEluZGV4ID0gZG9jdW1lbnRTdWJTdHJpbmcuaW5kZXhPZignOicpO1xuICAgICAgdmFyIGRvY3VtZW50RG9tYWluV2l0aFBvcnQgPSBkb2N1bWVudFN1YlN0cmluZy5zdWJzdHJpbmcoMCwgZG9jdW1lbnRJbmRleCk7XG4gICAgICAvL3ZhciBkb2N1bWVudFBvcnQ7XG5cbiAgICAgIHZhciBkb2N1bWVudHByb3RvY29sID0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICBpZiAoZG9jdW1lbnRQb3J0SW5kZXggIT09IC0xKSB7XG4gICAgICAgIC8vIGRvY3VtZW50UG9ydCA9ICtkb2N1bWVudFN1YlN0cmluZy5zdWJzdHJpbmcoZG9jdW1lbnRQb3J0SW5kZXgsIGRvY3VtZW50SW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnREb21haW5XaXRoUG9ydCArPSAnOicgKyAoZG9jdW1lbnRwcm90b2NvbC50b0xvd2VyQ2FzZSgpID09PSAnaHR0cDonID8gODAgOiA0NDMpO1xuICAgICAgfVxuICAgICAgaWYgKGRvY3VtZW50cHJvdG9jb2wudG9Mb3dlckNhc2UoKSAhPT0gc3Vic3RyaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3Vic3RyaW5nID0gdXJsLnN1YnN0cmluZyhpbmRleCArIDIpO1xuICAgICAgdmFyIHBvcnRJbmRleCA9IHN1YnN0cmluZy5pbmRleE9mKCc6Jyk7XG4gICAgICBpbmRleCA9IHN1YnN0cmluZy5pbmRleE9mKCcvJyk7XG4gICAgICB2YXIgZG9tYWluV2l0aFBvcnQgPSBzdWJzdHJpbmcuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgIHZhciBkb21haW47XG4gICAgICBpZiAocG9ydEluZGV4ICE9PSAtMSkge1xuICAgICAgICBkb21haW4gPSBzdWJzdHJpbmcuc3Vic3RyaW5nKDAsIHBvcnRJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21haW4gPSBzdWJzdHJpbmcuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgZG9tYWluV2l0aFBvcnQgKz0gJzonICsgKHByb3RvY29sLnRvTG93ZXJDYXNlKCkgPT09ICdodHRwOicgPyA4MCA6IDQ0Myk7XG4gICAgICB9XG4gICAgICB2YXIgZG9jdW1lbnREb21haW4gPSBkb2N1bWVudC5kb21haW47XG4gICAgICBpZiAoZG9tYWluID09PSBkb2N1bWVudERvbWFpbiAmJiBkb21haW5XaXRoUG9ydCA9PT0gZG9jdW1lbnREb21haW5XaXRoUG9ydCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgQ29tbW9uVXRpbFxuICAgKiBAZGVzY3JpcHRpb24g6K6h566XIGlTZXJ2ZXIg5pyN5Yqh55qEIFJFU1Qg5Zu+5bGC55qE5pi+56S65YiG6L6o546H77yM6ZyA6KaB5LuOIGlTZXJ2ZXIg55qEIFJFU1Qg5Zu+5bGC6KGo6L+w5Lit6I635Y+WIHZpZXdCb3VuZHPjgIF2aWV3ZXLjgIFzY2FsZeOAgWNvb3JkVW5pdOOAgWRhdHVtQXhpcyDkupTkuKrlj4LmlbDvvIzmnaXov5vooYzorqHnrpfjgIJcbiAgICogQHBhcmFtIHtCb3VuZHN9IHZpZXdCb3VuZHMgLSDlnLDlm77nmoTlj4Lnhaflj6/op4bojIPlm7TvvIzljbPlnLDlm77liJ3lp4vljJbml7bpu5jorqTnmoTlnLDlm77mmL7npLrojIPlm7TjgIJcbiAgICogQHBhcmFtIHtTaXplfSB2aWV3ZXIgLSDlnLDlm77liJ3lp4vljJbml7bpu5jorqTnmoTlnLDlm77lm77niYfnmoTlsLrlr7jjgIJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0g5Zyw5Zu+5Yid5aeL5YyW5pe26buY6K6k55qE5pi+56S65q+U5L6L5bC644CCXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29vcmRVbml0PSdkZWdyZWVzJ10gLSDmipXlvbHlnZDmoIfns7vnu5/nmoTlnLDlm77ljZXkvY3jgIJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXR1bUF4aXM9NjM3ODEzN10gLSDlnLDnkIblnZDmoIfns7vnu5/mpK3nkIPkvZPplb/ljYrovbTjgILnlKjmiLfoh6rlrprkuYnlnLDlm77nmoQgT3B0aW9ucyDml7bvvIzoi6XmnKrmjIflrpror6Xlj4LmlbDnmoTlgLzvvIzliJnns7vnu5/pu5jorqTkuLogV0dTODQg5Y+C6ICD57O755qE5qSt55CD5L2T6ZW/5Y2K6L20IDYzNzgxMzfjgIJcbiAgICogQHJldHVybnMge251bWJlcn0g5Zu+5bGC5pi+56S65YiG6L6o546H44CCXG4gICAqL1xuICBjYWxjdWxhdGVEcGk6IGZ1bmN0aW9uICh2aWV3Qm91bmRzLCB2aWV3ZXIsIHNjYWxlLCBjb29yZFVuaXQsIGRhdHVtQXhpcykge1xuICAgIC8vMTAwMDAg5pivIDAuMeavq+exs+S4juexs+eahOi9rOaNouOAgkRQSeeahOiuoeeul+WFrOW8j++8mlZpZXdlciAvIERQSSAqICAwLjAyNTQgKiAxMDAwMCA9IFZpZXdCb3VuZHMgKiBzY2FsZSDvvIzlhazlvI/kuK3nmoQxMDAwMOaYr+S4uuS6huaPkOmrmOiuoeeul+e7k+aenOeahOeyvuW6pu+8jOS7peS4i+WHuueOsOeahHJhdGlv55qG5Li65aaC5q2k44CCXG4gICAgaWYgKCF2aWV3Qm91bmRzIHx8ICF2aWV3ZXIgfHwgIXNjYWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByYXRpbyA9IDEwMDAwLFxuICAgICAgcnZiV2lkdGggPSB2aWV3Qm91bmRzLmdldFdpZHRoKCksXG4gICAgICBydmJIZWlnaHQgPSB2aWV3Qm91bmRzLmdldEhlaWdodCgpLFxuICAgICAgcnZXaWR0aCA9IHZpZXdlci53LFxuICAgICAgcnZIZWlnaHQgPSB2aWV3ZXIuaDtcbiAgICAvL+eUqOaIt+iHquWumuS5ieWcsOWbvueahE9wdGlvbnPml7bvvIzoi6XmnKrmjIflrpror6Xlj4LmlbDnmoTlgLzvvIzliJnns7vnu5/pu5jorqTkuLo2Mzc4MTM357Gz77yM5Y2zV0dTODTlj4LogIPns7vnmoTmpK3nkIPkvZPplb/ljYrovbTjgIJcbiAgICBkYXR1bUF4aXMgPSBkYXR1bUF4aXMgfHwgNjM3ODEzNztcbiAgICBjb29yZFVuaXQgPSBjb29yZFVuaXQgfHwgJ2RlZ3JlZXMnO1xuICAgIHZhciBkcGk7XG4gICAgaWYgKFxuICAgICAgY29vcmRVbml0LnRvTG93ZXJDYXNlKCkgPT09ICdkZWdyZWUnIHx8XG4gICAgICBjb29yZFVuaXQudG9Mb3dlckNhc2UoKSA9PT0gJ2RlZ3JlZXMnIHx8XG4gICAgICBjb29yZFVuaXQudG9Mb3dlckNhc2UoKSA9PT0gJ2RkJ1xuICAgICkge1xuICAgICAgbGV0IG51bTEgPSBydmJXaWR0aCAvIHJ2V2lkdGgsXG4gICAgICAgIG51bTIgPSBydmJIZWlnaHQgLyBydkhlaWdodCxcbiAgICAgICAgcmVzb2x1dGlvbiA9IG51bTEgPiBudW0yID8gbnVtMSA6IG51bTI7XG4gICAgICBkcGkgPSAoMC4wMjU0ICogcmF0aW8pIC8gcmVzb2x1dGlvbiAvIHNjYWxlIC8gKChNYXRoLlBJICogMiAqIGRhdHVtQXhpcykgLyAzNjApIC8gcmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXNvbHV0aW9uID0gcnZiV2lkdGggLyBydldpZHRoO1xuICAgICAgZHBpID0gKDAuMDI1NCAqIHJhdGlvKSAvIHJlc29sdXRpb24gLyBzY2FsZSAvIHJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gZHBpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgQ29tbW9uVXRpbFxuICAgKiBAZGVzY3JpcHRpb24g5bCG5a+56LGh6L2s5o2i5oiQIEpTT04g5a2X56ym5Liy44CCXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSDopoHovazmjaLmiJAgSlNPTiDnmoQgT2JqZWN0IOWvueixoeOAglxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSDovazmjaLlkI7nmoQgSlNPTiDlr7nosaHjgIJcbiAgICovXG4gIHRvSlNPTjogZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBvYmpJbm4gPSBvYmo7XG4gICAgaWYgKG9iaklubiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoIChvYmpJbm4uY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAvL3MgPSBcIidcIiArIHN0ci5yZXBsYWNlKC8oW1wiXFxcXF0pL2csIFwiXFxcXCQxXCIpICsgXCInXCI7ICAgc3RyaW5n5ZCr5pyJ5Y2V5byV5Y+35Ye66ZSZXG4gICAgICAgIG9iaklubiA9ICdcIicgKyBvYmpJbm4ucmVwbGFjZSgvKFtcIlxcXFxdKS9nLCAnXFxcXCQxJykgKyAnXCInO1xuICAgICAgICBvYmpJbm4gPSBvYmpJbm4ucmVwbGFjZSgvXFxuL2csICdcXFxcbicpO1xuICAgICAgICBvYmpJbm4gPSBvYmpJbm4ucmVwbGFjZSgvXFxyL2csICdcXFxccicpO1xuICAgICAgICBvYmpJbm4gPSBvYmpJbm4ucmVwbGFjZSgnPCcsICcmbHQ7Jyk7XG4gICAgICAgIG9iaklubiA9IG9iaklubi5yZXBsYWNlKCc+JywgJyZndDsnKTtcbiAgICAgICAgb2JqSW5uID0gb2JqSW5uLnJlcGxhY2UoLyUvZywgJyUyNScpO1xuICAgICAgICBvYmpJbm4gPSBvYmpJbm4ucmVwbGFjZSgvJi9nLCAnJTI2Jyk7XG4gICAgICAgIHJldHVybiBvYmpJbm47XG4gICAgICBjYXNlIEFycmF5OlxuICAgICAgICB2YXIgYXJyID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmpJbm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBhcnIgKz0gVXRpbC50b0pTT04ob2JqSW5uW2ldKTtcbiAgICAgICAgICBpZiAoaSAhPT0gb2JqSW5uLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGFyciArPSAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIltcIiArIGFyciArIFwiXVwiO1xuICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShvYmpJbm4pID8gU3RyaW5nKG9iaklubikgOiBudWxsO1xuICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICByZXR1cm4gU3RyaW5nKG9iaklubik7XG4gICAgICBjYXNlIERhdGU6XG4gICAgICAgIHZhciBkYXRlU3RyID1cbiAgICAgICAgICAneycgK1xuICAgICAgICAgICdcXCdfX3R5cGVcXCc6XCJTeXN0ZW0uRGF0ZVRpbWVcIiwnICtcbiAgICAgICAgICBcIidZZWFyJzpcIiArXG4gICAgICAgICAgb2JqSW5uLmdldEZ1bGxZZWFyKCkgK1xuICAgICAgICAgICcsJyArXG4gICAgICAgICAgXCInTW9udGgnOlwiICtcbiAgICAgICAgICAob2JqSW5uLmdldE1vbnRoKCkgKyAxKSArXG4gICAgICAgICAgJywnICtcbiAgICAgICAgICBcIidEYXknOlwiICtcbiAgICAgICAgICBvYmpJbm4uZ2V0RGF0ZSgpICtcbiAgICAgICAgICAnLCcgK1xuICAgICAgICAgIFwiJ0hvdXInOlwiICtcbiAgICAgICAgICBvYmpJbm4uZ2V0SG91cnMoKSArXG4gICAgICAgICAgJywnICtcbiAgICAgICAgICBcIidNaW51dGUnOlwiICtcbiAgICAgICAgICBvYmpJbm4uZ2V0TWludXRlcygpICtcbiAgICAgICAgICAnLCcgK1xuICAgICAgICAgIFwiJ1NlY29uZCc6XCIgK1xuICAgICAgICAgIG9iaklubi5nZXRTZWNvbmRzKCkgK1xuICAgICAgICAgICcsJyArXG4gICAgICAgICAgXCInTWlsbGlzZWNvbmQnOlwiICtcbiAgICAgICAgICBvYmpJbm4uZ2V0TWlsbGlzZWNvbmRzKCkgK1xuICAgICAgICAgICcsJyArXG4gICAgICAgICAgXCInVGltZXpvbmVPZmZzZXQnOlwiICtcbiAgICAgICAgICBvYmpJbm4uZ2V0VGltZXpvbmVPZmZzZXQoKSArXG4gICAgICAgICAgJ30nO1xuICAgICAgICByZXR1cm4gZGF0ZVN0cjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChvYmpJbm5bJ3RvSlNPTiddICE9IG51bGwgJiYgdHlwZW9mIG9iaklublsndG9KU09OJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb2JqSW5uLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqSW5uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChvYmpJbm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgYXJyID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb2JqSW5uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGFyci5wdXNoKFV0aWwudG9KU09OKG9iaklubltpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdbJyArIGFyci5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBhcnIgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBhdHRyIGluIG9iaklubikge1xuICAgICAgICAgICAgLy/kuLrop6PlhrNHZW9tZXRyeeexu+Wei+WktGpzb27ml7bloIbmoIjmuqLlh7rnmoTpl67popjvvIxhdHRyID09IFwicGFyZW50XCLml7bkuI3ov5vooYxqc29u6L2s5o2iXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaklublthdHRyXSAhPT0gJ2Z1bmN0aW9uJyAmJiBhdHRyICE9PSAnQ0xBU1NfTkFNRScgJiYgYXR0ciAhPT0gJ3BhcmVudCcpIHtcbiAgICAgICAgICAgICAgYXJyLnB1c2goXCInXCIgKyBhdHRyICsgXCInOlwiICsgVXRpbC50b0pTT04ob2JqSW5uW2F0dHJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3snICsgYXJyLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpJbm4udG9TdHJpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDmoLnmja7mr5TkvovlsLrlkowgZHBpIOiuoeeul+Wxj+W5leWIhui+qOeOh+OAglxuICAgKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIFV0aWxcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0g5q+U5L6L5bC644CCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkcGkgLSDlm77lg4/liIbovqjnjofvvIzooajnpLrmr4/oi7Hlr7jlhoXnmoTlg4/ntKDkuKrmlbDjgIJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb29yZFVuaXRdIC0g5oqV5b2x5Z2Q5qCH57O757uf55qE5Zyw5Zu+5Y2V5L2N44CCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0dW1BeGlzPTYzNzgxMzddIC0g5Zyw55CG5Z2Q5qCH57O757uf5qSt55CD5L2T6ZW/5Y2K6L2044CC55So5oi36Ieq5a6a5LmJ5Zyw5Zu+55qEIE9wdGlvbnMg5pe277yM6Iul5pyq5oyH5a6a6K+l5Y+C5pWw55qE5YC877yM5YiZIERQSSDpu5jorqTmjInnhacgV0dTODQg5Y+C6ICD57O755qE5qSt55CD5L2T6ZW/5Y2K6L20IDYzNzgxMzcg5p2l6K6h566X44CCXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IOW9k+WJjeavlOS+i+WwuuS4i+eahOWxj+W5leWIhui+qOeOh+OAglxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbkZyb21TY2FsZURwaTogZnVuY3Rpb24gKHNjYWxlLCBkcGksIGNvb3JkVW5pdCwgZGF0dW1BeGlzKSB7XG4gICAgdmFyIHJlc29sdXRpb24gPSBudWxsLFxuICAgICAgcmF0aW8gPSAxMDAwMDtcbiAgICAvL+eUqOaIt+iHquWumuS5ieWcsOWbvueahE9wdGlvbnPml7bvvIzoi6XmnKrmjIflrpror6Xlj4LmlbDnmoTlgLzvvIzliJnns7vnu5/pu5jorqTkuLo2Mzc4MTM357Gz77yM5Y2zV0dTODTlj4LogIPns7vnmoTmpK3nkIPkvZPplb/ljYrovbTjgIJcbiAgICBkYXR1bUF4aXMgPSBkYXR1bUF4aXMgfHwgNjM3ODEzNztcbiAgICBjb29yZFVuaXQgPSBjb29yZFVuaXQgfHwgJyc7XG4gICAgaWYgKHNjYWxlID4gMCAmJiBkcGkgPiAwKSB7XG4gICAgICBzY2FsZSA9IFV0aWwubm9ybWFsaXplU2NhbGUoc2NhbGUpO1xuICAgICAgaWYgKFxuICAgICAgICBjb29yZFVuaXQudG9Mb3dlckNhc2UoKSA9PT0gJ2RlZ3JlZScgfHxcbiAgICAgICAgY29vcmRVbml0LnRvTG93ZXJDYXNlKCkgPT09ICdkZWdyZWVzJyB8fFxuICAgICAgICBjb29yZFVuaXQudG9Mb3dlckNhc2UoKSA9PT0gJ2RkJ1xuICAgICAgKSB7XG4gICAgICAgIC8vc2NhbGUgPSBVdGlsLm5vcm1hbGl6ZVNjYWxlKHNjYWxlKTtcbiAgICAgICAgcmVzb2x1dGlvbiA9ICgwLjAyNTQgKiByYXRpbykgLyBkcGkgLyBzY2FsZSAvICgoTWF0aC5QSSAqIDIgKiBkYXR1bUF4aXMpIC8gMzYwKSAvIHJhdGlvO1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdXRpb24gPSAoMC4wMjU0ICogcmF0aW8pIC8gZHBpIC8gc2NhbGUgLyByYXRpbztcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOagueaNriByZXNvbHV0aW9u44CBZHBp44CBY29vcmRVbml0IOWSjCBkYXR1bUF4aXMg6K6h566X5q+U5L6L5bC644CCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIC0g55So5LqO6K6h566X5q+U5L6L5bC655qE5Zyw5Zu+5YiG6L6o546H44CCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkcGkgLSDlm77lg4/liIbovqjnjofvvIzooajnpLrmr4/oi7Hlr7jlhoXnmoTlg4/ntKDkuKrmlbDjgIJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb29yZFVuaXRdIC0g5oqV5b2x5Z2Q5qCH57O757uf55qE5Zyw5Zu+5Y2V5L2N44CCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0dW1BeGlzPTYzNzgxMzddIC0g5Zyw55CG5Z2Q5qCH57O757uf5qSt55CD5L2T6ZW/5Y2K6L2044CC55So5oi36Ieq5a6a5LmJ5Zyw5Zu+55qEIE9wdGlvbnMg5pe277yM6Iul5pyq5oyH5a6a6K+l5Y+C5pWw55qE5YC877yM5YiZIERQSSDpu5jorqTmjInnhacgV0dTODQg5Y+C6ICD57O755qE5qSt55CD5L2T6ZW/5Y2K6L20IDYzNzgxMzcg5p2l6K6h566X44CCXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IOW9k+WJjeWxj+W5leWIhui+qOeOh+S4i+eahOavlOS+i+WwuuOAglxuICAgKi9cbiAgZ2V0U2NhbGVGcm9tUmVzb2x1dGlvbkRwaTogZnVuY3Rpb24gKHJlc29sdXRpb24sIGRwaSwgY29vcmRVbml0LCBkYXR1bUF4aXMpIHtcbiAgICB2YXIgc2NhbGUgPSBudWxsLFxuICAgICAgcmF0aW8gPSAxMDAwMDtcbiAgICAvL+eUqOaIt+iHquWumuS5ieWcsOWbvueahE9wdGlvbnPml7bvvIzoi6XmnKrmjIflrpror6Xlj4LmlbDnmoTlgLzvvIzliJnns7vnu5/pu5jorqTkuLo2Mzc4MTM357Gz77yM5Y2zV0dTODTlj4LogIPns7vnmoTmpK3nkIPkvZPplb/ljYrovbTjgIJcbiAgICBkYXR1bUF4aXMgPSBkYXR1bUF4aXMgfHwgNjM3ODEzNztcbiAgICBjb29yZFVuaXQgPSBjb29yZFVuaXQgfHwgJyc7XG4gICAgaWYgKHJlc29sdXRpb24gPiAwICYmIGRwaSA+IDApIHtcbiAgICAgIGlmIChcbiAgICAgICAgY29vcmRVbml0LnRvTG93ZXJDYXNlKCkgPT09ICdkZWdyZWUnIHx8XG4gICAgICAgIGNvb3JkVW5pdC50b0xvd2VyQ2FzZSgpID09PSAnZGVncmVlcycgfHxcbiAgICAgICAgY29vcmRVbml0LnRvTG93ZXJDYXNlKCkgPT09ICdkZCdcbiAgICAgICkge1xuICAgICAgICBzY2FsZSA9ICgwLjAyNTQgKiByYXRpbykgLyBkcGkgLyByZXNvbHV0aW9uIC8gKChNYXRoLlBJICogMiAqIGRhdHVtQXhpcykgLyAzNjApIC8gcmF0aW87XG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlID0gKDAuMDI1NCAqIHJhdGlvKSAvIGRwaSAvIHJlc29sdXRpb24gLyByYXRpbztcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBDb21tb25VdGlsXG4gICAqIEBkZXNjcmlwdGlvbiDovazmjaLmn6Xor6Lnu5PmnpzjgIJcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCAtIOafpeivoue7k+aenOOAglxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSDovazmjaLlkI7nmoTmn6Xor6Lnu5PmnpzjgIJcbiAgICovXG4gIHRyYW5zZm9ybVJlc3VsdDogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQucmVzcG9uc2VUZXh0ICYmIHR5cGVvZiByZXN1bHQucmVzcG9uc2VUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQucmVzcG9uc2VUZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOWxnuaAp+aLt+i0ne+8jOS4jeaLt+i0neaWueazleexu+WQjShDTEFTU19OQU1FKeetieOAglxuICAgKiBAcGFyYW0ge09iamVjdH0gW2Rlc3RpbmF0aW9uXSAtIOaLt+i0neebruagh+OAglxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIC0g5rqQ5a+56LGh44CCXG4gICAqXG4gICAqL1xuICBjb3B5QXR0cmlidXRlczogZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICBkZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uIHx8IHt9O1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eSAhPT0gJ0NMQVNTX05BTUUnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOWwhua6kOWvueixoeS4iueahOWxnuaAp+aLt+i0neWIsOebruagh+WvueixoeS4iuOAgu+8iOS4jeaLt+i0nSBDTEFTU19OQU1FIOWSjOaWueazle+8iVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2Rlc3RpbmF0aW9uXSAtIOebruagh+WvueixoeOAglxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIC0g5rqQ5a+56LGh44CCXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNsaXAgLSDmupDlr7nosaHkuK3npoHmraLmi7fotJ3liLDnm67moIflr7nosaHnmoTlsZ7mgKfvvIznm67nmoTmmK/pmLLmraLnm67moIflr7nosaHkuIrkuI3lj6/kv67mlLnnmoTlsZ7mgKfooqvnr6HmlLnjgIJcbiAgICpcbiAgICovXG4gIGNvcHlBdHRyaWJ1dGVzV2l0aENsaXA6IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgc291cmNlLCBjbGlwKSB7XG4gICAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbiB8fCB7fTtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgLy/ljrvmjonnpoHmraLmi7fotJ3nmoTlsZ7mgKdcbiAgICAgICAgdmFyIGlzSW5DbGlwID0gZmFsc2U7XG4gICAgICAgIGlmIChjbGlwICYmIGNsaXAubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsaXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gY2xpcFtpXSkge1xuICAgICAgICAgICAgICBpc0luQ2xpcCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJbkNsaXAgPT09IHRydWUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnR5ICE9PSAnQ0xBU1NfTkFNRScgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgQ29tbW9uVXRpbFxuICAgKiBAZGVzY3JpcHRpb24g5YWL6ZqG5LiA5LiqIE9iamVjdCDlr7nosaFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIOmcgOimgeWFi+mahueahOWvueixoeOAglxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSDlr7nosaHnmoTmi7fotJ3lr7nosaHvvIzms6jmhI/mmK/mlrDnmoTlr7nosaHvvIzkuI3mmK/mjIflkJHjgIJcbiAgICovXG4gIGNsb25lT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgLy8gSGFuZGxlIHRoZSAzIHNpbXBsZSB0eXBlcywgYW5kIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgaWYgKG51bGwgPT09IG9iaiB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9iaikge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgRGF0ZVxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBsZXQgY29weSA9IG5ldyBEYXRlKCk7XG4gICAgICBjb3B5LnNldFRpbWUob2JqLmdldFRpbWUoKSk7XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgQXJyYXlcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGxldCBjb3B5ID0gb2JqLnNsaWNlKDApO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIE9iamVjdFxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGxldCBjb3B5ID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgY29weVthdHRyXSA9IFV0aWwuY2xvbmVPYmplY3Qob2JqW2F0dHJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkgb2JqISBJdHMgdHlwZSBpc24ndCBzdXBwb3J0ZWQuXCIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgQ29tbW9uVXRpbFxuICAgKiBAZGVzY3JpcHRpb24g5Yik5pat5Lik5p2h57q/5q615piv5LiN5piv5pyJ5Lqk54K544CCXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlQb2ludH0gYTEgLSDnrKzkuIDmnaHnur/mrrXnmoTotbflp4voioLngrnjgIJcbiAgICogQHBhcmFtIHtHZW9tZXRyeVBvaW50fSBhMiAtIOesrOS4gOadoee6v+auteeahOe7k+adn+iKgueCueOAglxuICAgKiBAcGFyYW0ge0dlb21ldHJ5UG9pbnR9IGIxIC0g56ys5LqM5p2h57q/5q6155qE6LW35aeL6IqC54K544CCXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlQb2ludH0gYjIgLSDnrKzkuozmnaHnur/mrrXnmoTnu5PmnZ/oioLngrnjgIJcbiAgICogQHJldHVybnMge09iamVjdH0g5aaC5p6c55u45Lqk6L+U5Zue5Lqk54K577yM5aaC5p6c5LiN55u45Lqk6L+U5Zue5Lik5p2h57q/5q6155qE5L2N572u5YWz57O744CCXG4gICAqL1xuICBsaW5lSW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoYTEsIGEyLCBiMSwgYjIpIHtcbiAgICB2YXIgaW50ZXJzZWN0VmFsdWUgPSBudWxsO1xuICAgIHZhciBrMTtcbiAgICB2YXIgazI7XG4gICAgdmFyIGIgPSAoYjIueCAtIGIxLngpICogKGExLnkgLSBiMS55KSAtIChiMi55IC0gYjEueSkgKiAoYTEueCAtIGIxLngpO1xuICAgIHZhciBhID0gKGEyLnggLSBhMS54KSAqIChhMS55IC0gYjEueSkgLSAoYTIueSAtIGExLnkpICogKGExLnggLSBiMS54KTtcbiAgICB2YXIgYWIgPSAoYjIueSAtIGIxLnkpICogKGEyLnggLSBhMS54KSAtIChiMi54IC0gYjEueCkgKiAoYTIueSAtIGExLnkpO1xuICAgIC8vYWI9PTDku6PooajkuKTmnaHnur/mlq3nmoTmlpznjofkuIDmoLdcbiAgICBpZiAoYWIgIT0gMCkge1xuICAgICAgazEgPSBiIC8gYWI7XG4gICAgICBrMiA9IGEgLyBhYjtcblxuICAgICAgaWYgKGsxID49IDAgJiYgazIgPD0gMSAmJiBrMSA8PSAxICYmIGsyID49IDApIHtcbiAgICAgICAgaW50ZXJzZWN0VmFsdWUgPSBuZXcgR2VvbWV0cnkuUG9pbnQoYTEueCArIGsxICogKGEyLnggLSBhMS54KSwgYTEueSArIGsxICogKGEyLnkgLSBhMS55KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnNlY3RWYWx1ZSA9ICdObyBJbnRlcnNlY3Rpb24nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYiA9PSAwICYmIGEgPT0gMCkge1xuICAgICAgICB2YXIgbWF4eSA9IE1hdGgubWF4KGExLnksIGEyLnkpO1xuICAgICAgICB2YXIgbWlueSA9IE1hdGgubWluKGExLnksIGEyLnkpO1xuICAgICAgICB2YXIgbWF4eCA9IE1hdGgubWF4KGExLngsIGEyLngpO1xuICAgICAgICB2YXIgbWlueCA9IE1hdGgubWluKGExLngsIGEyLngpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKCgoYjEueSA+PSBtaW55ICYmIGIxLnkgPD0gbWF4eSkgfHwgKGIyLnkgPj0gbWlueSAmJiBiMi55IDw9IG1heHkpKSAmJiBiMS54ID49IG1pbnggJiYgYjEueCA8PSBtYXh4KSB8fFxuICAgICAgICAgIChiMi54ID49IG1pbnggJiYgYjIueCA8PSBtYXh4KVxuICAgICAgICApIHtcbiAgICAgICAgICBpbnRlcnNlY3RWYWx1ZSA9ICdDb2luY2lkZW50JzsgLy/ph43lkIhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnNlY3RWYWx1ZSA9ICdQYXJhbGxlbCc7IC8v5bmz6KGMXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVyc2VjdFZhbHVlID0gJ1BhcmFsbGVsJzsgLy/lubPooYxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdFZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgQ29tbW9uVXRpbFxuICAgKiBAZGVzY3JpcHRpb24g6I635Y+W5paH5pys5aSW5o6l55+p5b2i5a695bqm5LiO6auY5bqm44CCXG4gICAqIEBwYXJhbSB7VGhlbWVTdHlsZX0gc3R5bGUgLSDmlofmnKzmoLflvI/jgIJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSDmlofmnKzlhoXlrrnjgIJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBET00g5YWD57Sg44CCXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IOijgeWJquWQjueahOWuveW6pu+8jOmrmOW6puS/oeaBr+OAglxuICAgKi9cbiAgZ2V0VGV4dEJvdW5kczogZnVuY3Rpb24gKHN0eWxlLCB0ZXh0LCBlbGVtZW50KSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgIGlmIChzdHlsZS5mb250U2l6ZSkge1xuICAgICAgZWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xuICAgIH1cbiAgICBpZiAoc3R5bGUuZm9udEZhbWlseSkge1xuICAgICAgZWxlbWVudC5zdHlsZS5mb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseTtcbiAgICB9XG4gICAgaWYgKHN0eWxlLmZvbnRXZWlnaHQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHQ7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIGVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIC8vZml4IOWcqOafkOS6m+aDheWGteS4i++8jGVsZW1lbnTlhoXnmoTmlofmnKzlj5jmiJDnq5botbfmjpLliJfvvIzlr7zoh7Tlrr3luqborqHnrpfkuI3mraPnoa7nmoRidWdcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IHRleHQ7XG4gICAgdmFyIHRleHRXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgdmFyIHRleHRIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0V2lkdGg6IHRleHRXaWR0aCxcbiAgICAgIHRleHRIZWlnaHQ6IHRleHRIZWlnaHRcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogQG1lbWJlck9mIENvbW1vblV0aWxcbiAgICogQGRlc2NyaXB0aW9uIOiOt+WPlui9rOaNouWQjueahHBhdGjot6/lvoTjgIJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSDlvoXovazmjaLnmoRwYXRoLCDljIXlkKtge3BhcmFtfWDjgIJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhdGhQYXJhbXMgLSBwYXRo5Lit5b6F5pu/5o2i55qE5Y+C5pWw44CCXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IOi9rOaNouWQjueahHBhdGjot6/lvoRcbiAgICovXG4gIGNvbnZlcnRQYXRoOiBmdW5jdGlvbiAocGF0aCwgcGF0aFBhcmFtcykge1xuICAgIGlmICghcGF0aFBhcmFtcykge1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1xceyhbXFx3LVxcLl0rKVxcfS9nLCAoZnVsbE1hdGNoLCBrZXkpID0+IHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChwYXRoUGFyYW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFsdWUgPSBwYXJhbVRvU3RyaW5nKHBhdGhQYXJhbXNba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZ1bGxNYXRjaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBlbnVtIElOQ0hFU19QRVJfVU5JVFxuICogQGRlc2NyaXB0aW9uIOavj+WNleS9jeeahOiLseWwuuaVsOOAglxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IElOQ0hFU19QRVJfVU5JVCA9IHtcbiAgaW5jaGVzOiAxLjAsXG4gIGZ0OiAxMi4wLFxuICBtaTogNjMzNjAuMCxcbiAgbTogMzkuMzcwMSxcbiAga206IDM5MzcwLjEsXG4gIGRkOiA0Mzc0NzU0LFxuICB5ZDogMzZcbn07XG5JTkNIRVNfUEVSX1VOSVRbJ2luJ10gPSBJTkNIRVNfUEVSX1VOSVQuaW5jaGVzO1xuSU5DSEVTX1BFUl9VTklUWydkZWdyZWVzJ10gPSBJTkNIRVNfUEVSX1VOSVQuZGQ7XG5JTkNIRVNfUEVSX1VOSVRbJ25taSddID0gMTg1MiAqIElOQ0hFU19QRVJfVU5JVC5tO1xuXG4vLyBVbml0cyBmcm9tIENTLU1hcFxuY29uc3QgTUVURVJTX1BFUl9JTkNIID0gMC4wMjU0MDAwNTA4MDAxMDE2MDAyO1xuVXRpbC5leHRlbmQoSU5DSEVTX1BFUl9VTklULCB7XG4gIEluY2g6IElOQ0hFU19QRVJfVU5JVC5pbmNoZXMsXG4gIE1ldGVyOiAxLjAgLyBNRVRFUlNfUEVSX0lOQ0gsIC8vRVBTRzo5MDAxXG4gIEZvb3Q6IDAuMzA0ODAwNjA5NjAxMjE5MjAyNDMgLyBNRVRFUlNfUEVSX0lOQ0gsIC8vRVBTRzo5MDAzXG4gIElGb290OiAwLjMwNDggLyBNRVRFUlNfUEVSX0lOQ0gsIC8vRVBTRzo5MDAyXG4gIENsYXJrZUZvb3Q6IDAuMzA0Nzk3MjY1MTE1MSAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwMDVcbiAgU2VhcnNGb290OiAwLjMwNDc5OTQ3MTUzODY3NjI0NjI0IC8gTUVURVJTX1BFUl9JTkNILCAvL0VQU0c6OTA0MVxuICBHb2xkQ29hc3RGb290OiAwLjMwNDc5OTcxMDE4MTUwODgxNzU4IC8gTUVURVJTX1BFUl9JTkNILCAvL0VQU0c6OTA5NFxuICBJSW5jaDogMC4wMjU0IC8gTUVURVJTX1BFUl9JTkNILFxuICBNaWNyb0luY2g6IDAuMDAwMDI1NCAvIE1FVEVSU19QRVJfSU5DSCxcbiAgTWlsOiAwLjAwMDAwMDAyNTQgLyBNRVRFUlNfUEVSX0lOQ0gsXG4gIENlbnRpbWV0ZXI6IDAuMDEgLyBNRVRFUlNfUEVSX0lOQ0gsXG4gIEtpbG9tZXRlcjogMTAwMC4wIC8gTUVURVJTX1BFUl9JTkNILCAvL0VQU0c6OTAzNlxuICBZYXJkOiAwLjkxNDQwMTgyODgwMzY1NzYwNzMxIC8gTUVURVJTX1BFUl9JTkNILFxuICBTZWFyc1lhcmQ6IDAuOTE0Mzk4NDE0NjE2MDI5IC8gTUVURVJTX1BFUl9JTkNILCAvL0VQU0c6OTA0MFxuICBJbmRpYW5ZYXJkOiAwLjkxNDM5ODUzMDc0NDQ0MDc5OTgzIC8gTUVURVJTX1BFUl9JTkNILCAvL0VQU0c6OTA4NFxuICBJbmRpYW5ZZDM3OiAwLjkxNDM5NTIzIC8gTUVURVJTX1BFUl9JTkNILCAvL0VQU0c6OTA4NVxuICBJbmRpYW5ZZDYyOiAwLjkxNDM5ODggLyBNRVRFUlNfUEVSX0lOQ0gsIC8vRVBTRzo5MDg2XG4gIEluZGlhbllkNzU6IDAuOTE0Mzk4NSAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwODdcbiAgSW5kaWFuRm9vdDogMC4zMDQ3OTk1MSAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwODBcbiAgSW5kaWFuRnQzNzogMC4zMDQ3OTg0MSAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwODFcbiAgSW5kaWFuRnQ2MjogMC4zMDQ3OTk2IC8gTUVURVJTX1BFUl9JTkNILCAvL0VQU0c6OTA4MlxuICBJbmRpYW5GdDc1OiAwLjMwNDc5OTUgLyBNRVRFUlNfUEVSX0lOQ0gsIC8vRVBTRzo5MDgzXG4gIE1pbGU6IDE2MDkuMzQ3MjE4Njk0NDM3Mzg4ODc0NzcgLyBNRVRFUlNfUEVSX0lOQ0gsXG4gIElZYXJkOiAwLjkxNDQgLyBNRVRFUlNfUEVSX0lOQ0gsIC8vRVBTRzo5MDk2XG4gIElNaWxlOiAxNjA5LjM0NCAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwOTNcbiAgTmF1dE06IDE4NTIuMCAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwMzBcbiAgJ0xhdC02Nic6IDExMDk0My4zMTY0ODg5MzI3MzEgLyBNRVRFUlNfUEVSX0lOQ0gsXG4gICdMYXQtODMnOiAxMTA5NDYuMjU3MzY4NzIyMzQxMjUgLyBNRVRFUlNfUEVSX0lOQ0gsXG4gIERlY2ltZXRlcjogMC4xIC8gTUVURVJTX1BFUl9JTkNILFxuICBNaWxsaW1ldGVyOiAwLjAwMSAvIE1FVEVSU19QRVJfSU5DSCxcbiAgRGVrYW1ldGVyOiAxMC4wIC8gTUVURVJTX1BFUl9JTkNILFxuICBEZWNhbWV0ZXI6IDEwLjAgLyBNRVRFUlNfUEVSX0lOQ0gsXG4gIEhlY3RvbWV0ZXI6IDEwMC4wIC8gTUVURVJTX1BFUl9JTkNILFxuICBHZXJtYW5NZXRlcjogMS4wMDAwMTM1OTY1IC8gTUVURVJTX1BFUl9JTkNILCAvL0VQU0c6OTAzMVxuICBDYUdyaWQ6IDAuOTk5NzM4IC8gTUVURVJTX1BFUl9JTkNILFxuICBDbGFya2VDaGFpbjogMjAuMTE2NjE5NDk3NiAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwMzhcbiAgR3VudGVyQ2hhaW46IDIwLjExNjg0MDIzMzY4MDQ3IC8gTUVURVJTX1BFUl9JTkNILCAvL0VQU0c6OTAzM1xuICBCZW5vaXRDaGFpbjogMjAuMTE2NzgyNDk0Mzc1ODcyIC8gTUVURVJTX1BFUl9JTkNILCAvL0VQU0c6OTA2MlxuICBTZWFyc0NoYWluOiAyMC4xMTY3NjUxMjE1NSAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwNDJcbiAgQ2xhcmtlTGluazogMC4yMDExNjYxOTQ5NzYgLyBNRVRFUlNfUEVSX0lOQ0gsIC8vRVBTRzo5MDM5XG4gIEd1bnRlckxpbms6IDAuMjAxMTY4NDAyMzM2ODA0NyAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwMzRcbiAgQmVub2l0TGluazogMC4yMDExNjc4MjQ5NDM3NTg3MiAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwNjNcbiAgU2VhcnNMaW5rOiAwLjIwMTE2NzY1MTIxNTUgLyBNRVRFUlNfUEVSX0lOQ0gsIC8vRVBTRzo5MDQzXG4gIFJvZDogNS4wMjkyMTAwNTg0MjAxMiAvIE1FVEVSU19QRVJfSU5DSCxcbiAgSW50bmxDaGFpbjogMjAuMTE2OCAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwOTdcbiAgSW50bmxMaW5rOiAwLjIwMTE2OCAvIE1FVEVSU19QRVJfSU5DSCwgLy9FUFNHOjkwOThcbiAgUGVyY2g6IDUuMDI5MjEwMDU4NDIwMTIgLyBNRVRFUlNfUEVSX0lOQ0gsXG4gIFBvbGU6IDUuMDI5MjEwMDU4NDIwMTIgLyBNRVRFUlNfUEVSX0lOQ0gsXG4gIEZ1cmxvbmc6IDIwMS4xNjg0MDIzMzY4MDQ2IC8gTUVURVJTX1BFUl9JTkNILFxuICBSb29kOiAzLjc3ODI2Njg5OCAvIE1FVEVSU19QRVJfSU5DSCxcbiAgQ2FwZUZvb3Q6IDAuMzA0Nzk3MjYxNSAvIE1FVEVSU19QRVJfSU5DSCxcbiAgQnJlYWxleTogMzc1LjAgLyBNRVRFUlNfUEVSX0lOQ0gsXG4gIE1vZEFtRnQ6IDAuMzA0ODEyMjUyOTg0NTA1OTY5MDExOTM4IC8gTUVURVJTX1BFUl9JTkNILFxuICBGYXRob206IDEuODI4OCAvIE1FVEVSU19QRVJfSU5DSCxcbiAgJ05hdXRNLVVLJzogMTg1My4xODQgLyBNRVRFUlNfUEVSX0lOQ0gsXG4gICc1MGtpbG9tZXRlcnMnOiA1MDAwMC4wIC8gTUVURVJTX1BFUl9JTkNILFxuICAnMTUwa2lsb21ldGVycyc6IDE1MDAwMC4wIC8gTUVURVJTX1BFUl9JTkNIXG59KTtcblxuLy91bml0IGFiYnJldmlhdGlvbnMgc3VwcG9ydGVkIGJ5IFBST0ouNFxuVXRpbC5leHRlbmQoSU5DSEVTX1BFUl9VTklULCB7XG4gIG1tOiBJTkNIRVNfUEVSX1VOSVRbJ01ldGVyJ10gLyAxMDAwLjAsXG4gIGNtOiBJTkNIRVNfUEVSX1VOSVRbJ01ldGVyJ10gLyAxMDAuMCxcbiAgZG06IElOQ0hFU19QRVJfVU5JVFsnTWV0ZXInXSAqIDEwMC4wLFxuICBrbTogSU5DSEVTX1BFUl9VTklUWydNZXRlciddICogMTAwMC4wLFxuICBrbWk6IElOQ0hFU19QRVJfVU5JVFsnbm1pJ10sIC8vSW50ZXJuYXRpb25hbCBOYXV0aWNhbCBNaWxlXG4gIGZhdGg6IElOQ0hFU19QRVJfVU5JVFsnRmF0aG9tJ10sIC8vSW50ZXJuYXRpb25hbCBGYXRob21cbiAgY2g6IElOQ0hFU19QRVJfVU5JVFsnSW50bmxDaGFpbiddLCAvL0ludGVybmF0aW9uYWwgQ2hhaW5cbiAgbGluazogSU5DSEVTX1BFUl9VTklUWydJbnRubExpbmsnXSwgLy9JbnRlcm5hdGlvbmFsIExpbmtcbiAgJ3VzLWluJzogSU5DSEVTX1BFUl9VTklUWydpbmNoZXMnXSwgLy9VLlMuIFN1cnZleW9yJ3MgSW5jaFxuICAndXMtZnQnOiBJTkNIRVNfUEVSX1VOSVRbJ0Zvb3QnXSwgLy9VLlMuIFN1cnZleW9yJ3MgRm9vdFxuICAndXMteWQnOiBJTkNIRVNfUEVSX1VOSVRbJ1lhcmQnXSwgLy9VLlMuIFN1cnZleW9yJ3MgWWFyZFxuICAndXMtY2gnOiBJTkNIRVNfUEVSX1VOSVRbJ0d1bnRlckNoYWluJ10sIC8vVS5TLiBTdXJ2ZXlvcidzIENoYWluXG4gICd1cy1taSc6IElOQ0hFU19QRVJfVU5JVFsnTWlsZSddLCAvL1UuUy4gU3VydmV5b3IncyBTdGF0dXRlIE1pbGVcbiAgJ2luZC15ZCc6IElOQ0hFU19QRVJfVU5JVFsnSW5kaWFuWWQzNyddLCAvL0luZGlhbiBZYXJkXG4gICdpbmQtZnQnOiBJTkNIRVNfUEVSX1VOSVRbJ0luZGlhbkZ0MzcnXSwgLy9JbmRpYW4gRm9vdFxuICAnaW5kLWNoJzogMjAuMTE2Njk1MDYgLyBNRVRFUlNfUEVSX0lOQ0ggLy9JbmRpYW4gQ2hhaW5cbn0pO1xuXG4vL+WwhuacjeWKoeerr+eahOWcsOWbvuWNleS9jei9rOaIkFN1cGVyTWFw55qE5Zyw5Zu+5Y2V5L2NXG5JTkNIRVNfUEVSX1VOSVRbJ2RlZ3JlZSddID0gSU5DSEVTX1BFUl9VTklULmRkO1xuSU5DSEVTX1BFUl9VTklUWydtZXRlciddID0gSU5DSEVTX1BFUl9VTklULm07XG5JTkNIRVNfUEVSX1VOSVRbJ2Zvb3QnXSA9IElOQ0hFU19QRVJfVU5JVC5mdDtcbklOQ0hFU19QRVJfVU5JVFsnaW5jaCddID0gSU5DSEVTX1BFUl9VTklULmluY2hlcztcbklOQ0hFU19QRVJfVU5JVFsnbWlsZSddID0gSU5DSEVTX1BFUl9VTklULm1pO1xuSU5DSEVTX1BFUl9VTklUWydraWxvbWV0ZXInXSA9IElOQ0hFU19QRVJfVU5JVC5rbTtcbklOQ0hFU19QRVJfVU5JVFsneWFyZCddID0gSU5DSEVTX1BFUl9VTklULnlkO1xuXG5mdW5jdGlvbiBwYXJhbVRvU3RyaW5nKHBhcmFtKSB7XG4gIGlmIChwYXJhbSA9PSB1bmRlZmluZWQgfHwgcGFyYW0gPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAocGFyYW0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIHBhcmFtLnRvSlNPTigpO1xuICB9XG4gIGlmIChjYW5CZUpzb25pZmllZChwYXJhbSkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtLnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGNhbkJlSnNvbmlmaWVkKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHN0ciAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB0eXBlID0gc3RyLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgeyBVdGlsLCBCcm93c2VyLCBJTkNIRVNfUEVSX1VOSVQsIE1FVEVSU19QRVJfSU5DSCwgRE9UU19QRVJfSU5DSCwgSVNfR0VDS08gfTtcbiIsIi8qIENvcHlyaWdodMKpIDIwMDAgLSAyMDIyIFN1cGVyTWFwIFNvZnR3YXJlIENvLkx0ZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cbmltcG9ydCAncHJvbWlzZS1wb2x5ZmlsbC9kaXN0L3BvbHlmaWxsJztcbmltcG9ydCAnZmV0Y2gtaWU4JztcbmltcG9ydCBmZXRjaEpzb25wIGZyb20gJ2ZldGNoLWpzb25wJztcbmltcG9ydCB7IFV0aWwgfSBmcm9tICcuLi9jb21tb250eXBlcy9VdGlsJztcblxubGV0IGZldGNoID0gd2luZG93LmZldGNoO1xuZXhwb3J0IHZhciBzZXRGZXRjaCA9IGZ1bmN0aW9uIChuZXdGZXRjaCkge1xuICAgIGZldGNoID0gbmV3RmV0Y2g7XG59XG5leHBvcnQgdmFyIFJlcXVlc3RKU09OUFByb21pc2UgPSB7XG4gIGxpbWl0TGVuZ3RoOiAxNTAwLFxuICBxdWVyeUtleXM6IFtdLFxuICBxdWVyeVZhbHVlczogW10sXG4gIHN1cGVybWFwX2NhbGxiYWNrczoge30sXG4gIGFkZFF1ZXJ5U3RyaW5nczogZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICBtZS5xdWVyeUtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzW2tleV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHZhbHVlc1trZXldID0gVXRpbC50b0pTT04odmFsdWVzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGVtcFZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlc1trZXldKTtcbiAgICAgICAgICBtZS5xdWVyeVZhbHVlcy5wdXNoKHRlbXBWYWx1ZSk7XG4gICAgICB9XG4gIH0sXG4gIGlzc3VlOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgIHVpZCA9IG1lLmdldFVpZCgpLFxuICAgICAgICAgIHVybCA9IGNvbmZpZy51cmwsXG4gICAgICAgICAgc3BsaXRRdWVzdFVybCA9IFtdO1xuICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIG1lLnN1cGVybWFwX2NhbGxiYWNrc1t1aWRdID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBtZS5zdXBlcm1hcF9jYWxsYmFja3NbdWlkXTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBtZS5hZGRRdWVyeVN0cmluZ3Moe1xuICAgICAgLy8gICAgIGNhbGxiYWNrOiBcIlJlcXVlc3RKU09OUFByb21pc2Uuc3VwZXJtYXBfY2FsbGJhY2tzW1wiICsgdWlkICsgXCJdXCJcbiAgICAgIC8vIH0pO1xuICAgICAgdmFyIHNlY3Rpb25VUkwgPSB1cmwsXG4gICAgICAgICAga2V5c0NvdW50ID0gMDsgLy/mraTmrKFzZWN0aW9uVVJM5Lit5pyJ5aSa5bCR5Liqa2V5XG4gICAgICB2YXIgbGVuZ3RoID0gbWUucXVlcnlLZXlzID8gbWUucXVlcnlLZXlzLmxlbmd0aCA6IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNlY3Rpb25VUkwubGVuZ3RoICsgbWUucXVlcnlLZXlzW2ldLmxlbmd0aCArIDIgPj0gbWUubGltaXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8rMiBmb3IgKFwiJlwib3JcIj9cIilhbmRcIj1cIlxuICAgICAgICAgICAgICBpZiAoa2V5c0NvdW50ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzcGxpdFF1ZXN0VXJsLnB1c2goc2VjdGlvblVSTCk7XG4gICAgICAgICAgICAgIHNlY3Rpb25VUkwgPSB1cmw7XG4gICAgICAgICAgICAgIGtleXNDb3VudCA9IDA7XG4gICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoc2VjdGlvblVSTC5sZW5ndGggKyBtZS5xdWVyeUtleXNbaV0ubGVuZ3RoICsgMiArIG1lLnF1ZXJ5VmFsdWVzW2ldLmxlbmd0aCA+IG1lLmxpbWl0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbGVmdFZhbHVlID0gbWUucXVlcnlWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICB3aGlsZSAobGVmdFZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdExlbmd0aCA9IG1lLmxpbWl0TGVuZ3RoIC0gc2VjdGlvblVSTC5sZW5ndGggLSBtZS5xdWVyeUtleXNbaV0ubGVuZ3RoIC0gMjsgLy8rMiBmb3IgKFwiJlwib3JcIj9cIilhbmRcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uVVJMLmluZGV4T2YoJz8nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25VUkwgKz0gJyYnO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25VUkwgKz0gJz8nO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcExlZnRWYWx1ZSA9IGxlZnRWYWx1ZS5zdWJzdHJpbmcoMCwgbGVmdExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgLy/pgb/lhY0g5oiq5patc2VjdGlvblVSTOaXtu+8jOWwhuexu+S8vOS6jiUyMui/meagt+eahOespuWPt+aIquaIkOS4pOWNiu+8jOS7juiAjOWvvOiHtOacjeWKoeerr+e7hOijhXNlY3Rpb25VUkzml7blj5HnlJ/plJnor69cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcExlZnRWYWx1ZS5zdWJzdHJpbmcobGVmdExlbmd0aCAtIDEsIGxlZnRMZW5ndGgpID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdExlbmd0aCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wTGVmdFZhbHVlID0gbGVmdFZhbHVlLnN1YnN0cmluZygwLCBsZWZ0TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRlbXBMZWZ0VmFsdWUuc3Vic3RyaW5nKGxlZnRMZW5ndGggLSAyLCBsZWZ0TGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0TGVuZ3RoIC09IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBMZWZ0VmFsdWUgPSBsZWZ0VmFsdWUuc3Vic3RyaW5nKDAsIGxlZnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25VUkwgKz0gbWUucXVlcnlLZXlzW2ldICsgJz0nICsgdGVtcExlZnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0VmFsdWUgPSBsZWZ0VmFsdWUuc3Vic3RyaW5nKGxlZnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wTGVmdFZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRRdWVzdFVybC5wdXNoKHNlY3Rpb25VUkwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uVVJMID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGtleXNDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKHNlY3Rpb25VUkwuaW5kZXhPZignPycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uVVJMICs9ICcmJztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2VjdGlvblVSTCArPSAnPyc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzZWN0aW9uVVJMICs9IG1lLnF1ZXJ5S2V5c1tpXSArICc9JyArIG1lLnF1ZXJ5VmFsdWVzW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3BsaXRRdWVzdFVybC5wdXNoKHNlY3Rpb25VUkwpO1xuICAgICAgbWUuc2VuZChcbiAgICAgICAgICBzcGxpdFF1ZXN0VXJsLFxuICAgICAgICAgICdSZXF1ZXN0SlNPTlBQcm9taXNlLnN1cGVybWFwX2NhbGxiYWNrc1snICsgdWlkICsgJ10nLFxuICAgICAgICAgIGNvbmZpZyAmJiBjb25maWcucHJveHlcbiAgICAgICk7XG4gICAgICByZXR1cm4gcDtcbiAgfSxcblxuICBnZXRVaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB1aWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTE3KTtcbiAgICAgIHJldHVybiB1aWQgKiAxMDAwICsgcmFuZG9tO1xuICB9LFxuXG4gIHNlbmQ6IGZ1bmN0aW9uIChzcGxpdFF1ZXN0VXJsLCBjYWxsYmFjaywgcHJveHkpIHtcbiAgICAgIHZhciBsZW4gPSBzcGxpdFF1ZXN0VXJsLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgdmFyIGpzb25wVXNlcklEID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICB2YXIgdXJsID0gc3BsaXRRdWVzdFVybFtpXTtcbiAgICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCc/JykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgdXJsICs9ICcmJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHVybCArPSAnPyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXJsICs9ICdzZWN0aW9uQ291bnQ9JyArIGxlbjtcbiAgICAgICAgICAgICAgdXJsICs9ICcmc2VjdGlvbkluZGV4PScgKyBpO1xuICAgICAgICAgICAgICB1cmwgKz0gJyZqc29ucFVzZXJJRD0nICsganNvbnBVc2VySUQ7XG4gICAgICAgICAgICAgIGlmIChwcm94eSkge1xuICAgICAgICAgICAgICAgICAgdXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KHVybCk7XG4gICAgICAgICAgICAgICAgICB1cmwgPSBwcm94eSArIGVuY29kZVVSSUNvbXBvbmVudCh1cmwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZldGNoSnNvbnAodXJsLCB7XG4gICAgICAgICAgICAgICAgICBqc29ucENhbGxiYWNrRnVuY3Rpb246IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgdGltZW91dDogMzAwMDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9LFxuXG4gIEdFVDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIG1lLnF1ZXJ5S2V5cy5sZW5ndGggPSAwO1xuICAgICAgbWUucXVlcnlWYWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgIG1lLmFkZFF1ZXJ5U3RyaW5ncyhjb25maWcucGFyYW1zKTtcbiAgICAgIHJldHVybiBtZS5pc3N1ZShjb25maWcpO1xuICB9LFxuXG4gIFBPU1Q6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBtZS5xdWVyeUtleXMubGVuZ3RoID0gMDtcbiAgICAgIG1lLnF1ZXJ5VmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICBtZS5hZGRRdWVyeVN0cmluZ3Moe1xuICAgICAgICAgIHJlcXVlc3RFbnRpdHk6IGNvbmZpZy5kYXRhXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtZS5pc3N1ZShjb25maWcpO1xuICB9LFxuXG4gIFBVVDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIG1lLnF1ZXJ5S2V5cy5sZW5ndGggPSAwO1xuICAgICAgbWUucXVlcnlWYWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgIG1lLmFkZFF1ZXJ5U3RyaW5ncyh7XG4gICAgICAgICAgcmVxdWVzdEVudGl0eTogY29uZmlnLmRhdGFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1lLmlzc3VlKGNvbmZpZyk7XG4gIH0sXG4gIERFTEVURTogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIG1lLnF1ZXJ5S2V5cy5sZW5ndGggPSAwO1xuICAgICAgbWUucXVlcnlWYWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgIG1lLmFkZFF1ZXJ5U3RyaW5ncyh7XG4gICAgICAgICAgcmVxdWVzdEVudGl0eTogY29uZmlnLmRhdGFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1lLmlzc3VlKGNvbmZpZyk7XG4gIH1cbn07XG5cbnZhciBDT1JTO1xudmFyIFJlcXVlc3RUaW1lb3V0O1xuLyoqXG4gKiBAZnVuY3Rpb24gc2V0Q09SU1xuICogQGRlc2NyaXB0aW9uIOiuvue9ruaYr+WQpuWFgeiuuOi3qOWfn+ivt+axgu+8jOWFqOWxgOmFjee9ru+8jOS8mOWFiOe6p+S9juS6jiBzZXJ2aWNlIOS4i+eahCBjcm9zc09yaW5nIOWPguaVsOOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBVdGlsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvcnMgLSDmmK/lkKblhYHorrjot6jln5/or7fmsYLjgIJcbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICB7bmFtZXNwYWNlfS5zZXRDT1JTKGNvcnMpO1xuICpcbiAqICAgLy8g5byD55So55qE5YaZ5rOVXG4gKiAgIFN1cGVyTWFwLnNldENPUlMoY29ycyk7XG4gKlxuICogPC9zY3JpcHQ+XG4gKlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgc2V0Q09SUyB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBzZXRDT1JTKGNvcnMpO1xuICogYGBgXG4gKi9cbmV4cG9ydCB2YXIgc2V0Q09SUyA9IGZ1bmN0aW9uIChjb3JzKSB7XG4gICAgQ09SUyA9IGNvcnM7XG59XG4vKipcbiAqIEBmdW5jdGlvbiBpc0NPUlNcbiAqIEBkZXNjcmlwdGlvbiDmmK/mmK/lkKblhYHorrjot6jln5/or7fmsYLjgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IOaYr+WQpuWFgeiuuOi3qOWfn+ivt+axguOAglxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LmlzQ09SUygpO1xuICpcbiAqICAgLy8g5byD55So55qE5YaZ5rOVXG4gKiAgIGNvbnN0IHJlc3VsdCA9IFN1cGVyTWFwLmlzQ09SUygpO1xuICpcbiAqIDwvc2NyaXB0PlxuICpcbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IGlzQ09SUyB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBpc0NPUlMoKTtcbiAqIGBgYFxuICovXG5leHBvcnQgdmFyIGlzQ09SUyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoQ09SUyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIENPUlM7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xufVxuLyoqXG4gKiBAZnVuY3Rpb24gc2V0UmVxdWVzdFRpbWVvdXRcbiAqIEBkZXNjcmlwdGlvbiDorr7nva7or7fmsYLotoXml7bml7bpl7TjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dD00NV0gLSDor7fmsYLotoXml7bml7bpl7TvvIzljZXkvY3np5LjgIJcbiAqIEBwcml2YXRlXG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gIDxzY3JpcHQ+XG4gICAge25hbWVzcGFjZX0uc2V0UmVxdWVzdFRpbWVvdXQodGltZW91dCk7XG5cbiAgICAvLyDlvIPnlKjnmoTlhpnms5VcbiAgICBTdXBlck1hcC5zZXRSZXF1ZXN0VGltZW91dCh0aW1lb3V0KTtcblxuICA8L3NjcmlwdD5cblxuICAvLyBFUzYgSW1wb3J0XG4gIGltcG9ydCB7IHNldFJlcXVlc3RUaW1lb3V0IH0gZnJvbSAne25wbX0nO1xuXG4gIHNldFJlcXVlc3RUaW1lb3V0KHRpbWVvdXQpO1xuICogYGBgXG4gKi9cbmV4cG9ydCB2YXIgc2V0UmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgIHJldHVybiBSZXF1ZXN0VGltZW91dCA9IHRpbWVvdXQ7XG59XG4vKipcbiAqIEBmdW5jdGlvbiBnZXRSZXF1ZXN0VGltZW91dFxuICogQGRlc2NyaXB0aW9uIOiOt+WPluivt+axgui2heaXtuaXtumXtOOAglxuICogQHJldHVybnMge251bWJlcn0g6K+35rGC6LaF5pe25pe26Ze044CCXG4gKiBAcHJpdmF0ZVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICA8c2NyaXB0PlxuICAgIHtuYW1lc3BhY2V9LmdldFJlcXVlc3RUaW1lb3V0KCk7XG5cbiAgICAvLyDlvIPnlKjnmoTlhpnms5VcbiAgICBTdXBlck1hcC5nZXRSZXF1ZXN0VGltZW91dCgpO1xuXG4gIDwvc2NyaXB0PlxuXG4gIC8vIEVTNiBJbXBvcnRcbiAgaW1wb3J0IHsgZ2V0UmVxdWVzdFRpbWVvdXQgfSBmcm9tICd7bnBtfSc7XG5cbiAgZ2V0UmVxdWVzdFRpbWVvdXQoKTtcbiAqIGBgYFxuICovXG5leHBvcnQgdmFyIGdldFJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZXF1ZXN0VGltZW91dCB8fCA0NTAwMDtcbn1cblxuLyoqXG4gKiBAbmFtZSBGZXRjaFJlcXVlc3RcbiAqIEBuYW1lc3BhY2VcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgVXRpbFxuICogQGRlc2NyaXB0aW9uIOiOt+WPluivt+axguOAglxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LkZldGNoUmVxdWVzdC5jb21taXQobWV0aG9kLCB1cmwsIHBhcmFtcywgb3B0aW9ucyk7XG4gKlxuICogPC9zY3JpcHQ+XG4gKlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgRmV0Y2hSZXF1ZXN0IH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEZldGNoUmVxdWVzdC5jb21taXQobWV0aG9kLCB1cmwsIHBhcmFtcywgb3B0aW9ucyk7XG4gKlxuICogYGBgXG4gKi9cbmV4cG9ydCB2YXIgRmV0Y2hSZXF1ZXN0ID0ge1xuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBGZXRjaFJlcXVlc3QuY29tbWl0XG4gICAgICogQGRlc2NyaXB0aW9uIGNvbW1pdCDor7fmsYLjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIC0g6K+35rGC5pa55rOV44CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIOivt+axguWcsOWdgOOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMgLSDor7fmsYLlj4LmlbDjgIJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIOivt+axgueahOmFjee9ruWxnuaAp+OAglxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIOWvueixoeOAglxuICAgICAqL1xuICAgIGNvbW1pdDogZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kID8gbWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBtZXRob2Q7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlICdHRVQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlICdQT1NUJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0KHVybCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgJ1BVVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHV0KHVybCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgJ0RFTEVURSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKHVybCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEZldGNoUmVxdWVzdC5zdXBwb3J0RGlyZWN0UmVxdWVzdFxuICAgICAqIEBkZXNjcmlwdGlvbiBzdXBwb3J0RGlyZWN0UmVxdWVzdCDor7fmsYLjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0g6K+35rGC5Zyw5Z2A44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSDor7fmsYLnmoTphY3nva7lsZ7mgKfjgIJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0g5piv5ZCm5YWB6K646Leo5Z+f6K+35rGC44CCXG4gICAgICovXG4gICAgc3VwcG9ydERpcmVjdFJlcXVlc3Q6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFV0aWwuaXNJblRoZVNhbWVEb21haW4odXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0NPUlMoKSB8fCBvcHRpb25zLnByb3h5O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRmV0Y2hSZXF1ZXN0LmdldFxuICAgICAqIEBkZXNjcmlwdGlvbiBnZXQg6K+35rGC44CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIOivt+axguWcsOWdgOOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMgLSDor7fmsYLlj4LmlbDjgIJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIOivt+axgueahOmFjee9ruWxnuaAp+OAglxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIOWvueixoeOAglxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKHVybCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgdHlwZSA9ICdHRVQnO1xuICAgICAgICB1cmwgPSBVdGlsLnVybEFwcGVuZCh1cmwsIHRoaXMuX2dldFBhcmFtZXRlclN0cmluZyhwYXJhbXMgfHwge30pKTtcbiAgICAgICAgdXJsID0gdGhpcy5fcHJvY2Vzc1VybCh1cmwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydERpcmVjdFJlcXVlc3QodXJsLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJy5qc29uJywgJy5qc29ucCcpO1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUmVxdWVzdEpTT05QUHJvbWlzZS5HRVQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudXJsSXNMb25nKHVybCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwsIHBhcmFtcywgb3B0aW9ucywgdHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zdFNpbXVsYXRpZSh0eXBlLCB1cmwuc3Vic3RyaW5nKDAsIHVybC5pbmRleE9mKCc/JykgLSAxKSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEZldGNoUmVxdWVzdC5kZWxldGVcbiAgICAgKiBAZGVzY3JpcHRpb24gZGVsZXRlIOivt+axguOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSDor7fmsYLlnLDlnYDjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zIC0g6K+35rGC5Y+C5pWw44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLeivt+axgueahOmFjee9ruWxnuaAp+OAglxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIOWvueixoeOAglxuICAgICAqL1xuICAgIGRlbGV0ZTogZnVuY3Rpb24gKHVybCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgdHlwZSA9ICdERUxFVEUnO1xuICAgICAgICB1cmwgPSBVdGlsLnVybEFwcGVuZCh1cmwsIHRoaXMuX2dldFBhcmFtZXRlclN0cmluZyhwYXJhbXMgfHwge30pKTtcbiAgICAgICAgdXJsID0gdGhpcy5fcHJvY2Vzc1VybCh1cmwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydERpcmVjdFJlcXVlc3QodXJsLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJy5qc29uJywgJy5qc29ucCcpO1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCArPSBcIiZfbWV0aG9kPURFTEVURVwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHBhcmFtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBSZXF1ZXN0SlNPTlBQcm9taXNlLkRFTEVURShjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVybElzTG9uZyh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zdFNpbXVsYXRpZSh0eXBlLCB1cmwuc3Vic3RyaW5nKDAsIHVybC5pbmRleE9mKCc/JykgLSAxKSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsLCBwYXJhbXMsIG9wdGlvbnMsIHR5cGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEZldGNoUmVxdWVzdC5wb3N0XG4gICAgICogQGRlc2NyaXB0aW9uIHBvc3Qg6K+35rGC44CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIOivt+axguWcsOWdgOOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMgLSDor7fmsYLlj4LmlbDjgIJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIOivt+axgueahOmFjee9ruWxnuaAp+OAglxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIOWvueixoeOAglxuICAgICAqL1xuICAgIHBvc3Q6IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnREaXJlY3RSZXF1ZXN0KHVybCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCcuanNvbicsICcuanNvbnAnKTtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwgKz0gXCImX21ldGhvZD1QT1NUXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFJlcXVlc3RKU09OUFByb21pc2UuUE9TVChjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaCh0aGlzLl9wcm9jZXNzVXJsKHVybCwgb3B0aW9ucyksIHBhcmFtcywgb3B0aW9ucywgJ1BPU1QnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBGZXRjaFJlcXVlc3QucHV0XG4gICAgICogQGRlc2NyaXB0aW9uIHB1dCDor7fmsYLjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0g6K+35rGC5Zyw5Z2A44CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcyAtIOivt+axguWPguaVsOOAglxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0g6K+35rGC55qE6YWN572u5bGe5oCn44CCXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2Ug5a+56LGh44CCXG4gICAgICovXG4gICAgcHV0OiBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHVybCA9IHRoaXMuX3Byb2Nlc3NVcmwodXJsLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnREaXJlY3RSZXF1ZXN0KHVybCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCcuanNvbicsICcuanNvbnAnKTtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwgKz0gXCImX21ldGhvZD1QVVRcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUmVxdWVzdEpTT05QUHJvbWlzZS5QVVQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsLCBwYXJhbXMsIG9wdGlvbnMsICdQVVQnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBGZXRjaFJlcXVlc3QudXJsSXNMb25nXG4gICAgICogQGRlc2NyaXB0aW9uIHVybCDnmoTlrZfoioLplb/luqbmmK/lkKblpKrplb/jgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0g6K+35rGC5Zyw5Z2A44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHVybCDnmoTlrZfoioLplb/luqbmmK/lkKblpKrplb/jgIJcbiAgICAgKi9cbiAgICB1cmxJc0xvbmc6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgLy/lvZPliY11cmznmoTlrZfoioLplb/luqbjgIJcbiAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gMCxcbiAgICAgICAgICAgIGNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHVybC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgLy/ovazljJbkuLpVbmljb2Rl57yW56CBXG4gICAgICAgICAgICBjaGFyQ29kZSA9IHVybC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMHgwMDdmKSB7XG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGgrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKDB4MDA4MCA8PSBjaGFyQ29kZSkgJiYgKGNoYXJDb2RlIDw9IDB4MDdmZikpIHtcbiAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoMHgwODAwIDw9IGNoYXJDb2RlKSAmJiAoY2hhckNvZGUgPD0gMHhmZmZmKSkge1xuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsTGVuZ3RoIDwgMjAwMCA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9LFxuICAgIF9wb3N0U2ltdWxhdGllOiBmdW5jdGlvbiAodHlwZSwgdXJsLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IHVybC5pbmRleE9mKCc/JykgPiAtMSA/ICcmJyA6ICc/JztcbiAgICAgICAgdXJsICs9IHNlcGFyYXRvciArICdfbWV0aG9kPScgKyB0eXBlO1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdCh1cmwsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIF9wcm9jZXNzVXJsOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc01WVFJlcXVlc3QodXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cmwuaW5kZXhPZignLmpzb24nKSA9PT0gLTEgJiYgIW9wdGlvbnMud2l0aG91dEZvcm1hdFN1ZmZpeCkge1xuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCc/JykgPCAwKSB7XG4gICAgICAgICAgICAgICAgdXJsICs9ICcuanNvbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB1cmxBcnJheXMgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICAgICAgICAgICAgICBpZiAodXJsQXJyYXlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmxBcnJheXNbMF0gKyAnLmpzb24/JyArIHVybEFycmF5c1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wcm94eSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnByb3h5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gb3B0aW9ucy5wcm94eSh1cmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBkZWNvZGVVUklDb21wb25lbnQodXJsKTtcbiAgICAgICAgICAgICAgICB1cmwgPSBvcHRpb25zLnByb3h5ICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9LFxuXG4gICAgX2ZldGNoOiBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIG9wdGlvbnMsIHR5cGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddICYmICFGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihwYXJhbXMpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dChcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB0eXBlID09PSAnUFVUJyB8fCB0eXBlID09PSAnUE9TVCcgPyBwYXJhbXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLl9nZXRXaXRoQ3JlZGVudGlhbHMob3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogZ2V0UmVxdWVzdFRpbWVvdXQoKVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IHR5cGUsXG4gICAgICAgICAgICBib2R5OiB0eXBlID09PSAnUFVUJyB8fCB0eXBlID09PSAnUE9TVCcgPyBwYXJhbXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogdGhpcy5fZ2V0V2l0aENyZWRlbnRpYWxzKG9wdGlvbnMpLFxuICAgICAgICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgICAgICAgdGltZW91dDogZ2V0UmVxdWVzdFRpbWVvdXQoKVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldFdpdGhDcmVkZW50aWFsczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2luY2x1ZGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLndpdGhDcmVkZW50aWFscyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiAnb21pdCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdzYW1lLW9yaWdpbic7XG4gICAgfSxcblxuICAgIF9mZXRjaEpzb25wOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICByZXR1cm4gZmV0Y2hKc29ucCh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXRcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF90aW1lb3V0OiBmdW5jdGlvbiAoc2Vjb25kcywgcHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigndGltZW91dCcpKTtcbiAgICAgICAgICAgIH0sIHNlY29uZHMpO1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0UGFyYW1ldGVyU3RyaW5nOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbXNBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhciBlbmNvZGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWRWYWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWRWYWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtc0FycmF5LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXNBcnJheS5qb2luKCcmJyk7XG4gICAgfSxcblxuICAgIF9pc01WVFJlcXVlc3Q6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHVybC5pbmRleE9mKCcubXZ0JykgPiAtMSB8fCB1cmwuaW5kZXhPZignLnBiZicpID4gLTE7XG4gICAgfVxufVxuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBwcm9ncmFtIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xuXG4vKipcbiAqIEBjbGFzcyBDcmVkZW50aWFsXG4gKiBAZGVwcmVjYXRlZGNsYXNzIFN1cGVyTWFwLkNyZWRlbnRpYWxcbiAqIEBjYXRlZ29yeSBTZWN1cml0eVxuICogQGNsYXNzZGVzYyBTdXBlck1hcCDnmoTlronlhajor4HkuabnsbvvvIzlhbbkuK3ljIXmi6wgdG9rZW4g562J5a6J5YWo6aqM6K+B5L+h5oGv44CCPC9icj5cbiAqIOmcgOimgeS9v+eUqOeUqOaIt+WQjeWSjOWvhueggeWcqO+8mlwiaHR0cDovL2xvY2FsaG9zdDo4MDkwL2lzZXJ2ZXIvc2VydmljZXMvc2VjdXJpdHkvdG9rZW5zXCIg5LiL55Sz6K+3IHZhbHVl44CCPC9icj5cbiAqIOiOt+W+l+W9ouWmgu+8mlwiMk9Nd0dtY05sclAyaXhxdjFNazRCdVFNeWJPR2ZMT3JsanJ1WDZWY1lNRFFLYzU4U2w5bk1Ic3FRYXFlQng0NGpSdktTamttcFpLSzFMNTk2eTdza1EuLlwiIOeahCB2YWx1ZeOAgjwvYnI+XG4gKiDnm67liY3mlK/mjIHnmoTlip/og73ljIXmi6zvvJrlnLDlm77mnI3liqHjgIHkuJPpopjlm77jgIHph4/nrpfjgIHmn6Xor6LjgIHlhazkuqTmjaLkuZjjgIHnqbrpl7TliIbmnpDjgIHnvZHnu5zliIbmnpDvvIzkuI3mlK/mjIHova7or6Llip/og73jgII8L2JyPlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0g6K6/6Zeu5Y+X5a6J5YWo6ZmQ5Yi255qE5pyN5Yqh5pe255So5LqO6YCa6L+H5a6J5YWo6K6k6K+B55qE6aqM6K+B5L+h5oGv44CCXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9J3Rva2VuJ10gLSDpqozor4Hkv6Hmga/liY3nvIDvvIxuYW1lPXZhbHVlIOmDqOWIhueahCBuYW1lIOmDqOWIhuOAglxuICogQGV4YW1wbGVcbiAqIHZhciBwaXhjZWwgPSBuZXcgQ3JlZGVudGlhbChcInZhbHVlU3RyaW5nXCIsXCJ0b2tlblwiKTtcbiAqIHBpeGNlbC5kZXN0cm95KCk7XG4gKiBAdXNhZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIENyZWRlbnRpYWwge1xuXG4gICAgY29uc3RydWN0b3IodmFsdWUsIG5hbWUpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBDcmVkZW50aWFsLnByb3RvdHlwZS52YWx1ZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g6K6/6Zeu5Y+X5a6J5YWo6ZmQ5Yi255qE5pyN5Yqh5pe255So5LqO6YCa6L+H5a6J5YWo6K6k6K+B55qE6aqM6K+B5L+h5oGv44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUgPyB2YWx1ZSA6IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gW0NyZWRlbnRpYWwucHJvdG90eXBlLm5hbWU9J3Rva2VuJ11cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOmqjOivgeS/oeaBr+WJjee8gO+8jG5hbWU9dmFsdWUg6YOo5YiG55qEIG5hbWUg6YOo5YiG44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lID8gbmFtZSA6IFwidG9rZW5cIjtcbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gXCJTdXBlck1hcC5DcmVkZW50aWFsXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENyZWRlbnRpYWwucHJvdG90eXBlLmdldFVybFBhcmFtZXRlcnNcbiAgICAgKiBAZGVzY3JpcHRpb24g6I635Y+WIG5hbWU9dmFsdWUg55qE6KGo6L6+5byP44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgY3JlZGVudGlhbCA9IG5ldyBDcmVkZW50aWFsKFwidmFsdWVTdHJpbmdcIixcInRva2VuXCIpO1xuICAgICAqIC8v6L+Z6YeMIHN0ciA9IFwidG9rZW49dmFsdWVTdHJpbmdcIjtcbiAgICAgKiB2YXIgc3RyID0gY3JlZGVudGlhbC5nZXRVcmxQYXJhbWV0ZXJzKCk7XG4gICAgICogQHJldHVybnMge3N0cmluZ30g5a6J5YWo5L+h5oGv57uE5oiQ55qEIHVybCDniYfmrrXjgIJcbiAgICAgKi9cbiAgICBnZXRVcmxQYXJhbWV0ZXJzKCkge1xuICAgICAgICAvL+W9k+mcgOimgeWFtuS7luWuieWFqOS/oeaBr+eahOaXtuWAme+8jOWImemcgOimgXJldHVybiB0aGlzLm5hbWUgKyBcIj1cIiArIHRoaXMudmFsdWUgKyBcIiZcIiArIFwiLi4uXCI755qE5b2i5byP5re75Yqg44CCXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIj1cIiArIHRoaXMudmFsdWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ3JlZGVudGlhbC5wcm90b3R5cGUuZ2V0VmFsdWVcbiAgICAgKiBAZGVzY3JpcHRpb24g6I635Y+WIHZhbHVl44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgY3JlZGVudGlhbCA9IG5ldyBDcmVkZW50aWFsKFwiMk9Nd0dtY05sclAyaXhxdjFNazRCdVFNeWJPR2ZMT3JsanJ1WDZWY1lNRFFLYzU4U2w5bk1Ic3FRYXFlQng0NGpSdktTamttcFpLSzFMNTk2eTdza1EuLlwiLFwidG9rZW5cIik7XG4gICAgICogLy/ov5nph4wgc3RyID0gXCIyT013R21jTmxyUDJpeHF2MU1rNEJ1UU15Yk9HZkxPcmxqcnVYNlZjWU1EUUtjNThTbDluTUhzcVFhcWVCeDQ0alJ2S1Nqa21wWktLMUw1OTZ5N3NrUS4uXCI7XG4gICAgICogdmFyIHN0ciA9IGNyZWRlbnRpYWwuZ2V0VmFsdWUoKTtcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB2YWx1ZSDlrZfnrKbkuLLvvIzlnKggaVNlcnZlciDmnI3liqHkuIvor6UgdmFsdWUg5YC85Y2z5Li6IHRva2VuIOWAvOOAglxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBDcmVkZW50aWFsLnByb3RvdHlwZS5kZXN0cm95XG4gICAgICogQGRlc2NyaXB0aW9uIOmUgOavgeatpOWvueixoeOAgumUgOavgeWQjuatpOWvueixoeeahOaJgOacieWxnuaAp+S4uiBudWxs77yM6ICM5LiN5piv5Yid5aeL5YC844CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgY3JlZGVudGlhbCA9IG5ldyBDcmVkZW50aWFsKFwidmFsdWVTdHJpbmdcIixcInRva2VuXCIpO1xuICAgICAqIGNyZWRlbnRpYWwuZGVzdHJveSgpO1xuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIH1cblxufVxuXG4vKipcbiAqIEBtZW1iZXIge0NyZWRlbnRpYWx9IENyZWRlbnRpYWwuQ1JFREVOVElBTFxuICogQGRlc2NyaXB0aW9uIOi/meS4quWvueixoeS/neWtmOS4gOS4quWuieWFqOexu+eahOWunuS+i++8jOWcqOacjeWKoeerr+mcgOimgeWuieWFqOmqjOivgeeahOaXtuWAmeW/hemhu+i/m+ihjOiuvue9ruOAglxuICogQGV4YW1wbGVcbiAqIOS7o+eggeWunuS+izpcbiAqICAvLyDlvZNpU2VydmVy5ZCv55So5pyN5Yqh5a6J5YWo55qE5pe25YCZ77yM5LiL6L6555qE5Luj56CB5piv5b+F6aG755qE44CC5a6J5YWo6K+B5Lmm57G76IO95aSf5o6l5pS25LiA5LiqdmFsdWXlkozkuIDkuKpuYW1l5Y+C5pWw44CCXG4gKiAgdmFyIHZhbHVlID0gXCIo5LulaVNlcnZlcuS4uuS+i++8jOi/memHjOaYr+eUs+ivt+eahHRva2Vu5YC8KVwiO1xuICogIHZhciBuYW1lID0gXCJ0b2tlblwiO1xuICogIC8vIOm7mOiupG5hbWXlj4LmlbDkuLp0b2tlbu+8jOaJgOS7peW9k+S9v+eUqGlTZXJ2ZXLmnI3liqHnmoTml7blgJnlj6/ku6XkuI3ov5vooYzorr7nva7jgIJcbiAqICBDcmVkZW50aWFsLkNSRURFTlRJQUwgPSBuZXcgQ3JlZGVudGlhbCh2YWx1ZSwgbmFtZSk7XG4gKlxuICovXG5cbiBDcmVkZW50aWFsLkNSRURFTlRJQUwgPSBudWxsO1xuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBwcm9ncmFtIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xuaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4uL2NvbW1vbnR5cGVzL1V0aWwnO1xuaW1wb3J0IHsgRmV0Y2hSZXF1ZXN0IH0gZnJvbSAnLi4vdXRpbC9GZXRjaFJlcXVlc3QnO1xuaW1wb3J0IHsgQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NvbW1vbnR5cGVzL0NyZWRlbnRpYWwnO1xuXG4vKipcbiAqIEBjbGFzcyBTZWN1cml0eU1hbmFnZXJcbiAqIEBkZXByZWNhdGVkY2xhc3MgU3VwZXJNYXAuU2VjdXJpdHlNYW5hZ2VyXG4gKiBAY2F0ZWdvcnkgU2VjdXJpdHlcbiAqIEBjbGFzc2Rlc2Mg5a6J5YWo566h55CG5Lit5b+D77yM5o+Q5L6bIGlTZXJ2ZXIsaVBvcnRhbCxPbmxpbmUg57uf5LiA5p2D6ZmQ6K6k6K+B566h55CG44CCXG4gKiAgPiDkvb/nlKjor7TmmI7vvJpcbiAqICA+IOWIm+W7uuS7u+S9leS4gOS4quacjeWKoeS5i+WJjeiwg+eUqCB7QGxpbmsgU2VjdXJpdHlNYW5hZ2VyLnJlZ2lzdGVyVG9rZW595oiWXG4gKiAgPiB7QGxpbmsgU2VjdXJpdHlNYW5hZ2VyLnJlZ2lzdGVyS2V5feazqOWGjOWHreaNruOAglxuICogID4g5Y+R6YCB6K+35rGC5pe25qC55o2uIHVybCDmiJbogIXmnI3liqEgaWQg6I635Y+W55u45bqU55qEIGtleSDmiJbogIUgdG9rZW4g5bm26Ieq5Yqo5re75Yqg5Yiw5pyN5Yqh5Zyw5Z2A5Lit44CCXG4gKiBAdXNhZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIFNlY3VyaXR5TWFuYWdlciB7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIOS7juacjeWKoeWZqOiOt+WPluS4gOS4qnRva2VuLOWcqOatpOS5i+WJjeimgeazqOWGjOacjeWKoeWZqOS/oeaBr+OAglxuICAgICAqIEBmdW5jdGlvbiBTZWN1cml0eU1hbmFnZXIuZ2VuZXJhdGVUb2tlblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSDmnI3liqHlmajln5/lkI0r56uv5Y+j77yM5aaC77yaaHR0cDovL2xvY2FsaG9zdDo4MDky44CCXG4gICAgICogQHBhcmFtIHtUb2tlblNlcnZpY2VQYXJhbWV0ZXJ9IHRva2VuUGFyYW0gLSB0b2tlbiDnlLPor7flj4LmlbDjgIJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0g5YyF5ZCrIHRva2VuIOS/oeaBr+eahCBQcm9taXNlIOWvueixoeOAglxuICAgICAqL1xuXG4gICAgc3RhdGljIGdlbmVyYXRlVG9rZW4odXJsLCB0b2tlblBhcmFtKSB7XG4gICAgICAgIHZhciBzZXJ2ZXJJbmZvID0gdGhpcy5zZXJ2ZXJzW3VybF07XG4gICAgICAgIGlmICghc2VydmVySW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGZXRjaFJlcXVlc3QucG9zdChzZXJ2ZXJJbmZvLnRva2VuU2VydmljZVVybCwgSlNPTi5zdHJpbmdpZnkodG9rZW5QYXJhbS50b0pTT04oKSkpLnRoZW4oZnVuY3Rpb24oXG4gICAgICAgICAgICByZXNwb25zZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiDms6jlhozlronlhajmnI3liqHlmajnm7jlhbPkv6Hmga/jgIJcbiAgICAgKiBAZnVuY3Rpb24gU2VjdXJpdHlNYW5hZ2VyLnJlZ2lzdGVyU2VydmVyc1xuICAgICAqIEBwYXJhbSB7U2VydmVySW5mb30gc2VydmVySW5mb3MgLSDmnI3liqHlmajkv6Hmga/jgIJcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXJTZXJ2ZXJzKHNlcnZlckluZm9zKSB7XG4gICAgICAgIHRoaXMuc2VydmVycyA9IHRoaXMuc2VydmVycyB8fCB7fTtcbiAgICAgICAgaWYgKCFVdGlsLmlzQXJyYXkoc2VydmVySW5mb3MpKSB7XG4gICAgICAgICAgICBzZXJ2ZXJJbmZvcyA9IFtzZXJ2ZXJJbmZvc107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXJ2ZXJJbmZvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNlcnZlckluZm8gPSBzZXJ2ZXJJbmZvc1tpXTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyc1tzZXJ2ZXJJbmZvLnNlcnZlcl0gPSBzZXJ2ZXJJbmZvO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIOacjeWKoeivt+axgumDveS8muiHquWKqOW4puS4iui/meS4qiB0b2tlbuOAglxuICAgICAqIEBmdW5jdGlvbiBTZWN1cml0eU1hbmFnZXIucmVnaXN0ZXJUb2tlblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLeacjeWKoeWZqOWfn+WQjSvnq6/lj6PvvJrlpoJodHRwOi8vbG9jYWxob3N0OjgwOTDjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSB0b2tlblxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlclRva2VuKHVybCwgdG9rZW4pIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0aGlzLnRva2VucyB8fCB7fTtcbiAgICAgICAgaWYgKCF1cmwgfHwgIXRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvbWFpbiA9IHRoaXMuX2dldFRva2VuU3RvcmFnZUtleSh1cmwpO1xuICAgICAgICB0aGlzLnRva2Vuc1tkb21haW5dID0gdG9rZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIOazqOWGjCBrZXksaWRzIOS4uuaVsOe7hCjlrZjlnKjkuIDkuKoga2V5IOWvueW6lOWkmuS4quacjeWKoSnjgIJcbiAgICAgKiBAZnVuY3Rpb24gU2VjdXJpdHlNYW5hZ2VyLnJlZ2lzdGVyS2V5XG4gICAgICogQHBhcmFtIHtBcnJheX0gaWRzIC0g5Y+v5Lul5piv5pyN5YqhIGlkIOaVsOe7hOaIluiAhSB1cmwg5Zyw5Z2A5pWw57uE5oiW6ICFIHdlYkFQSSDnsbvlnovmlbDnu4TjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0ga2V5XG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyS2V5KGlkcywga2V5KSB7XG4gICAgICAgIHRoaXMua2V5cyA9IHRoaXMua2V5cyB8fCB7fTtcbiAgICAgICAgaWYgKCFpZHMgfHwgaWRzLmxlbmd0aCA8IDEgfHwgIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWRzID0gVXRpbC5pc0FycmF5KGlkcykgPyBpZHMgOiBbaWRzXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuX2dldFVybFJlc3RTdHJpbmcoaWRzWzBdKSB8fCBpZHNbMF07XG4gICAgICAgICAgICB0aGlzLmtleXNbaWRdID0ga2V5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIOiOt+WPluacjeWKoeWZqOS/oeaBr+OAglxuICAgICAqIEBmdW5jdGlvbiBTZWN1cml0eU1hbmFnZXIuZ2V0U2VydmVySW5mb1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSDmnI3liqHlmajln5/lkI0r56uv5Y+j77yM5aaC77yaaHR0cDovL2xvY2FsaG9zdDo4MDky44CCXG4gICAgICogQHJldHVybnMge1NlcnZlckluZm99IOacjeWKoeWZqOS/oeaBr+OAglxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZXJ2ZXJJbmZvKHVybCkge1xuICAgICAgICB0aGlzLnNlcnZlcnMgPSB0aGlzLnNlcnZlcnMgfHwge307XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlcnNbdXJsXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24g5qC55o2uIFVybCDojrflj5Z0b2tlbuOAglxuICAgICAqIEBmdW5jdGlvbiBTZWN1cml0eU1hbmFnZXIuZ2V0VG9rZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0g5pyN5Yqh5Zmo5Z+f5ZCNK+err+WPo++8jOWmgu+8mmh0dHA6Ly9sb2NhbGhvc3Q6ODA5MuOAglxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRva2VuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRva2VuKHVybCkge1xuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5zID0gdGhpcy50b2tlbnMgfHwge307XG4gICAgICAgIHZhciBkb21haW4gPSB0aGlzLl9nZXRUb2tlblN0b3JhZ2VLZXkodXJsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW2RvbWFpbl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIOagueaNriBVcmwg6I635Y+WIGtleeOAglxuICAgICAqIEBmdW5jdGlvbiBTZWN1cml0eU1hbmFnZXIuZ2V0S2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gaWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBrZXlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0S2V5KGlkKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IHRoaXMua2V5cyB8fCB7fTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX2dldFVybFJlc3RTdHJpbmcoaWQpIHx8IGlkO1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIGlTZXJ2ZXIg55m75b2V6aqM6K+B44CCXG4gICAgICogQGZ1bmN0aW9uIFNlY3VyaXR5TWFuYWdlci5sb2dpbmlTZXJ2ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gaVNlcnZlciDpppbpobXlnLDlnYDvvIzlpoLvvJpodHRwOi8vbG9jYWxob3N0OjgwOTAvaXNlcnZlcuOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSAtIOeUqOaIt+WQjeOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIOWvhueggeOAglxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbWVtYmVybWU9ZmFsc2VdIC0g5piv5ZCm6K6w5L2P44CCXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IOWMheWQqyBpU2VydmVyIOeZu+W9leivt+axgue7k+aenOeahCBQcm9taXNlIOWvueixoeOAglxuICAgICAqL1xuICAgIHN0YXRpYyBsb2dpbmlTZXJ2ZXIodXJsLCB1c2VybmFtZSwgcGFzc3dvcmQsIHJlbWVtYmVybWUpIHtcbiAgICAgICAgdXJsID0gVXRpbC51cmxQYXRoQXBwZW5kKHVybCwgJ3NlcnZpY2VzL3NlY3VyaXR5L2xvZ2luJyk7XG4gICAgICAgIHZhciBsb2dpbkluZm8gPSB7XG4gICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUgJiYgdXNlcm5hbWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCAmJiBwYXNzd29yZC50b1N0cmluZygpLFxuICAgICAgICAgICAgcmVtZW1iZXJtZTogcmVtZW1iZXJtZVxuICAgICAgICB9O1xuICAgICAgICBsb2dpbkluZm8gPSBKU09OLnN0cmluZ2lmeShsb2dpbkluZm8pO1xuICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGZXRjaFJlcXVlc3QucG9zdCh1cmwsIGxvZ2luSW5mbywgcmVxdWVzdE9wdGlvbnMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBpU2VydmVy55m75Ye644CCXG4gICAgICogQGZ1bmN0aW9uIFNlY3VyaXR5TWFuYWdlci5sb2dvdXRpU2VydmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIGlTZXJ2ZXIg6aaW6aG15Zyw5Z2ALOWmgu+8mmh0dHA6Ly9sb2NhbGhvc3Q6ODA5MC9pc2VydmVy44CCXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IOaYr+WQpueZu+WHuuaIkOWKn+OAglxuICAgICAqL1xuICAgIHN0YXRpYyBsb2dvdXRpU2VydmVyKHVybCkge1xuICAgICAgICB1cmwgPSBVdGlsLnVybFBhdGhBcHBlbmQodXJsLCAnc2VydmljZXMvc2VjdXJpdHkvbG9nb3V0Jyk7XG4gICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aXRob3V0Rm9ybWF0U3VmZml4OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGZXRjaFJlcXVlc3QuZ2V0KHVybCwgJycsIHJlcXVlc3RPcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBPbmxpbmUg55m75b2V6aqM6K+B44CCXG4gICAgICogQGZ1bmN0aW9uIFNlY3VyaXR5TWFuYWdlci5sb2dpbk9ubGluZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYWxsYmFja0xvY2F0aW9uIC0g6Lez6L2s5L2N572u44CCXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbmV3VGFiPXRydWVdIC0g5piv5ZCm5paw56qX5Y+j5omT5byA44CCXG4gICAgICovXG4gICAgc3RhdGljIGxvZ2luT25saW5lKGNhbGxiYWNrTG9jYXRpb24sIG5ld1RhYikge1xuICAgICAgICB2YXIgbG9naW5VcmwgPSBTZWN1cml0eU1hbmFnZXIuU1NPICsgJy9sb2dpbj9zZXJ2aWNlPScgKyBjYWxsYmFja0xvY2F0aW9uO1xuICAgICAgICB0aGlzLl9vcGVuKGxvZ2luVXJsLCBuZXdUYWIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBpUG9ydGFs55m75b2V6aqM6K+B44CCXG4gICAgICogQGZ1bmN0aW9uIFNlY3VyaXR5TWFuYWdlci5sb2dpbmlQb3J0YWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gaXBvcnRhbCDpppbpobXlnLDlnYAs5aaC77yaaHR0cDovL2xvY2FsaG9zdDo4MDkyL2lwb3J0YWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIC0g55So5oi35ZCN44CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0g5a+G56CB44CCXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IOWMheWQqyBpUG9ydGFsIOeZu+W9leivt+axgue7k+aenOeahCBQcm9taXNlIOWvueixoeOAglxuICAgICAqL1xuICAgIHN0YXRpYyBsb2dpbmlQb3J0YWwodXJsLCB1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgdXJsID0gVXRpbC51cmxQYXRoQXBwZW5kKHVybCwgJ3dlYi9sb2dpbicpO1xuICAgICAgICB2YXIgbG9naW5JbmZvID0ge1xuICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lICYmIHVzZXJuYW1lLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQgJiYgcGFzc3dvcmQudG9TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICBsb2dpbkluZm8gPSBKU09OLnN0cmluZ2lmeShsb2dpbkluZm8pO1xuICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGZXRjaFJlcXVlc3QucG9zdCh1cmwsIGxvZ2luSW5mbywgcmVxdWVzdE9wdGlvbnMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBpUG9ydGFsIOeZu+WHuuOAglxuICAgICAqIEBmdW5jdGlvbiBTZWN1cml0eU1hbmFnZXIubG9nb3V0aVBvcnRhbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBpcG9ydGFsIOmmlumhteWcsOWdgCzlpoLvvJpodHRwOi8vbG9jYWxob3N0OjgwOTIvaXBvcnRhbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0g5aaC5p6c55m75Ye65oiQ5Yqf77yM6L+U5ZueIHRydWU75ZCm5YiZ6L+U5ZueIGZhbHNl44CCXG4gICAgICovXG4gICAgc3RhdGljIGxvZ291dGlQb3J0YWwodXJsKSB7XG4gICAgICAgIHVybCA9IFV0aWwudXJsUGF0aEFwcGVuZCh1cmwsICdzZXJ2aWNlcy9zZWN1cml0eS9sb2dvdXQnKTtcbiAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgICAgICAgIHdpdGhvdXRGb3JtYXRTdWZmaXg6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZldGNoUmVxdWVzdC5nZXQodXJsLCAnJywgcmVxdWVzdE9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIGlNYW5hZ2VyIOeZu+W9lemqjOivgeOAglxuICAgICAqIEBmdW5jdGlvbiBTZWN1cml0eU1hbmFnZXIubG9naW5NYW5hZ2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIGlNYW5hZ2VyIOWcsOWdgOOAguWcsOWdgOWPguaVsOS4uiBpTWFuYWdlciDpppbpobXlnLDlnYDvvIzlpoLvvJogaHR0cDovL2xvY2FsaG9zdDo4MzkwL2ltYW5hZ2Vy44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtsb2dpbkluZm9QYXJhbXNdIC0gaU1hbmFnZXIg55m75b2V5Y+C5pWw44CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvZ2luSW5mb1BhcmFtcy51c2VyTmFtZSAtIOeUqOaIt+WQjeOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2dpbkluZm9QYXJhbXMucGFzc3dvcmQgLSDlr4bnoIHjgIJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNOZXdUYWI9dHJ1ZV0gLSDkuI3lkIzln5/ml7bmmK/lkKblnKjmlrDnqpflj6PmiZPlvIDnmbvlvZXpobXpnaLjgIJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0g5YyF5ZCrIGlNYW5hZ2VyIOeZu+W9leivt+axgue7k+aenOeahCBQcm9taXNlIOWvueixoeOAglxuICAgICAqL1xuICAgIHN0YXRpYyBsb2dpbk1hbmFnZXIodXJsLCBsb2dpbkluZm9QYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFVdGlsLmlzSW5UaGVTYW1lRG9tYWluKHVybCkpIHtcbiAgICAgICAgICAgIHZhciBpc05ld1RhYiA9IG9wdGlvbnMgPyBvcHRpb25zLmlzTmV3VGFiIDogdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX29wZW4odXJsLCBpc05ld1RhYik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3RVcmwgPSBVdGlsLnVybFBhdGhBcHBlbmQodXJsLCAnaWNsb3VkL3NlY3VyaXR5L3Rva2VucycpO1xuICAgICAgICB2YXIgcGFyYW1zID0gbG9naW5JbmZvUGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgbG9naW5JbmZvID0ge1xuICAgICAgICAgICAgdXNlcm5hbWU6IHBhcmFtcy51c2VyTmFtZSAmJiBwYXJhbXMudXNlck5hbWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMucGFzc3dvcmQgJiYgcGFyYW1zLnBhc3N3b3JkLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgbG9naW5JbmZvID0gSlNPTi5zdHJpbmdpZnkobG9naW5JbmZvKTtcbiAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIEFjY2VwdDogJyovKicsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gRmV0Y2hSZXF1ZXN0LnBvc3QocmVxdWVzdFVybCwgbG9naW5JbmZvLCByZXF1ZXN0T3B0aW9ucykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgcmVzcG9uc2UudGV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgbWUuaW1hbmFnZXJUb2tlbiA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiDmuIXnqbrlhajpg6jpqozor4Hkv6Hmga/jgIJcbiAgICAgKiBAZnVuY3Rpb24gU2VjdXJpdHlNYW5hZ2VyLmRlc3Ryb3lBbGxDcmVkZW50aWFsc1xuICAgICAqL1xuICAgIHN0YXRpYyBkZXN0cm95QWxsQ3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXJ2ZXJzID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24g5riF56m65Luk54mM5L+h5oGv44CCXG4gICAgICogQGZ1bmN0aW9uIFNlY3VyaXR5TWFuYWdlci5kZXN0cm95VG9rZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gaXBvcnRhbCDpppbpobXlnLDlnYAs5aaC77yaaHR0cDovL2xvY2FsaG9zdDo4MDkyL2lwb3J0YWwuXG4gICAgICovXG4gICAgc3RhdGljIGRlc3Ryb3lUb2tlbih1cmwpIHtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9tYWluID0gdGhpcy5fZ2V0VG9rZW5TdG9yYWdlS2V5KHVybCk7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdGhpcy50b2tlbnMgfHwge307XG4gICAgICAgIGlmICh0aGlzLnRva2Vuc1tkb21haW5dKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy50b2tlbnNbZG9tYWluXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiDmuIXnqbrmnI3liqHmjojmnYPnoIHjgIJcbiAgICAgKiBAZnVuY3Rpb24gU2VjdXJpdHlNYW5hZ2VyLmRlc3Ryb3lLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gaVNlcnZlciDpppbpobXlnLDlnYAs5aaC77yaaHR0cDovL2xvY2FsaG9zdDo4MDkwL2lzZXJ2ZXLjgIJcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzdHJveUtleSh1cmwpIHtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtleXMgPSB0aGlzLmtleXMgfHwge307XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLl9nZXRVcmxSZXN0U3RyaW5nKHVybCkgfHwgdXJsO1xuICAgICAgICBpZiAodGhpcy5rZXlzW2tleV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmtleXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiDmnI3liqFVUkzov73liqDmjojmnYPkv6Hmga/vvIzmjojmnYPkv6Hmga/pnIDlhYjpgJrov4dTZWN1cml0eU1hbmFnZXIucmVnaXN0ZXJLZXnmiJZTZWN1cml0eU1hbmFnZXIucmVnaXN0ZXJUb2tlbuazqOWGjOOAglxuICAgICAqIEB2ZXJzaW9uIDEwLjEuMlxuICAgICAqIEBmdW5jdGlvbiBTZWN1cml0eU1hbmFnZXIuYXBwZW5kQ3JlZGVudGlhbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSDmnI3liqFVUkxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSDnu5HlrprkuoZ0b2tlbuaIluiAhWtleeeahOacjeWKoVVSTFxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBlbmRDcmVkZW50aWFsKHVybCkge1xuICAgICAgICB2YXIgbmV3VXJsID0gdXJsO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFRva2VuKHVybCk7XG4gICAgICAgIHZhciBjcmVkZW50aWFsID0gdmFsdWUgPyBuZXcgQ3JlZGVudGlhbCh2YWx1ZSwgJ3Rva2VuJykgOiBudWxsO1xuXHRcdGlmICghY3JlZGVudGlhbCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEtleSh1cmwpO1xuICAgICAgICAgICAgY3JlZGVudGlhbCA9IHZhbHVlID8gbmV3IENyZWRlbnRpYWwodmFsdWUsICdrZXknKSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAoY3JlZGVudGlhbCkge1xuICAgICAgICAgICAgbmV3VXJsID0gVXRpbC51cmxBcHBlbmQobmV3VXJsLCBjcmVkZW50aWFsLmdldFVybFBhcmFtZXRlcnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1VybDtcbiAgICB9XG5cbiAgICBzdGF0aWMgX29wZW4odXJsLCBuZXdUYWIpIHtcbiAgICAgICAgbmV3VGFiID0gbmV3VGFiICE9IG51bGwgPyBuZXdUYWIgOiB0cnVlO1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IHdpbmRvdy5zY3JlZW4uYXZhaWxXaWR0aCAvIDIgLSB0aGlzLklOTkVSX1dJTkRPV19XSURUSCAvIDI7XG4gICAgICAgIHZhciBvZmZzZXRZID0gd2luZG93LnNjcmVlbi5hdmFpbEhlaWdodCAvIDIgLSB0aGlzLklOTkVSX1dJTkRPV19IRUlHSFQgLyAyO1xuICAgICAgICB2YXIgb3B0aW9ucyA9XG4gICAgICAgICAgICAnaGVpZ2h0PScgK1xuICAgICAgICAgICAgdGhpcy5JTk5FUl9XSU5ET1dfSEVJR0hUICtcbiAgICAgICAgICAgICcsIHdpZHRoPScgK1xuICAgICAgICAgICAgdGhpcy5JTk5FUl9XSU5ET1dfV0lEVEggK1xuICAgICAgICAgICAgJyx0b3A9JyArXG4gICAgICAgICAgICBvZmZzZXRZICtcbiAgICAgICAgICAgICcsIGxlZnQ9JyArXG4gICAgICAgICAgICBvZmZzZXRYICtcbiAgICAgICAgICAgICcsdG9vbGJhcj1ubywgbWVudWJhcj1ubywgc2Nyb2xsYmFycz1ubywgcmVzaXphYmxlPW5vLCBsb2NhdGlvbj1ubywgc3RhdHVzPW5vJztcbiAgICAgICAgaWYgKG5ld1RhYikge1xuICAgICAgICAgICAgd2luZG93Lm9wZW4odXJsLCAnbG9naW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKHVybCwgJ2xvZ2luJywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFRva2VuU3RvcmFnZUtleSh1cmwpIHtcbiAgICAgICAgdmFyIHBhdHRlbiA9IC8oLio/KTpcXC9cXC8oW15cXC9dKykvaTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHVybC5tYXRjaChwYXR0ZW4pO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0VXJsUmVzdFN0cmluZyh1cmwpIHtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFyIHBhdHRlbiA9IC9odHRwOlxcL1xcLyguKlxcL3Jlc3QpL2k7XG4gICAgICAgIHZhciBwYXR0ZW4gPSAvKGh0dHB8aHR0cHMpOlxcL1xcLyguKlxcL3Jlc3QpL2k7XG4gICAgICAgIHZhciByZXN1bHQgPSB1cmwubWF0Y2gocGF0dGVuKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICB9XG59XG5TZWN1cml0eU1hbmFnZXIuSU5ORVJfV0lORE9XX1dJRFRIID0gNjAwO1xuU2VjdXJpdHlNYW5hZ2VyLklOTkVSX1dJTkRPV19IRUlHSFQgPSA2MDA7XG5TZWN1cml0eU1hbmFnZXIuU1NPID0gJ2h0dHBzOi8vc3NvLnN1cGVybWFwLmNvbSc7XG5TZWN1cml0eU1hbmFnZXIuT05MSU5FID0gJ2h0dHBzOi8vd3d3LnN1cGVybWFwb2wuY29tJztcbiIsIi8qIENvcHlyaWdodMKpIDIwMDAgLSAyMDIyIFN1cGVyTWFwIFNvZnR3YXJlIENvLkx0ZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cblxuLyoqXG4gKiBAY2xhc3MgIFNpemVcbiAqIEBkZXByZWNhdGVkY2xhc3MgU3VwZXJNYXAuU2l6ZVxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBTdHlsZVxuICogQGNsYXNzZGVzYyDmraTnsbvmj4/nu5jkuIDlr7npq5jlrr3lgLznmoTlrp7kvovjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdz0wLjBdIC0g5a695bqm44CCXG4gKiBAcGFyYW0ge251bWJlcn0gW2g9MC4wXSAtIOmrmOW6puOAglxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgc2l6ZSA9IG5ldyBTaXplKDMxLDQ2KTtcbiAqIEB1c2FnZVxuICovXG5leHBvcnQgY2xhc3MgU2l6ZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih3LCBoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFtTaXplLnByb3RvdHlwZS53PTAuMF1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOWuveW6puOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53ID0gdyA/IHBhcnNlRmxvYXQodykgOiAwLjA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gW1NpemUucHJvdG90eXBlLmg9MC4wXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g6auY5bqm44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmggPSB3ID8gcGFyc2VGbG9hdChoKSA6IDAuMDtcbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gXCJTdXBlck1hcC5TaXplXCI7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU2l6ZS5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgKiBAZGVzY3JpcHRpb24g6L+U5Zue5a2X56ym5Liy5b2i5byP44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgc2l6ZSA9IG5ldyBTaXplKDEwLDUpO1xuICAgICAqIHZhciBzdHIgPSBzaXplLnRvU3RyaW5nKCk7XG4gICAgICogQHJldHVybnMge3N0cmluZ30g5L6L5aaC77yaXCJ3PTEwLGg9NVwi44CCXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCJ3PVwiICsgdGhpcy53ICsgXCIsaD1cIiArIHRoaXMuaCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU2l6ZS5wcm90b3R5cGUuY2xvbmVcbiAgICAgKiBAZGVzY3JpcHRpb24g5YWL6ZqG5b2T5YmNc2l6ZeWvueixoeOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHNpemUgPSBuZXcgU2l6ZSgzMSw0Nik7XG4gICAgICogdmFyIHNpemUyID0gc2l6ZS5jbG9uZSgpO1xuICAgICAqIEByZXR1cm5zIHtTaXplfSAg5paw55qE5LiO5b2T5YmNIHNpemUg5a+56LGh5pyJ55u45ZCM5a6944CB6auY55qEIFNpemUg5a+56LGh44CCXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLncsIHRoaXMuaCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBTaXplLnByb3RvdHlwZS5lcXVhbHNcbiAgICAgKiBAZGVzY3JpcHRpb24g5q+U6L6D5Lik5LiqIHNpemUg5a+56LGh5piv5ZCm55u4562J44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgc2l6ZSA9IG5ldyBTaXplKDMxLDQ2KTtcbiAgICAgKiB2YXIgc2l6ZTIgPSBuZXcgU2l6ZSgzMSw0Nik7XG4gICAgICogdmFyIGlzRXF1YWxzID0gc2l6ZS5lcXVhbHMoc2l6ZTIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTaXplfSBzeiAtIOeUqOS6juavlOi+g+ebuOetieeahCBTaXplIOWvueixoeOAglxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDkvKDlhaXnmoQgc2l6ZSDlkozlvZPliY0gc2l6ZSDpq5jlrr3nm7jnrYnvvIzms6jmhI/vvJrlpoLmnpzkvKDlhaXnmoQgc2l6ZSDkuLrnqbrliJnov5Tlm54gZmFsc2XjgIJcbiAgICAgKlxuICAgICAqL1xuICAgIGVxdWFscyhzeikge1xuICAgICAgICB2YXIgZXF1YWxzID0gZmFsc2U7XG4gICAgICAgIGlmIChzeiAhPSBudWxsKSB7XG4gICAgICAgICAgICBlcXVhbHMgPSAoKHRoaXMudyA9PT0gc3oudyAmJiB0aGlzLmggPT09IHN6LmgpIHx8XG4gICAgICAgICAgICAgICAgKGlzTmFOKHRoaXMudykgJiYgaXNOYU4odGhpcy5oKSAmJiBpc05hTihzei53KSAmJiBpc05hTihzei5oKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcXVhbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gU2l6ZS5wcm90b3R5cGUuZGVzdHJveVxuICAgICAqIEBkZXNjcmlwdGlvbiDplIDmr4HmraTlr7nosaHjgILplIDmr4HlkI7mraTlr7nosaHnmoTmiYDmnInlsZ7mgKfkuLogbnVsbO+8jOiAjOS4jeaYr+WIneWni+WAvOOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHNpemUgPSBuZXcgU2l6ZSgzMSw0Nik7XG4gICAgICogc2l6ZS5kZXN0cm95KCk7XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy53ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oID0gbnVsbDtcbiAgICB9XG59XG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG5cbi8qKlxuICogQGNsYXNzIFBpeGVsXG4gKiBAZGVwcmVjYXRlZGNsYXNzIFN1cGVyTWFwLlBpeGVsXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIEdlb21ldHJ5XG4gKiBAY2xhc3NkZXNjIOeUqCB4LHkg5Z2Q5qCH5o+P57uY5bGP5bmV5Z2Q5qCH77yI5YOP57Sg54K577yJ44CCXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MC4wXSAtIHgg5Z2Q5qCH44CCXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MC4wXSAtIHkg5Z2Q5qCH44CCXG4gKiBAcGFyYW0ge1BpeGVsLk1vZGV9IFttb2RlPVBpeGVsLk1vZGUuTGVmdFRvcF0gLSDlnZDmoIfmqKHlvI/jgIJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy/ljZXni6zliJvlu7rkuIDkuKrlr7nosaFcbiAqIHZhciBwaXhjZWwgPSBuZXcgUGl4ZWwoMTAwLDUwKTtcbiAqXG4gKiAvL+S+neaNriBzaXplIOWIm+W7ulxuICogIHZhciBzaXplID0gbmV3IFNpemUoMjEsMjUpO1xuICogIHZhciBvZmZzZXQgPSBuZXcgUGl4ZWwoLShzaXplLncvMiksIC1zaXplLmgpO1xuICogQHVzYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBQaXhlbCB7XG4gIGNvbnN0cnVjdG9yKHgsIHksIG1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFtQaXhlbC5wcm90b3R5cGUueD0wLjBdXG4gICAgICogQGRlc2NyaXB0aW9uIHgg5Z2Q5qCH44CCXG4gICAgICovXG4gICAgdGhpcy54ID0geCA/IHBhcnNlRmxvYXQoeCkgOiAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFtQaXhlbC5wcm90b3R5cGUueT0wLjBdXG4gICAgICogQGRlc2NyaXB0aW9uIHkg5Z2Q5qCH44CCXG4gICAgICovXG4gICAgdGhpcy55ID0geSA/IHBhcnNlRmxvYXQoeSkgOiAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtQaXhlbC5Nb2RlfSBbUGl4ZWwucHJvdG90eXBlLm1vZGU9UGl4ZWwuTW9kZS5MZWZ0VG9wXVxuICAgICAqIEBkZXNjcmlwdGlvbiDlnZDmoIfmqKHlvI/vvIzmnInlt6bkuIrjgIHlj7PkuIrjgIHlj7PkuIvjgIHlt6bkuIvov5nlh6Dnp43mqKHlvI/vvIzliIbliKvooajnpLrnm7jlr7nkuo7lt6bkuIrop5LjgIHlj7PkuIrop5LjgIHlj7PkuIvop5LjgIHlt6bkuIvop5LnmoTlnZDmoIfjgIJcbiAgICAgKi9cbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMuQ0xBU1NfTkFNRSA9ICdTdXBlck1hcC5QaXhlbCc7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIFBpeGVsLnByb3RvdHlwZS50b1N0cmluZ1xuICAgKiBAZGVzY3JpcHRpb24g6L+U5Zue5q2k5a+56LGh55qE5a2X56ym5Liy5b2i5byP44CCXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBwaXhjZWwgPSBuZXcgUGl4ZWwoMTAwLDUwKTtcbiAgICogdmFyIHN0ciA9IHBpeGNlbC50b1N0cmluZygpO1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSDkvovlpoI6IFwieD0yMDAuNCx5PTI0Mi4yXCJcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAneD0nICsgdGhpcy54ICsgJyx5PScgKyB0aGlzLnk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIFBpeGVsLnByb3RvdHlwZS5jbG9uZVxuICAgKiBAZGVzY3JpcHRpb24g5YWL6ZqG5b2T5YmN55qEIHBpeGVsIOWvueixoeOAglxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcGl4Y2VsID0gbmV3IFBpeGVsKDEwMCw1MCk7XG4gICAqIHZhciBwaXhjZWwyID0gcGl4Y2VsLmNsb25lKCk7XG4gICAqIEByZXR1cm5zIHtQaXhlbH0g5paw55qE5LiO5b2T5YmNIHBpeGVsIOWvueixoeacieebuOWQjCB444CBeSDlnZDmoIfnmoQgcGl4ZWwg5a+56LGh44CCXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBpeGVsKHRoaXMueCwgdGhpcy55LCB0aGlzLm1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBQaXhlbC5wcm90b3R5cGUuZXF1YWxzXG4gICAqIEBkZXNjcmlwdGlvbiDmr5TovoPkuKQgcGl4ZWwg5piv5ZCm55u4562J44CCXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBwaXhjZWwgPSBuZXcgUGl4ZWwoMTAwLDUwKTtcbiAgICogdmFyIHBpeGNlbDIgPSBuZXcgUGl4ZWwoMTAwLDUwKTtcbiAgICogdmFyIGlzRXF1YWxzID0gcGl4Y2VsLmVxdWFscyhwaXhjZWwyKTtcbiAgICpcbiAgICogQHBhcmFtIHtQaXhlbH0gcHggLSDnlKjkuo7mr5TovoPnm7jnrYnnmoQgcGl4ZWwg5a+56LGh44CCXG4gICAqIEByZXR1cm5zIHtib29sZWFufSDlpoLmnpzkvKDlhaXnmoTlg4/ntKDngrnlkozlvZPliY3lg4/ntKDngrnnm7jlkIzov5Tlm54gdHJ1Ze+8jOWmguaenOS4jeWQjOaIluS8oOWFpeWPguaVsOS4uiBOVUxMIOWImei/lOWbniBmYWxzZeOAglxuICAgKi9cbiAgZXF1YWxzKHB4KSB7XG4gICAgdmFyIGVxdWFscyA9IGZhbHNlO1xuICAgIGlmIChweCAhPSBudWxsKSB7XG4gICAgICBlcXVhbHMgPSAodGhpcy54ID09IHB4LnggJiYgdGhpcy55ID09IHB4LnkpIHx8IChpc05hTih0aGlzLngpICYmIGlzTmFOKHRoaXMueSkgJiYgaXNOYU4ocHgueCkgJiYgaXNOYU4ocHgueSkpO1xuICAgIH1cbiAgICByZXR1cm4gZXF1YWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBQaXhlbC5wcm90b3R5cGUuZGlzdGFuY2VUb1xuICAgKiBAZGVzY3JpcHRpb24g6L+U5Zue5Lik5LiqIHBpeGVsIOeahOi3neemu+OAglxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcGl4Y2VsID0gbmV3IFBpeGVsKDEwMCw1MCk7XG4gICAqIHZhciBwaXhjZWwyID0gbmV3IFBpeGVsKDExMCwzMCk7XG4gICAqIHZhciBkaXN0YW5jZSA9IHBpeGNlbC5kaXN0YW5jZVRvKHBpeGNlbDIpO1xuICAgKlxuICAgKiBAcGFyYW0ge1BpeGVsfSBweCAtIOmcgOimgeiuoeeul+eahCBwaXhlbOOAglxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSDkvZzkuLrlj4LmlbDkvKDlhaXnmoTlg4/ntKDkuI7lvZPliY3lg4/ntKDngrnnmoTot53nprvjgIJcbiAgICovXG4gIGRpc3RhbmNlVG8ocHgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCAtIHB4LngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gcHgueSwgMikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBQaXhlbC5wcm90b3R5cGUuYWRkXG4gICAqIEBkZXNjcmlwdGlvbiDlnKjljp/mnaXlg4/ntKDlnZDmoIfln7rnoYDkuIrvvIx4IOWAvOWKoOS4iuS8oOWFpeeahCB4IOWPguaVsO+8jHkg5YC85Yqg5LiK5Lyg5YWl55qEIHkg5Y+C5pWw44CCXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBwaXhjZWwgPSBuZXcgUGl4ZWwoMTAwLDUwKTtcbiAgICogLy9waXhjZWwy5piv5paw55qE5a+56LGhXG4gICAqIHZhciBwaXhjZWwyID0gcGl4Y2VsLmFkZCgyMCwzMCk7XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0g5Lyg5YWl55qEIHgg5YC844CCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0g5Lyg5YWl55qEIHkg5YC844CCXG4gICAqIEByZXR1cm5zIHtQaXhlbH0g5paw55qEIHBpeGVsIOWvueixoe+8jOivpSBwaXhlbCDmmK/nlLHlvZPliY3nmoQgcGl4ZWwg5LiO5Lyg5YWl55qEIHjvvIx5IOebuOWKoOW+l+WIsOOAglxuICAgKi9cbiAgYWRkKHgsIHkpIHtcbiAgICBpZiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGl4ZWwuYWRkIGNhbm5vdCByZWNlaXZlIG51bGwgdmFsdWVzJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUGl4ZWwodGhpcy54ICsgeCwgdGhpcy55ICsgeSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIFBpeGVsLnByb3RvdHlwZS5vZmZzZXRcbiAgICogQGRlc2NyaXB0aW9uIOmAmui/h+S8oOWFpeeahCB7QGxpbmsgUGl4ZWx9IOWPguaVsOWvueWOn+Wxj+W5leWdkOagh+i/m+ihjOWBj+enu+OAglxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcGl4Y2VsID0gbmV3IFBpeGVsKDEwMCw1MCk7XG4gICAqIHZhciBwaXhjZWwyID0gbmV3IFBpeGVsKDEzMCwyMCk7XG4gICAqIC8vcGl4Y2VsMyDmmK/mlrDnmoTlr7nosaFcbiAgICogdmFyIHBpeGNlbDMgPSBwaXhjZWwub2Zmc2V0KHBpeGNlbDIpO1xuICAgKlxuICAgKiBAcGFyYW0ge1BpeGVsfSBweCAtIOS8oOWFpeeahCB7QGxpbmsgUGl4ZWx9IOWvueixoeOAglxuICAgKiBAcmV0dXJucyB7UGl4ZWx9IOaWsOeahCBwaXhlbO+8jOivpSBwaXhlbCDmmK/nlLHlvZPliY3nmoQgcGl4ZWwg5a+56LGh55qEIHjvvIx5IOWAvOS4juS8oOWFpeeahCBQaXhlbCDlr7nosaHnmoQgeO+8jHkg5YC855u45Yqg5b6X5Yiw44CCXG4gICAqL1xuICBvZmZzZXQocHgpIHtcbiAgICB2YXIgbmV3UHggPSB0aGlzLmNsb25lKCk7XG4gICAgaWYgKHB4KSB7XG4gICAgICBuZXdQeCA9IHRoaXMuYWRkKHB4LngsIHB4LnkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UHg7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGZ1bmN0aW9uIFBpeGVsLnByb3RvdHlwZS5kZXN0cm95XG4gICAqIEBkZXNjcmlwdGlvbiDplIDmr4HmraTlr7nosaHjgILplIDmr4HlkI7mraTlr7nosaHnmoTmiYDmnInlsZ7mgKfkuLogbnVsbO+8jOiAjOS4jeaYr+WIneWni+WAvOOAglxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcGl4Y2VsID0gbmV3IFBpeGVsKDEwMCw1MCk7XG4gICAqIHBpeGNlbC5kZXN0cm95KCk7XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMueCA9IG51bGw7XG4gICAgdGhpcy55ID0gbnVsbDtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICB9XG59XG4vKipcbiAqIEBlbnVtIE1vZGVcbiAqIEBtZW1iZXJPZiBQaXhlbFxuICogQHJlYWRvbmx5XG4gKiBAZGVzY3JpcHRpb24g5qih5byP44CCXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5QaXhlbC5Nb2RlID0ge1xuICAvKiog5bem5LiK5qih5byP44CCKi9cbiAgTGVmdFRvcDogJ2xlZnR0b3AnLFxuICAvKiog5Y+z5LiK5qih5byP44CCICovXG4gIFJpZ2h0VG9wOiAncmlnaHR0b3AnLFxuICAvKiog5Y+z5LiL5qih5byP44CCICovXG4gIFJpZ2h0Qm90dG9tOiAncmlnaHRib3R0b20nLFxuICAvKiog5bem5LiL5qih5byP44CCICovXG4gIExlZnRCb3R0b206ICdsZWZ0Ym90dG9tJ1xufTtcbiIsIi8qIENvcHlyaWdodMKpIDIwMDAgLSAyMDIyIFN1cGVyTWFwIFNvZnR3YXJlIENvLkx0ZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cbmltcG9ydCB7VXRpbH0gZnJvbSAnLi9VdGlsJztcblxuLyoqXG4gKiBAY2xhc3MgTG9uTGF0XG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIEdlb21ldHJ5XG4gKiBAY2xhc3NkZXNjICDov5nkuKrnsbvnlKjmnaXooajnpLrnu4/luqblkoznuqzluqblr7njgIJcbiAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbbG9uPTAuMF0gLSDlnLDlm77ljZXkvY3kuIrnmoQgWCDovbTlnZDmoIfmiJbogIXmqKrnurXlnZDmoIfnu4TmiJDnmoTmlbDnu4TvvJvlpoLmnpzlnLDlm77mmK/lnLDnkIbmipXlvbHvvIzliJnmraTlgLzmmK/nu4/luqbvvIzlkKbliJnvvIzmraTlgLzmmK/lnLDlm77lnLDnkIbkvY3nva7nmoQgeCDlnZDmoIfjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGF0PTAuMF0gLSDlnLDlm77ljZXkvY3kuIrnmoQgWSDovbTlnZDmoIfvvIzlpoLmnpzlnLDlm77mmK/lnLDnkIbmipXlvbHvvIzliJnmraTlgLzmmK/nuqzluqbvvIzlkKbliJnvvIzmraTlgLzmmK/lnLDlm77lnLDnkIbkvY3nva7nmoQgeSDlnZDmoIfjgIJcbiAqIEBleGFtcGxlXG4gKiB2YXIgbG9uTGF0ID0gbmV3IExvbkxhdCgzMCw0NSk7XG4gKiBAdXNhZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIExvbkxhdCB7XG5cblxuICAgIGNvbnN0cnVjdG9yKGxvbiwgbGF0KSB7XG4gICAgICAgIGlmIChVdGlsLmlzQXJyYXkobG9uKSkge1xuICAgICAgICAgICAgbGF0ID0gbG9uWzFdO1xuICAgICAgICAgICAgbG9uID0gbG9uWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFtMb25MYXQucHJvdG90eXBlLmxvbj0wLjBdXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDlnLDlm77nmoTljZXkvY3nmoQgWCDovbTvvIjmqKrovbTvvInlnZDmoIfjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9uID0gbG9uID8gVXRpbC50b0Zsb2F0KGxvbikgOiAwLjA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gW0xvbkxhdC5wcm90b3R5cGUubGF0PTAuMF1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOWcsOWbvueahOWNleS9jeeahCBZIOi9tO+8iOe6tei9tO+8ieWdkOagh+OAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXQgPSBsYXQgPyBVdGlsLnRvRmxvYXQobGF0KSA6IDAuMDtcbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gXCJTdXBlck1hcC5Mb25MYXRcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gTG9uTGF0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAqIEBkZXNjcmlwdGlvbiDov5Tlm57mraTlr7nosaHnmoTlrZfnrKbkuLLlvaLlvI9cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsb25MYXQgPSBuZXcgTG9uTGF0KDEwMCw1MCk7XG4gICAgICogdmFyIHN0ciA9IGxvbkxhdC50b1N0cmluZygpO1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOS+i+WmgjogXCJsb249MTAwLGxhdD01MFwiXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCJsb249XCIgKyB0aGlzLmxvbiArIFwiLGxhdD1cIiArIHRoaXMubGF0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gTG9uTGF0LnByb3RvdHlwZS50b1Nob3J0U3RyaW5nXG4gICAgICogQGRlc2NyaXB0aW9uIOWwhue7j+W6pue6rOW6pui9rOaNouaIkOeugOWNleWtl+espuS4suOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxvbkxhdCA9IG5ldyBMb25MYXQoMTAwLDUwKTtcbiAgICAgKiB2YXIgc3RyID0gbG9uTGF0LnRvU2hvcnRTdHJpbmcoKTtcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSDlpITnkIblkI7nmoTnu4/nuqzluqblrZfnrKbkuLLjgILkvovlpoLvvJpcIjEwMCw1MFwiXG4gICAgICovXG4gICAgdG9TaG9ydFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvbiArIFwiLFwiICsgdGhpcy5sYXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBMb25MYXQucHJvdG90eXBlLmNsb25lXG4gICAgICogQGRlc2NyaXB0aW9uIOWkjeWItuWdkOagh+Wvueixoe+8jOW5tui/lOWbnuWkjeWItuWQjueahOaWsOWvueixoeOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxvbkxhdDEgPSBuZXcgTG9uTGF0KDEwMCw1MCk7XG4gICAgICogdmFyIGxvbkxhdDIgPSBsb25MYXQxLmNsb25lKCk7XG4gICAgICogQHJldHVybnMge0xvbkxhdH0gIOebuOWQjOWdkOagh+WAvOeahOaWsOeahOWdkOagh+WvueixoeOAglxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbkxhdCh0aGlzLmxvbiwgdGhpcy5sYXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBMb25MYXQucHJvdG90eXBlLmFkZFxuICAgICAqIEBkZXNjcmlwdGlvbiDlnKjlt7LmnInlnZDmoIflr7nosaHnmoTnu4/nuqzluqbln7rnoYDkuIrliqDkuIrmlrDnmoTlnZDmoIfnu4/nuqzluqbvvIzlubbov5Tlm57mlrDnmoTlnZDmoIflr7nosaHjgIJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsb25MYXQxID0gbmV3IExvbkxhdCgxMDAsNTApO1xuICAgICAqIC8vbG9uTGF0MiDmmK/mlrDnmoTlr7nosaFcbiAgICAgKiB2YXIgbG9uTGF0MiA9IGxvbkxhdDEuYWRkKDEwMCw1MCk7XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvbiAtIOe7j+W6puWPguaVsOOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgLSDnuqzluqblj4LmlbDjgIJcbiAgICAgKiBAcmV0dXJucyB7TG9uTGF0fSDmlrDnmoQgTG9uTGF0IOWvueixoe+8jOatpOWvueixoeeahOe7j+e6rOW6puaYr+eUseS8oOWFpeeahOe7j+e6rOW6puS4juW9k+WJjeeahOe7j+e6rOW6puebuOWKoOaJgOW+l+OAglxuICAgICAqL1xuICAgIGFkZChsb24sIGxhdCkge1xuICAgICAgICBpZiAoKGxvbiA9PSBudWxsKSB8fCAobGF0ID09IG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMb25MYXQuYWRkIGNhbm5vdCByZWNlaXZlIG51bGwgdmFsdWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMb25MYXQodGhpcy5sb24gKyBVdGlsLnRvRmxvYXQobG9uKSxcbiAgICAgICAgICAgIHRoaXMubGF0ICsgVXRpbC50b0Zsb2F0KGxhdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBMb25MYXQucHJvdG90eXBlLmVxdWFsc1xuICAgICAqIEBkZXNjcmlwdGlvbiDliKTmlq3kuKTkuKrlnZDmoIflr7nosaHmmK/lkKbnm7jnrYnjgIJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsb25MYXQxID0gbmV3IExvbkxhdCgxMDAsNTApO1xuICAgICAqIHZhciBsb25MYXQyID0gbmV3IExvbkxhdCgxMDAsNTApO1xuICAgICAqIHZhciBpc0VxdWFscyA9IGxvbkxhdDEuZXF1YWxzKGxvbkxhdDIpO1xuICAgICAqIEBwYXJhbSB7TG9uTGF0fSBsbCAtIOmcgOimgei/m+ihjOavlOi+g+eahOWdkOagh+WvueixoeOAglxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDlpoLmnpxMb25MYXTlr7nosaHnmoTnu4/nuqzluqblkozkvKDlhaXnmoTnu4/nuqzluqbkuIDoh7TliJnov5Tlm550cnVlLOS4jeS4gFxuICAgICAqICAgICAg6Ie05oiW5Lyg5YWl55qEbGzlj4LmlbDkuLpOVUxM5YiZ6L+U5ZueZmFsc2XjgIJcbiAgICAgKi9cbiAgICBlcXVhbHMobGwpIHtcbiAgICAgICAgdmFyIGVxdWFscyA9IGZhbHNlO1xuICAgICAgICBpZiAobGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXF1YWxzID0gKCh0aGlzLmxvbiA9PT0gbGwubG9uICYmIHRoaXMubGF0ID09PSBsbC5sYXQpIHx8XG4gICAgICAgICAgICAgICAgKGlzTmFOKHRoaXMubG9uKSAmJiBpc05hTih0aGlzLmxhdCkgJiYgaXNOYU4obGwubG9uKSAmJiBpc05hTihsbC5sYXQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVxdWFscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gTG9uTGF0LnByb3RvdHlwZS53cmFwRGF0ZUxpbmVcbiAgICAgKiBAZGVzY3JpcHRpb24g6YCa6L+H5Lyg5YWl55qE6IyD5Zu05a+56LGh5a+55Z2Q5qCH5a+56LGh6L2s5o2i5Yiw6K+l6IyD5Zu05YaF44CCXG4gICAgICog5aaC5p6c57uP5bqm5bCP5LqO57uZ5a6a6IyD5Zu05pyA5bCP57K+5bqm77yM5YiZ5Zyo5Y6f57uP5bqm5Z+656GA5LiK5Yqg5LiK6IyD5Zu05a695bqm77yM55u05Yiw57K+5bqm5Zyo6IyD5Zu05YaF5Li65q2i77yM5aaC5p6c57uP5bqm5aSn5LqO57uZ5a6a6IyD5Zu05YiZ5Zyo5Y6f57uP5bqm5Z+656GA5LiK5YeP5Y676IyD5Zu05a695bqm44CCXG4gICAgICog5Y2z5oyH5bCG5LiN5Zyo57uP5bqm6IyD5Zu05YaF55qE5Z2Q5qCH6L2s5o2i5Yiw6IyD5Zu05Lul5YaF77yI5Y+q5Lya6L2s5o2iIGxvbu+8jOS4jeS8mui9rOaNoiBsYXTvvIzkuLvopoHnlKjkuo7ovaznp7vliLDml6XnlYznur/ku6XlhoXvvInjgIJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsb25MYXQxID0gbmV3IExvbkxhdCg0MjAsNTApO1xuICAgICAqIHZhciBsb25MYXQyID0gbG9uTGF0MS53cmFwRGF0ZUxpbmUoXG4gICAgICogICAgICBuZXcgQm91bmRzKC0xODAsLTkwLDE4MCw5MClcbiAgICAgKiAgKTtcbiAgICAgKiBAcGFyYW0ge0JvdW5kc30gbWF4RXh0ZW50IC0g5pyA5aSn6L6555WM55qE6IyD5Zu044CCXG4gICAgICogQHJldHVybnMge0xvbkxhdH0g5bCG5Z2Q5qCH6L2s5o2i5Yiw6IyD5Zu05a+56LGh5Lul5YaF77yM5bm26L+U5Zue5paw55qE5Z2Q5qCH44CCXG4gICAgICovXG4gICAgd3JhcERhdGVMaW5lKG1heEV4dGVudCkge1xuXG4gICAgICAgIHZhciBuZXdMb25MYXQgPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKG1heEV4dGVudCkge1xuICAgICAgICAgICAgLy9zaGlmdCByaWdodD9cbiAgICAgICAgICAgIHdoaWxlIChuZXdMb25MYXQubG9uIDwgbWF4RXh0ZW50LmxlZnQpIHtcbiAgICAgICAgICAgICAgICBuZXdMb25MYXQubG9uICs9IG1heEV4dGVudC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3NoaWZ0IGxlZnQ/XG4gICAgICAgICAgICB3aGlsZSAobmV3TG9uTGF0LmxvbiA+IG1heEV4dGVudC5yaWdodCkge1xuICAgICAgICAgICAgICAgIG5ld0xvbkxhdC5sb24gLT0gbWF4RXh0ZW50LmdldFdpZHRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3TG9uTGF0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIExvbkxhdC5wcm90b3R5cGUuZGVzdHJveVxuICAgICAqIEBkZXNjcmlwdGlvbiDplIDmr4HmraTlr7nosaHjgIJcbiAgICAgKiDplIDmr4HlkI7mraTlr7nosaHnmoTmiYDmnInlsZ7mgKfkuLogbnVsbO+8jOiAjOS4jeaYr+WIneWni+WAvOOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxvbkxhdCA9IG5ldyBMb25MYXQoMTAwLDUwKTtcbiAgICAgKiBsb25MYXQuZGVzdHJveSgpO1xuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubG9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBMb25MYXQuZnJvbVN0cmluZ1xuICAgICAqIEBkZXNjcmlwdGlvbiDpgJrov4flrZfnrKbkuLLnlJ/miJDkuIDkuKoge0BsaW5rIExvbkxhdH0g5a+56LGh44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgc3RyID0gXCIxMDAsNTBcIjtcbiAgICAgKiB2YXIgbG9uTGF0ID0gTG9uTGF0LmZyb21TdHJpbmcoc3RyKTtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0g5a2X56ym5Liy55qE5qC85byP77yaTG9uK1wiLFwiK0xhdOOAguWmgu+8mlwiMTAwLDUwXCLjgIJcbiAgICAgKiBAcmV0dXJucyB7TG9uTGF0fSB7QGxpbmsgTG9uTGF0fSDlr7nosaHjgIJcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIHBhaXIgPSBzdHIuc3BsaXQoXCIsXCIpO1xuICAgICAgICByZXR1cm4gbmV3IExvbkxhdChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gTG9uTGF0LmZyb21BcnJheVxuICAgICAqIEBkZXNjcmlwdGlvbiDpgJrov4fmlbDnu4TnlJ/miJDkuIDkuKoge0BsaW5rIExvbkxhdH0g5a+56LGh44CCXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyIC0g5pWw57uE55qE5qC85byP77yM6ZW/5bqm5Y+q6IO95Li6MizvvJpbTG9uLExhdF3jgILlpoLvvJpbNSwtNDJd44CCXG4gICAgICogQHJldHVybnMge0xvbkxhdH0ge0BsaW5rIExvbkxhdH0g5a+56LGh44CCXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BcnJheShhcnIpIHtcbiAgICAgICAgdmFyIGdvdEFyciA9IFV0aWwuaXNBcnJheShhcnIpLFxuICAgICAgICAgICAgbG9uID0gZ290QXJyICYmIGFyclswXSxcbiAgICAgICAgICAgIGxhdCA9IGdvdEFyciAmJiBhcnJbMV07XG4gICAgICAgIHJldHVybiBuZXcgTG9uTGF0KGxvbiwgbGF0KTtcbiAgICB9XG5cblxufVxuXG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG5pbXBvcnQge1NpemV9IGZyb20gJy4vU2l6ZSc7XG5pbXBvcnQge1BpeGVsfSBmcm9tICcuL1BpeGVsJztcbmltcG9ydCB7TG9uTGF0fSBmcm9tICcuL0xvbkxhdCc7XG5pbXBvcnQge1V0aWx9IGZyb20gJy4vVXRpbCc7XG5cbi8qKlxuICogQGNsYXNzIEJvdW5kc1xuICogQGRlcHJlY2F0ZWRjbGFzcyBTdXBlck1hcC5Cb3VuZHNcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgR2VvbWV0cnlcbiAqIEBjbGFzc2Rlc2Mg6KGo56S66L6555WM57G75a6e5L6L44CC5L2/55SoIGJvdW5kcyDkuYvliY3pnIDopoHorr7nva4gbGVmdO+8jGJvdHRvbe+8jHJpZ2h077yMdG9wIOWbm+S4quWxnuaAp++8jOi/meS6m+WxnuaAp+eahOWIneWni+WAvOS4uiBudWxs44CCXG4gKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW2xlZnRdIC0g5aaC5p6c5pivbnVtYmVy77yM5YiZ6KGo56S65bem6L6555WM77yM5rOo5oSP6ICD6JmR5a695bqm77yM55CG6K665LiK5bCP5LqOIHJpZ2h0IOWAvOOAguWmguaenOaYr+aVsOe7hO+8jOWImeihqOekuiBbbGVmdCwgYm90dG9tLCByaWdodCwgdG9wXSDlt6bkuIvlj7PkuIrnu4TmiJDnmoTmlbDnu4TjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYm90dG9tXSAtIOS4i+i+ueeVjOOAguiAg+iZkemrmOW6pu+8jOeQhuiuuuS4iuWwj+S6jiB0b3Ag5YC844CCXG4gKiBAcGFyYW0ge251bWJlcn0gW3JpZ2h0XSAtIOWPs+i+ueeVjOOAglxuICogQHBhcmFtIHtudW1iZXJ9IFt0b3BdIC0g5LiK6L6555WM44CCXG4gKiBAZXhhbXBsZVxuICogdmFyIGJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAqIGJvdW5kcy5leHRlbmQobmV3IExvbkxhdCg0LDUpKTtcbiAqIGJvdW5kcy5leHRlbmQobmV3IExvbkxhdCg1LDYpKTtcbiAqIGJvdW5kcy50b0JCT1goKTsgLy8gcmV0dXJucyA0LDUsNSw2XG4gKiBAdXNhZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIEJvdW5kcyB7XG5cblxuICAgIGNvbnN0cnVjdG9yKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcCkge1xuICAgICAgICBpZiAoVXRpbC5pc0FycmF5KGxlZnQpKSB7XG4gICAgICAgICAgICB0b3AgPSBsZWZ0WzNdO1xuICAgICAgICAgICAgcmlnaHQgPSBsZWZ0WzJdO1xuICAgICAgICAgICAgYm90dG9tID0gbGVmdFsxXTtcbiAgICAgICAgICAgIGxlZnQgPSBsZWZ0WzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IEJvdW5kcy5wcm90b3R5cGUubGVmdFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5pyA5bCP55qE5rC05bmz5Z2Q5qCH57O744CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0ICE9IG51bGwgPyBVdGlsLnRvRmxvYXQobGVmdCkgOiB0aGlzLmxlZnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gQm91bmRzLnByb3RvdHlwZS5ib3R0b21cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOacgOWwj+eahOWeguebtOWdkOagh+ezu+OAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3R0b20gPSBib3R0b20gIT0gbnVsbCA/IFV0aWwudG9GbG9hdChib3R0b20pIDogdGhpcy5ib3R0b207XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gQm91bmRzLnByb3RvdHlwZS5yaWdodFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5pyA5aSn55qE5rC05bmz5Z2Q5qCH57O744CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQgIT0gbnVsbCA/IFV0aWwudG9GbG9hdChyaWdodCkgOiB0aGlzLnJpZ2h0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IEJvdW5kcy5wcm90b3R5cGUudG9wXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDmnIDlpKfnmoTlnoLnm7TlnZDmoIfns7vjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9wID0gdG9wICE9IG51bGwgPyBVdGlsLnRvRmxvYXQodG9wKSA6IHRoaXMudG9wO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtMb25MYXR9IEJvdW5kcy5wcm90b3R5cGUuY2VudGVyTG9uTGF0XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBib3VuZHMg55qE5Zyw5Zu+56m66Ze055qE5Lit5b+D54K544CC55SoIGdldENlbnRlckxvbkxhdCgpIOiOt+W+l+OAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZW50ZXJMb25MYXQgPSBudWxsO1xuICAgICAgICB0aGlzLkNMQVNTX05BTUUgPSBcIlN1cGVyTWFwLkJvdW5kc1wiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLmNsb25lXG4gICAgICogQGRlc2NyaXB0aW9uIOWkjeWItuW9k+WJjSBib3VuZHMg5a+56LGh44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzMSA9IG5ldyBCb3VuZHMoLTE4MCwtOTAsMTgwLDkwKTtcbiAgICAgKiB2YXIgYm91bmRzMiA9IGJvdW5kczEuY2xvbmUoKTtcbiAgICAgKiBAcmV0dXJucyB7Qm91bmRzfSDlhYvpmoblkI7nmoQgYm91bmRz44CCXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRzKHRoaXMubGVmdCwgdGhpcy5ib3R0b20sXG4gICAgICAgICAgICB0aGlzLnJpZ2h0LCB0aGlzLnRvcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEJvdW5kcy5wcm90b3R5cGUuZXF1YWxzXG4gICAgICogQGRlc2NyaXB0aW9uIOWIpOaWreS4pOS4qiBib3VuZHMg5a+56LGh5piv5ZCm55u4562J44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzMSA9IG5ldyBCb3VuZHMoLTE4MCwtOTAsMTgwLDkwKTtcbiAgICAgKiB2YXIgYm91bmRzMiA9IG5ldyBCb3VuZHMoLTE4MCwtOTAsMTgwLDkwKTtcbiAgICAgKiB2YXIgaXNFcXVhbHMgPSBib3VuZHMxLmVxdWFscyhib3VuZHMyKTtcbiAgICAgKiBAcGFyYW0ge0JvdW5kc30gYm91bmRzIC0g6ZyA6KaB6L+b6KGM6K6h6L6D55qEIGJvdW5kc+OAglxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDlpoLmnpwgYm91bmRzIOWvueixoeeahOi+ueWSjOS8oOWFpeeahCBib3VuZHMg5LiA6Ie05YiZ6L+U5ZueIHRydWXvvIzkuI3kuIDoh7TmiJbkvKDlhaXnmoQgYm91bmRzIOWPguaVsOS4uiBOVUxMIOWImei/lOWbniBmYWxzZeOAglxuICAgICAqL1xuICAgIGVxdWFscyhib3VuZHMpIHtcbiAgICAgICAgdmFyIGVxdWFscyA9IGZhbHNlO1xuICAgICAgICBpZiAoYm91bmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVxdWFscyA9ICgodGhpcy5sZWZ0ID09PSBib3VuZHMubGVmdCkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5yaWdodCA9PT0gYm91bmRzLnJpZ2h0KSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnRvcCA9PT0gYm91bmRzLnRvcCkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5ib3R0b20gPT09IGJvdW5kcy5ib3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXF1YWxzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICogQGRlc2NyaXB0aW9uIOi/lOWbnuatpOWvueixoeeahOWtl+espuS4suW9ouW8j+OAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGJvdW5kcyA9IG5ldyBCb3VuZHMoLTE4MCwtOTAsMTgwLDkwKTtcbiAgICAgKiB2YXIgc3RyID0gYm91bmRzLnRvU3RyaW5nKCk7XG4gICAgICogQHJldHVybnMge3N0cmluZ30g6L6555WM5a+56LGh55qE5a2X56ym5Liy6KGo56S65b2i5byP77yIbGVmdCxib3R0b20scmlnaHQsdG9w77yJ77yM5L6L5aaCOiBcIi0xODAsLTkwLDE4MCw5MFwi44CCXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5sZWZ0LCB0aGlzLmJvdHRvbSwgdGhpcy5yaWdodCwgdGhpcy50b3BdLmpvaW4oXCIsXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLnRvQXJyYXlcbiAgICAgKiBAZGVzY3JpcHRpb24g6L6555WM5a+56LGh55qE5pWw57uE6KGo56S65b2i5byP44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gbmV3IEJvdW5kcygtMTgwLC05MCwxMDAsODApO1xuICAgICAqIC8vYXJyYXkxID0gWy0xODAsLTkwLDEwMCw4MF07XG4gICAgICogdmFyIGFycmF5MSA9IGJvdW5kcy50b0FycmF5KCk7XG4gICAgICogLy9hcnJheTEgPSBbLTkwLC0xODAsODAsMTAwXTtcbiAgICAgKiB2YXIgYXJyYXkyID0gYm91bmRzLnRvQXJyYXkodHJ1ZSk7XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZUF4aXNPcmRlcj1mYWxzZV0gLSDmmK/lkKblj43ovazovbTpobrluo/jgIJcbiAgICAgKiDlpoLmnpzorr7kuLogdHJ1Ze+8jOWImeWAkui9rOmhuuW6j++8iGJvdHRvbSxsZWZ0LHRvcCxyaWdodO+8ie+8jOWQpuWImeaMieato+W4uOi9tOmhuuW6j++8iGxlZnQsYm90dG9tLHJpZ2h0LHRvcO+8ieOAglxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gbGVmdCwgYm90dG9tLCByaWdodCwgdG9wIOaVsOe7hOOAglxuICAgICAqL1xuICAgIHRvQXJyYXkocmV2ZXJzZUF4aXNPcmRlcikge1xuICAgICAgICBpZiAocmV2ZXJzZUF4aXNPcmRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmJvdHRvbSwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5yaWdodF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMubGVmdCwgdGhpcy5ib3R0b20sIHRoaXMucmlnaHQsIHRoaXMudG9wXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLnRvQkJPWFxuICAgICAqIEBkZXNjcmlwdGlvbiDlj5blsI/mlbDngrnlkI4gZGVjaW1hbCDkvY3mlbDlrZfov5vooYzlm5voiI3kupTlhaXlho3ovazmjaLkuLogQkJPWCDlrZfnrKbkuLLjgIJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBib3VuZHMgPSBuZXcgQm91bmRzKC0xLjEyMzQ1NjcsLTEuNzY1NDMyMSwxLjQ0NDQ0NDQsMS41NTU1NTU1KTtcbiAgICAgKiAvL3N0cjEgPSBcIi0xLjEyMzQ1NywtMS43NjU0MzIsMS40NDQ0NDQsMS41NTU1NTZcIjtcbiAgICAgKiB2YXIgc3RyMSA9IGJvdW5kcy50b0JCT1goKTtcbiAgICAgKiAvL3N0cjIgPSBcIi0xLjEsLTEuOCwxLjQsMS42XCI7XG4gICAgICogdmFyIHN0cjIgPSBib3VuZHMudG9CQk9YKDEpO1xuICAgICAqIC8vc3RyMiA9IFwiLTEuOCwtMS4xLDEuNiwxLjRcIjtcbiAgICAgKiB2YXIgc3RyMiA9IGJvdW5kcy50b0JCT1goMSx0cnVlKTtcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlY2ltYWw9Nl0gLSDovrnnlYzmlrnkvY3lnZDmoIfnmoTmnInmlYjmlbDlrZfkuKrmlbDjgIJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlQXhpc09yZGVyPWZhbHNlXSAtIOaYr+WQpuaYr+WPjei9rOi9tOmhuuW6j+OAglxuICAgICAqIOWmguaenOiuvuS4unRydWXvvIzliJnlgJLovazpobrluo/vvIhib3R0b20sbGVmdCx0b3AscmlnaHTvvIks5ZCm5YiZ5oyJ5q2j5bi46L206aG65bqP77yIbGVmdCxib3R0b20scmlnaHQsdG9w77yJ44CCXG4gICAgICogQHJldHVybnMge3N0cmluZ30g6L6555WM5a+56LGh55qE5a2X56ym5Liy6KGo56S65b2i5byP77yM5aaC77yaXCI1LDQyLDEwLDQ1XCLjgIJcbiAgICAgKi9cbiAgICB0b0JCT1goZGVjaW1hbCwgcmV2ZXJzZUF4aXNPcmRlcikge1xuICAgICAgICBpZiAoZGVjaW1hbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWNpbWFsID0gNjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXVsdCA9IE1hdGgucG93KDEwLCBkZWNpbWFsKTtcbiAgICAgICAgdmFyIHhtaW4gPSBNYXRoLnJvdW5kKHRoaXMubGVmdCAqIG11bHQpIC8gbXVsdDtcbiAgICAgICAgdmFyIHltaW4gPSBNYXRoLnJvdW5kKHRoaXMuYm90dG9tICogbXVsdCkgLyBtdWx0O1xuICAgICAgICB2YXIgeG1heCA9IE1hdGgucm91bmQodGhpcy5yaWdodCAqIG11bHQpIC8gbXVsdDtcbiAgICAgICAgdmFyIHltYXggPSBNYXRoLnJvdW5kKHRoaXMudG9wICogbXVsdCkgLyBtdWx0O1xuICAgICAgICBpZiAocmV2ZXJzZUF4aXNPcmRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHltaW4gKyBcIixcIiArIHhtaW4gKyBcIixcIiArIHltYXggKyBcIixcIiArIHhtYXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geG1pbiArIFwiLFwiICsgeW1pbiArIFwiLFwiICsgeG1heCArIFwiLFwiICsgeW1heDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLyoqXG4gICAgLy8gKiBAZnVuY3Rpb24gQm91bmRzLnByb3RvdHlwZS50b0dlb21ldHJ5XG4gICAgLy8gKiBAZGVzY3JpcHRpb24g5Z+65LqO5b2T5YmN6L6555WM6IyD5Zu05Yib5bu65LiA5Liq5paw55qE5aSa6L655b2i5a+56LGh44CCXG4gICAgLy8gKiBAZXhhbXBsZVxuICAgIC8vICogdmFyIGJvdW5kcyA9IG5ldyBCb3VuZHMoLTE4MCwtOTAsMTAwLDgwKTtcbiAgICAvLyAqIC8vIFBvbHlnb27lr7nosaFcbiAgICAvLyAqIHZhciBnZW8gPSBib3VuZHMudG9HZW9tZXRyeSgpO1xuICAgIC8vICogQHJldHVybnMge0dlb21ldHJ5UG9seWdvbn0g5Z+65LqO5b2T5YmNIGJvdW5kcyDlnZDmoIfliJvlu7rnmoTmlrDnmoTlpJrovrnlvaLjgIJcbiAgICAvLyAqL1xuICAgIC8vIHRvR2VvbWV0cnkoKSB7XG4gICAgLy8gICAgIHJldHVybiBuZXcgUG9seWdvbihbXG4gICAgLy8gICAgICAgICBuZXcgTGluZWFyUmluZyhbXG4gICAgLy8gICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMubGVmdCwgdGhpcy5ib3R0b20pLFxuICAgIC8vICAgICAgICAgICAgIG5ldyBQb2ludCh0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSksXG4gICAgLy8gICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMucmlnaHQsIHRoaXMudG9wKSxcbiAgICAvLyAgICAgICAgICAgICBuZXcgUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcClcbiAgICAvLyAgICAgICAgIF0pXG4gICAgLy8gICAgIF0pO1xuICAgIC8vIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLmdldFdpZHRoXG4gICAgICogQGRlc2NyaXB0aW9uIOiOt+WPliBib3VuZHMg55qE5a695bqm44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gbmV3IEJvdW5kcygtMTgwLC05MCwxMDAsODApO1xuICAgICAqIC8vd2lkdGggPSAyODA7XG4gICAgICogdmFyIHdpZHRoID0gYm91bmRzLmdldFdpZHRoKCk7XG4gICAgICogQHJldHVybnMge251bWJlcn0g6I635Y+W5b2T5YmNIGJvdW5kcyDnmoTlrr3luqbvvIhyaWdodCDlh4/ljrsgbGVmdO+8ieOAglxuICAgICAqL1xuICAgIGdldFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucmlnaHQgLSB0aGlzLmxlZnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLmdldEhlaWdodFxuICAgICAqIEBkZXNjcmlwdGlvbiDojrflj5YgYm91bmRzIOeahOmrmOW6puOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGJvdW5kcyA9IG5ldyBCb3VuZHMoLTE4MCwtOTAsMTAwLDgwKTtcbiAgICAgKiAvL2hlaWdodCA9IDE3MDtcbiAgICAgKiB2YXIgaGVpZ2h0ID0gYm91bmRzLmdldEhlaWdodCgpO1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IOi+ueeVjOmrmOW6pu+8iHRvcCDlh4/ljrsgYm90dG9t77yJ44CCXG4gICAgICovXG4gICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudG9wIC0gdGhpcy5ib3R0b20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLmdldFNpemVcbiAgICAgKiBAZGVzY3JpcHRpb24g6I635Y+W6L655qGG5aSn5bCP44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gbmV3IEJvdW5kcygtMTgwLC05MCwxMDAsODApO1xuICAgICAqIHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcbiAgICAgKiBAcmV0dXJucyB7U2l6ZX0g6L655qGG5aSn5bCP44CCXG4gICAgICovXG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaXplKHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEJvdW5kcy5wcm90b3R5cGUuZ2V0Q2VudGVyUGl4ZWxcbiAgICAgKiBAZGVzY3JpcHRpb24g6I635Y+W5YOP57Sg5qC85byP55qE6IyD5Zu05Lit5b+D54K544CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gbmV3IEJvdW5kcygtMTgwLC05MCwxMDAsODApO1xuICAgICAqIHZhciBwaXhlbCA9IGJvdW5kcy5nZXRDZW50ZXJQaXhlbCgpO1xuICAgICAqIEByZXR1cm5zIHtQaXhlbH0g5YOP57Sg5qC85byP55qE5b2T5YmN6IyD5Zu055qE5Lit5b+D54K544CCXG4gICAgICovXG4gICAgZ2V0Q2VudGVyUGl4ZWwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGl4ZWwoKHRoaXMubGVmdCArIHRoaXMucmlnaHQpIC8gMixcbiAgICAgICAgICAgICh0aGlzLmJvdHRvbSArIHRoaXMudG9wKSAvIDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLmdldENlbnRlckxvbkxhdFxuICAgICAqIEBkZXNjcmlwdGlvbiDojrflj5blnLDnkIbmoLzlvI/nmoTojIPlm7TkuK3lv4PngrnjgIJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBib3VuZHMgPSBuZXcgQm91bmRzKC0xODAsLTkwLDEwMCw4MCk7XG4gICAgICogdmFyIGxvbmxhdCA9IGJvdW5kcy5nZXRDZW50ZXJMb25MYXQoKTtcbiAgICAgKiBAcmV0dXJucyB7TG9uTGF0fSDlvZPliY3lnLDnkIbojIPlm7TnmoTkuK3lv4PngrnjgIJcbiAgICAgKi9cbiAgICBnZXRDZW50ZXJMb25MYXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5jZW50ZXJMb25MYXQpIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyTG9uTGF0ID0gbmV3IExvbkxhdChcbiAgICAgICAgICAgICAgICAodGhpcy5sZWZ0ICsgdGhpcy5yaWdodCkgLyAyLCAodGhpcy5ib3R0b20gKyB0aGlzLnRvcCkgLyAyXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlckxvbkxhdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQm91bmRzLnByb3RvdHlwZS5zY2FsZVxuICAgICAqIEBkZXNjcmlwdGlvbiDmjInnhafmr5TkvovmianlpKcv57yp5bCP5Ye65LiA5Liq5paw55qEIGJvdW5kc+OAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGJvdW5kcyA9IG5ldyBCb3VuZHMoLTUwLC01MCw0MCw0MCk7XG4gICAgICogdmFyIGJvdW5kczIgPSBib3VuZHMuc2NhbGUoMik7XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYXRpbz0xXSAtIOmcgOimgeaJqeWkp+eahOavlOS+i+OAglxuICAgICAqIEBwYXJhbSB7KFBpeGVsfExvbkxhdCl9IFtvcmlnaW5dIC0g5omp5aSn5pe255qE5Z+65YeG54K577yM6buY6K6k5Li65b2T5YmNIGJvdW5kcyDnmoTkuK3lv4PngrnjgIJcbiAgICAgKiBAcmV0dXJucyB7Qm91bmRzfSDpgJrov4cgcmF0aW/jgIFvcmlnaW4g6K6h566X5b6X5Yiw55qE5paw55qE6L6555WM6IyD5Zu044CCXG4gICAgICovXG4gICAgc2NhbGUocmF0aW8sIG9yaWdpbikge1xuICAgICAgICByYXRpbyA9IHJhdGlvID8gcmF0aW8gOiAxO1xuICAgICAgICBpZiAob3JpZ2luID09IG51bGwpIHtcbiAgICAgICAgICAgIG9yaWdpbiA9IHRoaXMuZ2V0Q2VudGVyTG9uTGF0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ3gsIG9yaWd5O1xuXG4gICAgICAgIC8vIGdldCBvcmlnaW4gY29vcmRpbmF0ZXNcbiAgICAgICAgaWYgKG9yaWdpbi5DTEFTU19OQU1FID09PSBcIlN1cGVyTWFwLkxvbkxhdFwiKSB7XG4gICAgICAgICAgICBvcmlneCA9IG9yaWdpbi5sb247XG4gICAgICAgICAgICBvcmlneSA9IG9yaWdpbi5sYXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmlneCA9IG9yaWdpbi54O1xuICAgICAgICAgICAgb3JpZ3kgPSBvcmlnaW4ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0ID0gKHRoaXMubGVmdCAtIG9yaWd4KSAqIHJhdGlvICsgb3JpZ3g7XG4gICAgICAgIHZhciBib3R0b20gPSAodGhpcy5ib3R0b20gLSBvcmlneSkgKiByYXRpbyArIG9yaWd5O1xuICAgICAgICB2YXIgcmlnaHQgPSAodGhpcy5yaWdodCAtIG9yaWd4KSAqIHJhdGlvICsgb3JpZ3g7XG4gICAgICAgIHZhciB0b3AgPSAodGhpcy50b3AgLSBvcmlneSkgKiByYXRpbyArIG9yaWd5O1xuXG4gICAgICAgIHJldHVybiBuZXcgQm91bmRzKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEJvdW5kcy5wcm90b3R5cGUuYWRkXG4gICAgICogQGRlc2NyaXB0aW9uIOWcqOW9k+WJjeeahCBCb3VuZHMg5LiK5oyJ54Wn5Lyg5YWl55qE5Z2Q5qCH54K56L+b6KGM5bmz56e777yM6L+U5Zue5paw55qE6IyD5Zu044CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzMSA9IG5ldyBCb3VuZHMoLTUwLC01MCw0MCw0MCk7XG4gICAgICogLy9ib3VuZHMyIOaYr+aWsOeahCBib3VuZHNcbiAgICAgKiB2YXIgYm91bmRzMiA9IGJvdW5kcy5hZGQoMjAsMTApO1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0g5Z2Q5qCH54K555qEIHgg5Z2Q5qCH44CCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSDlnZDmoIfngrnnmoQgeSDlnZDmoIfjgIJcbiAgICAgKiBAcmV0dXJucyB7Qm91bmRzfSDmlrDnmoQgYm91bmRz77yM5q2kIGJvdW5kcyDnmoTlnZDmoIfmmK/nlLHkvKDlhaXnmoQgeO+8jHkg5Y+C5pWw5LiO5b2T5YmNIGJvdW5kcyDlnZDmoIforqHnrpfmiYDlvpfjgIJcbiAgICAgKi9cbiAgICBhZGQoeCwgeSkge1xuICAgICAgICBpZiAoKHggPT0gbnVsbCkgfHwgKHkgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvdW5kcy5hZGQgY2Fubm90IHJlY2VpdmUgbnVsbCB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kcyh0aGlzLmxlZnQgKyB4LCB0aGlzLmJvdHRvbSArIHksXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ICsgeCwgdGhpcy50b3AgKyB5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQm91bmRzLnByb3RvdHlwZS5leHRlbmRcbiAgICAgKiBAZGVzY3JpcHRpb24g5Zyo5b2T5YmNIGJvdW5kcyDkuIrmianlsZUgYm91bmRz77yM5pSv5oyBIHBvaW5077yMbGFubGF0IOWSjCBib3VuZHPjgILmianlsZXlkI7nmoQgYm91bmRzIOeahOiMg+WbtOaYr+S4pOiAheeahOe7k+WQiOOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGJvdW5kczEgPSBuZXcgQm91bmRzKC01MCwtNTAsNDAsNDApO1xuICAgICAqIC8vYm91bmRzIOaUueWPmFxuICAgICAqIGJvdW5kcy5leHRlbmQobmV3IExvbkxhdCg1MCw2MCkpO1xuICAgICAqIEBwYXJhbSB7R2VvbWV0cnlQb2ludHxMb25MYXR8Qm91bmRzfSBvYmplY3QgLSDlj6/ku6XmmK8gcG9pbnTjgIFsb25sYXQg5ZKMIGJvdW5kc+OAglxuICAgICAqL1xuICAgIGV4dGVuZChvYmplY3QpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IG51bGw7XG4gICAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIGNhY2hlZCBjZW50ZXIgbG9jYXRpb25cbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0LkNMQVNTX05BTUUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiU3VwZXJNYXAuTG9uTGF0XCI6XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMob2JqZWN0Lmxvbiwgb2JqZWN0LmxhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5sb24sIG9iamVjdC5sYXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiU3VwZXJNYXAuR2VvbWV0cnkuUG9pbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzID0gbmV3IEJvdW5kcyhvYmplY3QueCwgb2JqZWN0LnksXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QueCwgb2JqZWN0LnkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJTdXBlck1hcC5Cb3VuZHNcIjpcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzID0gb2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyTG9uTGF0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMubGVmdCA9PSBudWxsKSB8fCAoYm91bmRzLmxlZnQgPCB0aGlzLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IGJvdW5kcy5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuYm90dG9tID09IG51bGwpIHx8IChib3VuZHMuYm90dG9tIDwgdGhpcy5ib3R0b20pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm90dG9tID0gYm91bmRzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnJpZ2h0ID09IG51bGwpIHx8IChib3VuZHMucmlnaHQgPiB0aGlzLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID0gYm91bmRzLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMudG9wID09IG51bGwpIHx8IChib3VuZHMudG9wID4gdGhpcy50b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9wID0gYm91bmRzLnRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQm91bmRzLnByb3RvdHlwZS5jb250YWluc0xvbkxhdFxuICAgICAqIEBkZXNjcmlwdGlvbiDliKTmlq3kvKDlhaXnmoTlnZDmoIfmmK/lkKblnKjojIPlm7TlhoXjgIJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBib3VuZHMxID0gbmV3IEJvdW5kcygtNTAsLTUwLDQwLDQwKTtcbiAgICAgKiAvL2lzQ29udGFpbnMxID0gdHJ1ZVxuICAgICAqIC8v6L+Z6YeM55qE56ys5LqM5Liq5Y+C5pWw5Y+v5Lul55u05o6l5Li6IGJvb2xlYW4g57G75Z6L77yM5Lmf5bCx5pivaW5jbHVzaXZlXG4gICAgICogdmFyIGlzQ29udGFpbnMxID0gYm91bmRzLmNvbnRhaW5zTG9uTGF0KG5ldyBMb25MYXQoNDAsNDApLHRydWUpO1xuICAgICAqXG4gICAgICogLy8oNDAsNDAp5Zyo6IyD5Zu05YaF77yM5ZCM5qC3KDQwKzM2MCw0MCnkuZ/lnKjojIPlm7TlhoVcbiAgICAgKiB2YXIgYm91bmRzMiA9IG5ldyBCb3VuZHMoLTUwLC01MCw0MCw0MCk7XG4gICAgICogLy9pc0NvbnRhaW5zMiA9IHRydWU7XG4gICAgICogdmFyIGlzQ29udGFpbnMyID0gYm91bmRzMi5jb250YWluc0xvbkxhdChcbiAgICAgKiAgICAgIG5ldyBMb25MYXQoNDAwLDQwKSxcbiAgICAgKiAgICAgIHtcbiAgICAgKiAgICAgICAgICAgaW5jbHVzaXZlOnRydWUsXG4gICAgICogICAgICAgICAgIC8v5YWo55CD55qE6IyD5Zu0XG4gICAgICogICAgICAgICAgIHdvcmxkQm91bmRzOiBuZXcgQm91bmRzKC0xODAsLTkwLDE4MCw5MClcbiAgICAgKiAgICAgIH1cbiAgICAgKiApO1xuICAgICAqIEBwYXJhbSB7KExvbkxhdHxPYmplY3QpfSBsbCAtIDxMb25MYXQ+IOWvueixoeaIluiAheaYr+S4gOS4quWMheWQqyAnbG9uJyDkuI4gJ2xhdCcg5bGe5oCn55qE5a+56LGh44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSDlj6/pgInlj4LmlbDjgIJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmluY2x1c2l2ZT10cnVlXSAtIOaYr+WQpuWMheWQq+i+ueeVjOOAglxuICAgICAqIEBwYXJhbSB7Qm91bmRzfSBbb3B0aW9ucy53b3JsZEJvdW5kc10gLSDlpoLmnpzmj5Dkvpsgd29ybGRCb3VuZHMg5Y+C5pWwLCDlpoLmnpwgbGwg5Y+C5pWw5o+Q5L6b55qE5Z2Q5qCH6LaF5Ye65LqG5LiW55WM6L6555WM77yId29ybGRCb3VuZHPvvInvvIxcbiAgICAgKiAgICAgICAg5L2G5piv6YCa6L+H5pel55WM57q/55qE6L2s5YyW5Y+v5Lul6KKr5YyF5ZCrLCDlroPlsIbooqvorqTkuLrmmK/ljIXlkKvlnKjor6XojIPlm7TlhoXnmoTjgIJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0g5Lyg5YWl5Z2Q5qCH5piv5ZCm5YyF5ZCr5Zyo6IyD5Zu05YaF44CCXG4gICAgICovXG4gICAgY29udGFpbnNMb25MYXQobGwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtpbmNsdXNpdmU6IG9wdGlvbnN9O1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgY29udGFpbnMgPSB0aGlzLmNvbnRhaW5zKGxsLmxvbiwgbGwubGF0LCBvcHRpb25zLmluY2x1c2l2ZSksXG4gICAgICAgICAgICB3b3JsZEJvdW5kcyA9IG9wdGlvbnMud29ybGRCb3VuZHM7XG4gICAgICAgIC8v5pel55WM57q/5Lul5aSW55qE5Lmf5pyJ5Y+v6IO9566X5YyF5ZCr77yMXG4gICAgICAgIGlmICh3b3JsZEJvdW5kcyAmJiAhY29udGFpbnMpIHtcbiAgICAgICAgICAgIHZhciB3b3JsZFdpZHRoID0gd29ybGRCb3VuZHMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciB3b3JsZENlbnRlclggPSAod29ybGRCb3VuZHMubGVmdCArIHdvcmxkQm91bmRzLnJpZ2h0KSAvIDI7XG4gICAgICAgICAgICAvL+i/meS4gOatpeW+iOWFs+mUrlxuICAgICAgICAgICAgdmFyIHdvcmxkc0F3YXkgPSBNYXRoLnJvdW5kKChsbC5sb24gLSB3b3JsZENlbnRlclgpIC8gd29ybGRXaWR0aCk7XG4gICAgICAgICAgICBjb250YWlucyA9IHRoaXMuY29udGFpbnNMb25MYXQoe1xuICAgICAgICAgICAgICAgIGxvbjogbGwubG9uIC0gd29ybGRzQXdheSAqIHdvcmxkV2lkdGgsXG4gICAgICAgICAgICAgICAgbGF0OiBsbC5sYXRcbiAgICAgICAgICAgIH0sIHtpbmNsdXNpdmU6IG9wdGlvbnMuaW5jbHVzaXZlfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLmNvbnRhaW5zUGl4ZWxcbiAgICAgKiBAZGVzY3JpcHRpb24g5Yik5pat5Lyg5YWl55qE5YOP57Sg5piv5ZCm5Zyo6IyD5Zu05YaF44CC55u05o6l5Yy56YWN5aSn5bCP77yM5LiN5raJ5Y+K5YOP57Sg5ZKM5Zyw55CG6L2s5o2i44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gbmV3IEJvdW5kcygtNTAsLTUwLDQwLDQwKTtcbiAgICAgKiAvL2lzQ29udGFpbnMgPSB0cnVlXG4gICAgICogdmFyIGlzQ29udGFpbnMgPSBib3VuZHMuY29udGFpbnNQaXhlbChuZXcgUGl4ZWwoNDAsNDApLHRydWUpO1xuICAgICAqIEBwYXJhbSB7UGl4ZWx9IHB4IC0g5o+Q5L6b55qE5YOP57Sg5Y+C5pWw44CCXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVzaXZlPXRydWVdIC0g5piv5ZCm5YyF5ZCr6L6555WM44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IOS8oOWFpeeahCBwaXhlbCDlnKjlvZPliY3ovrnnlYzojIPlm7TkuYvlhoXjgIJcbiAgICAgKi9cbiAgICBjb250YWluc1BpeGVsKHB4LCBpbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMocHgueCwgcHgueSwgaW5jbHVzaXZlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQm91bmRzLnByb3RvdHlwZS5jb250YWluc1xuICAgICAqIEBkZXNjcmlwdGlvbiDliKTmlq3kvKDlhaXnmoQgeO+8jHkg5Z2Q5qCH5YC85piv5ZCm5Zyo6IyD5Zu05YaF44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gbmV3IEJvdW5kcygtNTAsLTUwLDQwLDQwKTtcbiAgICAgKiAvL2lzQ29udGFpbnMgPSB0cnVlXG4gICAgICogdmFyIGlzQ29udGFpbnMgPSBib3VuZHMuY29udGFpbnMoNDAsNDAsdHJ1ZSk7XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB4IOWdkOagh+WAvOOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0geSDlnZDmoIflgLzjgIJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdXNpdmU9dHJ1ZV0gLSDmmK/lkKbljIXlkKvovrnnlYzjgIJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0g5Lyg5YWl55qEIHjvvIx5IOWdkOagh+aYr+WQpuWcqOW9k+WJjeiMg+WbtOWGheOAglxuICAgICAqL1xuICAgIGNvbnRhaW5zKHgsIHksIGluY2x1c2l2ZSkge1xuICAgICAgICAvL3NldCBkZWZhdWx0XG4gICAgICAgIGlmIChpbmNsdXNpdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvL3ggPSBVdGlsLnRvRmxvYXQoeCk7XG4gICAgICAgIC8veSA9IFV0aWwudG9GbG9hdCh5KTtcblxuICAgICAgICB2YXIgY29udGFpbnMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGluY2x1c2l2ZSkge1xuICAgICAgICAgICAgY29udGFpbnMgPSAoKHggPj0gdGhpcy5sZWZ0KSAmJiAoeCA8PSB0aGlzLnJpZ2h0KSAmJlxuICAgICAgICAgICAgICAgICh5ID49IHRoaXMuYm90dG9tKSAmJiAoeSA8PSB0aGlzLnRvcCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbnMgPSAoKHggPiB0aGlzLmxlZnQpICYmICh4IDwgdGhpcy5yaWdodCkgJiZcbiAgICAgICAgICAgICAgICAoeSA+IHRoaXMuYm90dG9tKSAmJiAoeSA8IHRoaXMudG9wKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLmludGVyc2VjdHNCb3VuZHNcbiAgICAgKiBAZGVzY3JpcHRpb24g5Yik5pat55uu5qCH6L6555WM6IyD5Zu05piv5ZCm5LiO5b2T5YmN6L6555WM6IyD5Zu055u45Lqk44CC5aaC5p6c5Lik5Liq6L6555WM6IyD5Zu05Lit55qE5Lu75oSPXG4gICAgICogICAgICAgICAgICAgIOi+uee8mOebuOS6pOaIluiAheS4gOS4qui+ueeVjOWMheWQq+S6huWPpuWkluS4gOS4quWwseiupOS4uui/meS4pOS4qui+ueeVjOebuOS6pOOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGJvdW5kcyA9IG5ldyBCb3VuZHMoLTE4MCwtOTAsMTAwLDgwKTtcbiAgICAgKiB2YXIgaXNJbnRlcnNlY3RzID0gYm91bmRzLmludGVyc2VjdHNCb3VuZHMoXG4gICAgICogICAgICBuZXcgQm91bmRzKC0xNzAsLTkwLDEyMCw4MClcbiAgICAgKiAgKTtcbiAgICAgKiBAcGFyYW0ge0JvdW5kc30gYm91bmRzIC0g55uu5qCH6L6555WM44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSDlj4LmlbDjgIJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmluY2x1c2l2ZT10cnVlXSAtIOi+uee8mOmHjeWQiOS5n+eci+aIkOebuOS6pOOAguWmguaenOaYr2ZhbHNl77yMXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg5Lik5Liq6L6555WM6IyD5Zu05rKh5pyJ6YeN5Y+g6YOo5YiG5LuF5LuF5piv5Zyo6L6557yY55u45o6l77yI6YeN5ZCI77yJ77yMXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg6L+Z56eN5oOF5Ya16KKr6K6k5Li65rKh5pyJ55u45Lqk44CCXG4gICAgICogQHBhcmFtIHtCb3VuZHN9IFtvcHRpb25zLndvcmxkQm91bmRzXSAtIOaPkOS+m+S6hiB3b3JsZEJvdW5kcyDlj4LmlbAsIOWmguaenOS7luS7rOebuOS6pOaXtlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOaYr+WcqOWFqOeQg+iMg+WbtOWGhSwg5Lik5Liq6L6555WM5bCG6KKr6KeG5Li655u45Lqk44CC6L+Z5LuF6YCC55So5LqO5Lqk5Y+J5oiW5a6M5YWo5LiN5Zyo5LiW55WM6IyD5Zu055qE6L6555WM44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IOS8oOWFpeeahCBib3VuZHMg5a+56LGh5LiO5b2T5YmNIGJvdW5kcyDnm7jkuqTjgIJcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzQm91bmRzKGJvdW5kcywgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge2luY2x1c2l2ZTogb3B0aW9uc307XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChvcHRpb25zLndvcmxkQm91bmRzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMud3JhcERhdGVMaW5lKG9wdGlvbnMud29ybGRCb3VuZHMpO1xuICAgICAgICAgICAgYm91bmRzID0gYm91bmRzLndyYXBEYXRlTGluZShvcHRpb25zLndvcmxkQm91bmRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1c2l2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zLmluY2x1c2l2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVyc2VjdHMgPSBmYWxzZTtcbiAgICAgICAgdmFyIG1pZ2h0VG91Y2ggPSAoXG4gICAgICAgICAgICBzZWxmLmxlZnQgPT09IGJvdW5kcy5yaWdodCB8fFxuICAgICAgICAgICAgc2VsZi5yaWdodCA9PT0gYm91bmRzLmxlZnQgfHxcbiAgICAgICAgICAgIHNlbGYudG9wID09PSBib3VuZHMuYm90dG9tIHx8XG4gICAgICAgICAgICBzZWxmLmJvdHRvbSA9PT0gYm91bmRzLnRvcFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0d28gYm91bmRzIG9ubHkgdG91Y2ggYXQgYW4gZWRnZSwgYW5kIGluY2x1c2l2ZSBpcyBmYWxzZSxcbiAgICAgICAgLy8gdGhlbiB0aGUgYm91bmRzIGRvbid0ICpyZWFsbHkqIGludGVyc2VjdC5cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVzaXZlIHx8ICFtaWdodFRvdWNoKSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGlmIG9uZSBvZiB0aGUgYm91bmRhcmllcyBldmVuIHBhcnRpYWxseSBjb250YWlucyBhbm90aGVyLFxuICAgICAgICAgICAgLy8gaW5jbHVzaXZlIG9mIHRoZSBlZGdlcywgdGhlbiB0aGV5IGRvIGludGVyc2VjdC5cbiAgICAgICAgICAgIHZhciBpbkJvdHRvbSA9IChcbiAgICAgICAgICAgICAgICAoKGJvdW5kcy5ib3R0b20gPj0gc2VsZi5ib3R0b20pICYmIChib3VuZHMuYm90dG9tIDw9IHNlbGYudG9wKSkgfHxcbiAgICAgICAgICAgICAgICAoKHNlbGYuYm90dG9tID49IGJvdW5kcy5ib3R0b20pICYmIChzZWxmLmJvdHRvbSA8PSBib3VuZHMudG9wKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgaW5Ub3AgPSAoXG4gICAgICAgICAgICAgICAgKChib3VuZHMudG9wID49IHNlbGYuYm90dG9tKSAmJiAoYm91bmRzLnRvcCA8PSBzZWxmLnRvcCkpIHx8XG4gICAgICAgICAgICAgICAgKChzZWxmLnRvcCA+IGJvdW5kcy5ib3R0b20pICYmIChzZWxmLnRvcCA8IGJvdW5kcy50b3ApKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBpbkxlZnQgPSAoXG4gICAgICAgICAgICAgICAgKChib3VuZHMubGVmdCA+PSBzZWxmLmxlZnQpICYmIChib3VuZHMubGVmdCA8PSBzZWxmLnJpZ2h0KSkgfHxcbiAgICAgICAgICAgICAgICAoKHNlbGYubGVmdCA+PSBib3VuZHMubGVmdCkgJiYgKHNlbGYubGVmdCA8PSBib3VuZHMucmlnaHQpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBpblJpZ2h0ID0gKFxuICAgICAgICAgICAgICAgICgoYm91bmRzLnJpZ2h0ID49IHNlbGYubGVmdCkgJiYgKGJvdW5kcy5yaWdodCA8PSBzZWxmLnJpZ2h0KSkgfHxcbiAgICAgICAgICAgICAgICAoKHNlbGYucmlnaHQgPj0gYm91bmRzLmxlZnQpICYmIChzZWxmLnJpZ2h0IDw9IGJvdW5kcy5yaWdodCkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW50ZXJzZWN0cyA9ICgoaW5Cb3R0b20gfHwgaW5Ub3ApICYmIChpbkxlZnQgfHwgaW5SaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvY3VtZW50IG1lXG4gICAgICAgIGlmIChvcHRpb25zLndvcmxkQm91bmRzICYmICFpbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICB2YXIgd29ybGQgPSBvcHRpb25zLndvcmxkQm91bmRzO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gd29ybGQuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciBzZWxmQ3Jvc3NlcyA9ICF3b3JsZC5jb250YWluc0JvdW5kcyhzZWxmKTtcbiAgICAgICAgICAgIHZhciBib3VuZHNDcm9zc2VzID0gIXdvcmxkLmNvbnRhaW5zQm91bmRzKGJvdW5kcyk7XG4gICAgICAgICAgICBpZiAoc2VsZkNyb3NzZXMgJiYgIWJvdW5kc0Nyb3NzZXMpIHtcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBib3VuZHMuYWRkKC13aWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyA9IHNlbGYuaW50ZXJzZWN0c0JvdW5kcyhib3VuZHMsIHtpbmNsdXNpdmU6IG9wdGlvbnMuaW5jbHVzaXZlfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJvdW5kc0Nyb3NzZXMgJiYgIXNlbGZDcm9zc2VzKSB7XG4gICAgICAgICAgICAgICAgc2VsZiA9IHNlbGYuYWRkKC13aWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyA9IGJvdW5kcy5pbnRlcnNlY3RzQm91bmRzKHNlbGYsIHtpbmNsdXNpdmU6IG9wdGlvbnMuaW5jbHVzaXZlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVyc2VjdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEJvdW5kcy5wcm90b3R5cGUuY29udGFpbnNCb3VuZHNcbiAgICAgKiBAZGVzY3JpcHRpb24g5Yik5pat55uu5qCH6L6555WM5piv5ZCm6KKr5b2T5YmN6L6555WM5YyF5ZCr5Zyo5YaF44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gbmV3IEJvdW5kcygtMTgwLC05MCwxMDAsODApO1xuICAgICAqIHZhciBpc0NvbnRhaW5zID0gYm91bmRzLmNvbnRhaW5zQm91bmRzKFxuICAgICAqICAgICAgbmV3IEJvdW5kcygtMTcwLC05MCwxMDAsODApLHRydWUsdHJ1ZVxuICAgICAqICApO1xuICAgICAqIEBwYXJhbSB7Qm91bmRzfSBib3VuZHMgLSDnm67moIfovrnnlYzjgIJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJ0aWFsPWZhbHNlXSAtIOebruagh+i+ueeVjOeahOS7u+aEj+mDqOWIhumDveWMheWQq+WcqOW9k+WJjei+ueeVjOS4reWImeiiq+iupOS4uuaYr+WMheWQq+WFs+ezu+OAglxuICAgICAqIOWmguaenOiuvuS4uiBmYWxzZe+8jOaVtOS4quebruagh+i+ueeVjOWFqOmDqOiiq+WMheWQq+WcqOW9k+WJjei+ueeVjOiMg+WbtOWGheOAglxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1c2l2ZT10cnVlXSAtIOi+uee8mOWFseS6q+aYr+WQpuiiq+inhuS4uuWMheWQq+OAglxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDkvKDlhaXnmoTovrnnlYzmmK/lkKbooqvlvZPliY3ovrnnlYzljIXlkKvjgIJcbiAgICAgKi9cbiAgICBjb250YWluc0JvdW5kcyhib3VuZHMsIHBhcnRpYWwsIGluY2x1c2l2ZSkge1xuICAgICAgICBpZiAocGFydGlhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJ0aWFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1c2l2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmNsdXNpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib3R0b21MZWZ0ID0gdGhpcy5jb250YWlucyhib3VuZHMubGVmdCwgYm91bmRzLmJvdHRvbSwgaW5jbHVzaXZlKTtcbiAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gdGhpcy5jb250YWlucyhib3VuZHMucmlnaHQsIGJvdW5kcy5ib3R0b20sIGluY2x1c2l2ZSk7XG4gICAgICAgIHZhciB0b3BMZWZ0ID0gdGhpcy5jb250YWlucyhib3VuZHMubGVmdCwgYm91bmRzLnRvcCwgaW5jbHVzaXZlKTtcbiAgICAgICAgdmFyIHRvcFJpZ2h0ID0gdGhpcy5jb250YWlucyhib3VuZHMucmlnaHQsIGJvdW5kcy50b3AsIGluY2x1c2l2ZSk7XG5cbiAgICAgICAgcmV0dXJuIChwYXJ0aWFsKSA/IChib3R0b21MZWZ0IHx8IGJvdHRvbVJpZ2h0IHx8IHRvcExlZnQgfHwgdG9wUmlnaHQpXG4gICAgICAgICAgICA6IChib3R0b21MZWZ0ICYmIGJvdHRvbVJpZ2h0ICYmIHRvcExlZnQgJiYgdG9wUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMucHJvdG90eXBlLmRldGVybWluZVF1YWRyYW50XG4gICAgICogQGRlc2NyaXB0aW9uIOWIpOaWreS8oOWFpeWdkOagh+aYr+WQpuWcqCBib3VuZHMg6IyD5Zu05YaF55qE6LGh6ZmQ44CC5LulIGJvdW5kcyDkuK3lv4PngrnkuLrlnZDmoIfljp/ngrnjgIJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBib3VuZHMgPSBuZXcgQm91bmRzKC0xODAsLTkwLDEwMCw4MCk7XG4gICAgICogLy9zdHIgPSBcInRyXCI7XG4gICAgICogdmFyIHN0ciA9IGJvdW5kcy5kZXRlcm1pbmVRdWFkcmFudChcbiAgICAgKiAgICAgIG5ldyBMb25MYXQoMjAsMjApXG4gICAgICogICk7XG4gICAgICogQHBhcmFtIHtMb25MYXR9IGxvbmxhdCAtIOS8oOWFpeeahOWdkOagh+WvueixoeOAglxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOS8oOWFpeWdkOagh+aJgOWcqOeahOixoemZkO+8iFwiYnJcIiBcInRyXCIgXCJ0bFwiIFwiYmxcIiDliIbliKvlr7nlupRcIuWPs+S4i1wi77yMXCLlj7PkuIpcIu+8jFwi5bem5LiKXCIgXCLlt6bkuItcIu+8ieOAglxuICAgICAqL1xuICAgIGRldGVybWluZVF1YWRyYW50KGxvbmxhdCkge1xuXG4gICAgICAgIHZhciBxdWFkcmFudCA9IFwiXCI7XG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlckxvbkxhdCgpO1xuXG4gICAgICAgIHF1YWRyYW50ICs9IChsb25sYXQubGF0IDwgY2VudGVyLmxhdCkgPyBcImJcIiA6IFwidFwiO1xuICAgICAgICBxdWFkcmFudCArPSAobG9ubGF0LmxvbiA8IGNlbnRlci5sb24pID8gXCJsXCIgOiBcInJcIjtcblxuICAgICAgICByZXR1cm4gcXVhZHJhbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEJvdW5kcy5wcm90b3R5cGUud3JhcERhdGVMaW5lXG4gICAgICogQGRlc2NyaXB0aW9uIOWwhuW9k+WJjSBib3VuZHMg56e75Yqo5Yiw5pyA5aSn6L6555WM6IyD5Zu05YaF6YOo77yI5omA6LCT55qE5YaF6YOo5piv55u45Lqk5oiW6ICF5YaF6YOo77yJ44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gbmV3IEJvdW5kcygzODAsLTQwLDQwMCwtMjApO1xuICAgICAqIHZhciBtYXhFeHRlbnQgPSBuZXcgQm91bmRzKC0xODAsLTkwLDEwMCw4MCk7XG4gICAgICogLy/mlrDnmoRib3VuZHNcbiAgICAgKiB2YXIgbmV3Qm91bmRzID0gYm91bmRzLndyYXBEYXRlTGluZShtYXhFeHRlbnQpO1xuICAgICAqIEBwYXJhbSB7Qm91bmRzfSBtYXhFeHRlbnQgLSDmnIDlpKfnmoTovrnnlYzojIPlm7TvvIjkuIDoiKzmmK/lhajnkIPojIPlm7TvvInjgIJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIOWPr+mAiemAiemhueWPguaVsOOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZWZ0VG9sZXJhbmNlPTBdIC0gbGVmdCDlhYHorrjnmoTor6/lt67jgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmlnaHRUb2xlcmFuY2U9MF0gLSByaWdodCDlhYHorrjnmoTor6/lt67jgIJcbiAgICAgKiBAcmV0dXJucyB7Qm91bmRzfSDlhYvpmoblvZPliY3ovrnnlYzjgILlpoLmnpzlvZPliY3ovrnnlYzlrozlhajlnKjmnIDlpKfojIPlm7TkuYvlpJbmraTlh73mlbDliJnov5Tlm57kuIDkuKrkuI3lkIzlgLznmoTovrnnlYzvvIxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICDoi6XokL3lnKjmnIDlpKfovrnnlYznmoTlt6bovrnvvIzliJnnu5nlvZPliY3nmoRib3VuZHPlgLzliqDkuIrmnIDlpKfojIPlm7TnmoTlrr3luqbvvIzljbPlkJHlj7Pnp7vliqjvvIxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICDoi6XokL3lnKjlj7PovrnvvIzliJnlkJHlt6bnp7vliqjvvIzljbPnu5nlvZPliY3nmoRib3VuZHPlgLzliqDkuIrotJ/nmoTmnIDlpKfojIPlm7TnmoTlrr3luqbjgIJcbiAgICAgKi9cbiAgICB3cmFwRGF0ZUxpbmUobWF4RXh0ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBsZWZ0VG9sZXJhbmNlID0gb3B0aW9ucy5sZWZ0VG9sZXJhbmNlIHx8IDA7XG4gICAgICAgIHZhciByaWdodFRvbGVyYW5jZSA9IG9wdGlvbnMucmlnaHRUb2xlcmFuY2UgfHwgMDtcblxuICAgICAgICB2YXIgbmV3Qm91bmRzID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChtYXhFeHRlbnQpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IG1heEV4dGVudC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgLy/lpoLmnpwgbmV3Qm91bmRzIOWcqCBtYXhFeHRlbnQg55qE5bem6L6577yM6YKj5LmI5LiA55u05ZCR5Y+z56e75Yqo77yM55u05Yiw55u45Lqk5oiW6ICF5YyF5ZCr5Li65q2i77yM5q+P5qyh56e75Yqod2lkdGhcbiAgICAgICAgICAgIC8vc2hpZnQgcmlnaHQ/XG4gICAgICAgICAgICB3aGlsZSAobmV3Qm91bmRzLmxlZnQgPCBtYXhFeHRlbnQubGVmdCAmJlxuICAgICAgICAgICAgbmV3Qm91bmRzLnJpZ2h0IC0gcmlnaHRUb2xlcmFuY2UgPD0gbWF4RXh0ZW50LmxlZnQpIHtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZHMgPSBuZXdCb3VuZHMuYWRkKHdpZHRoLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8v5aaC5p6cIG5ld0JvdW5kcyDlnKggbWF4RXh0ZW50IOeahOWPs+i+ue+8jOmCo+S5iOS4gOebtOWQkeW3puenu+WKqO+8jOebtOWIsOebuOS6pOaIluiAheWMheWQq+S4uuatou+8jOavj+asoeenu+WKqHdpZHRoXG4gICAgICAgICAgICAvL3NoaWZ0IGxlZnQ/XG4gICAgICAgICAgICB3aGlsZSAobmV3Qm91bmRzLmxlZnQgKyBsZWZ0VG9sZXJhbmNlID49IG1heEV4dGVudC5yaWdodCAmJlxuICAgICAgICAgICAgbmV3Qm91bmRzLnJpZ2h0ID4gbWF4RXh0ZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbmV3Qm91bmRzID0gbmV3Qm91bmRzLmFkZCgtd2lkdGgsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy/lpoLmnpzlkozlj7Povrnnm7jkuqTvvIzlt6bovrnlj4jlnKjlhoXpg6jvvIzpgqPkuYjlho3mrKHlkJHlt6bovrnnp7vliqjkuIDmrKFcbiAgICAgICAgICAgIC8vIGNyb3NzZXMgcmlnaHQgb25seT8gZm9yY2UgbGVmdFxuICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSBuZXdCb3VuZHMubGVmdCArIGxlZnRUb2xlcmFuY2U7XG4gICAgICAgICAgICBpZiAobmV3TGVmdCA8IG1heEV4dGVudC5yaWdodCAmJiBuZXdMZWZ0ID4gbWF4RXh0ZW50LmxlZnQgJiZcbiAgICAgICAgICAgICAgICBuZXdCb3VuZHMucmlnaHQgLSByaWdodFRvbGVyYW5jZSA+IG1heEV4dGVudC5yaWdodCkge1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kcyA9IG5ld0JvdW5kcy5hZGQoLXdpZHRoLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdCb3VuZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEJvdW5kcy5wcm90b3R5cGUudG9TZXJ2ZXJKU09OT2JqZWN0XG4gICAgICogQGRlc2NyaXB0aW9uIOi9rOaNouaIkOWvueW6lOeahCBKU09OIOagvOW8j+WvueixoeOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGJvdW5kcyA9IG5ldyBCb3VuZHMoLTE4MCwtOTAsMTAwLDgwKTtcbiAgICAgKiB2YXIgb2JqID0gYm91bmRzLnRvU2VydmVySlNPTk9iamVjdCgpO1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEpTT04g5qC85byP55qEIE9iamVjdCDlr7nosaHjgIJcbiAgICAgKi9cbiAgICB0b1NlcnZlckpTT05PYmplY3QoKSB7XG4gICAgICAgIHZhciBqc29uT2JqZWN0ID0ge1xuICAgICAgICAgICAgcmlnaHRUb3A6IHt4OiB0aGlzLnJpZ2h0LCB5OiB0aGlzLnRvcH0sXG4gICAgICAgICAgICBsZWZ0Qm90dG9tOiB7eDogdGhpcy5sZWZ0LCB5OiB0aGlzLmJvdHRvbX0sXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmxlZnQsXG4gICAgICAgICAgICByaWdodDogdGhpcy5yaWdodCxcbiAgICAgICAgICAgIHRvcDogdGhpcy50b3AsXG4gICAgICAgICAgICBib3R0b206IHRoaXMuYm90dG9tXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb25PYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gQm91bmRzLnByb3RvdHlwZS5kZXN0cm95XG4gICAgICogQGRlc2NyaXB0aW9uIOmUgOavgeatpOWvueixoeOAglxuICAgICAqIOmUgOavgeWQjuatpOWvueixoeeahOaJgOacieWxnuaAp+S4uiBudWxs77yM6ICM5LiN5piv5Yid5aeL5YC844CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gbmV3IEJvdW5kcygtMTgwLC05MCwxMDAsODApO1xuICAgICAqIGJvdW5kcy5kZXN0cm95KCk7XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XG4gICAgICAgIHRoaXMudG9wID0gbnVsbDtcbiAgICAgICAgdGhpcy5ib3R0b20gPSBudWxsO1xuICAgICAgICB0aGlzLmNlbnRlckxvbkxhdCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEJvdW5kcy5mcm9tU3RyaW5nXG4gICAgICogQGRlc2NyaXB0aW9uIOmAmui/h+Wtl+espuS4suWPguaVsOWIm+W7uuaWsOeahCBib3VuZHMg55qE5p6E6YCg5Ye95pWw44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gQm91bmRzLmZyb21TdHJpbmcoXCItMTgwLC05MCwxMDAsODBcIik7XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIOi+ueeVjOWtl+espuS4su+8jOeUqOmAl+WPt+malOW8gO+8iGUuZy4gPGk+XCI1LDQyLDEwLDQ1XCI8L2k+77yJ44CCXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZUF4aXNPcmRlcj1mYWxzZV0gLSDmmK/lkKblj43ovazovbTpobrluo/jgIJcbiAgICAgKiDlpoLmnpzorr7kuLp0cnVl77yM5YiZ5YCS6L2s6aG65bqP77yIYm90dG9tLGxlZnQsdG9wLHJpZ2h077yJ77yM5ZCm5YiZ5oyJ5q2j5bi46L206aG65bqP77yIbGVmdCxib3R0b20scmlnaHQsdG9w77yJ44CCXG4gICAgICogQHJldHVybnMge0JvdW5kc30g57uZ5a6a55qE5a2X56ym5Liy5Yib5bu655qE5paw55qE6L6555WM5a+56LGh44CCXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJpbmcoc3RyLCByZXZlcnNlQXhpc09yZGVyKSB7XG4gICAgICAgIHZhciBib3VuZHMgPSBzdHIuc3BsaXQoXCIsXCIpO1xuICAgICAgICByZXR1cm4gQm91bmRzLmZyb21BcnJheShib3VuZHMsIHJldmVyc2VBeGlzT3JkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBCb3VuZHMuZnJvbUFycmF5XG4gICAgICogQGRlc2NyaXB0aW9uIOmAmui/h+i+ueeVjOahhuaVsOe7hOWIm+W7uiBCb3VuZHPjgIJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBib3VuZHMgPSBCb3VuZHMuZnJvbUFycmF5KFstMTgwLC05MCwxMDAsODBdKTtcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBiYm94IC0g6L6555WM5YC85pWw57uE44CC77yIZS5nLiA8aT5bNSw0MiwxMCw0NV08L2k+77yJ44CCXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZUF4aXNPcmRlcj1mYWxzZV0gLSDmmK/lkKbmmK/lj43ovazovbTpobrluo/jgILlpoLmnpzorr7kuLp0cnVl77yM5YiZ5YCS6L2s6aG65bqP77yIYm90dG9tLGxlZnQsdG9wLHJpZ2h077yJ77yM5ZCm5YiZ5oyJ5q2j5bi46L206aG65bqP77yIbGVmdCxib3R0b20scmlnaHQsdG9w77yJ44CCXG4gICAgICogQHJldHVybnMge0JvdW5kc30g5qC55o2u5Lyg5YWl55qE5pWw57uE5Yib5bu655qE5paw55qE6L6555WM5a+56LGh44CCXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BcnJheShiYm94LCByZXZlcnNlQXhpc09yZGVyKSB7XG4gICAgICAgIHJldHVybiByZXZlcnNlQXhpc09yZGVyID09PSB0cnVlID9cbiAgICAgICAgICAgIG5ldyBCb3VuZHMoYmJveFsxXSwgYmJveFswXSwgYmJveFszXSwgYmJveFsyXSkgOlxuICAgICAgICAgICAgbmV3IEJvdW5kcyhiYm94WzBdLCBiYm94WzFdLCBiYm94WzJdLCBiYm94WzNdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQm91bmRzLmZyb21TaXplXG4gICAgICogQGRlc2NyaXB0aW9uIOmAmui/h+S8oOWFpeeahOi+ueeVjOWkp+Wwj+adpeWIm+W7uuaWsOeahOi+ueeVjOOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGJvdW5kcyA9IEJvdW5kcy5mcm9tU2l6ZShuZXcgU2l6ZSgyMCwxMCkpO1xuICAgICAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSAtIOi+ueeVjOWkp+Wwj+OAglxuICAgICAqIEByZXR1cm5zIHtCb3VuZHN9IOagueaNruS8oOWFpeeahOi+ueeVjOWkp+Wwj+eahOWIm+W7uuaWsOeahOi+ueeVjOOAglxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2l6ZShzaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRzKDAsXG4gICAgICAgICAgICBzaXplLmgsXG4gICAgICAgICAgICBzaXplLncsXG4gICAgICAgICAgICAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQm91bmRzLm9wcG9zaXRlUXVhZHJhbnRcbiAgICAgKiBAZGVzY3JpcHRpb24g5Y+N6L2s6LGh6ZmQ44CCXCJ0XCLlkoxcImJcIiDkuqTmjaLvvIxcInJcIuWSjFwibFwi5Lqk5o2iLCDlpoLvvJpcInRsXCLlj5jkuLpcImJyXCLjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVhZHJhbnQgLSDku6PooajosaHpmZDnmoTlrZfnrKbkuLLvvIzlpoLvvJpcInRsXCLjgIJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSDlj43ovazlkI7nmoTosaHpmZDjgIJcbiAgICAgKi9cbiAgICBzdGF0aWMgb3Bwb3NpdGVRdWFkcmFudChxdWFkcmFudCkge1xuICAgICAgICB2YXIgb3BwID0gXCJcIjtcblxuICAgICAgICBvcHAgKz0gKHF1YWRyYW50LmNoYXJBdCgwKSA9PT0gJ3QnKSA/ICdiJyA6ICd0JztcbiAgICAgICAgb3BwICs9IChxdWFkcmFudC5jaGFyQXQoMSkgPT09ICdsJykgPyAncicgOiAnbCc7XG5cbiAgICAgICAgcmV0dXJuIG9wcDtcbiAgICB9XG5cbn1cbiIsIi8qIENvcHlyaWdodMKpIDIwMDAgLSAyMDIyIFN1cGVyTWFwIFNvZnR3YXJlIENvLkx0ZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cbmltcG9ydCB7R2VvbWV0cnl9IGZyb20gJy4uL0dlb21ldHJ5JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9Cb3VuZHMnO1xuaW1wb3J0IHtVdGlsfSBmcm9tICcuLi9VdGlsJztcblxuLyoqXG4gKiBAY2xhc3MgR2VvbWV0cnlQb2ludFxuICogQGFsaWFzY2xhc3MgR2VvbWV0cnkuUG9pbnRcbiAqIEBkZXByZWNhdGVkY2xhc3MgU3VwZXJNYXAuR2VvbWV0cnkuUG9pbnRcbiAqIEBjbGFzc2Rlc2Mg54K55Yeg5L2V5a+56LGh57G744CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIEdlb21ldHJ5XG4gKiBAZXh0ZW5kcyB7R2VvbWV0cnl9XG4gKiBAcGFyYW0ge251bWJlcn0geCAtIHgg5Z2Q5qCH44CCXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIHkg5Z2Q5qCH44CCXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGUgPSAnUG9pbnQnXSAtIOeCueeahOexu+Wei+OAglxuICogQHBhcmFtIHtudW1iZXJ9IFt0YWddIC0g6aKd5aSW55qE5bGe5oCn77yM5q+U5aaC5beu5YC85YiG5p6Q5Lit55qEIFog5YC844CCXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50ID0gbmV3IEdlb21ldHJ5UG9pbnQoLTExMS4wNCwgNDUuNjgpO1xuICogQHVzYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2ludCBleHRlbmRzIEdlb21ldHJ5IHtcblxuXG4gICAgY29uc3RydWN0b3IoeCwgeSwgdHlwZSwgdGFnKSB7XG4gICAgICAgIHN1cGVyKHgsIHksIHR5cGUsIHRhZyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IEdlb21ldHJ5UG9pbnQucHJvdG90eXBlLnhcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOaoquWdkOagh+OAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0gcGFyc2VGbG9hdCh4KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBHZW9tZXRyeVBvaW50LnByb3RvdHlwZS55XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDnurXlnZDmoIfjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHBhcnNlRmxvYXQoeSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gR2VvbWV0cnlQb2ludC5wcm90b3R5cGUudGFnXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiAg55So5p2l5a2Y5YKo6aKd5aSW55qE5bGe5oCn77yM5q+U5aaC5beu5YC85YiG5p6Q5Lit55qEIFog5YC844CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZyA9ICh0YWcgfHwgdGFnID09IDApID8gcGFyc2VGbG9hdCh0YWcpIDogbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBHZW9tZXRyeVBvaW50LnByb3RvdHlwZS50eXBlXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiAg55So5p2l5a2Y5YKo54K555qE57G75Z6LXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IFwiUG9pbnRcIjtcbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gXCJTdXBlck1hcC5HZW9tZXRyeS5Qb2ludFwiO1xuICAgICAgICB0aGlzLmdlb21ldHJ5VHlwZSA9IFwiUG9pbnRcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlQb2ludC5wcm90b3R5cGUuY2xvbmVcbiAgICAgKiBAZGVzY3JpcHRpb24g5YWL6ZqG54K55a+56LGh44CCXG4gICAgICogQHJldHVybnMge0dlb21ldHJ5UG9pbnR9IOWFi+mahuWQjueahOeCueWvueixoeOAglxuICAgICAqL1xuICAgIGNsb25lKG9iaikge1xuICAgICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgICAgIG9iaiA9IG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYXRjaCBhbnkgcmFuZG9tbHkgdGFnZ2VkLW9uIHByb3BlcnRpZXNcbiAgICAgICAgVXRpbC5hcHBseURlZmF1bHRzKG9iaiwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlQb2ludC5wcm90b3R5cGUuY2FsY3VsYXRlQm91bmRzXG4gICAgICogQGRlc2NyaXB0aW9uIOiuoeeul+eCueWvueixoeeahOiMg+WbtOOAglxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSBuZXcgQm91bmRzKHRoaXMueCwgdGhpcy55LFxuICAgICAgICAgICAgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeVBvaW50LnByb3RvdHlwZS5lcXVhbHNcbiAgICAgKiBAZGVzY3JpcHRpb24g5Yik5pat5Lik5Liq54K55a+56LGh5piv5ZCm55u4562J44CC5aaC5p6c5Lik5Liq54K55a+56LGh5YW35pyJ55u45ZCM55qE5Z2Q5qCH77yM5YiZ6K6k5Li65piv55u4562J55qE44CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9pbnQ9IG5ldyBHZW9tZXRyeVBvaW50KDAsMCk7XG4gICAgICogdmFyIHBvaW50MT17eDowLHk6MH07XG4gICAgICogdmFyIHJlc3VsdD0gcG9pbnQuZXF1YWxzKHBvaW50MSk7XG4gICAgICogQHBhcmFtIHtHZW9tZXRyeVBvaW50fSBnZW9tIC0g6ZyA6KaB5Yik5pat55qE54K55a+56LGh44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IOS4pOS4queCueWvueixoeaYr+WQpuebuOetie+8iHRydWUg5Li655u4562J77yMZmFsc2Ug5Li65LiN562J77yJ44CCXG4gICAgICovXG4gICAgZXF1YWxzKGdlb20pIHtcbiAgICAgICAgdmFyIGVxdWFscyA9IGZhbHNlO1xuICAgICAgICBpZiAoZ2VvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBlcXVhbHMgPSAoKHRoaXMueCA9PT0gZ2VvbS54ICYmIHRoaXMueSA9PT0gZ2VvbS55KSB8fFxuICAgICAgICAgICAgICAgIChpc05hTih0aGlzLngpICYmIGlzTmFOKHRoaXMueSkgJiYgaXNOYU4oZ2VvbS54KSAmJiBpc05hTihnZW9tLnkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVxdWFscztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeVBvaW50LnByb3RvdHlwZS5tb3ZlXG4gICAgICogQGRlc2NyaXB0aW9uIOayv+edgCB444CBeSDovbTnmoTmraPmlrnlkJHkuIrmjInnhafnu5nlrprnmoTkvY3np7vnp7vliqjngrnlr7nosaHvvIxtb3ZlIOS4jeS7heaUueWPmOS6huWHoOS9leWvueixoeeahOS9jee9ruW5tuS4lOa4heeQhuS6hui+ueeVjOe8k+WtmOOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCDovbTmraPmlrnlkJHkuIrnmoTlgY/np7vph4/jgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHkg6L205q2j5pa55ZCR5LiK5YGP56e76YeP44CCXG4gICAgICovXG4gICAgbW92ZSh4LCB5KSB7XG4gICAgICAgIHRoaXMueCA9IHRoaXMueCArIHg7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueSArIHk7XG4gICAgICAgIHRoaXMuY2xlYXJCb3VuZHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlQb2ludC5wcm90b3R5cGUudG9TaG9ydFN0cmluZ1xuICAgICAqIEBkZXNjcmlwdGlvbiDlsIYgeC95IOWdkOagh+i9rOaNouaIkOeugOWNleWtl+espuS4suOAglxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOWtl+espuS4suS7o+ihqOeCueWvueixoeOAgihleC4gPGk+XCI1LCA0MlwiPC9pPilcbiAgICAgKi9cbiAgICB0b1Nob3J0U3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5UG9pbnQucHJvdG90eXBlLmRlc3Ryb3lcbiAgICAgKiBAZGVzY3JpcHRpb24g6YeK5pS+54K55a+56LGh55qE6LWE5rqQ44CCXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy54ID0gbnVsbDtcbiAgICAgICAgdGhpcy55ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5UG9pbnQucHJvdG90eXBlLmdldFZlcnRpY2VzXG4gICAgICogQGRlc2NyaXB0aW9uIOiOt+WPluWHoOS9leWbvuW9ouaJgOaciemhtueCueeahOWIl+ihqOOAglxuICAgICAqIEByZXR1cm5zIHtBcnJheX0g5Yeg5L2V5Zu+5b2i55qE6aG254K55YiX6KGo44CCXG4gICAgICovXG4gICAgZ2V0VmVydGljZXMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuXG5cbn1cbiIsIi8qIENvcHlyaWdodMKpIDIwMDAgLSAyMDIyIFN1cGVyTWFwIFNvZnR3YXJlIENvLkx0ZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9Cb3VuZHMnO1xuaW1wb3J0IHtHZW9tZXRyeX0gZnJvbSAnLi4vR2VvbWV0cnknO1xuaW1wb3J0IHtVdGlsfSBmcm9tICcuLi9VdGlsJztcblxuLyoqXG4gKiBAY2xhc3MgR2VvbWV0cnlDb2xsZWN0aW9uXG4gKiBAYWxpYXNjbGFzcyBHZW9tZXRyeS5Db2xsZWN0aW9uXG4gKiBAZGVwcmVjYXRlZGNsYXNzIFN1cGVyTWFwLkdlb21ldHJ5LkNvbGxlY3Rpb25cbiAqIEBjbGFzc2Rlc2Mg5Yeg5L2V5a+56LGh6ZuG5ZCI57G777yM5a2Y5YKo5Zyo5pys5Zyw55qEIGNvbXBvbmVudHMg5bGe5oCn5Lit77yI5Y+v5L2c5Li65Y+C5pWw5Lyg6YCS57uZ5p6E6YCg5Ye95pWw77yJ44CCPGJyPlxuICogICAgICAgICAgICDpmo/nnYDmlrDnmoTlh6DkvZXlm77lvaLmt7vliqDliLDpm4blkIjkuK3vvIzlsIbkuI3og73ooqvlhYvpmobvvIzlvZPnp7vliqjlh6DkvZXlm77lvaLml7bvvIzpnIDopoHmjIflrprlj4LnhafnianjgII8YnI+XG4gKiAgICAgICAgICAgIGdldEFyZWEg5ZKMIGdldExlbmd0aCDlh73mlbDlj6rog73pgJrov4fpgY3ljoblrZjlgqjlh6DkvZXlr7nosaHnmoQgY29tcG9uZW50cyDmlbDnu4TvvIzmgLvorqHmiYDmnInlh6DkvZXlm77lvaLnmoTpnaLnp6/lkozplb/luqbjgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgR2VvbWV0cnlcbiAqIEBleHRlbmRzIHtHZW9tZXRyeX1cbiAqIEBwYXJhbSB7QXJyYXkuPEdlb21ldHJ5Pn0gY29tcG9uZW50cyAtIOWHoOS9leWvueixoeaVsOe7hOOAglxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludDEgPSBuZXcgR2VvbWV0cnlQb2ludCgxMCwyMCk7XG4gKiB2YXIgcG9pbnQyID0gbmV3IEdlb21ldHJ5UG9pbnQoMzAsNDApO1xuICogdmFyIGNvbCA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oW3BvaW50MSxwb2ludDJdKTtcbiAqIEB1c2FnZVxuICovXG5leHBvcnQgY2xhc3MgQ29sbGVjdGlvbiBleHRlbmRzIEdlb21ldHJ5IHtcblxuXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5a2Y5YKo5Yeg5L2V5a+56LGh55qE5pWw57uE44CCXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxHZW9tZXRyeT59IEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuY29tcG9uZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmNvbXBvbmVudFR5cGVzXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBjb21wb25lbnRzIOWtmOWCqOeahOeahOWHoOS9leWvueixoeaJgOaUr+aMgeeahOWHoOS9leexu+Wei+aVsOe7hO+8jOS4uuepuuihqOekuuexu+Wei+S4jeWPl+mZkOWItuOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlcyA9IG51bGw7XG4gICAgICAgIGlmIChjb21wb25lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ29tcG9uZW50cyhjb21wb25lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkNMQVNTX05BTUUgPSBcIlN1cGVyTWFwLkdlb21ldHJ5LkNvbGxlY3Rpb25cIjtcbiAgICAgICAgdGhpcy5nZW9tZXRyeVR5cGUgPSBcIkNvbGxlY3Rpb25cIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5kZXN0cm95XG4gICAgICogQGRlc2NyaXB0aW9uIOmUgOavgeWHoOS9leWbvuW9ouOAglxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBudWxsO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuY2xvbmVcbiAgICAgKiBAZGVzY3JpcHRpb24g5YWL6ZqG5b2T5YmN5Yeg5L2V5a+56LGh44CCXG4gICAgICogQHJldHVybnMge0dlb21ldHJ5Q29sbGVjdGlvbn0g5YWL6ZqG55qE5Yeg5L2V5a+56LGh6ZuG5ZCI44CCXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBDb2xsZWN0aW9uKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZENvbXBvbmVudCh0aGlzLmNvbXBvbmVudHNbaV0uY2xvbmUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYXRjaCBhbnkgcmFuZG9tbHkgdGFnZ2VkLW9uIHByb3BlcnRpZXNcbiAgICAgICAgVXRpbC5hcHBseURlZmF1bHRzKGdlb21ldHJ5LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0Q29tcG9uZW50c1N0cmluZ1xuICAgICAqIEBkZXNjcmlwdGlvbiDojrflj5YgY29tcG9uZW50cyDlrZfnrKbkuLLjgIJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjb21wb25lbnRzIOWtl+espuS4suOAglxuICAgICAqL1xuICAgIGdldENvbXBvbmVudHNTdHJpbmcoKSB7XG4gICAgICAgIHZhciBzdHJpbmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHN0cmluZ3MucHVzaCh0aGlzLmNvbXBvbmVudHNbaV0udG9TaG9ydFN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5ncy5qb2luKFwiLFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5jYWxjdWxhdGVCb3VuZHNcbiAgICAgKiBAZGVzY3JpcHRpb24g6YCa6L+H6YGN5Y6G5pWw57uE6YeN5paw6K6h566X6L6555WM77yM5Zyo6YGN5Y6G5q+P5LiA5a2Q6aG55Lit5pe26LCD55SoIGV4dGVuZCDmlrnms5XjgIJcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgICAgICAgdmFyIGJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5leHRlbmQoY29tcG9uZW50c1tpXS5nZXRCb3VuZHMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG8gcHJlc2VydmUgb2xkIGJlaGF2aW9yLCB3ZSBvbmx5IHNldCBib3VuZHMgaWYgbm9uLW51bGxcbiAgICAgICAgLy8gaW4gdGhlIGZ1dHVyZSwgd2UgY291bGQgYWRkIGJvdW5kcy5pc0VtcHR5KClcbiAgICAgICAgaWYgKGJvdW5kcy5sZWZ0ICE9IG51bGwgJiYgYm91bmRzLmJvdHRvbSAhPSBudWxsICYmXG4gICAgICAgICAgICBib3VuZHMucmlnaHQgIT0gbnVsbCAmJiBib3VuZHMudG9wICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRzKGJvdW5kcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5hZGRDb21wb25lbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIOe7meWHoOS9leWbvuW9ouWvueixoea3u+WKoOWFg+e0oOOAglxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEdlb21ldHJ5Pn0gY29tcG9uZW50cyAtIOWHoOS9leWvueixoee7hOS7tuOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGdlb21ldHJ5Q29sbGVjdGlvbiA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oKTtcbiAgICAgKiBnZW9tZXRyeUNvbGxlY3Rpb24uYWRkQ29tcG9uZW50cyhuZXcgU3VlcnBNYXAuR2VvbWV0cnkuUG9pbnQoMTAsMTApKTtcbiAgICAgKi9cbiAgICBhZGRDb21wb25lbnRzKGNvbXBvbmVudHMpIHtcbiAgICAgICAgaWYgKCEoVXRpbC5pc0FycmF5KGNvbXBvbmVudHMpKSkge1xuICAgICAgICAgICAgY29tcG9uZW50cyA9IFtjb21wb25lbnRzXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoY29tcG9uZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5hZGRDb21wb25lbnRcbiAgICAgKiBAZGVzY3JpcHRpb24g5re75Yqg5Yeg5L2V5a+56LGh5Yiw6ZuG5ZCI5Lit44CC5aaC5p6c6K6+572u5LqGIGNvbXBvbmVudFR5cGVzIOexu+Wei++8jOWImea3u+WKoOeahOWHoOS9leWvueixoeW/hemhu+aYryBjb21wb25lbnRUeXBlcyDkuK3nmoTnsbvlnovjgIJcbiAgICAgKiBAcGFyYW0ge0dlb21ldHJ5fSBjb21wb25lbnQgLSDlvoXmt7vliqDnmoTlh6DkvZXlr7nosaHjgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XSAtIOWHoOS9leWvueixoeaPkuWFpeeahOS9jee9ruOAglxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDmmK/lkKbmt7vliqDmiJDlip/jgIJcbiAgICAgKi9cbiAgICBhZGRDb21wb25lbnQoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50VHlwZXMgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChVdGlsLmluZGV4T2YodGhpcy5jb21wb25lbnRUeXBlcyxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LkNMQVNTX05BTUUpID4gLTEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiAoaW5kZXggPCB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50czEgPSB0aGlzLmNvbXBvbmVudHMuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50czIgPSB0aGlzLmNvbXBvbmVudHMuc2xpY2UoaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czEucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzMS5jb25jYXQoY29tcG9uZW50czIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZUNvbXBvbmVudHNcbiAgICAgKiBAZGVzY3JpcHRpb24g5riF6Zmk5Yeg5L2V5a+56LGh44CCXG4gICAgICogQHBhcmFtIHtBcnJheS48R2VvbWV0cnk+fSBjb21wb25lbnRzIC0g6ZyA6KaB5riF6Zmk55qE5Yeg5L2V5a+56LGh44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IOWFg+e0oOaYr+WQpuiiq+WIoOmZpOOAglxuICAgICAqL1xuICAgIHJlbW92ZUNvbXBvbmVudHMoY29tcG9uZW50cykge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghKFV0aWwuaXNBcnJheShjb21wb25lbnRzKSkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBbY29tcG9uZW50c107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IGNvbXBvbmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSB0aGlzLnJlbW92ZUNvbXBvbmVudChjb21wb25lbnRzW2ldKSB8fCByZW1vdmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZUNvbXBvbmVudFxuICAgICAqIEBkZXNjcmlwdGlvbiDku47pm4blkIjkuK3np7vpmaTlh6DkvZXlr7nosaHjgIJcbiAgICAgKiBAcGFyYW0ge0dlb21ldHJ5fSBjb21wb25lbnQgLSDopoHnp7vpmaTnmoTlh6DkvZXlr7nosaHjgIJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0g5Yeg5L2V5a+56LGh5piv5ZCm56e76Zmk5oiQ5Yqf44CCXG4gICAgICovXG4gICAgcmVtb3ZlQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBVdGlsLnJlbW92ZUl0ZW0odGhpcy5jb21wb25lbnRzLCBjb21wb25lbnQpO1xuXG4gICAgICAgIC8vIGNsZWFyQm91bmRzKCkgc28gdGhhdCBpdCBnZXRzIHJlY2FsY3VsYXRlZCBvbiB0aGUgbmV4dCBjYWxsXG4gICAgICAgIC8vIHRvIHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgICAgIHRoaXMuY2xlYXJCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0QXJlYVxuICAgICAqIEBkZXNjcmlwdGlvbiDorqHnrpflh6DkvZXlr7nosaHnmoTpnaLnp6/jgILms6jmhI/vvIzov5nkuKrmlrnms5XlnKgge0BsaW5rIEdlb21ldHJ5UG9seWdvbn0g57G75Lit6ZyA6KaB6YeN5YaZ44CCXG4gICAgICogQHJldHVybnMge251bWJlcn0g5Yeg5L2V5Zu+5b2i55qE6Z2i56ev77yM5piv5Yeg5L2V5a+56LGh5Lit5omA5pyJ57uE5oiQ6YOo5YiG55qE6Z2i56ev5LmL5ZKM44CCXG4gICAgICovXG4gICAgZ2V0QXJlYSgpIHtcbiAgICAgICAgdmFyIGFyZWEgPSAwLjA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGFyZWEgKz0gdGhpcy5jb21wb25lbnRzW2ldLmdldEFyZWEoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJlYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5lcXVhbHNcbiAgICAgKiBAZGVzY3JpcHRpb24g5Yik5pat5Lik5Liq5Yeg5L2V5Zu+5b2i5piv5ZCm55u4562J44CC5aaC5p6c5omA5pyJ55qEIGNvbXBvbmVudHMg5YW35pyJ55u45ZCM55qE5Z2Q5qCH77yM5YiZ6K6k5Li65piv55u4562J55qE44CCXG4gICAgICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgLSDpnIDopoHliKTmlq3nmoTlh6DkvZXlm77lvaLjgIJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0g6L6T5YWl55qE5Yeg5L2V5Zu+5b2i5LiO5b2T5YmN5Yeg5L2V5Zu+5b2i5piv5ZCm55u4562J44CCXG4gICAgICovXG4gICAgZXF1YWxzKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBlcXVpdmFsZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFnZW9tZXRyeSB8fCAhZ2VvbWV0cnkuQ0xBU1NfTkFNRSB8fFxuICAgICAgICAgICAgKHRoaXMuQ0xBU1NfTkFNRSAhPT0gZ2VvbWV0cnkuQ0xBU1NfTkFNRSkpIHtcbiAgICAgICAgICAgIGVxdWl2YWxlbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghKFV0aWwuaXNBcnJheShnZW9tZXRyeS5jb21wb25lbnRzKSkgfHxcbiAgICAgICAgICAgIChnZW9tZXRyeS5jb21wb25lbnRzLmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGVxdWl2YWxlbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50c1tpXS5lcXVhbHMoZ2VvbWV0cnkuY29tcG9uZW50c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXF1aXZhbGVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVxdWl2YWxlbnQ7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRWZXJ0aWNlc1xuICAgICAqIEBkZXNjcmlwdGlvbiDov5Tlm57lh6DkvZXlr7nosaHnmoTmiYDmnInnu5PngrnnmoTliJfooajjgIJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtub2Rlc10gLSDlr7nkuo7nur/mnaXor7TvvIzku4Xku4Xov5Tlm57kvZzkuLrnq6/ngrnnmoTpobbngrnvvIzlpoLmnpzorr7kuLogZmFsc2XvvIzliJnov5Tlm57pnZ7nq6/ngrnnmoTpobbngrnlpoLmnpzmsqHmnInorr7nva7mraTlj4LmlbDvvIzliJnov5Tlm57miYDmnInpobbngrnjgIJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IOWHoOS9leWvueixoeeahOmhtueCueWIl+ihqOOAglxuICAgICAqL1xuICAgIGdldFZlcnRpY2VzKG5vZGVzKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcywgdGhpcy5jb21wb25lbnRzW2ldLmdldFZlcnRpY2VzKG5vZGVzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfVxuXG59XG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG5pbXBvcnQge0NvbGxlY3Rpb259IGZyb20gJy4vQ29sbGVjdGlvbic7XG5cbi8qKlxuICogQGNsYXNzIEdlb21ldHJ5TXVsdGlQb2ludFxuICogQGFsaWFzY2xhc3MgR2VvbWV0cnkuTXVsdGlQb2ludFxuICogQGRlcHJlY2F0ZWRjbGFzcyBTdXBlck1hcC5HZW9tZXRyeS5NdWx0aVBvaW50XG4gKiBAY2xhc3NkZXNjIOWHoOS9leWvueixoeWkmueCueexu+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBHZW9tZXRyeVxuICogQGV4dGVuZHMgR2VvbWV0cnlDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxHZW9tZXRyeVBvaW50Pn0gY29tcG9uZW50cyAtIOeCueWvueixoeaVsOe7hOOAglxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludDEgPSBuZXcgR2VvbWV0cnlQb2ludCg1LDYpO1xuICogdmFyIHBvaW5lMiA9IG5ldyBHZW9tZXRyeU11bHRpUG9pbnQoNyw4KTtcbiAqIHZhciBtdWx0aVBvaW50ID0gbmV3IE11bHRpUG9pbnQoW3BvaW50MSxwb2ludDJdKTtcbiAqIEB1c2FnZVxuICovXG5leHBvcnQgY2xhc3MgTXVsdGlQb2ludCBleHRlbmRzIENvbGxlY3Rpb24ge1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRzKSB7XG4gICAgICAgIHN1cGVyKGNvbXBvbmVudHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IFtHZW9tZXRyeU11bHRpUG9pbnQucHJvdG90eXBlLmNvbXBvbmVudFR5cGVzPVtcIlN1cGVyTWFwLkdlb21ldHJ5LlBvaW50XCJdXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gY29tcG9uZW50cyDlrZjlgqjnmoTnmoTlh6DkvZXlr7nosaHmiYDmlK/mjIHnmoTlh6DkvZXnsbvlnovmlbDnu4TjgIJcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGVzID0gW1wiU3VwZXJNYXAuR2VvbWV0cnkuUG9pbnRcIl07XG4gICAgICAgIHRoaXMuQ0xBU1NfTkFNRSA9IFwiU3VwZXJNYXAuR2VvbWV0cnkuTXVsdGlQb2ludFwiO1xuICAgICAgICB0aGlzLmdlb21ldHJ5VHlwZSA9IFwiTXVsdGlQb2ludFwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeU11bHRpUG9pbnQucHJvdG90eXBlLmFkZFBvaW50XG4gICAgICogQGRlc2NyaXB0aW9uIOa3u+WKoOeCue+8jOWwgeijheS6hiB7QGxpbmsgR2VvbWV0cnlDb2xsZWN0aW9ufEdlb21ldHJ5Q29sbGVjdGlvbi5hZGRDb21wb25lbnR9IOaWueazleOAglxuICAgICAqIEBwYXJhbSB7R2VvbWV0cnlQb2ludH0gcG9pbnQgLSDmt7vliqDnmoTngrnjgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XSAtIOS4i+agh+OAglxuICAgICAqL1xuICAgIGFkZFBvaW50KHBvaW50LCBpbmRleCkge1xuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChwb2ludCwgaW5kZXgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5TXVsdGlQb2ludC5wcm90b3R5cGUucmVtb3ZlUG9pbnRcbiAgICAgKiBAZGVzY3JpcHRpb24g56e76Zmk54K577yM5bCB6KOF5LqGIHtAbGluayBHZW9tZXRyeUNvbGxlY3Rpb258R2VvbWV0cnlDb2xsZWN0aW9uLnJlbW92ZUNvbXBvbmVudH0g5pa55rOV44CCXG4gICAgICogQHBhcmFtIHtHZW9tZXRyeVBvaW50fSBwb2ludCAtIOenu+mZpOeahOeCueWvueixoeOAglxuICAgICAqL1xuICAgIHJlbW92ZVBvaW50KHBvaW50KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29tcG9uZW50KHBvaW50KTtcbiAgICB9XG5cblxufVxuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBwcm9ncmFtIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xuaW1wb3J0IHtNdWx0aVBvaW50fSBmcm9tICcuL011bHRpUG9pbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBHZW9tZXRyeUN1cnZlXG4gKiBAYWxpYXNjbGFzcyBHZW9tZXRyeS5DdXJ2ZVxuICogQGRlcHJlY2F0ZWRjbGFzcyBTdXBlck1hcC5HZW9tZXRyeS5DdXJ2ZVxuICogQGNsYXNzZGVzYyDlh6DkvZXlr7nosaHmm7Lnur/nsbvjgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgR2VvbWV0cnlcbiAqIEBleHRlbmRzIEdlb21ldHJ5TXVsdGlQb2ludFxuICogQHBhcmFtIHtBcnJheS48R2VvbWV0cnlQb2ludD59IGNvbXBvbmVudHMgLSDlh6DkvZXlr7nosaHmlbDnu4TjgIJcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnQxID0gbmV3IEdlb21ldHJ5UG9pbnQoMTAsMjApO1xuICogdmFyIHBvaW50MiA9IG5ldyBHZW9tZXRyeVBvaW50KDMwLDQwKTtcbiAqIHZhciBjdXJ2ZSA9IG5ldyBDdXJ2ZShbcG9pbnQxLHBvaW50Ml0pO1xuICogQHVzYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBDdXJ2ZSBleHRlbmRzIE11bHRpUG9pbnQge1xuXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cykge1xuICAgICAgICBzdXBlcihjb21wb25lbnRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBbR2VvbWV0cnlDdXJ2ZS5wcm90b3R5cGUuY29tcG9uZW50VHlwZXM9W1wiU3VwZXJNYXAuR2VvbWV0cnkuUG9pbnRcIiwgXCJTdXBlck1hcC5Qb2ludFdpdGhNZWFzdXJlXCJdXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gY29tcG9uZW50cyDlrZjlgqjnmoTnmoTlh6DkvZXlr7nosaHmiYDmlK/mjIHnmoTlh6DkvZXnsbvlnovmlbDnu4TjgIJcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGVzID0gW1wiU3VwZXJNYXAuR2VvbWV0cnkuUG9pbnRcIiwgXCJTdXBlck1hcC5Qb2ludFdpdGhNZWFzdXJlXCJdO1xuICAgICAgICB0aGlzLkNMQVNTX05BTUUgPSBcIlN1cGVyTWFwLkdlb21ldHJ5LkN1cnZlXCI7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnlUeXBlID0gXCJDdXJ2ZVwiO1xuXG4gICAgfVxuXG5cbn1cbiIsIi8qIENvcHlyaWdodMKpIDIwMDAgLSAyMDIyIFN1cGVyTWFwIFNvZnR3YXJlIENvLkx0ZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cbmltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xuaW1wb3J0IHtDdXJ2ZX0gZnJvbSAnLi9DdXJ2ZSc7XG5cbi8qKlxuICogQGNsYXNzIEdlb21ldHJ5TGluZVN0cmluZ1xuICogQGFsaWFzY2xhc3MgR2VvbWV0cnkuTGluZVN0cmluZ1xuICogQGRlcHJlY2F0ZWRjbGFzcyBTdXBlck1hcC5HZW9tZXRyeS5MaW5lU3RyaW5nXG4gKiBAY2xhc3NkZXNjIOWHoOS9leWvueixoee6v+S4suexu+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBHZW9tZXRyeVxuICogQHBhcmFtIHtBcnJheS48R2VvbWV0cnlQb2ludD59IHBvaW50cyAtIOeUqOadpeeUn+aIkOe6v+S4sueahOeCueaVsOe7hOOAglxuICogQGV4dGVuZHMgR2VvbWV0cnlDdXJ2ZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludHMgPSBbbmV3IEdlb21ldHJ5UG9pbnQoNDkzMy4zMTkyODcwMjIzNTIsIC0zMzM3LjM4NDkxNDE1MDIxMjQpLFxuICogICAgIG5ldyBHZW9tZXRyeVBvaW50KDQ5NjAuOTY3NDA2MDE5OTAyMiwgLTMzNDkuMzMxNjMyMjM1NTczNiksXG4gKiAgICAgbmV3IEdlb21ldHJ5UG9pbnQoNTAwNi4wMjM1OTk5NDE4MzY0LCAtMzM1OC44ODkwMDY3MDM4NjI4KSxcbiAqICAgICBuZXcgR2VvbWV0cnlQb2ludCg1MDc1LjMxNDU2NDgzNjkzMTgsIC0zMzc4LjAwMzc1NTY0MDQ0MDkpLFxuICogICAgIG5ldyBHZW9tZXRyeVBvaW50KDUzMDUuMTk1NTE0MzYwMTMsIC0zMzc2Ljk2NjkxMTE3Njg5MjYpXSxcbiAqIHZhciByb2FkTGluZSA9IG5ldyBHZW9tZXRyeUxpbmVTdHJpbmcocG9pbnRzKe+8m1xuICogQHVzYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBMaW5lU3RyaW5nIGV4dGVuZHMgQ3VydmUge1xuXG4gICAgY29uc3RydWN0b3IocG9pbnRzKSB7XG4gICAgICAgIHN1cGVyKHBvaW50cyk7XG4gICAgICAgIHRoaXMuQ0xBU1NfTkFNRSA9IFwiU3VwZXJNYXAuR2VvbWV0cnkuTGluZVN0cmluZ1wiO1xuICAgICAgICB0aGlzLmdlb21ldHJ5VHlwZSA9IFwiTGluZVN0cmluZ1wiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeUxpbmVTdHJpbmcucHJvdG90eXBlLnJlbW92ZUNvbXBvbmVudFxuICAgICAqIEBkZXNjcmlwdGlvbiDlj6rmnInlnKjnur/kuLLkuIrmnInkuInkuKrmiJbmm7TlpJrnmoTngrnnmoTml7blgJnvvIzmiY3kvJrlhYHorrjnp7vpmaTngrnvvIjlkKbliJnnu5PmnpzlsIbkvJrmmK/ljZXkuIDnmoTngrnvvInjgIJcbiAgICAgKiBAcGFyYW0ge0dlb21ldHJ5UG9pbnR9IHBvaW50IC0g5bCG6KKr5Yig6Zmk55qE54K544CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IOWIoOmZpOeahOeCueOAglxuICAgICAqL1xuICAgIHJlbW92ZUNvbXBvbmVudChwb2ludCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5jb21wb25lbnRzICYmICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoID4gMik7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICBzdXBlci5yZW1vdmVDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRTb3J0ZWRTZWdtZW50c1xuICAgICAqIEBkZXNjcmlwdGlvbiDojrflj5bljYfluo/mjpLliJfnmoTngrnlnZDmoIflr7nosaHmlbDnu4TjgIJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IOWNh+W6j+aOkuWIl+eahOeCueWdkOagh+WvueixoeaVsOe7hOOAglxuICAgICAqL1xuICAgIGdldFNvcnRlZFNlZ21lbnRzKCkge1xuICAgICAgICB2YXIgbnVtU2VnID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IG5ldyBBcnJheShudW1TZWcpLCBwb2ludDEsIHBvaW50MjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWc7ICsraSkge1xuICAgICAgICAgICAgcG9pbnQxID0gdGhpcy5jb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgcG9pbnQyID0gdGhpcy5jb21wb25lbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChwb2ludDEueCA8IHBvaW50Mi54KSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHNbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHgxOiBwb2ludDEueCxcbiAgICAgICAgICAgICAgICAgICAgeTE6IHBvaW50MS55LFxuICAgICAgICAgICAgICAgICAgICB4MjogcG9pbnQyLngsXG4gICAgICAgICAgICAgICAgICAgIHkyOiBwb2ludDIueVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICB4MTogcG9pbnQyLngsXG4gICAgICAgICAgICAgICAgICAgIHkxOiBwb2ludDIueSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHBvaW50MS54LFxuICAgICAgICAgICAgICAgICAgICB5MjogcG9pbnQxLnlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gZGVmaW5lIHRoaXMgc29tZXdoZXJlIHN0YXRpY1xuICAgICAgICBmdW5jdGlvbiBieVgxKHNlZzEsIHNlZzIpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWcxLngxIC0gc2VnMi54MTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWdtZW50cy5zb3J0KGJ5WDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeUxpbmVTdHJpbmcucHJvdG90eXBlLmdldFZlcnRpY2VzXG4gICAgICogQGRlc2NyaXB0aW9uIOi/lOWbnuWHoOS9leWbvuW9oueahOaJgOaciemhtueCueeahOWIl+ihqOOAglxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vZGVzXSAtIOWvueS6jue6v+adpeivtO+8jOS7heS7hei/lOWbnuS9nOS4uuerr+eCueeahOmhtueCue+8jOWmguaenOiuvuS4uiBmYWxzZe+8jOWImei/lOWbnumdnuerr+eCueeahOmhtueCueOAguWmguaenOayoeacieiuvue9ruatpOWPguaVsO+8jOWImei/lOWbnuaJgOaciemhtueCueOAglxuICAgICAqIEByZXR1cm5zIHtBcnJheX0g5Yeg5L2V5Zu+5b2i55qE6aG254K55YiX6KGo44CCXG4gICAgICovXG4gICAgZ2V0VmVydGljZXMobm9kZXMpIHtcbiAgICAgICAgdmFyIHZlcnRpY2VzO1xuICAgICAgICBpZiAobm9kZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZlcnRpY2VzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1swXSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5jb21wb25lbnRzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmVydGljZXMgPSB0aGlzLmNvbXBvbmVudHMuc2xpY2UoMSwgdGhpcy5jb21wb25lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVydGljZXMgPSB0aGlzLmNvbXBvbmVudHMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5TGluZVN0cmluZy5jYWxjdWxhdGVDaXJjbGVcbiAgICAgKiBAZGVzY3JpcHRpb24g5LiJ54K555S75ZyG5byn44CCXG4gICAgICogQHBhcmFtIHtBcnJheS48R2VvbWV0cnlQb2ludD59IHBvaW50cyAtIOS8oOWFpeeahOW+heiuoeeul+eahOWIneWni+eCueS4suOAglxuICAgICAqIEByZXR1cm5zIHtBcnJheS48R2VvbWV0cnlQb2ludD59IOiuoeeul+WHuuebuOW6lOeahOWchuW8p+aOp+WItueCueOAglxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvaW50cyA9IFtdO1xuICAgICAqIHBvaW50cy5wdXNoKG5ldyBHZW9tZXRyeVBvaW50KC01MCwzMCkpO1xuICAgICAqIHBvaW50cy5wdXNoKG5ldyBHZW9tZXRyeVBvaW50KC0zMCw1MCkpO1xuICAgICAqIHBvaW50cy5wdXNoKG5ldyBHZW9tZXRyeVBvaW50KDIsNjApKTtcbiAgICAgKiB2YXIgY2lyY2xlID0gR2VvbWV0cnlMaW5lU3RyaW5nLmNhbGN1bGF0ZUNpcmNsZShwb2ludHMpO1xuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVDaXJjbGUocG9pbnRzKSB7XG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50c1xuICAgICAgICB9XG4gICAgICAgIHZhciBjZW50ZXJQb2ludCA9IHt9LFxuICAgICAgICAgICAgcDEgPSBwb2ludHNbMF0sXG4gICAgICAgICAgICBwMiA9IHBvaW50c1sxXSxcbiAgICAgICAgICAgIHAzID0gcG9pbnRzWzJdO1xuICAgICAgICB2YXIgUiA9IDAsXG4gICAgICAgICAgICBkU3RlcCA9IDAsXG4gICAgICAgICAgICBkaXJlYyA9IHRydWUsXG4gICAgICAgICAgICBkUm90YXRpb24gPSAwLFxuICAgICAgICAgICAgZFJvdGF0aW9uQmVnaW4gPSAwLFxuICAgICAgICAgICAgZFJvdGF0aW9uQW5nbGUgPSAwLFxuICAgICAgICAgICAgblNlZ21lbnRDb3VudCA9IDcyLFxuICAgICAgICAgICAgY2lyY2xlUG9pbnRzID0gW107XG5cbiAgICAgICAgdmFyIEtUYW4xMyA9IChwMy55IC0gcDEueSkgLyAocDMueCAtIHAxLngpO1xuICAgICAgICB2YXIgQjEzID0gcDMueSAtIEtUYW4xMyAqIHAzLng7XG4gICAgICAgIGlmICgoKChwMy54ICE9IHAxLngpICYmIChwMy55ICE9IHAxLnkpKSAmJiAocDIueSA9PSBLVGFuMTMgKiBwMi54ICsgQjEzKSkgfHxcbiAgICAgICAgICAgICgocDMueCA9PSBwMS54KSAmJiAocDIueCA9PSBwMS54KSkgfHwgKChwMy55ID09IHAxLnkpICYmIChwMi55ID09IHAxLnkpKSB8fFxuICAgICAgICAgICAgKChwMy54ID09IHAxLngpICYmIChwMy55ID09IHAxLnkpKSB8fCAoKHAzLnggPT0gcDIueCkgJiYgKHAzLnkgPT0gcDIueSkpIHx8ICgocDEueCA9PSBwMi54KSAmJiAocDEueSA9PSBwMi55KSkpIHtcbiAgICAgICAgICAgIGNpcmNsZVBvaW50cy5wdXNoKHAxKTtcbiAgICAgICAgICAgIGNpcmNsZVBvaW50cy5wdXNoKHAyKTtcbiAgICAgICAgICAgIGNpcmNsZVBvaW50cy5wdXNoKHAzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBEID0gKChwMi54ICogcDIueCArIHAyLnkgKiBwMi55KSAtIChwMS54ICogcDEueCArIHAxLnkgKiBwMS55KSkgKiAoMiAqIChwMy55IC0gcDEueSkpIC0gKChwMy54ICogcDMueCArIHAzLnkgKiBwMy55KSAtXG4gICAgICAgICAgICAgICAgKHAxLnggKiBwMS54ICsgcDEueSAqIHAxLnkpKSAqICgyICogKHAyLnkgLSBwMS55KSk7XG4gICAgICAgICAgICB2YXIgRSA9ICgyICogKHAyLnggLSBwMS54KSkgKiAoKHAzLnggKiBwMy54ICsgcDMueSAqIHAzLnkpIC0gKHAxLnggKiBwMS54ICsgcDEueSAqIHAxLnkpKSAtXG4gICAgICAgICAgICAgICAgKDIgKiAocDMueCAtIHAxLngpKSAqICgocDIueCAqIHAyLnggKyBwMi55ICogcDIueSkgLSAocDEueCAqIHAxLnggKyBwMS55ICogcDEueSkpO1xuICAgICAgICAgICAgdmFyIEYgPSA0ICogKChwMi54IC0gcDEueCkgKiAocDMueSAtIHAxLnkpIC0gKHAzLnggLSBwMS54KSAqIChwMi55IC0gcDEueSkpO1xuICAgICAgICAgICAgY2VudGVyUG9pbnQueCA9IEQgLyBGO1xuICAgICAgICAgICAgY2VudGVyUG9pbnQueSA9IEUgLyBGO1xuICAgICAgICAgICAgUiA9IE1hdGguc3FydCgocDEueCAtIGNlbnRlclBvaW50LngpICogKHAxLnggLSBjZW50ZXJQb2ludC54KSArIChwMS55IC0gY2VudGVyUG9pbnQueSkgKiAocDEueSAtIGNlbnRlclBvaW50LnkpKTtcblxuICAgICAgICAgICAgdmFyIGRpcyA9IChwMS54IC0gcDMueCkgKiAocDEueCAtIHAzLngpICsgKHAxLnkgLSBwMy55KSAqIChwMS55IC0gcDMueSk7XG4gICAgICAgICAgICB2YXIgY29ucyA9ICgyICogUiAqIFIgLSBkaXMpIC8gKDIgKiBSICogUik7XG4gICAgICAgICAgICBjb25zID0gY29ucyA+PSAxID8gMSA6IGNvbnM7XG4gICAgICAgICAgICBjb25zID0gY29ucyA8PSAtMSA/IC0xIDogY29ucztcbiAgICAgICAgICAgIGRSb3RhdGlvbkFuZ2xlID0gTWF0aC5hY29zKGNvbnMpICogMTgwIC8gTWF0aC5QSTtcblxuICAgICAgICAgICAgaWYgKHAzLnggPT0gcDEueCkge1xuICAgICAgICAgICAgICAgIGRSb3RhdGlvbkFuZ2xlID0gKChjZW50ZXJQb2ludC54ID4gcDEueCAmJiBwMi54ID4gcDEueCkgfHwgKGNlbnRlclBvaW50LnggPCBwMS54ICYmIHAyLnggPCBwMS54KSkgPyAoMzYwIC0gZFJvdGF0aW9uQW5nbGUpIDogZFJvdGF0aW9uQW5nbGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRSb3RhdGlvbkFuZ2xlID0gKChjZW50ZXJQb2ludC55ID4gKEtUYW4xMyAqIGNlbnRlclBvaW50LnggKyBCMTMpICYmIHAyLnkgPiAoS1RhbjEzICogcDIueCArIEIxMykpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjZW50ZXJQb2ludC55IDwgKEtUYW4xMyAqIGNlbnRlclBvaW50LnggKyBCMTMpICYmIHAyLnkgPCAoS1RhbjEzICogcDIueCArIEIxMykpKSA/ICgzNjAgLSBkUm90YXRpb25BbmdsZSkgOiBkUm90YXRpb25BbmdsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRTdGVwID0gZFJvdGF0aW9uQW5nbGUgLyA3MjtcblxuICAgICAgICAgICAgaWYgKHAzLnkgIT0gcDEueSkge1xuICAgICAgICAgICAgICAgIGlmIChwMy54ID09IHAxLngpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAzLnkgPiBwMS55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocDIueCA8IHAxLngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAyLnggPiBwMS54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocDMueCA8IHAxLngpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAyLnkgPCBLVGFuMTMgKiBwMi54ICsgQjEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAyLnkgPiBLVGFuMTMgKiBwMi54ICsgQjEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocDMueCA+IHAxLngpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAyLnkgPiBwMS55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAyLnkgPCBwMS55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgSzEwID0gKHAxLnkgLSBjZW50ZXJQb2ludC55KSAvIChwMS54IC0gY2VudGVyUG9pbnQueCk7XG4gICAgICAgICAgICB2YXIgYXRhbjEwID0gSzEwID49IDAgPyBNYXRoLmF0YW4oSzEwKSAqIDE4MCAvIE1hdGguUEkgOiBNYXRoLmFicyhNYXRoLmF0YW4oSzEwKSAqIDE4MCAvIE1hdGguUEkpICsgOTA7XG5cbiAgICAgICAgICAgIHZhciBDWSA9IE1hdGguYWJzKGNlbnRlclBvaW50LnkpO1xuICAgICAgICAgICAgaWYgKChwMS55ID09IENZKSAmJiAoQ1kgPT0gcDMueSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocDEueCA8IHAzLngpIHtcbiAgICAgICAgICAgICAgICAgICAgYXRhbjEwID0gYXRhbjEwICsgMTgwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5ld1BZID0gcDEueSAtIGNlbnRlclBvaW50Lnk7XG4gICAgICAgICAgICBjaXJjbGVQb2ludHMucHVzaChwMSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG5TZWdtZW50Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGRSb3RhdGlvbiA9IGRTdGVwICogaTtcbiAgICAgICAgICAgICAgICBkUm90YXRpb25CZWdpbiA9IGF0YW4xMDtcblxuICAgICAgICAgICAgICAgIGlmIChkaXJlYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3UFkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEsxMCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZFJvdGF0aW9uQmVnaW4gPSBkUm90YXRpb25CZWdpbiArIGRSb3RhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZFJvdGF0aW9uQmVnaW4gPSAoMTgwIC0gKGRSb3RhdGlvbkJlZ2luIC0gOTApKSArIGRSb3RhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChLMTAgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZFJvdGF0aW9uQmVnaW4gPSAoZFJvdGF0aW9uQmVnaW4gLSAxODApICsgZFJvdGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkUm90YXRpb25CZWdpbiA9ICg5MCAtIGRSb3RhdGlvbkJlZ2luKSArIGRSb3RhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdQWSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSzEwID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkUm90YXRpb25CZWdpbiA9IGRSb3RhdGlvbkJlZ2luIC0gZFJvdGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkUm90YXRpb25CZWdpbiA9ICgxODAgLSAoZFJvdGF0aW9uQmVnaW4gLSA5MCkpIC0gZFJvdGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEsxMCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZFJvdGF0aW9uQmVnaW4gPSAoZFJvdGF0aW9uQmVnaW4gLSAxODApIC0gZFJvdGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkUm90YXRpb25CZWdpbiA9ICg5MCAtIGRSb3RhdGlvbkJlZ2luKSAtIGRSb3RhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRSb3RhdGlvbkJlZ2luID0gZFJvdGF0aW9uQmVnaW4gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gY2VudGVyUG9pbnQueCArIFIgKiBNYXRoLmNvcyhkUm90YXRpb25CZWdpbik7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBjZW50ZXJQb2ludC55ICsgUiAqIE1hdGguc2luKGRSb3RhdGlvbkJlZ2luKTtcbiAgICAgICAgICAgICAgICBjaXJjbGVQb2ludHMucHVzaChuZXcgUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2lyY2xlUG9pbnRzLnB1c2gocDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaXJjbGVQb2ludHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5TGluZVN0cmluZy5jcmVhdGVMaW5lRVBTXG4gICAgICogQGRlc2NyaXB0aW9uIOagueaNrueCueeahOexu+Wei+eUu+WHuuS4jeWQjOexu+Wei+eahOabsue6v+OAglxuICAgICAqIOeCueeahOexu+Wei+acieS4ieenje+8mkxUeXBlQXJj77yMTFR5cGVDdXJ2Ze+8jE5PTkXjgIJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxHZW9tZXRyeVBvaW50Pn0gcG9pbnRzIC0g5Lyg5YWl55qE5b6F6K6h566X55qE5Yid5aeL54K55Liy44CCXG4gICAgICogQHJldHVybnMge0FycmF5LjxHZW9tZXRyeVBvaW50Pn0g6K6h566X5Ye655u45bqU55qEIGxpbmVFUFMg5o6n5Yi254K544CCXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9pbnRzID0gW107XG4gICAgICogcG9pbnRzLnB1c2gobmV3IEdlb21ldHJ5UG9pbnQoLTUwLDMwKSk7XG4gICAgICogcG9pbnRzLnB1c2gobmV3IEdlb21ldHJ5UG9pbnQoLTMwLDUwLFwiTFR5cGVBcmNcIikpO1xuICAgICAqIHBvaW50cy5wdXNoKG5ldyBHZW9tZXRyeVBvaW50KDIsNjApKTtcbiAgICAgKiBwb2ludHMucHVzaChuZXcgR2VvbWV0cnlQb2ludCg4LDIwKSk7XG4gICAgICogdmFyIGxpbmVFUFMgPSBHZW9tZXRyeUxpbmVTdHJpbmcuY3JlYXRlTGluZUVQUyhwb2ludHMpO1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVMaW5lRVBTKHBvaW50cykge1xuICAgICAgICB2YXIgbGlzdCA9IFtdLFxuICAgICAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHBvaW50c1tpXS50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ0xUeXBlQXJjJykge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0T2JqID0gTGluZVN0cmluZy5jcmVhdGVMaW5lQXJjKGxpc3QsIGksIGxlbiwgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdE9ialswXTtcbiAgICAgICAgICAgICAgICBpID0gbGlzdE9ialsxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHBvaW50c1tpXSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVMaW5lQXJjKGxpc3QsIGksIGxlbiwgcG9pbnRzKSB7XG4gICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgIGxldCBiZXppZXJQdHNPYmogPSBMaW5lU3RyaW5nLmFkZFBvaW50RVBTKHBvaW50cywgaSwgbGVuLCAnTFR5cGVBcmMnKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3QsIGJlemllclB0c09ialswXSk7XG4gICAgICAgICAgICBpID0gYmV6aWVyUHRzT2JqWzFdICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChpID09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIHZhciBiZXppZXJQID0gW3BvaW50c1tpIC0gMV0sIHBvaW50c1tpXV0sXG4gICAgICAgICAgICAgICAgYmV6aWVyUHRzID0gTGluZVN0cmluZy5jYWxjdWxhdGVDaXJjbGUoYmV6aWVyUCk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0LCBiZXppZXJQdHMpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJlemllclB0c09iaiA9IExpbmVTdHJpbmcuYWRkUG9pbnRFUFMocG9pbnRzLCBpLCBsZW4sICdMVHlwZUFyYycpO1xuICAgICAgICAgICAgbGlzdC5wb3AoKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3QsIGJlemllclB0c09ialswXSk7XG4gICAgICAgICAgICBpID0gYmV6aWVyUHRzT2JqWzFdICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2xpc3QsIGldO1xuICAgIH1cblxuICAgIHN0YXRpYyBhZGRQb2ludEVQUyhwb2ludHMsIGksIGxlbiwgdHlwZSkge1xuICAgICAgICB2YXIgYmV6aWVyUCA9IFtdLCBqID0gaSArIDE7XG4gICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJlemllclAsIFtwb2ludHNbaV0sIHBvaW50c1tpICsgMV1dKTtcbiAgICAgICAgfSBlbHNlIGlmIChpID09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJlemllclAsIFtwb2ludHNbaSAtIDFdLCBwb2ludHNbaV1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJlemllclAsIFtwb2ludHNbaSAtIDFdLCBwb2ludHNbaV0sIHBvaW50c1tpICsgMV1dKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmV6aWVyUHRzO1xuICAgICAgICBpZiAodHlwZSA9PSAnTFR5cGVDdXJ2ZScpIHtcbiAgICAgICAgICAgIGJlemllclB0cyA9IExpbmVTdHJpbmcuY2FsY3VsYXRlUG9pbnRzRkJaTihiZXppZXJQKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdMVHlwZUFyYycpIHtcbiAgICAgICAgICAgIGJlemllclB0cyA9IExpbmVTdHJpbmcuY2FsY3VsYXRlQ2lyY2xlKGJlemllclApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYmV6aWVyUHRzLCBqXTtcbiAgICB9XG59XG5cblxuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBwcm9ncmFtIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xuaW1wb3J0IHtMaW5lU3RyaW5nfSBmcm9tICcuL0xpbmVTdHJpbmcnO1xuXG4vKipcbiAqIEBjbGFzcyAgR2VvbWV0cnlMaW5lYXJSaW5nXG4gKiBAYWxpYXNjbGFzcyBHZW9tZXRyeS5MaW5lYXJSaW5nXG4gKiBAZGVwcmVjYXRlZGNsYXNzIFN1cGVyTWFwLkdlb21ldHJ5LkxpbmVhclJpbmdcbiAqIEBjbGFzc2Rlc2Mg5Yeg5L2V5a+56LGh57q/546v57G777yM5piv5LiA5Liq54m55q6K55qE5bCB6Zet55qE57q/5Liy77yM5Zyo5q+P5qyhIGFkZFBvaW50L3JlbW92ZVBvaW50IOS5i+WQjuS8mumAmui/h+a3u+WKoOS4gOS4queCue+8iOatpOeCueaYr+WkjeWItueahOesrOS4gOS4queCueW+l+WIsOeahO+8iVxuICog5L2c5Li65pyA5ZCO55qE5LiA5Liq54K55p2l6Ieq5Yqo5YWz6Zet57q/546v44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIEdlb21ldHJ5XG4gKiBAZXh0ZW5kcyBHZW9tZXRyeUxpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXkuPEdlb21ldHJ5UG9pbnQ+fSBwb2ludHMgLSDnu4TmiJDnur/mgKfnjq/nmoTngrnjgIJcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnRzID0gW25ldyBHZW9tZXRyeVBvaW50KDQ5MzMuMzE5Mjg3MDIyMzUyLCAtMzMzNy4zODQ5MTQxNTAyMTI0KSxcbiAqICAgICAgbmV3IEdlb21ldHJ5UG9pbnQoNDk2MC45Njc0MDYwMTk5MDIyLCAtMzM0OS4zMzE2MzIyMzU1NzM2KSxcbiAqICAgICAgbmV3IEdlb21ldHJ5UG9pbnQoNTAwNi4wMjM1OTk5NDE4MzY0LCAtMzM1OC44ODkwMDY3MDM4NjI4KSxcbiAqICAgICAgbmV3IEdlb21ldHJ5UG9pbnQoNTA3NS4zMTQ1NjQ4MzY5MzE4LCAtMzM3OC4wMDM3NTU2NDA0NDA5KSxcbiAqICAgICAgbmV3IEdlb21ldHJ5UG9pbnQoNTMwNS4xOTU1MTQzNjAxMywgLTMzNzYuOTY2OTExMTc2ODkyNildLFxuICogdmFyIGxpbmVhclJpbmcgPSBuZXcgR2VvbWV0cnlMaW5lYXJSaW5nKHBvaW50cyk7XG4gKiBAdXNhZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIExpbmVhclJpbmcgZXh0ZW5kcyBMaW5lU3RyaW5nIHtcblxuXG4gICAgY29uc3RydWN0b3IocG9pbnRzKSB7XG4gICAgICAgIHN1cGVyKHBvaW50cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48c3RyaW5nPn0gW0dlb21ldHJ5TGluZWFyUmluZy5wcm90b3R5cGUuY29tcG9uZW50VHlwZXM9W1wiU3VwZXJNYXAuR2VvbWV0cnkuUG9pbnRcIl1dXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBjb21wb25lbnRzIOWtmOWCqOeahOeahOWHoOS9leWvueixoeaJgOaUr+aMgeeahOWHoOS9leexu+Wei+aVsOe7hO+8jOS4uuepuuihqOekuuexu+Wei+S4jeWPl+mZkOWItuOAglxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcG9uZW50VHlwZXMgPSBbXCJTdXBlck1hcC5HZW9tZXRyeS5Qb2ludFwiXTtcbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gXCJTdXBlck1hcC5HZW9tZXRyeS5MaW5lYXJSaW5nXCI7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnlUeXBlID0gXCJMaW5lYXJSaW5nXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5TGluZWFyUmluZy5wcm90b3R5cGUuYWRkQ29tcG9uZW50XG4gICAgICogQGRlc2NyaXB0aW9uIOa3u+WKoOS4gOS4queCueWIsOWHoOS9leWbvuW9ouaVsOe7hOS4re+8jOWmguaenOi/meS4queCueWwhuimgeiiq+a3u+WKoOWIsOe7hOS7tuaVsOe7hOeahOacq+err++8jOW5tuS4lOS4juaVsOe7hOS4reW3sue7j+WtmOWcqOeahOacgOWQjuS4gOS4queCueebuOWQjO+8jFxuICAgICAqIOmHjeWkjeeahOeCueaYr+S4jeiDveiiq+a3u+WKoOeahOOAgui/meWwhuW9seWTjeacquWFs+mXreeOr+eahOWFs+mXreOAglxuICAgICAqIOi/meS4quaWueazleWPr+S7pemAmui/h+Wwhumdnuepuue0ouW8le+8iOe7hOS7tuaVsOe7hOeahOS4i+agh++8ieS9nOS4uuesrOS6jOS4quWPguaVsOmHjeWGmeOAglxuICAgICAqIEBwYXJhbSB7R2VvbWV0cnlQb2ludH0gcG9pbnQgLSDngrnlr7nosaHjgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XSAtIOaPkuWFpee7hOS7tuaVsOe7hOeahOS4i+agh+OAglxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDngrnlr7nosaHmmK/lkKbmt7vliqDmiJDlip/jgIJcbiAgICAgKi9cbiAgICBhZGRDb21wb25lbnQocG9pbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBhZGRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vcmVtb3ZlIGxhc3QgcG9pbnRcbiAgICAgICAgdmFyIGxhc3RQb2ludCA9IHRoaXMuY29tcG9uZW50cy5wb3AoKTtcblxuICAgICAgICAvLyBnaXZlbiBhbiBpbmRleCwgYWRkIHRoZSBwb2ludFxuICAgICAgICAvLyB3aXRob3V0IGFuIGluZGV4IG9ubHkgYWRkIG5vbi1kdXBsaWNhdGUgcG9pbnRzXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsIHx8ICFwb2ludC5lcXVhbHMobGFzdFBvaW50KSkge1xuICAgICAgICAgICAgYWRkZWQgPSBzdXBlci5hZGRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYXBwZW5kIGNvcHkgb2YgZmlyc3QgcG9pbnRcbiAgICAgICAgdmFyIGZpcnN0UG9pbnQgPSB0aGlzLmNvbXBvbmVudHNbMF07XG4gICAgICAgIHN1cGVyLmFkZENvbXBvbmVudC5hcHBseSh0aGlzLCBbZmlyc3RQb2ludF0pO1xuXG4gICAgICAgIHJldHVybiBhZGRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlMaW5lYXJSaW5nLnByb3RvdHlwZS5yZW1vdmVDb21wb25lbnRcbiAgICAgKiBAZGVzY3JpcHRpb24g5LuO5Yeg5L2V57uE5Lu25Lit5Yig6Zmk5LiA5Liq54K544CCXG4gICAgICogQHBhcmFtIHtHZW9tZXRyeVBvaW50fSBwb2ludCAtIOeCueWvueixoeOAglxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDngrnlr7nosaHmmK/lkKbliKDpmaTjgIJcbiAgICAgKi9cbiAgICByZW1vdmVDb21wb25lbnQocG9pbnQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuY29tcG9uZW50cyAmJiAodGhpcy5jb21wb25lbnRzLmxlbmd0aCA+IDMpO1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgLy9yZW1vdmUgbGFzdCBwb2ludFxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnBvcCgpO1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBvdXIgcG9pbnRcbiAgICAgICAgICAgIHN1cGVyLnJlbW92ZUNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy9hcHBlbmQgY29weSBvZiBmaXJzdCBwb2ludFxuICAgICAgICAgICAgdmFyIGZpcnN0UG9pbnQgPSB0aGlzLmNvbXBvbmVudHNbMF07XG4gICAgICAgICAgICBzdXBlci5hZGRDb21wb25lbnQuYXBwbHkodGhpcywgW2ZpcnN0UG9pbnRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvbWV0cnlMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRBcmVhXG4gICAgICogQGRlc2NyaXB0aW9uIOiOt+W+l+W9k+WJjeWHoOS9leWvueixoeWMuuWfn+Wkp+Wwj++8jOWmguaenOaYr+ayv+mhuuaXtumSiOaWueWQkeeahOeOr+WImeaYr+ato+WAvO+8jOWQpuWImeS4uui0n+WAvOOAglxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IOeOr+eahOmdouenr+OAglxuICAgICAqL1xuICAgIGdldEFyZWEoKSB7XG4gICAgICAgIHZhciBhcmVhID0gMC4wO1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzICYmICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoID4gMikpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwLjA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5jb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jb21wb25lbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzdW0gKz0gKGIueCArIGMueCkgKiAoYy55IC0gYi55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZWEgPSAtc3VtIC8gMi4wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmVhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9tZXRyeUxpbmVhclJpbmcucHJvdG90eXBlLmdldFZlcnRpY2VzXG4gICAgICogQGRlc2NyaXB0aW9uIOi/lOWbnuWHoOS9leWbvuW9oueahOaJgOacieeCueeahOWIl+ihqOOAglxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vZGVzXSAtIOWvueS6jue6v+adpeivtO+8jOS7heS7hei/lOWbnuS9nOS4uuerr+eCueeahOmhtueCue+8jOWmguaenOiuvuS4uiBmYWxzZSDvvIzliJnov5Tlm57pnZ7nq6/ngrnnmoTpobbngrnvvIzlpoLmnpzmsqHmnInorr7nva7mraTlj4LmlbDvvIzliJnov5Tlm57miYDmnInpobbngrnjgIJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IOWHoOS9leWvueixoeaJgOacieeCueeahOWIl+ihqOOAglxuICAgICAqL1xuICAgIGdldFZlcnRpY2VzKG5vZGVzKSB7XG4gICAgICAgIHJldHVybiAobm9kZXMgPT09IHRydWUpID8gW10gOiB0aGlzLmNvbXBvbmVudHMuc2xpY2UoMCwgdGhpcy5jb21wb25lbnRzLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuXG59XG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG5pbXBvcnQge0NvbGxlY3Rpb259IGZyb20gJy4vQ29sbGVjdGlvbic7XG5pbXBvcnQgJy4vTGluZVN0cmluZyc7XG5cblxuLyoqXG4gKiBAY2xhc3MgR2VvbWV0cnlNdWx0aUxpbmVTdHJpbmdcbiAqIEBhbGlhc2NsYXNzIEdlb21ldHJ5Lk11bHRpTGluZVN0cmluZ1xuICogQGRlcHJlY2F0ZWRjbGFzcyBTdXBlck1hcC5HZW9tZXRyeS5NdWx0aUxpbmVTdHJpbmdcbiAqIEBjbGFzc2Rlc2Mg5Yeg5L2V5a+56LGh5aSa57q/57G744CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIEdlb21ldHJ5XG4gKiBAZXh0ZW5kcyBHZW9tZXRyeUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXkuPEdlb21ldHJ5TGluZVN0cmluZz59IGNvbXBvbmVudHMgLSBHZW9tZXRyeUxpbmVTdHJpbmcg5pWw57uE44CCXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpID0gbmV3IEdlb21ldHJ5TXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgICAgbmV3IEdlb21ldHJ5TGluZVN0cmluZyhbXG4gKiAgICAgICAgICBuZXcgR2VvbWV0cnlQb2ludCgxLCAwKSxcbiAqICAgICAgICAgIG5ldyBHZW9tZXRyeVBvaW50KDAsIDEpXG4gKiAgICAgIF0pXG4gKiAgXSk7XG4gKiBAdXNhZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpTGluZVN0cmluZyBleHRlbmRzIENvbGxlY3Rpb24ge1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRzKSB7XG4gICAgICAgIHN1cGVyKGNvbXBvbmVudHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IFtHZW9tZXRyeU11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuY29tcG9uZW50VHlwZXM9W1wiU3VwZXJNYXAuR2VvbWV0cnkuTGluZVN0cmluZ1wiXV1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIGNvbXBvbmVudHMg5a2Y5YKo55qE55qE5Yeg5L2V5a+56LGh5omA5pSv5oyB55qE5Yeg5L2V57G75Z6L5pWw57uE44CCXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlcyA9IFtcIlN1cGVyTWFwLkdlb21ldHJ5LkxpbmVTdHJpbmdcIl07XG4gICAgICAgIHRoaXMuQ0xBU1NfTkFNRSA9IFwiU3VwZXJNYXAuR2VvbWV0cnkuTXVsdGlMaW5lU3RyaW5nXCI7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnlUeXBlID0gXCJNdWx0aUxpbmVTdHJpbmdcIjtcbiAgICB9XG5cblxufVxuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBwcm9ncmFtIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xuaW1wb3J0IHtDb2xsZWN0aW9ufSBmcm9tICcuL0NvbGxlY3Rpb24nO1xuaW1wb3J0ICcuL1BvaW50JztcbmltcG9ydCAnLi9MaW5lU3RyaW5nJztcbmltcG9ydCAnLi9MaW5lYXJSaW5nJztcblxuLyoqXG4gKiBAY2xhc3MgR2VvbWV0cnlQb2x5Z29uXG4gKiBAYWxpYXNjbGFzcyBHZW9tZXRyeS5Qb2x5Z29uXG4gKiBAZGVwcmVjYXRlZGNsYXNzIFN1cGVyTWFwLkdlb21ldHJ5LlBvbHlnb25cbiAqIEBjbGFzc2Rlc2MgIOWkmui+ueW9ouWHoOS9leWvueixoeexu+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBHZW9tZXRyeVxuICogQGV4dGVuZHMgR2VvbWV0cnlDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxHZW9tZXRyeUxpbmVhclJpbmc+fSBjb21wb25lbnRzIC0g5aSa6L655b2i55qE57q/546v5pWw57uE44CCXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9W25ldyBHZW9tZXRyeVBvaW50KDAsNDAxMDMzOCksXG4gKiAgICAgIG5ldyBHZW9tZXRyeVBvaW50KDEwNjM1MjQsNDAxMDMzOCksXG4gKiAgICAgIG5ldyBHZW9tZXRyeVBvaW50KDEwNjM1MjQsMzE1MDMyMiksXG4gKiAgICAgIG5ldyBHZW9tZXRyeVBvaW50KDAsMzE1MDMyMilcbiAqICBdLFxuICogIHZhciBsaW5lYXJSaW5ncyA9IG5ldyBHZW9tZXRyeUxpbmVhclJpbmcocG9pbnRzKSxcbiAqICB2YXIgIHJlZ2lvbiA9IG5ldyBHZW9tZXRyeVBvbHlnb24oW2xpbmVhclJpbmdzXSk7XG4gKiBAdXNhZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbHlnb24gZXh0ZW5kcyBDb2xsZWN0aW9uIHtcblxuXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cykge1xuICAgICAgICBzdXBlcihjb21wb25lbnRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBbR2VvbWV0cnlQb2x5Z29uLnByb3RvdHlwZS5jb21wb25lbnRUeXBlcz1bXCJTdXBlck1hcC5HZW9tZXRyeS5MaW5lYXJSaW5nXCJdXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gY29tcG9uZW50cyDlrZjlgqjnmoTnmoTlh6DkvZXlr7nosaHmiYDmlK/mjIHnmoTlh6DkvZXnsbvlnovmlbDnu4TjgIJcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGVzID0gW1wiU3VwZXJNYXAuR2VvbWV0cnkuTGluZWFyUmluZ1wiXTtcbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gXCJTdXBlck1hcC5HZW9tZXRyeS5Qb2x5Z29uXCI7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnlUeXBlID0gXCJQb2x5Z29uXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb21ldHJ5TXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0QXJlYVxuICAgICAqIEBkZXNjcmlwdGlvbiDojrflvpfljLrln5/pnaLnp6/vvIzku47ljLrln5/nmoTlpJbpg6jlj6PlvoTlh4/ljrvorqHmraTljLrln5/lhoXpg6jlj6PlvoTnrpfmiYDlvpfnmoTpnaLnp6/jgIJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSDlh6DkvZXlr7nosaHnmoTpnaLnp6/jgIJcbiAgICAgKi9cbiAgICBnZXRBcmVhKCkge1xuICAgICAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cyAmJiAodGhpcy5jb21wb25lbnRzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICBhcmVhICs9IE1hdGguYWJzKHRoaXMuY29tcG9uZW50c1swXS5nZXRBcmVhKCkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHRoaXMuY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZWEgLT0gTWF0aC5hYnModGhpcy5jb21wb25lbnRzW2ldLmdldEFyZWEoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfVxuXG5cbn1cbiIsIi8qIENvcHlyaWdodMKpIDIwMDAgLSAyMDIyIFN1cGVyTWFwIFNvZnR3YXJlIENvLkx0ZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cbmltcG9ydCB7Q29sbGVjdGlvbn0gZnJvbSAnLi9Db2xsZWN0aW9uJztcblxuLyoqXG4gKiBAY2xhc3MgR2VvbWV0cnlNdWx0aVBvbHlnb25cbiAqIEBhbGlhc2NsYXNzIEdlb21ldHJ5Lk11bHRpUG9seWdvblxuICogQGRlcHJlY2F0ZWRjbGFzcyBTdXBlck1hcC5HZW9tZXRyeS5NdWx0aVBvbHlnb25cbiAqIEBjbGFzc2Rlc2Mg5Yeg5L2V5a+56LGh5aSa5aSa6L655b2i57G744CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIEdlb21ldHJ5XG4gKiBAZXh0ZW5kcyBHZW9tZXRyeUNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0FycmF5LjxHZW9tZXRyeVBvbHlnb24+fSBjb21wb25lbnRzIC0g5b2i5oiQIEdlb21ldHJ5TXVsdGlQb2x5Z29uIOeahOWkmui+ueW9ouaVsOe7hOOAglxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludHMxID0gW25ldyBHZW9tZXRyeVBvaW50KDEwLDEwKSxuZXcgR2VvbWV0cnlQb2ludCgwLDApXTtcbiAqIHZhciBwb2ludHMyID0gW25ldyBHZW9tZXRyeVBvaW50KDEwLDEwKSxuZXcgR2VvbWV0cnlQb2ludCgwLDApLG5ldyBHZW9tZXRyeVBvaW50KDMsMyksbmV3IEdlb21ldHJ5UG9pbnQoMTAsMTApXTtcbiAqXG4gKiB2YXIgbGluZWFyUmluZzEgPSBuZXcgR2VvbWV0cnlMaW5lYXJSaW5nKHBvaW50czEpO1xuICogdmFyIGxpbmVhclJpbmcyID0gbmV3IEdlb21ldHJ5TGluZWFyUmluZyhwb2ludHMyKTtcbiAqXG4gKiB2YXIgcG9seWdvbjEgPSBuZXcgR2VvbWV0cnlQb2x5Z29uKFtsaW5lYXJSaW5nMV0pO1xuICogdmFyIHBvbHlnb24yID0gbmV3IEdlb21ldHJ5UG9seWdvbihbbGluZWFyUmluZzJdKTtcbiAqXG4gKiB2YXIgbXVsdGlQb2x5Z29uMSA9IG5ldyBHZW9tZXRyeU11bHRpUG9seWdvbihbcG9seWdvbjEscG9seWdvbjJdKTtcbiAqIEB1c2FnZVxuICovXG5leHBvcnQgY2xhc3MgTXVsdGlQb2x5Z29uIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG5cblxuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudHMpIHtcbiAgICAgICAgc3VwZXIoY29tcG9uZW50cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48c3RyaW5nPn0gW0dlb21ldHJ5TXVsdGlQb2x5Z29uLnByb3RvdHlwZS5jb21wb25lbnRUeXBlcz1bXCJTdXBlck1hcC5HZW9tZXRyeS5Qb2x5Z29uXCJdXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gY29tcG9uZW50cyDlrZjlgqjnmoTnmoTlh6DkvZXlr7nosaHmiYDmlK/mjIHnmoTlh6DkvZXnsbvlnovmlbDnu4TjgIJcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGVzID0gW1wiU3VwZXJNYXAuR2VvbWV0cnkuUG9seWdvblwiXTtcbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gXCJTdXBlck1hcC5HZW9tZXRyeS5NdWx0aVBvbHlnb25cIjtcbiAgICAgICAgdGhpcy5nZW9tZXRyeVR5cGUgPSBcIk11bHRpUG9seWdvblwiO1xuICAgIH1cblxuXG59XG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG5cbi8qKlxuICogQGNsYXNzIFNlcnZlckNvbG9yXG4gKiBAZGVwcmVjYXRlZGNsYXNzIFN1cGVyTWFwLlNlcnZlckNvbG9yXG4gKiBAY2F0ZWdvcnkgaVNlcnZlciBNYXAgVGhlbWVcbiAqIEBjbGFzc2Rlc2Mg6aKc6Imy57G744CC6K+l57G75L2/55So5LiJ5Y6f6Imy77yIIFJHQiDvvInmnaXooajovr7popzoibLjgIJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0g5Y+v6YCJ5Y+C5pWw44CCXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVkPTI1NV0gLSDojrflj5bmiJborr7nva7nuqLoibLlgLzjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ncmVlbj0wXSAtIOiOt+WPluaIluiuvue9rue7v+iJsuWAvOOAglxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJsdWU9MF0gLSDojrflj5bmiJborr7nva7ok53oibLlgLzjgIJcbiAqIEB1c2FnZVxuICovXG5leHBvcnQgY2xhc3MgU2VydmVyQ29sb3Ige1xuXG4gICAgY29uc3RydWN0b3IocmVkLCBncmVlbiwgYmx1ZSkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFtTZXJ2ZXJDb2xvci5wcm90b3R5cGUucmVkPTI1NV1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOiOt+WPluaIluiuvue9rue6ouiJsuWAvOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWQgPSAoIXJlZCAmJiByZWQgIT0gMCk/MjU1OnJlZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBbU2VydmVyQ29sb3IucHJvdG90eXBlLmdyZWVuPTBdXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDojrflj5bmiJborr7nva7nu7/oibLlgLzjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JlZW4gPSBncmVlbnx8MDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBbU2VydmVyQ29sb3IucHJvdG90eXBlLmJsdWU9MF1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOiOt+WPluaIluiuvue9ruiTneiJsuWAvOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibHVlID0gYmx1ZXx8MDtcblxuICAgICAgICB0aGlzLkNMQVNTX05BTUUgPSBcIlN1cGVyTWFwLlNlcnZlckNvbG9yXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFNlcnZlckNvbG9yLnByb3RvdHlwZS5kZXN0cm95XG4gICAgICogQGRlc2NyaXB0aW9uIOmHiuaUvui1hOa6kO+8jOWwhuW8leeUqOi1hOa6kOeahOWxnuaAp+e9ruepuuOAglxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnJlZCA9IG51bGw7XG4gICAgICAgIG1lLmdyZWVuID0gbnVsbDtcbiAgICAgICAgbWUuYmx1ZSA9IG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU2VydmVyQ29sb3IuZm9ybUpzb25cbiAgICAgKiBAZGVzY3JpcHRpb24g5bCGIEpTT04g5a+56LGh6L2s5YyW5Li6IFNlcnZlckNvbG9yIOWvueixoeOAglxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uT2JqZWN0IC0g6KaB6L2s5o2i55qEIEpTT04g5a+56LGh44CCXG4gICAgICogQHJldHVybnMge1NlcnZlckNvbG9yfSDovazljJblkI7nmoQgU2VydmVyQ29sb3Ig5a+56LGh44CCXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25PYmplY3QpIHtcbiAgICAgICAgaWYgKCFqc29uT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbG9yID0gbmV3IFNlcnZlckNvbG9yKCk7XG4gICAgICAgIHZhciByZWQgPSAyNTU7XG4gICAgICAgIGlmIChqc29uT2JqZWN0LnJlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVkID0gTnVtYmVyKGpzb25PYmplY3QucmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb2xvci5yZWQgPSByZWQ7XG5cbiAgICAgICAgdmFyIGdyZWVuID0gMDtcbiAgICAgICAgaWYgKGpzb25PYmplY3QuZ3JlZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGdyZWVuID0gTnVtYmVyKGpzb25PYmplY3QuZ3JlZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yLmdyZWVuID0gZ3JlZW47XG5cbiAgICAgICAgdmFyIGJsdWUgPSAwO1xuICAgICAgICBpZiAoanNvbk9iamVjdC5ibHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBibHVlID0gTnVtYmVyKGpzb25PYmplY3QuYmx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29sb3IuYmx1ZSA9IGJsdWU7XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG5cbn1cblxuXG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG5pbXBvcnQge1V0aWx9IGZyb20gJy4uL2NvbW1vbnR5cGVzL1V0aWwnO1xuaW1wb3J0IHtTZXJ2ZXJDb2xvcn0gZnJvbSAnLi9TZXJ2ZXJDb2xvcic7XG5cbi8qKlxuICogQGNsYXNzIFNlcnZlclN0eWxlXG4gKiBAZGVwcmVjYXRlZGNsYXNzIFN1cGVyTWFwLlNlcnZlclN0eWxlXG4gKiBAY2F0ZWdvcnkgIGlTZXJ2ZXIgTWFwIFRoZW1lXG4gKiBAY2xhc3NkZXNjIOacjeWKoeerr+efoumHj+imgee0oOmjjuagvOexu+OAguivpeexu+eUqOS6juWumuS5ieeCueeKtuespuWPt+OAgee6v+eKtuespuWPt+OAgeWhq+WFheespuWPt+mjjuagvOWPiuWFtuebuOWFs+WxnuaAp+OAglxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSDlj4LmlbDjgIJcbiAqIEBwYXJhbSB7RmlsbEdyYWRpZW50TW9kZX0gb3B0aW9ucy5maWxsR3JhZGllbnRNb2RlIC0g5riQ5Y+Y5aGr5YWF6aOO5qC855qE5riQ5Y+Y57G75Z6L44CCXG4gKiBAcGFyYW0ge1NlcnZlckNvbG9yfSBbb3B0aW9ucy5maWxsQmFja0NvbG9yPVsyNTUsMjU1LDI1NV1dIC0g5aGr5YWF6IOM5pmv6aKc6Imy44CCXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZpbGxCYWNrT3BhcXVlPWZhbHNlXSAtIOiDjOaZr+aYr+WQpuS4jemAj+aYjuOAglxuICogQHBhcmFtIHtTZXJ2ZXJDb2xvcn0gW29wdGlvbnMuZmlsbEZvcmVDb2xvcj1bMjU1LDAsMF1dIC0g5aGr5YWF6aKc6Imy44CCXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZmlsbEdyYWRpZW50QW5nbGU9MF0gLSDmuJDlj5jloavlhYXnmoTml4vovazop5LluqbjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5maWxsR3JhZGllbnRPZmZzZXRSYXRpb1g9MF0gLSDmuJDlj5jloavlhYXkuK3lv4Pngrnnm7jlr7nkuo7loavlhYXljLrln5/ojIPlm7TkuK3lv4PngrnnmoTmsLTlubPlgY/np7vnmb7liIbmr5TjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5maWxsR3JhZGllbnRPZmZzZXRSYXRpb1k9MF0gLSDloavlhYXkuK3lv4Pngrnnm7jlr7nkuo7loavlhYXljLrln5/ojIPlm7TkuK3lv4PngrnnmoTlnoLnm7TlgY/np7vnmb7liIbmr5TjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5maWxsT3BhcXVlUmF0ZT0xMDBdIC0g5aGr5YWF5LiN6YCP5piO5bqm44CCXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZmlsbFN5bWJvbElEPTBdIC0g5aGr5YWF56ym5Y+355qE57yW56CB44CCXG4gKiBAcGFyYW0ge1NlcnZlckNvbG9yfSBbb3B0aW9ucy5saW5lQ29sb3JdIC0g55+i6YeP6KaB57Sg55qE6L6557q/6aKc6Imy44CC6buY6K6kIGxpbmVDb2xvciA9IG5ldyBTZXJ2ZXJDb2xvcigwLCAwLCAwKeOAglxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbmVTeW1ib2xJRD0wXSAtIOe6v+eKtuespuWPt+eahOe8lueggeOAglxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbmVXaWR0aD0xXSAtIOi+uee6v+eahOWuveW6puOAglxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1hcmtlckFuZ2xlPTBdIC0g54K554q256ym5Y+355qE5peL6L2s6KeS5bqm44CCXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWFya2VyU2l6ZT0xXSAtIOeCueeKtuespuWPt+eahOWkp+Wwj+OAglxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1hcmtlclN5bWJvbElEPS0xXSAtIOeCueeKtuespuWPt+eahOe8lueggeOAglxuICogQHVzYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXJ2ZXJTdHlsZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTZXJ2ZXJDb2xvcn0gU2VydmVyU3R5bGUucHJvdG90eXBlLmZpbGxCYWNrQ29sb3JcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOWhq+WFheiDjOaZr+minOiJsuOAguW9k+Whq+WFheaooeW8j+S4uua4kOWPmOWhq+WFheaXtu+8jOivpeminOiJsuS4uuWhq+WFhee7iOatouiJsuOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWxsQmFja0NvbG9yID0gbmV3IFNlcnZlckNvbG9yKDI1NSwgMjU1LCAyNTUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBbU2VydmVyU3R5bGUucHJvdG90eXBlLmZpbGxCYWNrT3BhcXVlPWZhbHNlXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g6IOM5pmv5piv5ZCm5LiN6YCP5piO44CCZmFsc2Ug6KGo56S66YCP5piO44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbGxCYWNrT3BhcXVlID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1NlcnZlckNvbG9yfSBTZXJ2ZXJTdHlsZS5wcm90b3R5cGUuZmlsbEZvcmVDb2xvclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5aGr5YWF6aKc6Imy44CC5b2T5aGr5YWF5qih5byP5Li65riQ5Y+Y5aGr5YWF5pe277yM6K+l6aKc6Imy5Li65aGr5YWF6LW35aeL6aKc6Imy44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbGxGb3JlQ29sb3IgPSBuZXcgU2VydmVyQ29sb3IoMjU1LCAwLCAwKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7RmlsbEdyYWRpZW50TW9kZX0gU2VydmVyU3R5bGUucHJvdG90eXBlLmZpbGxHcmFkaWVudE1vZGVcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOa4kOWPmOWhq+WFhemjjuagvOeahOa4kOWPmOexu+Wei+OAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWxsR3JhZGllbnRNb2RlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBTZXJ2ZXJTdHlsZS5wcm90b3R5cGUuZmlsbEdyYWRpZW50QW5nbGUgLVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5riQ5Y+Y5aGr5YWF55qE5peL6L2s6KeS5bqm44CC5Y2V5L2N5Li65bqm77yM57K+56Gu5YiwIDAuMSDluqbvvIzpgIbml7bpkojmlrnlkJHkuLrmraPmlrnlkJHjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsbEdyYWRpZW50QW5nbGUgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFNlcnZlclN0eWxlLnByb3RvdHlwZS5maWxsR3JhZGllbnRPZmZzZXRSYXRpb1hcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOa4kOWPmOWhq+WFheS4reW/g+eCueebuOWvueS6juWhq+WFheWMuuWfn+iMg+WbtOS4reW/g+eCueeahOawtOW5s+WBj+enu+eZvuWIhuavlOOAguWug+S7rOeahOWFs+ezu+WmguS4i++8muiuvuWhq+WFheWMuuWfn+iMg+WbtOS4reW/g+eCueeahOWdkOagh+S4uu+8iHgwLCB5MO+8ie+8jFxuICAgICAgICAgKiAgICAgICAgICAgICAg5aGr5YWF5Lit5b+D54K555qE5Z2Q5qCH5Li677yIeCwgee+8ie+8jOWhq+WFheWMuuWfn+iMg+WbtOeahOWuveW6puS4uiBh77yM5rC05bmz5YGP56e755m+5YiG5q+U5Li6IGR477yM5YiZIHg9eDAgKyBhKmR4LzEwMOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWxsR3JhZGllbnRPZmZzZXRSYXRpb1ggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFNlcnZlclN0eWxlLnByb3RvdHlwZS5maWxsR3JhZGllbnRPZmZzZXRSYXRpb1lcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOWhq+WFheS4reW/g+eCueebuOWvueS6juWhq+WFheWMuuWfn+iMg+WbtOS4reW/g+eCueeahOWeguebtOWBj+enu+eZvuWIhuavlOOAguWug+S7rOeahOWFs+ezu+WmguS4i++8mjxicj5cbiAgICAgICAgICogICAgICAgICAgICAgIOiuvuWhq+WFheWMuuWfn+iMg+WbtOS4reW/g+eCueeahOWdkOagh+S4uu+8iHgwLCB5MO+8ie+8jOWhq+WFheS4reW/g+eCueeahOWdkOagh+S4uu+8iHgsIHnvvInvvIzloavlhYXljLrln5/ojIPlm7TnmoTpq5jluqbkuLogYu+8jOWeguebtOWBj+enu+eZvuWIhuavlOS4uiBkee+8jOWImSB5PXkwICsgYipkeC8xMDDjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsbEdyYWRpZW50T2Zmc2V0UmF0aW9ZID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBbU2VydmVyU3R5bGUucHJvdG90eXBlLmZpbGxPcGFxdWVSYXRlPTEwMF1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOWhq+WFheS4jemAj+aYjuW6puOAguWQiOazleWAvOS4uiAwIC0gMTAwIOeahOaVsOWAvOOAguWFtuS4reS4uiAwIOihqOekuuWujOWFqOmAj+aYju+8m1xuICAgICAgICAgKiAgICAgICAgICAgICAgMTAwIOihqOekuuWujOWFqOS4jemAj+aYjuOAgui1i+WAvOWwj+S6jiAwIOaXtuaMieeFpyAwIOWkhOeQhu+8jOWkp+S6jiAxMDAg5pe25oyJ54WnIDEwMCDlpITnkIbjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsbE9wYXF1ZVJhdGUgPSAxMDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gU2VydmVyU3R5bGUucHJvdG90eXBlLmZpbGxTeW1ib2xJRFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5aGr5YWF56ym5Y+355qE57yW56CB44CC5q2k57yW56CB55So5LqO5ZSv5LiA5qCH6K+G5ZCE5pmu6YCa5aGr5YWF6aOO5qC855qE5aGr5YWF56ym5Y+344CCXG4gICAgICAgICAqICAgICAgICAgICAgICDlhbPkuo7loavlhYXnrKblj7fnmoTmoLflvI/kuI7lr7nlupTnmoQgSUQg5Y+36K+35ZyoIFN1cGVyTWFwIOahjOmdoui9r+S7tuS4reafpeaJvuOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWxsU3ltYm9sSUQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTZXJ2ZXJDb2xvcn0gU2VydmVyU3R5bGUucHJvdG90eXBlLmxpbmVDb2xvclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g55+i6YeP6KaB57Sg55qE6L6557q/6aKc6Imy44CC5aaC5p6c562J57qn56ym5Y+35piv54K556ym5Y+377yM54K556ym5Y+355qE6aKc6Imy55SxIGxpbmVDb2xvciDmjqfliLbjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZUNvbG9yID0gbmV3IFNlcnZlckNvbG9yKDAsIDAsIDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFtTZXJ2ZXJTdHlsZS5wcm90b3R5cGUubGluZVN5bWJvbElEPTBdXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDnur/nirbnrKblj7fnmoTnvJbnoIHjgILmraTnvJbnoIHnlKjkuo7llK/kuIDmoIfor4blkITmma7pgJrloavlhYXpo47moLznmoTloavlhYXnrKblj7fjgIJcbiAgICAgICAgICogICAgICAgICAgICAgIOWFs+S6jue6v+eKtuespuWPt+eahOagt+W8j+S4juWvueW6lOeahCBJRCDlj7for7flnKggU3VwZXJNYXAg5qGM6Z2i6L2v5Lu25Lit5p+l5om+44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVTeW1ib2xJRCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gW1NlcnZlclN0eWxlLnByb3RvdHlwZS5saW5lV2lkdGg9MS4wXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g6L6557q/55qE5a695bqm44CC5Y2V5L2N5Li65q+r57Gz77yM57K+5bqm5YiwIDAuMeOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFtTZXJ2ZXJTdHlsZS5wcm90b3R5cGUubWFya2VyQW5nbGU9MF1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOeCueeKtuespuWPt+eahOaXi+i9rOinkuW6puOAguS7peW6puS4uuWNleS9je+8jOeyvuehruWIsCAwLjEg5bqm77yM6YCG5pe26ZKI5pa55ZCR5Li65q2j5pa55ZCR44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtlckFuZ2xlID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBbU2VydmVyU3R5bGUucHJvdG90eXBlLm1hcmtlclNpemU9MS4wXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g54K554q256ym5Y+355qE5aSn5bCP44CC5Y2V5L2N5Li65q+r57Gz77yM57K+5bqm5Li6IDAuMeOAguW9k+ivpeWxnuaAp+iuvue9ruS4ujDml7bvvIzph4fnlKjnrKblj7fpu5jorqTlpKflsI8gMS4wIOaYvuekuuOAglxuICAgICAgICAgKiAgICAgICAgICAgICAg5b2T6K+l5bGe5oCn6K6+572u5Li66Z2e5rOV5YC85pe277yM5Lqk55Sx5pyN5Yqh5Zmo6buY6K6k5aSE55CG44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtlclNpemUgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFtTZXJ2ZXJTdHlsZS5wcm90b3R5cGUubWFya2VyU3ltYm9sSUQ9LTFdXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDngrnnirbnrKblj7fnmoTnvJbnoIHjgILmraTnvJbnoIHnlKjkuo7llK/kuIDmoIfor4blkITngrnnirbnrKblj7fjgIJcbiAgICAgICAgICogICAgICAgICAgICAgIOWFs+S6jue6v+eKtuespuWPt+eahOagt+W8j+S4juWvueW6lOeahCBJRCDlj7for7flnKggU3VwZXJNYXAg5qGM6Z2i6L2v5Lu25Lit5p+l5om+44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtlclN5bWJvbElEID0gLTE7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBVdGlsLmV4dGVuZCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuQ0xBU1NfTkFNRSA9IFwiU3VwZXJNYXAuU2VydmVyU3R5bGVcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU2VydmVyU3R5bGUucHJvdG90eXBlLmRlc3Ryb3lcbiAgICAgKiBAZGVzY3JpcHRpb24g6YeK5pS+6LWE5rqQ77yM5bCG5byV55So6LWE5rqQ55qE5bGe5oCn572u56m644CCXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLmZpbGxCYWNrQ29sb3IpIHtcbiAgICAgICAgICAgIG1lLmZpbGxCYWNrQ29sb3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgbWUuZmlsbEJhY2tDb2xvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbWUuZmlsbEJhY2tPcGFxdWUgPSBudWxsO1xuXG4gICAgICAgIGlmIChtZS5maWxsRm9yZUNvbG9yKSB7XG4gICAgICAgICAgICBtZS5maWxsRm9yZUNvbG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIG1lLmZpbGxGb3JlQ29sb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG1lLmZpbGxHcmFkaWVudE1vZGUgPSBudWxsO1xuICAgICAgICBtZS5maWxsR3JhZGllbnRBbmdsZSA9IG51bGw7XG4gICAgICAgIG1lLmZpbGxHcmFkaWVudE9mZnNldFJhdGlvWCA9IG51bGw7XG4gICAgICAgIG1lLmZpbGxHcmFkaWVudE9mZnNldFJhdGlvWSA9IG51bGw7XG4gICAgICAgIG1lLmZpbGxPcGFxdWVSYXRlID0gbnVsbDtcbiAgICAgICAgbWUuZmlsbFN5bWJvbElEID0gbnVsbDtcbiAgICAgICAgaWYgKG1lLmxpbmVDb2xvcikge1xuICAgICAgICAgICAgbWUubGluZUNvbG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIG1lLmxpbmVDb2xvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbWUubGluZVN5bWJvbElEID0gbnVsbDtcbiAgICAgICAgbWUubGluZVdpZHRoID0gbnVsbDtcbiAgICAgICAgbWUubWFya2VyQW5nbGUgPSBudWxsO1xuICAgICAgICBtZS5tYXJrZXJTaXplID0gbnVsbDtcbiAgICAgICAgbWUubWFya2VyU3ltYm9sSUQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBTZXJ2ZXJTdHlsZS5wcm90b3R5cGUudG9TZXJ2ZXJKU09OT2JqZWN0XG4gICAgICogQGRlc2NyaXB0aW9uIOi9rOaNouaIkOWvueW6lOeahCBKU09OIOagvOW8j+WvueixoeOAglxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IOWvueW6lOeahCBKU09OIOagvOW8j+WvueixoS5cbiAgICAgKi9cbiAgICB0b1NlcnZlckpTT05PYmplY3QoKSB7XG4gICAgICAgIHZhciBzdHlsZU9iaiA9IHt9O1xuICAgICAgICBzdHlsZU9iaiA9IFV0aWwuY29weUF0dHJpYnV0ZXMoc3R5bGVPYmosIHRoaXMpO1xuICAgICAgICAvL+aaguaXtuWFiOW/veeVpXNlcnZlckNvbG9y5b6ASnNvbueahOi9rOaNolxuICAgICAgICByZXR1cm4gc3R5bGVPYmo7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFNlcnZlclN0eWxlLmZyb21Kc29uXG4gICAgICogQGRlc2NyaXB0aW9uIOWwhkpTT07lr7nosaHovazmjaLkuLogU2VydmVyU3R5bGUg5a+56LGh44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGpzb25PYmplY3QgLSDopoHovazmjaLnmoQgSlNPTiDlr7nosaHjgIJcbiAgICAgKiBAcmV0dXJucyB7U2VydmVyU3R5bGV9IOi9rOWMluWQjueahCBTZXJ2ZXJTdHlsZSDlr7nosaHjgIJcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvbk9iamVjdCkge1xuICAgICAgICBpZiAoIWpzb25PYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlcnZlclN0eWxlKHtcbiAgICAgICAgICAgIGZpbGxCYWNrQ29sb3I6IFNlcnZlckNvbG9yLmZyb21Kc29uKGpzb25PYmplY3QuZmlsbEJhY2tDb2xvciksXG4gICAgICAgICAgICBmaWxsQmFja09wYXF1ZToganNvbk9iamVjdC5maWxsQmFja09wYXF1ZSxcbiAgICAgICAgICAgIGZpbGxGb3JlQ29sb3I6IFNlcnZlckNvbG9yLmZyb21Kc29uKGpzb25PYmplY3QuZmlsbEZvcmVDb2xvciksXG4gICAgICAgICAgICBmaWxsR3JhZGllbnRNb2RlOiBqc29uT2JqZWN0LmZpbGxHcmFkaWVudE1vZGUsXG4gICAgICAgICAgICBmaWxsR3JhZGllbnRBbmdsZToganNvbk9iamVjdC5maWxsR3JhZGllbnRBbmdsZSxcbiAgICAgICAgICAgIGZpbGxHcmFkaWVudE9mZnNldFJhdGlvWDoganNvbk9iamVjdC5maWxsR3JhZGllbnRPZmZzZXRSYXRpb1gsXG4gICAgICAgICAgICBmaWxsR3JhZGllbnRPZmZzZXRSYXRpb1k6IGpzb25PYmplY3QuZmlsbEdyYWRpZW50T2Zmc2V0UmF0aW9ZLFxuICAgICAgICAgICAgZmlsbE9wYXF1ZVJhdGU6IGpzb25PYmplY3QuZmlsbE9wYXF1ZVJhdGUsXG4gICAgICAgICAgICBmaWxsU3ltYm9sSUQ6IGpzb25PYmplY3QuZmlsbFN5bWJvbElELFxuICAgICAgICAgICAgbGluZUNvbG9yOiBTZXJ2ZXJDb2xvci5mcm9tSnNvbihqc29uT2JqZWN0LmxpbmVDb2xvciksXG4gICAgICAgICAgICBsaW5lU3ltYm9sSUQ6IGpzb25PYmplY3QubGluZVN5bWJvbElELFxuICAgICAgICAgICAgbGluZVdpZHRoOiBqc29uT2JqZWN0LmxpbmVXaWR0aCxcbiAgICAgICAgICAgIG1hcmtlckFuZ2xlOiBqc29uT2JqZWN0Lm1hcmtlckFuZ2xlLFxuICAgICAgICAgICAgbWFya2VyU2l6ZToganNvbk9iamVjdC5tYXJrZXJTaXplLFxuICAgICAgICAgICAgbWFya2VyU3ltYm9sSUQ6IGpzb25PYmplY3QubWFya2VyU3ltYm9sSURcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cblxuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBwcm9ncmFtIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xuaW1wb3J0IHtVdGlsfSBmcm9tICcuLi9jb21tb250eXBlcy9VdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2NvbW1vbnR5cGVzL2dlb21ldHJ5L1BvaW50JztcblxuLyoqXG4gKiBAY2xhc3MgUG9pbnRXaXRoTWVhc3VyZVxuICogQGRlcHJlY2F0ZWRjbGFzcyBTdXBlck1hcC5Qb2ludFdpdGhNZWFzdXJlXG4gKiBAY2F0ZWdvcnkgaVNlcnZlciBTcGF0aWFsQW5hbHlzdCBSb3V0ZUxvY2F0b3JcbiAqIEBjbGFzc2Rlc2Mg6Lev55Sx54K557G744CC6Lev55Sx54K55piv5oyH5YW35pyJ57q/5oCn5bqm6YeP5YC8IChNZWFzdXJlKSDnmoTkuoznu7TlnLDnkIblnZDmoIfngrnjgIJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0g5Y+C5pWw44CCXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tZWFzdXJlIC0g5bqm6YeP5YC877yM5Y2z6Lev55Sx5a+56LGh5bGe5oCn5YC8IE3jgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnggLSDlnLDnkIblnZDmoIfns7vkuIvnmoQgWCDlnZDmoIflgLzjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnkgLSDlnLDnkIblnZDmoIfns7vkuIvnmoQgWSDlnZDmoIflgLzjgIJcbiAqIEBleHRlbmRzIHtHZW9tZXRyeVBvaW50fVxuICogQHVzYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2ludFdpdGhNZWFzdXJlIGV4dGVuZHMgUG9pbnQge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBQb2ludFdpdGhNZWFzdXJlLnByb3RvdHlwZS5tZWFzdXJlXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDluqbph4/lgLzvvIzljbPot6/nlLHlr7nosaHlsZ7mgKflgLwgTeOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlID0gbnVsbDtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgVXRpbC5leHRlbmQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLkNMQVNTX05BTUUgPSBcIlN1cGVyTWFwLlBvaW50V2l0aE1lYXN1cmVcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gUG9pbnRXaXRoTWVhc3VyZS5wcm90b3R5cGUuZXF1YWxzXG4gICAgICogQGRlc2NyaXB0aW9uIOWIpOaWreS4pOS4qui3r+eUseeCueWvueixoeaYr+WQpuebuOetieOAguWmguaenOS4pOS4qui3r+eUseeCueWvueixoeWFt+acieebuOWQjOeahOWdkOagh+S7peWPiuW6pumHj+WAvO+8jOWImeiupOS4uuaYr+ebuOetieeahOOAglxuICAgICAqIEBwYXJhbSB7UG9pbnRXaXRoTWVhc3VyZX0gZ2VvbSAtIOmcgOimgeWIpOaWreeahOi3r+eUseeCueWvueixoeOAglxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDkuKTkuKrot6/nlLHngrnlr7nosaHmmK/lkKbnm7jnrYnvvIh0cnVlIOS4uuebuOetie+8jGZhbHNlIOS4uuS4jeetie+8ieOAglxuICAgICAqL1xuICAgIGVxdWFscyhnZW9tKSB7XG4gICAgICAgIHZhciBlcXVhbHMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGdlb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGlzVmFsdWVFcXVhbHMgPSB0aGlzLnggPT09IGdlb20ueCAmJiB0aGlzLnkgPT09IGdlb20ueSAmJiB0aGlzLm1lYXN1cmUgPT09IGdlb20ubWVhc3VyZTtcbiAgICAgICAgICAgIHZhciBpc05hTlZhbHVlID0gaXNOYU4odGhpcy54KSAmJiBpc05hTih0aGlzLnkpICYmIGlzTmFOKHRoaXMubWVhc3VyZSk7XG4gICAgICAgICAgICB2YXIgaXNOYU5HZW9tZXRyeSA9IGlzTmFOKGdlb20ueCkgJiYgaXNOYU4oZ2VvbS55KSAmJiBpc05hTihnZW9tLm1lYXN1cmUpO1xuICAgICAgICAgICAgZXF1YWxzID0gKCBpc1ZhbHVlRXF1YWxzIHx8ICggaXNOYU5WYWx1ZSAmJiBpc05hTkdlb21ldHJ5ICkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcXVhbHM7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gUG9pbnRXaXRoTWVhc3VyZS5wcm90b3R5cGUudG9Kc29uXG4gICAgICogQGRlc2NyaXB0aW9uIOi9rOaNouS4uiBKU09OIOWvueixoeOAglxuICAgICAqICovXG4gICAgIHRvSnNvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwie1wiO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlICE9IG51bGwgJiYgdGhpcy5tZWFzdXJlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxcIm1lYXN1cmVcXFwiOlwiICsgdGhpcy5tZWFzdXJlICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IFwiXFxcInhcXFwiOlwiICsgdGhpcy54ICsgXCIsXCI7XG4gICAgICAgIHJlc3VsdCArPSBcIlxcXCJ5XFxcIjpcIiArIHRoaXMueTtcbiAgICAgICAgcmVzdWx0ICs9IFwifVwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuXG4gICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBQb2ludFdpdGhNZWFzdXJlLnByb3RvdHlwZS5kZXN0cm95XG4gICAgICogQGRlc2NyaXB0aW9uIOmHiuaUvui1hOa6kO+8jOWwhuW8leeUqOi1hOa6kOeahOWxnuaAp+e9ruepuuOAglxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLm1lYXN1cmUgPSBudWxsO1xuICAgICAgICBtZS54ID0gbnVsbDtcbiAgICAgICAgbWUueSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFBvaW50V2l0aE1lYXN1cmUuZnJvbUpzb25cbiAgICAgKiBAZGVzY3JpcHRpb24g5bCGIEpTT04g5a+56LGh6L2s5o2i5Li6e0BsaW5rIFBvaW50V2l0aE1lYXN1cmV9IOWvueixoeOAglxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uT2JqZWN0IC0gSlNPTiDlr7nosaHooajnpLrnmoTot6/nlLHngrnjgIJcbiAgICAgKiBAcmV0dXJucyB7UG9pbnRXaXRoTWVhc3VyZX0g6L2s5YyW5ZCO55qEIFBvaW50V2l0aE1lYXN1cmUg5a+56LGh44CCXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25PYmplY3QpIHtcbiAgICAgICAgaWYgKCFqc29uT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludFdpdGhNZWFzdXJlKHtcbiAgICAgICAgICAgIHg6IGpzb25PYmplY3QueCxcbiAgICAgICAgICAgIHk6IGpzb25PYmplY3QueSxcbiAgICAgICAgICAgIG1lYXN1cmU6IGpzb25PYmplY3QubWVhc3VyZVxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBwcm9ncmFtIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xuaW1wb3J0IHtVdGlsfSBmcm9tICcuLi9jb21tb250eXBlcy9VdGlsJztcbmltcG9ydCB7TGluZWFyUmluZ30gZnJvbSAnLi4vY29tbW9udHlwZXMvZ2VvbWV0cnkvTGluZWFyUmluZyc7XG5pbXBvcnQge0xpbmVTdHJpbmd9IGZyb20gJy4uL2NvbW1vbnR5cGVzL2dlb21ldHJ5L0xpbmVTdHJpbmcnO1xuaW1wb3J0IHtQb2ludFdpdGhNZWFzdXJlfSBmcm9tICcuL1BvaW50V2l0aE1lYXN1cmUnO1xuaW1wb3J0IHtDb2xsZWN0aW9ufSBmcm9tICcuLi9jb21tb250eXBlcy9nZW9tZXRyeS9Db2xsZWN0aW9uJztcblxuLyoqXG4gKiBAY2xhc3MgUm91dGVcbiAqIEBkZXByZWNhdGVkY2xhc3MgU3VwZXJNYXAuUm91dGVcbiAqIEBjYXRlZ29yeSBpU2VydmVyIFNwYXRpYWxBbmFseXN0IFJvdXRlQ2FsY3VsYXRlTWVhc3VyZVxuICogQGNsYXNzZGVzYyDot6/nlLHlr7nosaHnsbvjgILot6/nlLHlr7nosaHkuLrkuIDns7vliJfmnInluo/nmoTluKbmnInlsZ7mgKflgLwgTSDnmoQgeO+8jHkg5Z2Q5qCH5a+577yM5YW25LitIE0g5YC85Li66K+l57uT54K555qE6Led56a75bGe5oCn77yI5Yiw5bey55+l54K555qE6Led56a777yJ44CCXG4gKiBAcGFyYW0ge0FycmF5LjxHZW9tZXRyeT59IHBvaW50cyAtIOW9ouaIkOi3r+eUseWvueixoeeahOe6v+aVsOe7hOOAglxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSDlj4LmlbDjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmlkIC0g6Lev55Sx5a+56LGh5Zyo5pWw5o2u5bqT5Lit55qEIGlk44CCXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZW5ndGggLSDot6/nlLHlr7nosaHnmoTplb/luqbjgILljZXkvY3kuI7mlbDmja7pm4bnmoTljZXkvY3nm7jlkIzjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhNXSAtIOacgOWkp+e6v+aAp+W6pumHj+WAvO+8jOWNs+aJgOaciee7k+eCueWIsOi1t+Wni+eCueeahOmHj+eul+i3neemu+S4reacgOWkp+WAvOOAglxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pbk1dIC0g5pyA5bCP57q/5oCn5bqm6YeP5YC877yM5Y2z5omA5pyJ57uT54K55Yiw6LW35aeL54K555qE6YeP566X6Led56a75Lit5pyA5bCP5YC844CCXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHlwZV0gLSDmlbDmja7nsbvlnovvvIzlpoLvvJpcIkxJTkVNXCLjgIJcbiAqIEBleHRlbmRzIEdlb21ldHJ5Q29sbGVjdGlvblxuICogQHVzYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBSb3V0ZSBleHRlbmRzIENvbGxlY3Rpb24ge1xuXG4gICAgY29uc3RydWN0b3IocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHBvaW50cywgb3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gUm91dGUucHJvdG90eXBlLmlkXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDot6/nlLHlr7nosaHlnKjmlbDmja7lupPkuK3nmoQgSUTjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFJvdXRlLnByb3RvdHlwZS5jZW50ZXJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOi3r+eUseWvueixoeeahOS4reW/g+eCueOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZW50ZXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IFJvdXRlLnByb3RvdHlwZS5zdHlsZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g6Lev55Sx5a+56LGh55qE5qC35byP44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBSb3V0ZS5wcm90b3R5cGUubGVuZ3RoXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDot6/nlLHlr7nosaHnmoTplb/luqbjgILljZXkvY3kuI7mlbDmja7pm4bnmoTljZXkvY3nm7jlkIzjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogIEBtZW1iZXIge251bWJlcn0gUm91dGUucHJvdG90eXBlLm1heE1cbiAgICAgICAgICogIEBkZXNjcmlwdGlvbiDmnIDlpKfnur/mgKfluqbph4/lgLzvvIzljbPmiYDmnInnu5PngrnliLDotbflp4vngrnnmoTph4/nrpfot53nprvkuK3mnIDlpKflgLzjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4TSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gUm91dGUucHJvdG90eXBlLm1pbk1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOacgOWwj+e6v+aAp+W6pumHj+WAvO+8jOWNs+aJgOaciee7k+eCueWIsOi1t+Wni+eCueeahOmHj+eul+i3neemu+S4reacgOWwj+WAvOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5NID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IFJvdXRlLnByb3RvdHlwZS5wYXJ0c1xuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5pyN5Yqh56uv5Yeg5L2V5a+56LGh5Lit5ZCE5Liq5a2Q5a+56LGh5omA5YyF5ZCr55qE6IqC54K55Liq5pWw44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcnRzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPE9iamVjdD59IFJvdXRlLnByb3RvdHlwZS5wb2ludHNcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOi3r+eUseWvueixoeeahOaJgOaciei3r+eUseeCueOAglxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAoc3RhcnQgY29kZSlcbiAgICAgICAgICogW1xuICAgICAgICAgKiAge1xuICAgICAgICAgKiAgICAgIFwibWVhc3VyZVwiOiAwLFxuICAgICAgICAgKiAgICAgIFwieVwiOiAtNDM3Ny4wMjcxODQyOTgyNjcsXG4gICAgICAgICAqICAgICAgXCJ4XCI6IDQwMjAuMDA0NTIyMTcyMDQ2NlxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogIHtcbiAgICAgICAgICogICAgICBcIm1lYXN1cmVcIjogMzcuMzMyODgzODEzOTE1MTksXG4gICAgICAgICAqICAgICAgXCJ5XCI6IC00MzgxLjU2OTM2MzI2MDQ5OSxcbiAgICAgICAgICogICAgICBcInhcIjogNDA1Ny4wNjAwNTkxOTYwNjQyXG4gICAgICAgICAqICB9XG4gICAgICAgICAqIF1cbiAgICAgICAgICogKGVuZClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9pbnRzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBSb3V0ZS5wcm90b3R5cGUudHlwZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5pyN5Yqh56uv5Yeg5L2V5a+56LGh57G75Z6L44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48c3RyaW5nPn0gW1JvdXRlLnByb3RvdHlwZS5jb21wb25lbnRUeXBlcz1MaW5lU3RyaW5nXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gY29tcG9uZW50cyDlrZjlgqjnmoTnmoTlh6DkvZXlr7nosaHmiYDmlK/mjIHnmoTlh6DkvZXnsbvlnovmlbDnu4TjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcG9uZW50VHlwZXMgPSBbXCJTdXBlck1hcC5HZW9tZXRyeS5MaW5lYXJSaW5nXCIsIFwiU3VwZXJNYXAuR2VvbWV0cnkuTGluZVN0cmluZ1wiXTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgVXRpbC5leHRlbmQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLkNMQVNTX05BTUUgPSBcIlN1cGVyTWFwLlJvdXRlXCI7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnlUeXBlID0gXCJMSU5FTVwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIFJvdXRlLnByb3RvdHlwZS50b0pzb25cbiAgICAgKiBAZGVzY3JpcHRpb24g6L2s5o2i5Li6IEpTT04g5a+56LGh44CCXG4gICAgICogQHJldHVybnMge09iamVjdH0gSlNPTiDlr7nosaHjgIJcbiAgICAgKi9cbiAgICB0b0pzb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIntcIjtcbiAgICAgICAgaWYgKHRoaXMuaWQgIT0gbnVsbCAmJiB0aGlzLmlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxcImlkXFxcIjpcIiArIHRoaXMuaWQgKyBcIixcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jZW50ZXIgIT0gbnVsbCAmJiB0aGlzLmNlbnRlciAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcXCJjZW50ZXJcXFwiOlwiICsgdGhpcy5jZW50ZXIgKyBcIixcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdHlsZSAhPSBudWxsICYmIHRoaXMuc3R5bGUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXFwic3R5bGVcXFwiOlwiICsgdGhpcy5zdHlsZSArIFwiLFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPSBudWxsICYmIHRoaXMubGVuZ3RoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxcImxlbmd0aFxcXCI6XCIgKyB0aGlzLmxlbmd0aCArIFwiLFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1heE0gIT0gbnVsbCAmJiB0aGlzLm1heE0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXFwibWF4TVxcXCI6XCIgKyB0aGlzLm1heE0gKyBcIixcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW5NICE9IG51bGwgJiYgdGhpcy5taW5NICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxcIm1pbk1cXFwiOlwiICsgdGhpcy5taW5NICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPSBudWxsICYmIHRoaXMudHlwZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcXCJ0eXBlXFxcIjpcXFwiXCIgKyB0aGlzLnR5cGUgKyBcIlxcXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFydHMgIT0gbnVsbCAmJiB0aGlzLnBhcnRzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxcInBhcnRzXFxcIjpbXCIgKyB0aGlzLnBhcnRzWzBdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIsXCIgKyB0aGlzLnBhcnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXSxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzICE9IG51bGwgJiYgdGhpcy5jb21wb25lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcXCJwb2ludHNcXFwiOltcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwgbGVuMiA9IHRoaXMuY29tcG9uZW50c1tqXS5jb21wb25lbnRzLmxlbmd0aDsgayA8IGxlbjI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5jb21wb25lbnRzW2pdLmNvbXBvbmVudHNba10udG9Kc29uKCkgKyBcIixcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvLCQvZywgJycpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC8sJC9nLCAnJyk7XG4gICAgICAgIHJlc3VsdCArPSBcIn1cIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBSb3V0ZS5wcm90b3R5cGUuZGVzdHJveVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmlkID0gbnVsbDtcbiAgICAgICAgbWUuY2VudGVyID0gbnVsbDtcbiAgICAgICAgbWUuc3R5bGUgPSBudWxsO1xuICAgICAgICBtZS5sZW5ndGggPSBudWxsO1xuICAgICAgICBtZS5tYXhNID0gbnVsbDtcbiAgICAgICAgbWUubWluTSA9IG51bGw7XG4gICAgICAgIG1lLnR5cGUgPSBudWxsO1xuICAgICAgICBtZS5wYXJ0cyA9IG51bGw7XG4gICAgICAgIG1lLmNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgbWUuY29tcG9uZW50cyA9IG51bGw7XG4gICAgICAgIG1lLmNvbXBvbmVudFR5cGVzID0gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBSb3V0ZS5mcm9tSnNvblxuICAgICAqIEBkZXNjcmlwdGlvbiDlsIYgSlNPTiDlr7nosaHovazmjaLkuLogUm91dGUg5a+56LGh44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtqc29uT2JqZWN0XSAtIEpTT04g5a+56LGh6KGo56S655qE6Lev55Sx5a+56LGh44CCXG4gICAgICogQHJldHVybnMge1JvdXRlfSDovazljJblkI7nmoQgUm91dGUg5a+56LGh44CCXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25PYmplY3QpIHtcbiAgICAgICAgaWYgKCFqc29uT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2VvUGFydHMgPSBqc29uT2JqZWN0LnBhcnRzIHx8IFtdLFxuICAgICAgICAgICAgZ2VvUG9pbnRzID0ganNvbk9iamVjdC5wb2ludHMgfHwgW10sXG4gICAgICAgICAgICBsZW4gPSBnZW9QYXJ0cy5sZW5ndGgsXG4gICAgICAgICAgICBsaW5lTGlzdCA9IFtdO1xuICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHBvaW50SW5kZXggPSAwLCBwb2ludExpc3QgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnZW9QYXJ0c1tpXTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50TGlzdC5wdXNoKFBvaW50V2l0aE1lYXN1cmUuZnJvbUpzb24oZ2VvUG9pbnRzW3BvaW50SW5kZXggKyBqXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb2ludEluZGV4ICs9IGdlb1BhcnRzW2ldO1xuICAgICAgICAgICAgICAgIC8v5Yik5pat57q/5piv5ZCm6Zet5ZCI77yM5aaC5p6c6Zet5ZCI77yM5YiZ6L+U5ZueTGluZWFyUmluZ++8jOWQpuWImei/lOWbnkxpbmVTdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRMaXN0WzBdLmVxdWFscyhwb2ludExpc3RbZ2VvUGFydHNbaV0gLSAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUxpc3QucHVzaChuZXcgTGluZWFyUmluZyhwb2ludExpc3QpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5lTGlzdC5wdXNoKG5ldyBMaW5lU3RyaW5nKHBvaW50TGlzdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb2ludExpc3QgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJvdXRlKGxpbmVMaXN0LCB7XG4gICAgICAgICAgICBpZDoganNvbk9iamVjdC5pZCxcbiAgICAgICAgICAgIGNlbnRlcjoganNvbk9iamVjdC5jZW50ZXIsXG4gICAgICAgICAgICBzdHlsZToganNvbk9iamVjdC5zdHlsZSxcbiAgICAgICAgICAgIGxlbmd0aDoganNvbk9iamVjdC5sZW5ndGgsXG4gICAgICAgICAgICBtYXhNOiBqc29uT2JqZWN0Lm1heE0sXG4gICAgICAgICAgICBtaW5NOiBqc29uT2JqZWN0Lm1pbk0sXG4gICAgICAgICAgICB0eXBlOiBqc29uT2JqZWN0LnR5cGUsXG4gICAgICAgICAgICBwYXJ0czoganNvbk9iamVjdC5wYXJ0c1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiIsIi8qIENvcHlyaWdodMKpIDIwMDAgLSAyMDIyIFN1cGVyTWFwIFNvZnR3YXJlIENvLkx0ZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cblxuIC8qKlxuICogQGVudW0gRGF0YUZvcm1hdFxuICogQGRlc2NyaXB0aW9uIOacjeWKoeivt+axgui/lOWbnue7k+aenOaVsOaNruexu+Wei1xuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5EYXRhRm9ybWF0LkdFT0pTT047XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBEYXRhRm9ybWF0IH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IERhdGFGb3JtYXQuR0VPSlNPTjtcbiAqIGBgYFxuICovXG52YXIgRGF0YUZvcm1hdCA9IHtcbiAgICAvKiogR0VPSlNPTiAqL1xuICAgIEdFT0pTT046IFwiR0VPSlNPTlwiLFxuICAgIC8qKiBJU0VSVkVSICovXG4gICAgSVNFUlZFUjogXCJJU0VSVkVSXCJcbn07XG5cbi8qKlxuICogQGVudW0gU2VydmVyVHlwZVxuICogQGRlc2NyaXB0aW9uIOacjeWKoeWZqOexu+Wei1xuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5TZXJ2ZXJUeXBlLklTRVJWRVI7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBTZXJ2ZXJUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFNlcnZlclR5cGUuSVNFUlZFUjtcbiAqIGBgYFxuICovXG52YXIgU2VydmVyVHlwZSA9IHtcbiAgICAvKiogSVNFUlZFUiAqL1xuICAgIElTRVJWRVI6IFwiSVNFUlZFUlwiLFxuICAgIC8qKiBJUE9SVEFMICovXG4gICAgSVBPUlRBTDogXCJJUE9SVEFMXCIsXG4gICAgLyoqIE9OTElORSAqL1xuICAgIE9OTElORTogXCJPTkxJTkVcIlxufTtcblxuLyoqXG4gKiBAZW51bSBHZW9tZXRyeVR5cGVcbiAqIEBkZXNjcmlwdGlvbiDlh6DkvZXlr7nosaHmnprkuL4s5a6a5LmJ5LqG5LiA57O75YiX5Yeg5L2V5a+56LGh57G75Z6L44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9Lkdlb21ldHJ5VHlwZS5MSU5FO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgR2VvbWV0cnlUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEdlb21ldHJ5VHlwZS5MSU5FO1xuICogYGBgXG4gKi9cbnZhciBHZW9tZXRyeVR5cGUgPSB7XG4gICAgLyoqIExJTkUgKi9cbiAgICBMSU5FOiBcIkxJTkVcIixcbiAgICAvKiogTElORU0gKi9cbiAgICBMSU5FTTogXCJMSU5FTVwiLFxuICAgIC8qKiBQT0lOVCAqL1xuICAgIFBPSU5UOiBcIlBPSU5UXCIsXG4gICAgLyoqIFJFR0lPTiAqL1xuICAgIFJFR0lPTjogXCJSRUdJT05cIixcbiAgICAvKiogUE9JTlRFUFMgKi9cbiAgICBQT0lOVEVQUzogXCJQT0lOVEVQU1wiLFxuICAgIC8qKiBMSU5FRVBTICovXG4gICAgTElORUVQUzogXCJMSU5FRVBTXCIsXG4gICAgLyoqIFJFR0lPTkVQUyAqL1xuICAgIFJFR0lPTkVQUzogXCJSRUdJT05FUFNcIixcbiAgICAvKiogRUxMSVBTRSAqL1xuICAgIEVMTElQU0U6IFwiRUxMSVBTRVwiLFxuICAgIC8qKiBDSVJDTEUgKi9cbiAgICBDSVJDTEU6IFwiQ0lSQ0xFXCIsXG4gICAgLyoqIFRFWFQgKi9cbiAgICBURVhUOiBcIlRFWFRcIixcbiAgICAvKiogUkVDVEFOR0xFICovXG4gICAgUkVDVEFOR0xFOiBcIlJFQ1RBTkdMRVwiLFxuICAgIC8qKiBVTktOT1dOICovXG4gICAgVU5LTk9XTjogXCJVTktOT1dOXCIsXG4gICAgLyoqIEdFT0NPTVBPVU5EICovXG4gICAgR0VPQ09NUE9VTkQ6XCJHRU9DT01QT1VORFwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFF1ZXJ5T3B0aW9uXG4gKiBAZGVzY3JpcHRpb24g5p+l6K+i57uT5p6c57G75Z6L5p6a5Li+LOaPj+i/sOafpeivoue7k+aenOi/lOWbnuexu+Wei++8jOWMheaLrOWPqui/lOWbnuWxnuaAp+OAgeWPqui/lOWbnuWHoOS9leWunuS9k+S7peWPiui/lOWbnuWxnuaAp+WSjOWHoOS9leWunuS9k+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5RdWVyeU9wdGlvbi5BVFRSSUJVVEU7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBRdWVyeU9wdGlvbiB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBRdWVyeU9wdGlvbi5BVFRSSUJVVEU7XG4gKiBgYGBcbiAqL1xudmFyIFF1ZXJ5T3B0aW9uID0ge1xuICAgIC8qKiDlsZ7mgKcgKi9cbiAgICBBVFRSSUJVVEU6IFwiQVRUUklCVVRFXCIsXG4gICAgLyoqIOWxnuaAp+WSjOWHoOS9leWvueixoSAqL1xuICAgIEFUVFJJQlVURUFOREdFT01FVFJZOiBcIkFUVFJJQlVURUFOREdFT01FVFJZXCIsXG4gICAgLyoqIOWHoOS9leWvueixoSAqL1xuICAgIEdFT01FVFJZOiBcIkdFT01FVFJZXCJcbn07XG5cbi8qKlxuICogQGVudW0gSm9pblR5cGVcbiAqIEBkZXNjcmlwdGlvbiDlhbPogZTmn6Xor6Lml7bnmoTlhbPogZTnsbvlnovluLjph4/jgIJcbiAqIOivpeexu+WumuS5ieS6huS4pOS4quihqOS5i+mXtOeahOi/nuaOpeexu+Wei+W4uOmHj++8jOWGs+WumuS6huWvueS4pOS4quihqOS5i+mXtOi/m+ihjOi/nuaOpeafpeivouaXtu+8jOafpeivoue7k+aenOS4reW+l+WIsOeahOiusOW9leeahOaDheWGteOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5Kb2luVHlwZS5JTk5FUkpPSU47XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBKb2luVHlwZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBKb2luVHlwZS5JTk5FUkpPSU47XG4gKiBgYGBcbiAqL1xudmFyIEpvaW5UeXBlID0ge1xuICAgIC8qKiDlhoXov57mjqUgKi9cbiAgICBJTk5FUkpPSU46IFwiSU5ORVJKT0lOXCIsXG4gICAgLyoqIOW3pui/nuaOpSAqL1xuICAgIExFRlRKT0lOOiBcIkxFRlRKT0lOXCJcbn07XG5cbi8qKlxuICogQGVudW0gU3BhdGlhbFF1ZXJ5TW9kZVxuICogQGRlc2NyaXB0aW9uICDnqbrpl7Tmn6Xor6LmqKHlvI/mnprkuL7jgILor6XnsbvlrprkuYnkuobnqbrpl7Tmn6Xor6Lmk43kvZzmqKHlvI/luLjph4/jgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uU3BhdGlhbFF1ZXJ5TW9kZS5DT05UQUlOO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgU3BhdGlhbFF1ZXJ5TW9kZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBTcGF0aWFsUXVlcnlNb2RlLkNPTlRBSU47XG4gKiBgYGBcbiAqL1xudmFyIFNwYXRpYWxRdWVyeU1vZGUgPSB7XG4gICAgLyoqIOWMheWQq+epuumXtOafpeivouaooeW8jyAqL1xuICAgIENPTlRBSU46IFwiQ09OVEFJTlwiLFxuICAgIC8qKiDkuqTlj4nnqbrpl7Tmn6Xor6LmqKHlvI8gKi9cbiAgICBDUk9TUzogXCJDUk9TU1wiLFxuICAgIC8qKiDliIbnprvnqbrpl7Tmn6Xor6LmqKHlvI8gKi9cbiAgICBESVNKT0lOVDogXCJESVNKT0lOVFwiLFxuICAgIC8qKiDph43lkIjnqbrpl7Tmn6Xor6LmqKHlvI8gKi9cbiAgICBJREVOVElUWTogXCJJREVOVElUWVwiLFxuICAgIC8qKiDnm7jkuqTnqbrpl7Tmn6Xor6LmqKHlvI8gKi9cbiAgICBJTlRFUlNFQ1Q6IFwiSU5URVJTRUNUXCIsXG4gICAgLyoqIOaXoOepuumXtOafpeivoiAqL1xuICAgIE5PTkU6IFwiTk9ORVwiLFxuICAgIC8qKiDlj6DliqDnqbrpl7Tmn6Xor6LmqKHlvI8gKi9cbiAgICBPVkVSTEFQOiBcIk9WRVJMQVBcIixcbiAgICAvKiog6YK75o6l56m66Ze05p+l6K+i5qih5byPICovXG4gICAgVE9VQ0g6IFwiVE9VQ0hcIixcbiAgICAvKiog6KKr5YyF5ZCr56m66Ze05p+l6K+i5qih5byPICovXG4gICAgV0lUSElOOiBcIldJVEhJTlwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFNwYXRpYWxSZWxhdGlvblR5cGVcbiAqIEBkZXNjcmlwdGlvbiAg5pWw5o2u6ZuG5a+56LGh6Ze055qE56m66Ze05YWz57O75p6a5Li+44CCXG4gKiDor6XnsbvlrprkuYnkuobmlbDmja7pm4blr7nosaHpl7TnmoTnqbrpl7TlhbPns7vnsbvlnovluLjph4/jgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uU3BhdGlhbFJlbGF0aW9uVHlwZS5DT05UQUlOO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgU3BhdGlhbFJlbGF0aW9uVHlwZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5TcGF0aWFsUmVsYXRpb25UeXBlLkNPTlRBSU47XG4gKiBgYGBcbiAqL1xudmFyIFNwYXRpYWxSZWxhdGlvblR5cGUgPSB7XG4gICAgLyoqIOWMheWQq+WFs+ezuyAqL1xuICAgIENPTlRBSU46IFwiQ09OVEFJTlwiLFxuICAgIC8qKiDnm7jkuqTlhbPns7sgKi9cbiAgICBJTlRFUlNFQ1Q6IFwiSU5URVJTRUNUXCIsXG4gICAgLyoqIOiiq+WMheWQq+WFs+ezuyAqL1xuICAgIFdJVEhJTjogXCJXSVRISU5cIlxufTtcblxuLyoqXG4gKiBAZW51bSBNZWFzdXJlTW9kZVxuICogQHR5cGUge3N0cmluZ31cbiAqIEBkZXNjcmlwdGlvbiAg6YeP566X5qih5byP5p6a5Li+44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiDor6XnsbvlrprkuYnkuobkuKTnp43mtYvph4/mqKHlvI/vvJrot53nprvmtYvph4/lkozpnaLnp6/mtYvph4/jgIJcbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5NZWFzdXJlTW9kZS5ESVNUQU5DRTtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IE1lYXN1cmVNb2RlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IE1lYXN1cmVNb2RlLkRJU1RBTkNFO1xuICogYGBgXG4gKi9cbnZhciBNZWFzdXJlTW9kZSA9IHtcbiAgICAvKiog6Led56a75rWL6YePICovXG4gICAgRElTVEFOQ0U6IFwiRElTVEFOQ0VcIixcbiAgICAvKiog6Z2i56ev5rWL6YePICovXG4gICAgQVJFQTogXCJBUkVBXCJcbn07XG5cbi8qKlxuICogQGVudW0gVW5pdFxuICogQGRlc2NyaXB0aW9uICDot53nprvljZXkvY3mnprkuL7jgIJcbiAqIOivpeexu+WumuS5ieS6huS4gOezu+WIl+i3neemu+WNleS9jeexu+Wei+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5Vbml0Lk1FVEVSO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgVW5pdCB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBVbml0Lk1FVEVSO1xuICogYGBgXG4gKi9cbnZhciBVbml0ID0ge1xuICAgIC8qKiAg57GzICovXG4gICAgTUVURVI6IFwiTUVURVJcIixcbiAgICAvKiogIOWNg+exsyAqL1xuICAgIEtJTE9NRVRFUjogXCJLSUxPTUVURVJcIixcbiAgICAvKiogIOiLsemHjCAqL1xuICAgIE1JTEU6IFwiTUlMRVwiLFxuICAgIC8qKiAg56CBICovXG4gICAgWUFSRDogXCJZQVJEXCIsXG4gICAgLyoqICDluqYgKi9cbiAgICBERUdSRUU6IFwiREVHUkVFXCIsXG4gICAgLyoqICDmr6vnsbMgKi9cbiAgICBNSUxMSU1FVEVSOiBcIk1JTExJTUVURVJcIixcbiAgICAvKiogIOWOmOexsyAqL1xuICAgIENFTlRJTUVURVI6IFwiQ0VOVElNRVRFUlwiLFxuICAgIC8qKiAg6Iux5a+4ICovXG4gICAgSU5DSDogXCJJTkNIXCIsXG4gICAgLyoqICDliIbnsbMgKi9cbiAgICBERUNJTUVURVI6IFwiREVDSU1FVEVSXCIsXG4gICAgLyoqICDoi7HlsLogKi9cbiAgICBGT09UOiBcIkZPT1RcIixcbiAgICAvKiogIOenkiAqL1xuICAgIFNFQ09ORDogXCJTRUNPTkRcIixcbiAgICAvKiogIOWIhiAqL1xuICAgIE1JTlVURTogXCJNSU5VVEVcIixcbiAgICAvKiogIOW8p+W6piAqL1xuICAgIFJBRElBTjogXCJSQURJQU5cIlxufTtcblxuLyoqXG4gKiBAZW51bSBCdWZmZXJSYWRpdXNVbml0XG4gKiBAZGVzY3JpcHRpb24gIOe8k+WGsuWMuui3neemu+WNleS9jeaemuS4vuOAguivpeexu+WumuS5ieS6huS4gOezu+WIl+e8k+WGsui3neemu+WNleS9jeexu+Wei+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5CdWZmZXJSYWRpdXNVbml0LkNFTlRJTUVURVI7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBCdWZmZXJSYWRpdXNVbml0IH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlclJhZGl1c1VuaXQuQ0VOVElNRVRFUjtcbiAqIGBgYFxuICovXG52YXIgQnVmZmVyUmFkaXVzVW5pdCA9IHtcbiAgICAvKiogIOWOmOexsyAqL1xuICAgIENFTlRJTUVURVI6IFwiQ0VOVElNRVRFUlwiLFxuICAgIC8qKiAg5YiG57GzICovXG4gICAgREVDSU1FVEVSOiBcIkRFQ0lNRVRFUlwiLFxuICAgIC8qKiAg6Iux5bC6ICovXG4gICAgRk9PVDogXCJGT09UXCIsXG4gICAgLyoqICDoi7Hlr7ggKi9cbiAgICBJTkNIOiBcIklOQ0hcIixcbiAgICAvKiogIOWNg+exsyAqL1xuICAgIEtJTE9NRVRFUjogXCJLSUxPTUVURVJcIixcbiAgICAvKiogIOexsyAqL1xuICAgIE1FVEVSOiBcIk1FVEVSXCIsXG4gICAgLyoqICDoi7Hph4wgKi9cbiAgICBNSUxFOiBcIk1JTEVcIixcbiAgICAvKiogIOavq+exsyAqL1xuICAgIE1JTExJTUVURVI6IFwiTUlMTElNRVRFUlwiLFxuICAgIC8qKiAg56CBICovXG4gICAgWUFSRDogXCJZQVJEXCJcbn1cblxuLyoqXG4gKiBAZW51bSBFbmdpbmVUeXBlXG4gKiBAZGVzY3JpcHRpb24gIOaVsOaNrua6kOW8leaTjuexu+Wei+aemuS4vuOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5FbmdpbmVUeXBlLklNQUdFUExVR0lOUztcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IEVuZ2luZVR5cGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gRW5naW5lVHlwZS5JTUFHRVBMVUdJTlM7XG4gKiBgYGBcbiAqL1xudmFyIEVuZ2luZVR5cGUgPSB7XG4gICAgLyoqIOW9seWDj+WPquivu+W8leaTjuexu+Wei++8jOaWh+S7tuW8leaTju+8jOmSiOWvuemAmueUqOW9seWDj+agvOW8j+WmgiBCTVDvvIxKUEfvvIxUSUZGIOS7peWPiui2heWbvuiHquWumuS5ieW9seWDj+agvOW8jyBTSVQg562J44CCICovXG4gICAgSU1BR0VQTFVHSU5TOiBcIklNQUdFUExVR0lOU1wiLFxuICAgIC8qKiAgT0dDIOW8leaTjuexu+Wei++8jOmSiOWvueS6jiBXZWIg5pWw5o2u5rqQ77yMV2ViIOW8leaTju+8jOebruWJjeaUr+aMgeeahOexu+Wei+aciSBXTVPvvIxXRlPvvIxXQ1PjgIIgKi9cbiAgICBPR0M6IFwiT0dDXCIsXG4gICAgLyoqICBPcmFjbGUg5byV5pOO57G75Z6L77yM6ZKI5a+5IE9yYWNsZSDmlbDmja7mupDvvIzmlbDmja7lupPlvJXmk47jgIIgKi9cbiAgICBPUkFDTEVQTFVTOiBcIk9SQUNMRVBMVVNcIixcbiAgICAvKiogIFNEQiDlvJXmk47nsbvlnovvvIzmlofku7blvJXmk47vvIzljbMgU0RCIOaVsOaNrua6kOOAgiAqL1xuICAgIFNEQlBMVVM6IFwiU0RCUExVU1wiLFxuICAgIC8qKiAgU1FMIFNlcnZlciDlvJXmk47nsbvlnovvvIzpkojlr7kgU1FMIFNlcnZlciDmlbDmja7mupDvvIzmlbDmja7lupPlvJXmk44gKi9cbiAgICBTUUxQTFVTOiBcIlNRTFBMVVNcIixcbiAgICAvKiogIFVEQiDlvJXmk47nsbvlnovvvIzmlofku7blvJXmk47jgIIgKi9cbiAgICBVREI6IFwiVURCXCJcbn07XG5cbi8qKlxuICogQGVudW0gVGhlbWVHcmFwaFRleHRGb3JtYXRcbiAqIEBkZXNjcmlwdGlvbiAg57uf6K6h5LiT6aKY5Zu+5paH5pys5pi+56S65qC85byP5p6a5Li+44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LlRoZW1lR3JhcGhUZXh0Rm9ybWF0LkNBUFRJT047XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBUaGVtZUdyYXBoVGV4dEZvcm1hdCB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBUaGVtZUdyYXBoVGV4dEZvcm1hdC5DQVBUSU9OO1xuICogYGBgXG4gKi9cbnZhciBUaGVtZUdyYXBoVGV4dEZvcm1hdCA9IHtcbiAgICAvKiogIOagh+mimOOAguS7peWQhOWtkOmhueeahOagh+mimOadpei/m+ihjOagh+azqOOAgiAqL1xuICAgIENBUFRJT046IFwiQ0FQVElPTlwiLFxuICAgIC8qKiAg5qCH6aKYICsg55m+5YiG5pWw44CC5Lul5ZCE5a2Q6aG555qE5qCH6aKY5ZKM5omA5Y2g55qE55m+5YiG5q+U5p2l6L+b6KGM5qCH5rOo44CCICovXG4gICAgQ0FQVElPTl9QRVJDRU5UOiBcIkNBUFRJT05fUEVSQ0VOVFwiLFxuICAgIC8qKiAg5qCH6aKYICsg5a6e6ZmF5pWw5YC844CC5Lul5ZCE5a2Q6aG555qE5qCH6aKY5ZKM55yf5a6e5pWw5YC85p2l6L+b6KGM5qCH5rOo44CCICovXG4gICAgQ0FQVElPTl9WQUxVRTogXCJDQVBUSU9OX1ZBTFVFXCIsXG4gICAgLyoqICDnmb7liIbmlbDjgILku6XlkITlrZDpobnmiYDljaDnmoTnmb7liIbmr5TmnaXov5vooYzmoIfms6jjgIIgKi9cbiAgICBQRVJDRU5UOiBcIlBFUkNFTlRcIixcbiAgICAvKiogIOWunumZheaVsOWAvOOAguS7peWQhOWtkOmhueeahOecn+WunuaVsOWAvOadpei/m+ihjOagh+azqOOAgiAqL1xuICAgIFZBTFVFOiBcIlZBTFVFXCJcblxufTtcblxuLyoqXG4gKiBAZW51bSBUaGVtZUdyYXBoVHlwZVxuICogQGRlc2NyaXB0aW9uICDnu5/orqHkuJPpopjlm77nsbvlnovmnprkuL7jgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uVGhlbWVHcmFwaFR5cGUuQVJFQTtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFRoZW1lR3JhcGhUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFRoZW1lR3JhcGhUeXBlLkFSRUE7XG4gKiBgYGBcbiAqL1xudmFyIFRoZW1lR3JhcGhUeXBlID0ge1xuICAgIC8qKiAg6Z2i56ev5Zu+44CCICovXG4gICAgQVJFQTogXCJBUkVBXCIsXG4gICAgLyoqICDmn7Hnirblm77jgIIgKi9cbiAgICBCQVI6IFwiQkFSXCIsXG4gICAgLyoqICDkuInnu7Tmn7Hnirblm77jgIIgKi9cbiAgICBCQVIzRDogXCJCQVIzRFwiLFxuICAgIC8qKiAg5oqY57q/5Zu+44CCICovXG4gICAgTElORTogXCJMSU5FXCIsXG4gICAgLyoqICDppbzlm77jgIIgKi9cbiAgICBQSUU6IFwiUElFXCIsXG4gICAgLyoqICDkuInnu7Tppbzlm77jgIIgKi9cbiAgICBQSUUzRDogXCJQSUUzRFwiLFxuICAgIC8qKiAg54K554q25Zu+44CCICovXG4gICAgUE9JTlQ6IFwiUE9JTlRcIixcbiAgICAvKiogIOeOr+eKtuWbvuOAgiAqL1xuICAgIFJJTkc6IFwiUklOR1wiLFxuICAgIC8qKiAg546r55Gw5Zu+44CCICovXG4gICAgUk9TRTogXCJST1NFXCIsXG4gICAgLyoqICDkuInnu7TnjqvnkbDlm77jgIIgKi9cbiAgICBST1NFM0Q6IFwiUk9TRTNEXCIsXG4gICAgLyoqICDloIblj6Dmn7Hnirblm77jgIIgKi9cbiAgICBTVEFDS19CQVI6IFwiU1RBQ0tfQkFSXCIsXG4gICAgLyoqICDkuInnu7TloIblj6Dmn7Hnirblm77jgIIgKi9cbiAgICBTVEFDS19CQVIzRDogXCJTVEFDS19CQVIzRFwiLFxuICAgIC8qKiAg6Zi25qKv5Zu+44CCICovXG4gICAgU1RFUDogXCJTVEVQXCJcbn07XG5cbi8qKlxuICogQGVudW0gR3JhcGhBeGVzVGV4dERpc3BsYXlNb2RlXG4gKiBAZGVzY3JpcHRpb24gIOe7n+iuoeS4k+mimOWbvuWdkOagh+i9tOaWh+acrOaYvuekuuaooeW8j+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5HcmFwaEF4ZXNUZXh0RGlzcGxheU1vZGUuQUxMO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgR3JhcGhBeGVzVGV4dERpc3BsYXlNb2RlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEdyYXBoQXhlc1RleHREaXNwbGF5TW9kZS5BTEw7XG4gKiBgYGBcbiAqL1xudmFyIEdyYXBoQXhlc1RleHREaXNwbGF5TW9kZSA9IHtcbiAgICAvKiogIOaYvuekuuWFqOmDqOaWh+acrOOAgiAqL1xuICAgIEFMTDogXCJBTExcIixcbiAgICAvKiogIOS4jeaYvuekuuOAgiAqL1xuICAgIE5PTkU6IFwiTk9ORVwiLFxuICAgIC8qKiAg5pi+56S6Wei9tOeahOaWh+acrOOAgiAqL1xuICAgIFlBWEVTOiBcIllBWEVTXCJcbn07XG5cbi8qKlxuICogQGVudW0gR3JhZHVhdGVkTW9kZVxuICogQGRlc2NyaXB0aW9uICDkuJPpopjlm77liIbnuqfmqKHlvI/mnprkuL7jgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uR3JhZHVhdGVkTW9kZS5DT05TVEFOVDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IEdyYWR1YXRlZE1vZGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gR3JhZHVhdGVkTW9kZS5DT05TVEFOVDtcbiAqIGBgYFxuICovXG52YXIgR3JhZHVhdGVkTW9kZSA9IHtcbiAgICAvKiogIOW4uOmHj+WIhue6p+aooeW8j+OAgiAqL1xuICAgIENPTlNUQU5UOiBcIkNPTlNUQU5UXCIsXG4gICAgLyoqIOWvueaVsOWIhue6p+aooeW8j+OAgiAqL1xuICAgIExPR0FSSVRITTogXCJMT0dBUklUSE1cIixcbiAgICAvKiogIOW5s+aWueagueWIhue6p+aooeW8j+OAgiAqL1xuICAgIFNRVUFSRVJPT1Q6IFwiU1FVQVJFUk9PVFwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFJhbmdlTW9kZVxuICogQGRlc2NyaXB0aW9uICDojIPlm7TliIbmrrXkuJPpopjlm77liIbmrrXmlrnlvI/mnprkuL7jgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uUmFuZ2VNb2RlLkNVU1RPTUlOVEVSVkFMO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgUmFuZ2VNb2RlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFJhbmdlTW9kZS5DVVNUT01JTlRFUlZBTDtcbiAqIGBgYFxuICovXG52YXIgUmFuZ2VNb2RlID0ge1xuICAgIC8qKiAg6Ieq5a6a5LmJ5YiG5q615rOV44CCICovXG4gICAgQ1VTVE9NSU5URVJWQUw6IFwiQ1VTVE9NSU5URVJWQUxcIixcbiAgICAvKiogIOetiei3neemu+WIhuauteazleOAgiAqL1xuICAgIEVRVUFMSU5URVJWQUw6IFwiRVFVQUxJTlRFUlZBTFwiLFxuICAgIC8qKiAg5a+55pWw5YiG5q615rOV44CCICovXG4gICAgTE9HQVJJVEhNOiBcIkxPR0FSSVRITVwiLFxuICAgIC8qKiAg562J6K6h5pWw5YiG5q615rOV44CCICovXG4gICAgUVVBTlRJTEU6IFwiUVVBTlRJTEVcIixcbiAgICAvKiogIOW5s+aWueagueWIhuauteazleOAgiAqL1xuICAgIFNRVUFSRVJPT1Q6IFwiU1FVQVJFUk9PVFwiLFxuICAgIC8qKiAg5qCH5YeG5beu5YiG5q615rOV44CCICovXG4gICAgU1REREVWSUFUSU9OOiBcIlNURERFVklBVElPTlwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFRoZW1lVHlwZVxuICogQGRlc2NyaXB0aW9uICDkuJPpopjlm77nsbvlnovmnprkuL7jgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uVGhlbWVUeXBlLkRPVERFTlNJVFk7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBUaGVtZVR5cGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gVGhlbWVUeXBlLkRPVERFTlNJVFk7XG4gKiBgYGBcbiAqL1xudmFyIFRoZW1lVHlwZSA9IHtcbiAgICAvKiog54K55a+G5bqm5LiT6aKY5Zu+44CCICovXG4gICAgRE9UREVOU0lUWTogXCJET1RERU5TSVRZXCIsXG4gICAgLyoqIOetiee6p+espuWPt+S4k+mimOWbvuOAgiAqL1xuICAgIEdSQURVQVRFRFNZTUJPTDogXCJHUkFEVUFURURTWU1CT0xcIixcbiAgICAvKiog57uf6K6h5LiT6aKY5Zu+44CCICovXG4gICAgR1JBUEg6IFwiR1JBUEhcIixcbiAgICAvKiog5qCH562+5LiT6aKY5Zu+44CCICovXG4gICAgTEFCRUw6IFwiTEFCRUxcIixcbiAgICAvKiog5YiG5q615LiT6aKY5Zu+44CCICovXG4gICAgUkFOR0U6IFwiUkFOR0VcIixcbiAgICAvKiog5Y2Y5YC85LiT6aKY5Zu+44CCICovXG4gICAgVU5JUVVFOiBcIlVOSVFVRVwiXG59O1xuXG4vKipcbiAqIEBlbnVtIENvbG9yR3JhZGllbnRUeXBlXG4gKiBAZGVzY3JpcHRpb24gIOa4kOWPmOminOiJsuaemuS4vuOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5Db2xvckdyYWRpZW50VHlwZS5CTEFDS19XSElURTtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IENvbG9yR3JhZGllbnRUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IENvbG9yR3JhZGllbnRUeXBlLkJMQUNLX1dISVRFO1xuICogYGBgXG4gKi9cbnZhciBDb2xvckdyYWRpZW50VHlwZSA9IHtcbiAgICAvKiog6buR55m95riQ5Y+Y6Imy44CCICovXG4gICAgQkxBQ0tfV0hJVEU6IFwiQkxBQ0tXSElURVwiLFxuICAgIC8qKiDok53pu5HmuJDlj5joibLjgIIgKi9cbiAgICBCTFVFX0JMQUNLOiBcIkJMVUVCTEFDS1wiLFxuICAgIC8qKiDok53nuqLmuJDlj5joibLjgIIgKi9cbiAgICBCTFVFX1JFRDogXCJCTFVFUkVEXCIsXG4gICAgLyoqIOiTneeZvea4kOWPmOiJsuOAgiAqL1xuICAgIEJMVUVfV0hJVEU6IFwiQkxVRVdISVRFXCIsXG4gICAgLyoqIOmdkum7kea4kOWPmOiJsuOAgiAqL1xuICAgIENZQU5fQkxBQ0s6IFwiQ1lBTkJMQUNLXCIsXG4gICAgLyoqIOmdkuiTnea4kOWPmOiJsuOAgiAqL1xuICAgIENZQU5fQkxVRTogXCJDWUFOQkxVRVwiLFxuICAgIC8qKiDpnZLnu7/muJDlj5joibLjgIIgKi9cbiAgICBDWUFOX0dSRUVOOiBcIkNZQU5HUkVFTlwiLFxuICAgIC8qKiDpnZLnmb3muJDlj5joibLjgIIgKi9cbiAgICBDWUFOX1dISVRFOiBcIkNZQU5XSElURVwiLFxuICAgIC8qKiDnu7/pu5HmuJDlj5joibLjgIIgKi9cbiAgICBHUkVFTl9CTEFDSzogXCJHUkVFTkJMQUNLXCIsXG4gICAgLyoqIOe7v+iTnea4kOWPmOiJsuOAgiAqL1xuICAgIEdSRUVOX0JMVUU6IFwiR1JFRU5CTFVFXCIsXG4gICAgLyoqIOe7v+apmee0q+a4kOWPmOiJsuOAgiAqL1xuICAgIEdSRUVOX09SQU5HRV9WSU9MRVQ6IFwiR1JFRU5PUkFOR0VWSU9MRVRcIixcbiAgICAvKiog57u/57qi5riQ5Y+Y6Imy44CCICovXG4gICAgR1JFRU5fUkVEOiBcIkdSRUVOUkVEXCIsXG4gICAgLyoqIOiTnee6oua4kOWPmOiJsuOAgiAqL1xuICAgIEdSRUVOX1dISVRFOiBcIkdSRUVOV0hJVEVcIixcbiAgICAvKiog57KJ6buR5riQ5Y+Y6Imy44CCICovXG4gICAgUElOS19CTEFDSzogXCJQSU5LQkxBQ0tcIixcbiAgICAvKiog57KJ6JOd5riQ5Y+Y6Imy44CCICovXG4gICAgUElOS19CTFVFOiBcIlBJTktCTFVFXCIsXG4gICAgLyoqIOeyiee6oua4kOWPmOiJsuOAgiAqL1xuICAgIFBJTktfUkVEOiBcIlBJTktSRURcIixcbiAgICAvKiog57KJ55m95riQ5Y+Y6Imy44CCICovXG4gICAgUElOS19XSElURTogXCJQSU5LV0hJVEVcIixcbiAgICAvKiog5b2p6Jm56Imy44CCICovXG4gICAgUkFJTl9CT1c6IFwiUkFJTkJPV1wiLFxuICAgIC8qKiDnuqLpu5HmuJDlj5joibLjgIIgKi9cbiAgICBSRURfQkxBQ0s6IFwiUkVEQkxBQ0tcIixcbiAgICAvKiog57qi55m95riQ5Y+Y6Imy44CCICovXG4gICAgUkVEX1dISVRFOiBcIlJFRFdISVRFXCIsXG4gICAgLyoqIOWFieiwsea4kOWPmOOAgiAqL1xuICAgIFNQRUNUUlVNOiBcIlNQRUNUUlVNXCIsXG4gICAgLyoqIOWcsOW9oua4kOWPmCznlKjkuo7kuInnu7TmmL7npLrmlYjmnpzovoPlpb3jgIIgKi9cbiAgICBURVJSQUlOOiBcIlRFUlJBSU5cIixcbiAgICAvKiog6buE6buR5riQ5Y+Y6Imy44CCICovXG4gICAgWUVMTE9XX0JMQUNLOiBcIllFTExPV0JMQUNLXCIsXG4gICAgLyoqIOm7hOiTnea4kOWPmOiJsuOAgiAqL1xuICAgIFlFTExPV19CTFVFOiBcIllFTExPV0JMVUVcIixcbiAgICAvKiog6buE57u/5riQ5Y+Y6Imy44CCICovXG4gICAgWUVMTE9XX0dSRUVOOiBcIllFTExPV0dSRUVOXCIsXG4gICAgLyoqIOm7hOe6oua4kOWPmOiJsuOAgiAqL1xuICAgIFlFTExPV19SRUQ6IFwiWUVMTE9XUkVEXCIsXG4gICAgLyoqIOm7hOeZvea4kOWPmOiJsuOAgiAqL1xuICAgIFlFTExPV19XSElURTogXCJZRUxMT1dXSElURVwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFRleHRBbGlnbm1lbnRcbiAqIEBkZXNjcmlwdGlvbiAg5paH5pys5a+56b2Q5p6a5Li+44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LlRleHRBbGlnbm1lbnQuVE9QTEVGVDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFRleHRBbGlnbm1lbnQgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gVGV4dEFsaWdubWVudC5UT1BMRUZUO1xuICogYGBgXG4gKi9cbnZhciBUZXh0QWxpZ25tZW50ID0ge1xuICAgIC8qKiDlt6bkuIrop5Llr7npvZDjgIIgKi9cbiAgICBUT1BMRUZUOiBcIlRPUExFRlRcIixcbiAgICAvKiog6aG26YOo5bGF5Lit5a+56b2Q44CCICovXG4gICAgVE9QQ0VOVEVSOiBcIlRPUENFTlRFUlwiLFxuICAgIC8qKiDlj7PkuIrop5Llr7npvZDjgIIgKi9cbiAgICBUT1BSSUdIVDogXCJUT1BSSUdIVFwiLFxuICAgIC8qKiDln7rlh4bnur/lt6blr7npvZDjgIIgKi9cbiAgICBCQVNFTElORUxFRlQ6IFwiQkFTRUxJTkVMRUZUXCIsXG4gICAgLyoqIOWfuuWHhue6v+WxheS4reWvuem9kOOAgiAqL1xuICAgIEJBU0VMSU5FQ0VOVEVSOiBcIkJBU0VMSU5FQ0VOVEVSXCIsXG4gICAgLyoqIOWfuuWHhue6v+WPs+Wvuem9kOOAgiAqL1xuICAgIEJBU0VMSU5FUklHSFQ6IFwiQkFTRUxJTkVSSUdIVFwiLFxuICAgIC8qKiDlt6bkuIvop5Llr7npvZDjgIIgKi9cbiAgICBCT1RUT01MRUZUOiBcIkJPVFRPTUxFRlRcIixcbiAgICAvKiog5bqV6YOo5bGF5Lit5a+56b2Q44CCICovXG4gICAgQk9UVE9NQ0VOVEVSOiBcIkJPVFRPTUNFTlRFUlwiLFxuICAgIC8qKiDlj7PkuIvop5Llr7npvZDjgIIgKi9cbiAgICBCT1RUT01SSUdIVDogXCJCT1RUT01SSUdIVFwiLFxuICAgIC8qKiDlt6bkuK3lr7npvZDjgIIgKi9cbiAgICBNSURETEVMRUZUOiBcIk1JRERMRUxFRlRcIixcbiAgICAvKiog5Lit5b+D5a+56b2Q44CCICovXG4gICAgTUlERExFQ0VOVEVSOiBcIk1JRERMRUNFTlRFUlwiLFxuICAgIC8qKiDlj7PkuK3lr7npvZDjgIIgKi9cbiAgICBNSURETEVSSUdIVDogXCJNSURETEVSSUdIVFwiXG59O1xuXG4vKipcbiAqIEBlbnVtIEZpbGxHcmFkaWVudE1vZGVcbiAqIEBkZXNjcmlwdGlvbiAg5riQ5Y+Y5aGr5YWF6aOO5qC855qE5riQ5Y+Y57G75Z6L5p6a5Li+44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LkZpbGxHcmFkaWVudE1vZGUuTk9ORTtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IEZpbGxHcmFkaWVudE1vZGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gRmlsbEdyYWRpZW50TW9kZS5OT05FO1xuICogYGBgXG4gKi9cbnZhciBGaWxsR3JhZGllbnRNb2RlID0ge1xuICAgIC8qKiDml6DmuJDlj5jjgIIgKi9cbiAgICBOT05FOiBcIk5PTkVcIixcbiAgICAvKiog57q/5oCn5riQ5Y+Y5aGr5YWF44CCICovXG4gICAgTElORUFSOiBcIkxJTkVBUlwiLFxuICAgIC8qKiDovpDlsITmuJDlj5jloavlhYXjgIIgKi9cbiAgICBSQURJQUw6IFwiUkFESUFMXCIsXG4gICAgLyoqIOWchumUpea4kOWPmOWhq+WFheOAgiAqL1xuICAgIENPTklDQUw6IFwiQ09OSUNBTFwiLFxuICAgIC8qKiDlm5vop5LmuJDlj5jloavlhYXjgIIgKi9cbiAgICBTUVVBUkU6IFwiU1FVQVJFXCJcbn07XG5cbi8qKlxuICogQGVudW0gQWxvbmdMaW5lRGlyZWN0aW9uXG4gKiBAZGVzY3JpcHRpb24gIOagh+etvuayv+e6v+agh+azqOaWueWQkeaemuS4vuOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5BbG9uZ0xpbmVEaXJlY3Rpb24uTk9STUFMO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgQWxvbmdMaW5lRGlyZWN0aW9uIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEFsb25nTGluZURpcmVjdGlvbi5OT1JNQUw7XG4gKiBgYGBcbiAqL1xudmFyIEFsb25nTGluZURpcmVjdGlvbiA9IHtcbiAgICAvKiog5rK/57q/55qE5rOV57q/5pa55ZCR5pS+572u5qCH562+44CCICovXG4gICAgTk9STUFMOiBcIkFMT05HX0xJTkVfTk9STUFMXCIsXG4gICAgLyoqIOS7juS4i+WIsOS4iu+8jOS7juW3puWIsOWPs+aUvue9ruOAgiAqL1xuICAgIExCX1RPX1JUOiBcIkxFRlRfQk9UVE9NX1RPX1JJR0hUX1RPUFwiLFxuICAgIC8qKiDku47kuIrliLDkuIvvvIzku47lt6bliLDlj7PmlL7nva7jgIIgKi9cbiAgICBMVF9UT19SQjogXCJMRUZUX1RPUF9UT19SSUdIVF9CT1RUT01cIixcbiAgICAvKiog5LuO5LiL5Yiw5LiK77yM5LuO5Y+z5Yiw5bem5pS+572u44CCICovXG4gICAgUkJfVE9fTFQ6IFwiUklHSFRfQk9UVE9NX1RPX0xFRlRfVE9QXCIsXG4gICAgLyoqIOS7juS4iuWIsOS4i++8jOS7juWPs+WIsOW3puaUvue9ruOAgiAqL1xuICAgIFJUX1RPX0xCOiBcIlJJR0hUX1RPUF9UT19MRUZUX0JPVFRPTVwiXG59O1xuXG4vKipcbiAqIEBlbnVtIExhYmVsQmFja1NoYXBlXG4gKiBAZGVzY3JpcHRpb24gIOagh+etvuS4k+mimOWbvuS4reagh+etvuiDjOaZr+eahOW9oueKtuaemuS4vuOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5MYWJlbEJhY2tTaGFwZS5ESUFNT05EO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgTGFiZWxCYWNrU2hhcGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gTGFiZWxCYWNrU2hhcGUuRElBTU9ORDtcbiAqIGBgYFxuICovXG52YXIgTGFiZWxCYWNrU2hhcGUgPSB7XG4gICAgLyoqIOiPseW9ouiDjOaZr++8jOWNs+agh+etvuiDjOaZr+eahOW9oueKtuS4uuiPseW9ouOAgiAqL1xuICAgIERJQU1PTkQ6IFwiRElBTU9ORFwiLFxuICAgIC8qKiDmpK3lnIblvaLog4zmma/vvIzljbPmoIfnrb7og4zmma/nmoTooYznirbkuLrmpK3lnIblvaLjgIIgKi9cbiAgICBFTExJUFNFOiBcIkVMTElQU0VcIixcbiAgICAvKiog56ym5Y+36IOM5pmv77yM5Y2z5qCH562+6IOM5pmv55qE5b2i54q25Li66K6+5a6a55qE56ym5Y+344CCICovXG4gICAgTUFSS0VSOiBcIk1BUktFUlwiLFxuICAgIC8qKiDnqbrog4zmma/vvIzljbPkuI3kvb/nlKjku7vkvZXlvaLnirbkvZzkuLrmoIfnrb7nmoTog4zmma/jgIIgKi9cbiAgICBOT05FOiBcIk5PTkVcIixcbiAgICAvKiog55+p5b2i6IOM5pmv77yM5Y2z5qCH562+6IOM5pmv55qE5b2i54q25Li655+p5b2i44CCICovXG4gICAgUkVDVDogXCJSRUNUXCIsXG4gICAgLyoqIOWchuinkuefqeW9ouiDjOaZr++8jOWNs+agh+etvuiDjOaZr+eahOW9oueKtuS4uuWchuinkuefqeW9ouOAgiAqL1xuICAgIFJPVU5EUkVDVDogXCJST1VORFJFQ1RcIixcbiAgICAvKiog5LiJ6KeS5b2i6IOM5pmv77yM5Y2z5qCH562+6IOM5pmv55qE5b2i54q25Li65LiJ6KeS5b2i44CCICovXG4gICAgVFJJQU5HTEU6IFwiVFJJQU5HTEVcIlxufTtcblxuLyoqXG4gKiBAZW51bSBMYWJlbE92ZXJMZW5ndGhNb2RlXG4gKiBAZGVzY3JpcHRpb24gIOagh+etvuS4k+mimOWbvuS4rei2hemVv+agh+etvueahOWkhOeQhuaooeW8j+aemuS4vuOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5MYWJlbE92ZXJMZW5ndGhNb2RlLk5FV0xJTkU7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBMYWJlbE92ZXJMZW5ndGhNb2RlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IExhYmVsT3Zlckxlbmd0aE1vZGUuTkVXTElORTtcbiAqIGBgYFxuICovXG52YXIgTGFiZWxPdmVyTGVuZ3RoTW9kZSA9IHtcbiAgICAvKiog5o2i6KGM5pi+56S644CCICovXG4gICAgTkVXTElORTogXCJORVdMSU5FXCIsXG4gICAgLyoqIOWvuei2hemVv+agh+etvuS4jei/m+ihjOWkhOeQhuOAgiAqL1xuICAgIE5PTkU6IFwiTk9ORVwiLFxuICAgIC8qKiDnnIHnlaXotoXlh7rpg6jliIbjgIIgKi9cbiAgICBPTUlUOiBcIk9NSVRcIlxufTtcblxuLyoqXG4gKiBAZW51bSBEaXJlY3Rpb25UeXBlXG4gKiBAZGVzY3JpcHRpb24gIOe9kee7nOWIhuaekOS4reaWueWQkeaemuS4vuOAglxuICog5Zyo6KGM6am25byV5a+85a2Q6aG55Lit5L2/55So44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LkRpcmVjdGlvblR5cGUuRUFTVDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IERpcmVjdGlvblR5cGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gRGlyZWN0aW9uVHlwZS5FQVNUO1xuICogYGBgXG4gKi9cbnZhciBEaXJlY3Rpb25UeXBlID0ge1xuICAgIC8qKiDkuJzjgIIgKi9cbiAgICBFQVNUOiBcIkVBU1RcIixcbiAgICAvKiog5peg5pa55ZCR44CCICovXG4gICAgTk9ORTogXCJOT05FXCIsXG4gICAgLyoqIOWMl+OAgiAqL1xuICAgIE5PUlRIOiBcIk5PUlRIXCIsXG4gICAgLyoqIOWNl+OAgiAqL1xuICAgIFNPVVJUSDogXCJTT1VSVEhcIixcbiAgICAvKiog6KW/44CCICovXG4gICAgV0VTVDogXCJXRVNUXCJcbn07XG5cbi8qKlxuICogQGVudW0gU2lkZVR5cGVcbiAqIEBkZXNjcmlwdGlvbiAg6KGM6am25L2N572u5p6a5Li+44CCXG4gKiDooajnpLrlnKjooYzpqbblnKjot6/nmoTlt6bovrnjgIHlj7PovrnmiJbogIXot6/kuIrnmoTmnprkuL4s6K+l57G755So5Zyo6KGM6am25a+85byV5a2Q6aG557G75Lit44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LlNpZGVUeXBlLkxFRlQ7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBTaWRlVHlwZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBTaWRlVHlwZS5MRUZUO1xuICogYGBgXG4gKi9cbnZhciBTaWRlVHlwZSA9IHtcbiAgICAvKiog6Lev55qE5bem5L6n44CCICovXG4gICAgTEVGVDogXCJMRUZUXCIsXG4gICAgLyoqIOWcqOi3r+S4iu+8iOWNs+i3r+eahOS4remXtO+8ieOAgiAqL1xuICAgIE1JRERMRTogXCJNSURETEVcIixcbiAgICAvKiog5peg5pWI5YC844CCICovXG4gICAgTk9ORTogXCJOT05FXCIsXG4gICAgLyoqIOi3r+eahOWPs+S+p+OAgiAqL1xuICAgIFJJR0hUOiBcIlJJR0hUXCJcbn07XG5cbi8qKlxuICogQGVudW0gU3VwcGx5Q2VudGVyVHlwZVxuICogQGRlc2NyaXB0aW9uICDotYTmupDkvpvnu5nkuK3lv4PnsbvlnovmnprkuL7jgIJcbiAqIOivpeaemuS4vuWumuS5ieS6hue9kee7nOWIhuaekOS4rei1hOa6kOS4reW/g+eCueeahOexu+Wei++8jOS4u+imgeeUqOS6jui1hOa6kOWIhumFjeWSjOmAieWdgOWIhuWMuuOAglxuICog6LWE5rqQ5L6b57uZ5Lit5b+D54K555qE57G75Z6L5YyF5ous6Z2e5Lit5b+D77yM5Zu65a6a5Lit5b+D5ZKM5Y+v6YCJ5Lit5b+D44CC5Zu65a6a5Lit5b+D55So5LqO6LWE5rqQ5YiG6YWN5YiG5p6Q77ybIOWbuuWumuS4reW/g+WSjOWPr+mAieS4reW/g+eUqOS6jumAieWdgOWIhuaekO+8m+mdnuS4reW/g+WcqOS4pOenjee9kee7nOWIhuaekOaXtumDveS4jeS6iOiAg+iZkeOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5TdXBwbHlDZW50ZXJUeXBlLkZJWEVEQ0VOVEVSO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgU3VwcGx5Q2VudGVyVHlwZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBTdXBwbHlDZW50ZXJUeXBlLkZJWEVEQ0VOVEVSO1xuICogYGBgXG4gKi9cbnZhciBTdXBwbHlDZW50ZXJUeXBlID0ge1xuICAgIC8qKiDlm7rlrprkuK3lv4PngrnjgIIgKi9cbiAgICBGSVhFRENFTlRFUjogXCJGSVhFRENFTlRFUlwiLFxuICAgIC8qKiDpnZ7kuK3lv4PngrnjgIIgKi9cbiAgICBOVUxMOiBcIk5VTExcIixcbiAgICAvKiog5Y+v6YCJ5Lit5b+D54K544CCICovXG4gICAgT1BUSU9OQUxDRU5URVI6IFwiT1BUSU9OQUxDRU5URVJcIlxufTtcblxuLyoqXG4gKiBAZW51bSBUdXJuVHlwZVxuICogQGRlc2NyaXB0aW9uICDovazlvK/mlrnlkJHmnprkuL7jgIJcbiAqIOeUqOWcqOihjOmptuW8leWvvOWtkOmhueexu+S4re+8jOihqOekuui9rOW8r+eahOaWueWQkeOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5UdXJuVHlwZS5BSEVBRDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFR1cm5UeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFR1cm5UeXBlLkFIRUFEO1xuICogYGBgXG4gKi9cbnZhciBUdXJuVHlwZSA9IHtcbiAgICAvKiog5ZCR5YmN55u06KGM44CCICovXG4gICAgQUhFQUQ6IFwiQUhFQURcIixcbiAgICAvKiog5o6J5aS044CCICovXG4gICAgQkFDSzogXCJCQUNLXCIsXG4gICAgLyoqIOe7iOeCue+8jOS4jeaLkOW8r+OAgiAqL1xuICAgIEVORDogXCJFTkRcIixcbiAgICAvKiog5bem6L2s5byv44CCICovXG4gICAgTEVGVDogXCJMRUZUXCIsXG4gICAgLyoqIOaXoOaViOWAvOOAgiAqL1xuICAgIE5PTkU6IFwiTk9ORVwiLFxuICAgIC8qKiDlj7PovazlvK/jgIIgKi9cbiAgICBSSUdIVDogXCJSSUdIVFwiXG59O1xuXG4vKipcbiAqIEBlbnVtIEJ1ZmZlckVuZFR5cGVcbiAqIEBkZXNjcmlwdGlvbiAg57yT5Yay5Yy65YiG5p6QQnVmZmVyRW5k57G75Z6L44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LkJ1ZmZlckVuZFR5cGUuRkxBVDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IEJ1ZmZlckVuZFR5cGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gQnVmZmVyRW5kVHlwZS5GTEFUO1xuICogYGBgXG4gKi9cbnZhciBCdWZmZXJFbmRUeXBlID0ge1xuICAgIC8qKiBGTEFUICovXG4gICAgRkxBVDogXCJGTEFUXCIsXG4gICAgLyoqIFJPVU5EICovXG4gICAgUk9VTkQ6IFwiUk9VTkRcIlxufTtcbi8qKlxuICogQGVudW0gT3ZlcmxheU9wZXJhdGlvblR5cGVcbiAqIEBkZXNjcmlwdGlvbiAg5Y+g5Yqg5YiG5p6Q57G75Z6L5p6a5Li+44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9Lk92ZXJsYXlPcGVyYXRpb25UeXBlLkNMSVA7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBPdmVybGF5T3BlcmF0aW9uVHlwZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBPdmVybGF5T3BlcmF0aW9uVHlwZS5DTElQO1xuICogYGBgXG4gKi9cbiB2YXIgT3ZlcmxheU9wZXJhdGlvblR5cGUgPSB7XG4gICAgLyoqIOaTjeS9nOaVsOaNrumbhu+8iOWHoOS9leWvueixoe+8ieijgeWJquiiq+aTjeS9nOaVsOaNrumbhu+8iOWHoOS9leWvueixoe+8ieOAgiAqL1xuICAgIENMSVA6IFwiQ0xJUFwiLFxuICAgIC8qKiDlnKjooqvmk43kvZzmlbDmja7pm4bvvIjlh6DkvZXlr7nosaHvvInkuIrmk6bpmaTmjonkuI7mk43kvZzmlbDmja7pm4bvvIjlh6DkvZXlr7nosaHvvInnm7jph43lkIjnmoTpg6jliIbjgIIgKi9cbiAgICBFUkFTRTogXCJFUkFTRVwiLFxuICAgIC8qKuWvueiiq+aTjeS9nOaVsOaNrumbhu+8iOWHoOS9leWvueixoe+8iei/m+ihjOWQjOS4gOaTjeS9nO+8jOWNs+aTjeS9nOaJp+ihjOWQju+8jOiiq+aTjeS9nOaVsOaNrumbhu+8iOWHoOS9leWvueixoe+8ieWMheWQq+adpeiHquaTjeS9nOaVsOaNrumbhu+8iOWHoOS9leWvueixoe+8ieeahOWHoOS9leW9oueKtuOAgiAqL1xuICAgIElERU5USVRZOiBcIklERU5USVRZXCIsXG4gICAgLyoqIOWvueS4pOS4quaVsOaNrumbhu+8iOWHoOS9leWvueixoe+8ieaxguS6pO+8jOi/lOWbnuS4pOS4quaVsOaNrumbhu+8iOWHoOS9leWvueixoe+8ieeahOS6pOmbhuOAgiAqL1xuICAgIElOVEVSU0VDVDogXCJJTlRFUlNFQ1RcIixcbiAgICAvKiog5a+55Lik5Liq6Z2i5pWw5o2u6ZuG77yI5Yeg5L2V5a+56LGh77yJ6L+b6KGM5ZCI5bm25pON5L2c44CCICovXG4gICAgVU5JT046IFwiVU5JT05cIixcbiAgICAvKiog5a+55Lik5Liq6Z2i5pWw5o2u6ZuG77yI5Yeg5L2V5a+56LGh77yJ6L+b6KGM5pu05paw5pON5L2c44CCICovXG4gICAgVVBEQVRFOiBcIlVQREFURVwiLFxuICAgIC8qKiDlr7nkuKTkuKrpnaLmlbDmja7pm4bvvIjlh6DkvZXlr7nosaHvvInov5vooYzlr7nnp7Dlt67mk43kvZzjgIIgKi9cbiAgICBYT1I6IFwiWE9SXCJcbn07XG5cbi8qKlxuICogQGVudW0gT3V0cHV0VHlwZVxuICogQGRlc2NyaXB0aW9uICDliIbluIPlvI/liIbmnpDovpPlh7rnsbvlnovmnprkuL7jgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uT3V0cHV0VHlwZS5JTkRFWEVESERGUztcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IE91dHB1dFR5cGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gT3V0cHV0VHlwZS5JTkRFWEVESERGUztcbiAqIGBgYFxuICovXG52YXIgT3V0cHV0VHlwZSA9ICB7XG4gICAgLyoqIElOREVYRURIREZTICovXG4gICAgSU5ERVhFREhERlM6IFwiSU5ERVhFREhERlNcIixcbiAgICAvKiogVURCICovXG4gICAgVURCOiBcIlVEQlwiLFxuICAgIC8qKiBNT05HT0RCICovXG4gICAgTU9OR09EQjogXCJNT05HT0RCXCIsXG4gICAgLyoqIFBHICovXG4gICAgUEc6IFwiUEdcIlxufTtcblxuLyoqXG4gKiBAZW51bSBTbW9vdGhNZXRob2RcbiAqIEBkZXNjcmlwdGlvbiAg5YWJ5ruR5pa55rOV5p6a5Li+44CCXG4gKiDnlKjkuo7ku45HcmlkIOaIlkRFTeaVsOaNrueUn+aIkOetieWAvOe6v+aIluetieWAvOmdouaXtuWvueetieWAvOe6v+aIluiAheetieWAvOmdoueahOi+ueeVjOe6v+i/m+ihjOW5s+a7keWkhOeQhueahOaWueazleOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5TbW9vdGhNZXRob2QuQlNQTElORTtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFNtb290aE1ldGhvZCB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBTbW9vdGhNZXRob2QuQlNQTElORTtcbiAqIGBgYFxuICovXG4gdmFyIFNtb290aE1ldGhvZCA9IHtcbiAgICAvKiogQiDmoLfmnaHms5XjgIIgKi9cbiAgICBCU1BMSU5FOiBcIkJTUExJTkVcIixcbiAgICAvKiog56Oo6KeS5rOV44CCICovXG4gICAgUE9MSVNIOiBcIlBPTElTSFwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFN1cmZhY2VBbmFseXN0TWV0aG9kXG4gKiBAZGVzY3JpcHRpb24gIOihqOmdouWIhuaekOaWueazleaemuS4vuOAglxuICog6YCa6L+H5a+55pWw5o2u6L+b6KGM6KGo6Z2i5YiG5p6Q77yM6IO95aSf5oyW5o6Y5Y6f5aeL5pWw5o2u5omA5YyF5ZCr55qE5L+h5oGv77yM5L2/5p+Q5Lqb57uG6IqC5piO5pi+5YyW77yM5piT5LqO5YiG5p6Q44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LlN1cmZhY2VBbmFseXN0TWV0aG9kLklTT0xJTkU7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBTdXJmYWNlQW5hbHlzdE1ldGhvZCB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBTdXJmYWNlQW5hbHlzdE1ldGhvZC5JU09MSU5FO1xuICogYGBgXG4gKi9cbnZhciBTdXJmYWNlQW5hbHlzdE1ldGhvZCA9IHtcbiAgICAvKiog562J5YC857q/5o+Q5Y+W44CCICovXG4gICAgSVNPTElORTogXCJJU09MSU5FXCIsXG4gICAgLyoqIOetieWAvOmdouaPkOWPluOAgiAqL1xuICAgIElTT1JFR0lPTjogXCJJU09SRUdJT05cIlxufTtcblxuLyoqXG4gKiBAZW51bSBEYXRhUmV0dXJuTW9kZVxuICogQGRlc2NyaXB0aW9uICDmlbDmja7ov5Tlm57mqKHlvI/mnprkuL7jgIJcbiAqIOivpeaemuS4vueUqOS6juaMh+WumuepuumXtOWIhuaekOi/lOWbnue7k+aenOaooeW8jyzljIXlkKvov5Tlm57mlbDmja7pm4bmoIfor4blkozorrDlvZXpm4bjgIHlj6rov5Tlm57mlbDmja7pm4bmoIfor4Yo5pWw5o2u6ZuG5ZCN56ewQOaVsOaNrua6kOWQjeensCnlj4rlj6rov5Tlm57orrDlvZXpm4bkuInnp43mqKHlvI/jgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uRGF0YVJldHVybk1vZGUuREFUQVNFVF9BTkRfUkVDT1JEU0VUO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgRGF0YVJldHVybk1vZGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gRGF0YVJldHVybk1vZGUuREFUQVNFVF9BTkRfUkVDT1JEU0VUO1xuICogYGBgXG4gKi9cbnZhciBEYXRhUmV0dXJuTW9kZSA9IHtcbiAgICAvKiog6L+U5Zue57uT5p6c5pWw5o2u6ZuG5qCH6K+GKOaVsOaNrumbhuWQjeensEDmlbDmja7mupDlkI3np7Ap5ZKM6K6w5b2V6ZuG77yIUmVjb3JkU2V077yJ44CCICovXG4gICAgREFUQVNFVF9BTkRfUkVDT1JEU0VUOiBcIkRBVEFTRVRfQU5EX1JFQ09SRFNFVFwiLFxuICAgIC8qKiDlj6rov5Tlm57mlbDmja7pm4bmoIfor4bvvIjmlbDmja7pm4blkI3np7BA5pWw5o2u5rqQ5ZCN56ew77yJ44CCICovXG4gICAgREFUQVNFVF9PTkxZOiBcIkRBVEFTRVRfT05MWVwiLFxuICAgIC8qKiDlj6rov5Tlm57orrDlvZXpm4bvvIhSZWNvcmRTZXTvvInjgIIgKi9cbiAgICBSRUNPUkRTRVRfT05MWTogXCJSRUNPUkRTRVRfT05MWVwiXG59O1xuXG4vKipcbiAqIEBlbnVtIEVkaXRUeXBlXG4gKiBAZGVzY3JpcHRpb24gIOimgee0oOmbhuabtOaWsOaooeW8j+aemuS4vuOAglxuICog6K+l5p6a5Li+55So5LqO5oyH5a6a5pWw5o2u5pyN5Yqh5Lit6KaB57Sg6ZuG5pu05paw5qih5byPLOWMheWQq+a3u+WKoOimgee0oOmbhuOAgeabtOaWsOimgee0oOmbhuWSjOWIoOmZpOimgee0oOmbhuOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5FZGl0VHlwZS5BREQ7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBFZGl0VHlwZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5FZGl0VHlwZS5BREQ7XG4gKiBgYGBcbiAqL1xudmFyIEVkaXRUeXBlID0ge1xuICAgIC8qKiDlop7liqDmk43kvZzjgIIgKi9cbiAgICBBREQ6IFwiYWRkXCIsXG4gICAgLyoqIOS/ruaUueaTjeS9nOOAgiAqL1xuICAgIFVQREFURTogXCJ1cGRhdGVcIixcbiAgICAvKiog5Yig6Zmk5pON5L2c44CCICovXG4gICAgREVMRVRFOiBcImRlbGV0ZVwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFRyYW5zZmVyVGFjdGljXG4gKiBAZGVzY3JpcHRpb24gIOWFrOS6pOaNouS5mOetlueVpeaemuS4vuOAglxuICog6K+l5p6a5Li+55So5LqO5oyH5a6a5YWs5Lqk5pyN5Yqh5Lit6KaB57Sg6ZuG5pu05paw5qih5byPLOWMheWQq+a3u+WKoOimgee0oOmbhuOAgeabtOaWsOimgee0oOmbhuWSjOWIoOmZpOimgee0oOmbhuOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5UcmFuc2ZlclRhY3RpYy5MRVNTX1RJTUU7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBUcmFuc2ZlclRhY3RpYyB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBUcmFuc2ZlclRhY3RpYy5MRVNTX1RJTUU7XG4gKiBgYGBcbiAqL1xudmFyIFRyYW5zZmVyVGFjdGljID0ge1xuICAgIC8qKiDml7bpl7Tnn63jgIIgKi9cbiAgICBMRVNTX1RJTUU6IFwiTEVTU19USU1FXCIsXG4gICAgLyoqIOWwkeaNouS5mOOAgiAqL1xuICAgIExFU1NfVFJBTlNGRVI6IFwiTEVTU19UUkFOU0ZFUlwiLFxuICAgIC8qKiDlsJHmraXooYzjgIIgKi9cbiAgICBMRVNTX1dBTEs6IFwiTEVTU19XQUxLXCIsXG4gICAgLyoqIOi3neemu+acgOefreOAgiAqL1xuICAgIE1JTl9ESVNUQU5DRTogXCJNSU5fRElTVEFOQ0VcIlxufTtcblxuLyoqXG4gKiBAZW51bSBUcmFuc2ZlclByZWZlcmVuY2VcbiAqIEBkZXNjcmlwdGlvbiAg5YWs5Lqk5o2i5LmY562W55Wl5p6a5Li+44CCXG4gKiDor6XmnprkuL7nlKjkuo7mjIflrprkuqTpgJrmjaLkuZjmnI3liqHkuK3orr7nva7lnLDpk4HkvJjlhYjjgIHlhazkuqTkvJjlhYjjgIHkuI3kuZjlnLDpk4HjgIHml6DlgY/lpb3nrYnlgY/lpb3orr7nva7jgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uVHJhbnNmZXJQcmVmZXJlbmNlLkJVUztcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFRyYW5zZmVyUHJlZmVyZW5jZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBUcmFuc2ZlclByZWZlcmVuY2UuQlVTO1xuICogYGBgXG4gKi9cbnZhciBUcmFuc2ZlclByZWZlcmVuY2UgPSB7XG4gICAgLyoqIOWFrOS6pOaxvei9puS8mOWFiOOAgiAqL1xuICAgIEJVUzogXCJCVVNcIixcbiAgICAvKiog5Zyw6ZOB5LyY5YWI44CCICovXG4gICAgU1VCV0FZOiBcIlNVQldBWVwiLFxuICAgIC8qKiDkuI3kuZjlnZDlnLDpk4HjgIIgKi9cbiAgICBOT19TVUJXQVk6IFwiTk9fU1VCV0FZXCIsXG4gICAgLyoqIOaXoOS5mOi9puWBj+WlveOAgiAqL1xuICAgIE5PTkU6IFwiTk9ORVwiXG59O1xuXG4vKipcbiAqIEBlbnVtIEdyaWRUeXBlXG4gKiBAZGVzY3JpcHRpb24gIOWcsOWbvuiDjOaZr+agvOe9keexu+Wei+aemuS4vuOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5HcmlkVHlwZS5DUk9TUztcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IEdyaWRUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEdyaWRUeXBlLkNST1NTO1xuICogYGBgXG4gKi9cbnZhciBHcmlkVHlwZSA9ICB7XG4gICAgLyoqIOWNgeWtl+WPieS4neOAgiAqL1xuICAgIENST1NTOiBcIkNST1NTXCIsXG4gICAgLyoqIOe9keagvOe6v+OAgiAqL1xuICAgIEdSSUQ6IFwiR1JJRFwiLFxuICAgIC8qKiDngrnjgIIgKi9cbiAgICBQT0lOVDogXCJQT0lOVFwiXG59O1xuXG4vKipcbiAqIEBlbnVtIENvbG9yU3BhY2VUeXBlXG4gKiBAZGVzY3JpcHRpb24gIOiJsuW9qeepuumXtOaemuS4vuOAglxuICog55Sx5LqO5oiQ6Imy5Y6f55CG55qE5LiN5ZCM77yM5Yaz5a6a5LqG5pi+56S65Zmo44CB5oqV5b2x5Luq6L+Z57G76Z2g6Imy5YWJ55u05o6l5ZCI5oiQ6aKc6Imy55qE6aKc6Imy6K6+5aSH5ZKM5omT5Y2w5py644CBXG4gKiDljbDliLfmnLrov5nnsbvpnaDkvb/nlKjpopzmlpnnmoTljbDliLforr7lpIflnKjnlJ/miJDpopzoibLmlrnlvI/kuIrnmoTljLrliKvjgIJcbiAqIOmSiOWvueS4iui/sOS4jeWQjOaIkOiJsuaWueW8j++8jFN1cGVyTWFwIOaPkOS+m+S4pOenjeiJsuW9qeepuumXtO+8jFxuICog5YiG5Yir5Li6IFJHQiDlkowgQ01ZS+OAglJHQiDkuLvopoHnlKjkuo7mmL7npLrns7vnu5/kuK3vvIxDTVlLIOS4u+imgeeUqOS6juWNsOWIt+ezu+e7n+S4reOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5Db2xvclNwYWNlVHlwZS5DTVlLO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgQ29sb3JTcGFjZVR5cGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gQ29sb3JTcGFjZVR5cGUuQ01ZSztcbiAqIGBgYFxuICovXG52YXIgQ29sb3JTcGFjZVR5cGUgPSB7XG4gICAgLyoqIOivpeexu+Wei+S4u+imgeWcqOWNsOWIt+ezu+e7n+S9v+eUqOOAgiAqL1xuICAgIENNWUs6IFwiQ01ZS1wiLFxuICAgIC8qKiDor6XnsbvlnovkuLvopoHlnKjmmL7npLrns7vnu5/kuK3kvb/nlKjjgIIgKi9cbiAgICBSR0I6IFwiUkdCXCJcbn07XG5cbi8qKlxuICogQGVudW0gTGF5ZXJUeXBlXG4gKiBAZGVzY3JpcHRpb24gIOWbvuWxguexu+Wei+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5MYXllclR5cGUuVUdDO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgTGF5ZXJUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IExheWVyVHlwZS5VR0M7XG4gKiBgYGBcbiAqL1xudmFyIExheWVyVHlwZSA9IHtcbiAgICAvKiogU3VwZXJNYXAgVUdDIOexu+Wei+WbvuWxguOAguWmguefoumHj+WbvuWxguOAgeagheagvChHcmlkKeWbvuWxguOAgeW9seWDj+WbvuWxguOAgiAqL1xuICAgIFVHQzogXCJVR0NcIixcbiAgICAvKiogV01TIOWbvuWxguOAgiAqL1xuICAgIFdNUzogXCJXTVNcIixcbiAgICAvKiogV0ZTIOWbvuWxguOAgiAqL1xuICAgIFdGUzogXCJXRlNcIixcbiAgICAvKiog6Ieq5a6a5LmJ5Zu+5bGC44CCICovXG4gICAgQ1VTVE9NOiBcIkNVU1RPTVwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFVHQ0xheWVyVHlwZVxuICogQGRlc2NyaXB0aW9uICBTdXBlck1hcCDlm77lsYLnsbvlnovjgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uVUdDTGF5ZXJUeXBlLlRIRU1FO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgVUdDTGF5ZXJUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFVHQ0xheWVyVHlwZS5USEVNRTtcbiAqIGBgYFxuICovXG52YXIgVUdDTGF5ZXJUeXBlID0ge1xuICAgIC8qKiDkuJPpopjlm77lsYLjgIIgKi9cbiAgICBUSEVNRTogXCJUSEVNRVwiLFxuICAgIC8qKiDnn6Lph4/lm77lsYLjgIIgKi9cbiAgICBWRUNUT1I6IFwiVkVDVE9SXCIsXG4gICAgLyoqIOagheagvOWbvuWxguOAguOAgiAqL1xuICAgIEdSSUQ6IFwiR1JJRFwiLFxuICAgIC8qKiDlvbHlg4/lm77lsYLjgIIgKi9cbiAgICBJTUFHRTogXCJJTUFHRVwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFN0YXRpc3RpY01vZGVcbiAqIEBkZXNjcmlwdGlvbiAg5a2X5q6157uf6K6h5pa55rOV57G75Z6L44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LlN0YXRpc3RpY01vZGUuQVZFUkFHRTtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFN0YXRpc3RpY01vZGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gU3RhdGlzdGljTW9kZS5BVkVSQUdFO1xuICogYGBgXG4gKi9cbnZhciBTdGF0aXN0aWNNb2RlID0ge1xuICAgIC8qKiDnu5/orqHmiYDpgInlrZfmrrXnmoTlubPlnYflgLzjgIIgKi9cbiAgICBBVkVSQUdFOiBcIkFWRVJBR0VcIixcbiAgICAvKiog57uf6K6h5omA6YCJ5a2X5q6155qE5pyA5aSn5YC844CCICovXG4gICAgTUFYOiBcIk1BWFwiLFxuICAgIC8qKiDnu5/orqHmiYDpgInlrZfmrrXnmoTmnIDlsI/lgLzjgIIgKi9cbiAgICBNSU46IFwiTUlOXCIsXG4gICAgLyoqIOe7n+iuoeaJgOmAieWtl+auteeahOagh+WHhuW3riAqL1xuICAgIFNURERFVklBVElPTjogXCJTVERERVZJQVRJT05cIixcbiAgICAvKiog57uf6K6h5omA6YCJ5a2X5q6155qE5oC75ZKM44CCICovXG4gICAgU1VNOiBcIlNVTVwiLFxuICAgIC8qKiDnu5/orqHmiYDpgInlrZfmrrXnmoTmlrnlt67jgIIgKi9cbiAgICBWQVJJQU5DRTogXCJWQVJJQU5DRVwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFBpeGVsRm9ybWF0XG4gKiBAZGVzY3JpcHRpb24gIOagheagvOS4juW9seWDj+aVsOaNruWtmOWCqOeahOWDj+e0oOagvOW8j+aemuS4vuOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5QaXhlbEZvcm1hdC5CSVQxNjtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFBpeGVsRm9ybWF0IH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFBpeGVsRm9ybWF0LkJJVDE2O1xuICogYGBgXG4gKi9cbnZhciBQaXhlbEZvcm1hdCA9IHtcbiAgICAvKiog5q+P5Liq5YOP5YWD55SoMTbkuKrmr5Tnibko5Y2zMuS4quWtl+iKginooajnpLrjgIIgKi9cbiAgICBCSVQxNjogXCJCSVQxNlwiLFxuICAgIC8qKiDmr4/kuKrlg4/lhYPnlKgzMuS4quavlOeJuSjljbM05Liq5a2X6IqCKeihqOekuuOAgiAqL1xuICAgIEJJVDMyOiBcIkJJVDMyXCIsXG4gICAgLyoqIOavj+S4quWDj+WFg+eUqDY05Liq5q+U54m5KOWNszjkuKrlrZfoioIp6KGo56S677yM5Y+q5o+Q5L6b57uZ5qCF5qC85pWw5o2u6ZuG5L2/55So44CCICovXG4gICAgQklUNjQ6IFwiQklUNjRcIixcbiAgICAvKiog5q+P5Liq5YOP5YWD55SoNOS4quWtl+iKguadpeihqOekuu+8jOWPquaPkOS+m+e7meagheagvOaVsOaNrumbhuS9v+eUqOOAgiAqL1xuICAgIFNJTkdMRTogXCJTSU5HTEVcIixcbiAgICAvKiog5q+P5Liq5YOP5YWD55SoOOS4quWtl+iKguadpeihqOekuu+8jOWPquaPkOS+m+e7meagheagvOaVsOaNrumbhuS9v+eUqOOAgiAqL1xuICAgIERPVUJMRTogXCJET1VCTEVcIixcbiAgICAvKiog5q+P5Liq5YOP5YWD55SoMeS4quavlOeJueihqOekuuOAgiAqL1xuICAgIFVCSVQxOiBcIlVCSVQxXCIsXG4gICAgLyoqIOavj+S4quWDj+WFg+eUqDTkuKrmr5TnibnmnaXooajnpLrjgIIgKi9cbiAgICBVQklUNDogXCJVQklUNFwiLFxuICAgIC8qKiDmr4/kuKrlg4/lhYPnlKg45Liq5q+U54m5KOWNszHkuKrlrZfoioIp5p2l6KGo56S644CCICovXG4gICAgVUJJVDg6IFwiVUJJVDhcIixcbiAgICAvKiog5q+P5Liq5YOP5YWD55SoMjTkuKrmr5Tnibko5Y2zM+S4quWtl+iKginmnaXooajnpLrjgIIgKi9cbiAgICBVQklUMjQ6IFwiVUJJVDI0XCIsXG4gICAgLyoqIOavj+S4quWDj+WFg+eUqDMy5Liq5q+U54m5KOWNszTkuKrlrZfoioIp5p2l6KGo56S644CCICovXG4gICAgVUJJVDMyOiBcIlVCSVQzMlwiXG59O1xuXG4vKipcbiAqIEBlbnVtIFNlYXJjaE1vZGVcbiAqIEBkZXNjcmlwdGlvbiAg5YaF5o+S5pe25L2/55So55qE5qC35pys54K555qE5p+l5om+5pa55byP5p6a5Li+XG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LlNlYXJjaE1vZGUuS0RUUkVFX0ZJWEVEX0NPVU5UO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgU2VhcmNoTW9kZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBTZWFyY2hNb2RlLktEVFJFRV9GSVhFRF9DT1VOVDtcbiAqIGBgYFxuICovXG52YXIgU2VhcmNoTW9kZSA9IHtcbiAgICAvKiog5L2/55SoIEtEVFJFRSDnmoTlm7rlrprngrnmlbDmlrnlvI/mn6Xmib7lj4LkuI7lhoXmj5LliIbmnpDnmoTngrnjgIIgKi9cbiAgICBLRFRSRUVfRklYRURfQ09VTlQ6IFwiS0RUUkVFX0ZJWEVEX0NPVU5UXCIsXG4gICAgLyoqIOS9v+eUqCBLRFRSRUUg55qE5a6a6ZW/5pa55byP5p+l5om+5Y+C5LiO5YaF5o+S5YiG5p6Q55qE54K544CCICovXG4gICAgS0RUUkVFX0ZJWEVEX1JBRElVUzogXCJLRFRSRUVfRklYRURfUkFESVVTXCIsXG4gICAgLyoqIOS4jei/m+ihjOafpeaJvu+8jOS9v+eUqOaJgOacieeahOi+k+WFpeeCuei/m+ihjOWGheaPkuWIhuaekOOAgiAqL1xuICAgIE5PTkU6IFwiTk9ORVwiLFxuICAgIC8qKiDkvb/nlKggUVVBRFRSRUUg5pa55byP5p+l5om+5Y+C5LiO5YaF5o+S5YiG5p6Q55qE54K577yM5LuF5a+55qC35p2h77yIUkJG77yJ5o+S5YC85ZKM5pmu6YCa5YWL5ZCV6YeR77yIS3JpZ2luZ++8ieacieeUqOOAgiAqL1xuICAgIFFVQURUUkVFOiBcIlFVQURUUkVFXCJcbn07XG5cbi8qKlxuICogQGVudW0gSW50ZXJwb2xhdGlvbkFsZ29yaXRobVR5cGVcbiAqIEBkZXNjcmlwdGlvbiAg5o+S5YC85YiG5p6Q55qE566X5rOV55qE57G75Z6LXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LkludGVycG9sYXRpb25BbGdvcml0aG1UeXBlLktSSUdJTkc7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBJbnRlcnBvbGF0aW9uQWxnb3JpdGhtVHlwZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBJbnRlcnBvbGF0aW9uQWxnb3JpdGhtVHlwZS5LUklHSU5HO1xuICogYGBgXG4gKi9cbnZhciBJbnRlcnBvbGF0aW9uQWxnb3JpdGhtVHlwZSA9IHtcbiAgICAvKiog5pmu6YCa5YWL5ZCV6YeR5o+S5YC85rOV44CCICovXG4gICAgS1JJR0lORzogXCJLUklHSU5HXCIsXG4gICAgLyoqIOeugOWNleWFi+WQlemHkeaPkuWAvOazleOAgiAqL1xuICAgIFNpbXBsZUtyaWdpbmc6IFwiU2ltcGxlS3JpZ2luZ1wiLFxuICAgIC8qKiDms5vlhYvlkJXph5Hmj5LlgLzms5XjgIIgKi9cbiAgICBVbml2ZXJzYWxLcmlnaW5nOiBcIlVuaXZlcnNhbEtyaWdpbmdcIlxufTtcblxuLyoqXG4gKiBAZW51bSBWYXJpb2dyYW1Nb2RlXG4gKiBAZGVzY3JpcHRpb24gIOWFi+WQlemHke+8iEtyaWdpbmfvvInmj5LlgLzml7bnmoTljYrlj5jlh73mlbDnsbvlnovmnprkuL5cbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uVmFyaW9ncmFtTW9kZS5FWFBPTkVOVElBTDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFZhcmlvZ3JhbU1vZGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gVmFyaW9ncmFtTW9kZS5FWFBPTkVOVElBTDtcbiAqIGBgYFxuICovXG52YXIgVmFyaW9ncmFtTW9kZSA9IHtcbiAgICAvKiog5oyH5pWw5Ye95pWw44CCICovXG4gICAgRVhQT05FTlRJQUw6IFwiRVhQT05FTlRJQUxcIixcbiAgICAvKiog6auY5pav5Ye95pWw44CCICovXG4gICAgR0FVU1NJQU46IFwiR0FVU1NJQU5cIixcbiAgICAvKiog55CD5Z6L5Ye95pWw44CCICovXG4gICAgU1BIRVJJQ0FMOiBcIlNQSEVSSUNBTFwiXG59O1xuXG4vKipcbiAqIEBlbnVtIEV4cG9uZW50XG4gKiBAZGVzY3JpcHRpb24gIOWumuS5ieS6huazm+WFi+WQlemHke+8iFVuaXZlcnNhbEtyaWdpbmfvvInmj5LlgLzml7bmoLfngrnmlbDmja7kuK3otovlir/pnaLmlrnnqIvnmoTpmLbmlbBcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uRXhwb25lbnQuRVhQMTtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IEV4cG9uZW50IH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEV4cG9uZW50LkVYUDE7XG4gKiBgYGBcbiAqL1xudmFyIEV4cG9uZW50ID0ge1xuICAgIC8qKiDpmLbmlbDkuLox44CCICovXG4gICAgRVhQMTogXCJFWFAxXCIsXG4gICAgLyoqIOmYtuaVsOS4ujLjgIIgKi9cbiAgICBFWFAyOiBcIkVYUDJcIlxufTtcblxuLyoqXG4gKiBAZW51bSBDbGllbnRUeXBlXG4gKiBAZGVzY3JpcHRpb24gdG9rZW7nlLPor7fnmoTlrqLmiLfnq6/moIfor4bnsbvlnotcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uQ2xpZW50VHlwZS5JUDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IENsaWVudFR5cGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gQ2xpZW50VHlwZS5JUDtcbiAqIGBgYFxuICovXG52YXIgQ2xpZW50VHlwZSA9IHtcbiAgICAvKiog5oyH5a6a55qEIElQIOWcsOWdgOOAgiAqL1xuICAgIElQOiBcIklQXCIsXG4gICAgLyoqIOaMh+WumueahCBVUkzjgIIgKi9cbiAgICBSRUZFUkVSOiBcIlJlZmVyZXJcIixcbiAgICAvKiog5Y+R6YCB55Sz6K+35Luk54mM6K+35rGC55qE5a6i5oi356uvIElQ44CCICovXG4gICAgUkVRVUVTVElQOiBcIlJlcXVlc3RJUFwiLFxuICAgIC8qKiDkuI3lgZrku7vkvZXpqozor4HjgIIgKi9cbiAgICBOT05FOiBcIk5PTkVcIixcbiAgICAvKiogU0VSVkVS44CCICovXG4gICAgU0VSVkVSOiBcIlNFUlZFUlwiLFxuICAgIC8qKiBXRULjgIIgKi9cbiAgICBXRUI6IFwiV0VCXCJcbn07XG5cbi8qKlxuICogQGVudW0gQ2hhcnRUeXBlXG4gKiBAZGVzY3JpcHRpb24g5a6i5oi356uv5LiT6aKY5Zu+5Zu+6KGo57G75Z6LXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LkNoYXJ0VHlwZS5CQVI7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBDaGFydFR5cGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gQ2hhcnRUeXBlLkJBUjtcbiAqIGBgYFxuICovXG52YXIgQ2hhcnRUeXBlID0ge1xuICAgIC8qKiDmn7Hnirblm77jgIIgKi9cbiAgICBCQVI6IFwiQmFyXCIsXG4gICAgLyoqIOS4iee7tOafseeKtuWbvuOAgiAqL1xuICAgIEJBUjNEOiBcIkJhcjNEXCIsXG4gICAgLyoqIOWchuW9ouWbvuOAgiAqL1xuICAgIENJUkNMRTogXCJDaXJjbGVcIixcbiAgICAvKiog6aW85Zu+44CCICovXG4gICAgUElFOiBcIlBpZVwiLFxuICAgIC8qKiDmlaPngrnlm77jgIIgKi9cbiAgICBQT0lOVDogXCJQb2ludFwiLFxuICAgIC8qKiDmipjnur/lm77jgIIgKi9cbiAgICBMSU5FOiBcIkxpbmVcIixcbiAgICAvKiog546v54q25Zu+44CCICovXG4gICAgUklORzogXCJSaW5nXCJcbn07XG5cbi8qKlxuICogQGVudW0gQ2xpcEFuYWx5c3RNb2RlXG4gKiBAZGVzY3JpcHRpb24gIOijgeWJquWIhuaekOaooeW8j1xuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5DbGlwQW5hbHlzdE1vZGUuQ0xJUDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IENsaXBBbmFseXN0TW9kZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBDbGlwQW5hbHlzdE1vZGUuQ0xJUDtcbiAqIGBgYFxuICovXG52YXIgQ2xpcEFuYWx5c3RNb2RlID0ge1xuICAgIC8qKiBDTElQ44CCICovXG4gICAgQ0xJUDogXCJjbGlwXCIsXG4gICAgLyoqIElOVEVSU0VDVOOAgiAqL1xuICAgIElOVEVSU0VDVDogXCJpbnRlcnNlY3RcIlxufTtcblxuLyoqXG4gKiBAZW51bSBBbmFseXN0QXJlYVVuaXRcbiAqIEBkZXNjcmlwdGlvbiDliIbluIPlvI/liIbmnpDpnaLnp6/ljZXkvY1cbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uQW5hbHlzdEFyZWFVbml0LlNRVUFSRU1FVEVSO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgQW5hbHlzdEFyZWFVbml0IH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEFuYWx5c3RBcmVhVW5pdC5TUVVBUkVNRVRFUjtcbiAqIGBgYFxuICovXG52YXIgQW5hbHlzdEFyZWFVbml0ID0ge1xuICAgIC8qKiDlubPmlrnnsbPjgIIgKi9cbiAgICBcIlNRVUFSRU1FVEVSXCI6IFwiU3F1YXJlTWV0ZXJcIixcbiAgICAvKiog5bmz5pa55Y2D57Gz44CCICovXG4gICAgXCJTUVVBUkVLSUxPTUVURVJcIjogXCJTcXVhcmVLaWxvTWV0ZXJcIixcbiAgICAvKiog5YWs6aG344CCICovXG4gICAgXCJIRUNUQVJFXCI6IFwiSGVjdGFyZVwiLFxuICAgIC8qKiDlhazkuqnjgIIgKi9cbiAgICBcIkFSRVwiOiBcIkFyZVwiLFxuICAgIC8qKiDoi7HkuqnjgIIgKi9cbiAgICBcIkFDUkVcIjogXCJBY3JlXCIsXG4gICAgLyoqIOW5s+aWueiLseWwuuOAgiAqL1xuICAgIFwiU1FVQVJFRk9PVFwiOiBcIlNxdWFyZUZvb3RcIixcbiAgICAvKiog5bmz5pa556CB44CCICovXG4gICAgXCJTUVVBUkVZQVJEXCI6IFwiU3F1YXJlWWFyZFwiLFxuICAgIC8qKiDlubPmlrnoi7Hph4zjgIIgKi9cbiAgICBcIlNRVUFSRU1JTEVcIjogXCJTcXVhcmVNaWxlXCJcbn07XG5cbi8qKlxuICogQGVudW0gQW5hbHlzdFNpemVVbml0XG4gKiBAZGVzY3JpcHRpb24g5YiG5biD5byP5YiG5p6Q5Y2V5L2NXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LkFuYWx5c3RTaXplVW5pdC5NRVRFUjtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IEFuYWx5c3RTaXplVW5pdCB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBBbmFseXN0U2l6ZVVuaXQuTUVURVI7XG4gKiBgYGBcbiAqL1xudmFyIEFuYWx5c3RTaXplVW5pdCA9IHtcbiAgICAvKiog57Gz44CCICovXG4gICAgXCJNRVRFUlwiOiBcIk1ldGVyXCIsXG4gICAgLyoqIOWNg+exs+OAgiAqL1xuICAgIFwiS0lMT01FVEVSXCI6IFwiS2lsb21ldGVyXCIsXG4gICAgLyoqIOeggeOAgiAqL1xuICAgIFwiWUFSRFwiOiBcIllhcmRcIixcbiAgICAvKiog6Iux5bC644CCICovXG4gICAgXCJGT09UXCI6IFwiRm9vdFwiLFxuICAgIC8qKiDoi7Hph4zjgIIgKi9cbiAgICBcIk1JTEVcIjogXCJNaWxlXCJcbn07XG5cbi8qKlxuICogQGVudW0gU3RhdGlzdGljQW5hbHlzdE1vZGVcbiAqIEBkZXNjcmlwdGlvbiDliIbluIPlvI/liIbmnpDnu5/orqHmqKHlvI9cbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uU3RhdGlzdGljQW5hbHlzdE1vZGUuTUFYO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgU3RhdGlzdGljQW5hbHlzdE1vZGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gU3RhdGlzdGljQW5hbHlzdE1vZGUuTUFYO1xuICogYGBgXG4gKi9cbnZhciBTdGF0aXN0aWNBbmFseXN0TW9kZSA9IHtcbiAgICAvKiog57uf6K6h5omA6YCJ5a2X5q6155qE5pyA5aSn5YC844CCICovXG4gICAgXCJNQVhcIjogXCJtYXhcIixcbiAgICAvKiog57uf6K6h5omA6YCJ5a2X5q6155qE5pyA5bCP5YC844CCICovXG4gICAgXCJNSU5cIjogXCJtaW5cIixcbiAgICAvKiog57uf6K6h5omA6YCJ5a2X5q6155qE5bmz5Z2H5YC844CCICovXG4gICAgXCJBVkVSQUdFXCI6IFwiYXZlcmFnZVwiLFxuICAgIC8qKiDnu5/orqHmiYDpgInlrZfmrrXnmoTmgLvlkozjgIIgKi9cbiAgICBcIlNVTVwiOiBcInN1bVwiLFxuICAgIC8qKiDnu5/orqHmiYDpgInlrZfmrrXnmoTmlrnlt67jgIIgKi9cbiAgICBcIlZBUklBTkNFXCI6IFwidmFyaWFuY2VcIixcbiAgICAvKiog57uf6K6h5omA6YCJ5a2X5q6155qE5qCH5YeG5beuICovXG4gICAgXCJTVERERVZJQVRJT05cIjogXCJzdGREZXZpYXRpb25cIlxufTtcblxuLyoqXG4gKiBAZW51bSBTdW1tYXJ5VHlwZVxuICogQGRlc2NyaXB0aW9uIOWIhuW4g+W8j+WIhuaekOiBmuWQiOexu+Wei1xuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5TdW1tYXJ5VHlwZS5TVU1NQVJZTUVTSDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFN1bW1hcnlUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFN1bW1hcnlUeXBlLlNVTU1BUllNRVNIO1xuICogYGBgXG4gKi9cbnZhciBTdW1tYXJ5VHlwZSA9IHtcbiAgICAvKiog5qC8572R6IGa5ZCI44CCICovXG4gICAgXCJTVU1NQVJZTUVTSFwiOiBcIlNVTU1BUllNRVNIXCIsXG4gICAgLyoqIOWkmui+ueW9ouiBmuWQiOOAgiAqL1xuICAgIFwiU1VNTUFSWVJFR0lPTlwiOiBcIlNVTU1BUllSRUdJT05cIlxufTtcblxuLyoqXG4gKiBAZW51bSBUb3BvbG9neVZhbGlkYXRvclJ1bGVcbiAqIEBkZXNjcmlwdGlvbiAg5ouT5omR5qOA5p+l5qih5byP5p6a5Li+44CC6K+l57G75a6a5LmJ5LqG5ouT5omR5qOA5p+l5pON5L2c5qih5byP5bi46YeP44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LlRvcG9sb2d5VmFsaWRhdG9yUnVsZS5SRUdJT05OT09WRVJMQVA7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBUb3BvbG9neVZhbGlkYXRvclJ1bGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gVG9wb2xvZ3lWYWxpZGF0b3JSdWxlLlJFR0lPTk5PT1ZFUkxBUDtcbiAqIGBgYFxuICovXG52YXIgVG9wb2xvZ3lWYWxpZGF0b3JSdWxlID0ge1xuICAgIC8qKiDpnaLlhoXml6Dph43lj6DvvIznlKjkuo7lr7npnaLmlbDmja7ov5vooYzmi5PmiZHmo4Dmn6XjgIIgKi9cbiAgICBSRUdJT05OT09WRVJMQVA6IFwiUkVHSU9OTk9PVkVSTEFQXCIsXG4gICAgLyoqIOmdouS4jumdouaXoOmHjeWPoO+8jOeUqOS6juWvuemdouaVsOaNrui/m+ihjOaLk+aJkeajgOafpeOAgiAqL1xuICAgIFJFR0lPTk5PT1ZFUkxBUFdJVEg6IFwiUkVHSU9OTk9PVkVSTEFQV0lUSFwiLFxuICAgIC8qKiDpnaLooqvpnaLljIXlkKvvvIznlKjkuo7lr7npnaLmlbDmja7ov5vooYzmi5PmiZHmo4Dmn6XjgIIgKi9cbiAgICBSRUdJT05DT05UQUlORURCWVJFR0lPTjogXCJSRUdJT05DT05UQUlORURCWVJFR0lPTlwiLFxuICAgIC8qKiDpnaLooqvpnaLopobnm5bvvIznlKjkuo7lr7npnaLmlbDmja7ov5vooYzmi5PmiZHmo4Dmn6XjgIIgKi9cbiAgICBSRUdJT05DT1ZFUkVEQllSRUdJT046IFwiUkVHSU9OQ09WRVJFREJZUkVHSU9OXCIsXG4gICAgLyoqIOe6v+S4jue6v+aXoOmHjeWPoO+8jOeUqOS6juWvuee6v+aVsOaNrui/m+ihjOaLk+aJkeajgOafpeOAgiAqL1xuICAgIExJTkVOT09WRVJMQVA6IFwiTElORU5PT1ZFUkxBUFwiLFxuICAgIC8qKiDnur/lhoXml6Dph43lj6DvvIznlKjkuo7lr7nnur/mlbDmja7ov5vooYzmi5PmiZHmo4Dmn6XjgIIgKi9cbiAgICBMSU5FTk9PVkVSTEFQV0lUSDogXCJMSU5FTk9PVkVSTEFQV0lUSFwiLFxuICAgIC8qKiDngrnkuI3nm7jlkIzvvIznlKjkuo7lr7nngrnmlbDmja7ov5vooYzmi5PmiZHmo4Dmn6XjgIIgKi9cbiAgICBQT0lOVE5PSURFTlRJQ0FMOiBcIlBPSU5UTk9JREVOVElDQUxcIlxufTtcblxuLyoqXG4gKiBAZW51bSBCdWNrZXRBZ2dUeXBlXG4gKiBAZGVzY3JpcHRpb24gIOagvOe9keiBmuWQiOafpeivouaemuS4vuexu++8jOivpeexu+WumuS5ieS6hkVsYXN0aWNzZWFyY2jmlbDmja7mnI3liqHkuK3ogZrlkIjmn6Xor6LmqKHlvI/luLjph49cbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uQnVja2V0QWdnVHlwZS5HRU9IQVNIX0dSSUQ7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBCdWNrZXRBZ2dUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEJ1Y2tldEFnZ1R5cGUuR0VPSEFTSF9HUklEO1xuICogYGBgXG4gKi9cbnZhciBCdWNrZXRBZ2dUeXBlID0ge1xuICAgIC8qKiDmoLznvZHogZrlkIjnsbvlnosgKi9cbiAgICBHRU9IQVNIX0dSSUQ6IFwiZ2VvaGFzaF9ncmlkXCJcbn07XG5cbi8qKlxuICogQGVudW0gTWV0cmljc0FnZ1R5cGVcbiAqIEBkZXNjcmlwdGlvbiAg5oyH5qCH6IGa5ZCI57G75Z6L5p6a5Li+57G777yM6K+l57G75a6a5LmJ5LqGRWxhc3RpY3NlYXJjaOaVsOaNruacjeWKoeS4reiBmuWQiOafpeivouaooeW8j+W4uOmHj1xuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5NZXRyaWNzQWdnVHlwZS5BVkc7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBNZXRyaWNzQWdnVHlwZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBNZXRyaWNzQWdnVHlwZS5BVkc7XG4gKiBgYGBcbiAqL1xudmFyIE1ldHJpY3NBZ2dUeXBlID0ge1xuICAvKiog5bmz5Z2H5YC86IGa5ZCI57G75Z6LICovXG4gIEFWRzonYXZnJyxcbiAgLyoqIOacgOWkp+WAvOiBmuWQiOexu+WeiyAqL1xuICBNQVg6J21heCcsXG4gIC8qKiDmnIDlsI/lgLzogZrlkIjnsbvlnosgKi9cbiAgTUlOOidtaW4nLFxuICAvKiog5rGC5ZKM6IGa5ZCI57G75Z6LICovXG4gIFNVTTonc3VtJ1xufTtcblxuLyoqXG4gKiBAZW51bSBHZXRGZWF0dXJlTW9kZVxuICogQGRlc2NyaXB0aW9uIGZlYXR1cmUg5p+l6K+i5pa55byP44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LkdldEZlYXR1cmVNb2RlLkJPVU5EUztcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IEdldEZlYXR1cmVNb2RlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEdldEZlYXR1cmVNb2RlLkJPVU5EUztcbiAqIGBgYFxuICovXG52YXIgR2V0RmVhdHVyZU1vZGUgPSB7XG4gICAgLyoqIOmAmui/h+iMg+WbtOafpeivouadpeiOt+WPluimgee0oOOAgiAqL1xuICAgIEJPVU5EUzogXCJCT1VORFNcIixcbiAgICAvKiog6YCa6L+H5Yeg5L2V5a+56LGh55qE57yT5Yay5Yy65p2l6I635Y+W6KaB57Sg44CCICovXG4gICAgQlVGRkVSOiBcIkJVRkZFUlwiLFxuICAgIC8qKiDpgJrov4cgSUQg5p2l6I635Y+W6KaB57Sg44CCICovXG4gICAgSUQ6IFwiSURcIixcbiAgICAvKiog6YCa6L+H56m66Ze05p+l6K+i5qih5byP5p2l6I635Y+W6KaB57Sg44CCICovXG4gICAgU1BBVElBTDogXCJTUEFUSUFMXCIsXG4gICAgLyoqIOmAmui/hyBTUUwg5p+l6K+i5p2l6I635Y+W6KaB57Sg44CCICovXG4gICAgU1FMOiAnU1FMJ1xufVxuXG4vKipcbiAqIEBlbnVtIFJhc3RlckZ1bmN0aW9uVHlwZVxuICogQGRlc2NyaXB0aW9uIOagheagvOWIhuaekOaWueazleOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5HZXRGZWF0dXJlTW9kZS5ORFZJO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgR2V0RmVhdHVyZU1vZGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gR2V0RmVhdHVyZU1vZGUuTkRWSTtcbiAqIGBgYFxuICovXG52YXIgUmFzdGVyRnVuY3Rpb25UeXBlID0ge1xuICAgIC8qKiDlvZLkuIDljJbmpI3ooqvmjIfmlbDjgIIgKi9cbiAgICBORFZJOiBcIk5EVklcIixcbiAgICAvKiog6Zi05b2x6Z2i5YiG5p6Q44CCICovXG4gICAgSElMTFNIQURFOiBcIkhJTExTSEFERVwiXG59XG5cbi8qKlxuICogQGVudW0gUmVzb3VyY2VUeXBlXG4gKiBAZGVzY3JpcHRpb24gaXBvcnRhbOi1hOa6kOexu+Wei+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHZlcnNpb24gMTAuMC4xXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LkdldEZlYXR1cmVNb2RlLk1BUDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IEdldEZlYXR1cmVNb2RlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEdldEZlYXR1cmVNb2RlLk1BUDtcbiAqIGBgYFxuICovXG52YXIgUmVzb3VyY2VUeXBlID0ge1xuICAgIC8qKiDlnLDlm77jgIIgKi9cbiAgICBNQVA6IFwiTUFQXCIsXG4gICAgLyoqIOacjeWKoeOAgiAqL1xuICAgIFNFUlZJQ0U6IFwiU0VSVklDRVwiLFxuICAgIC8qKiDlnLrmma/jgIIgKi9cbiAgICBTQ0VORTogXCJTQ0VORVwiLFxuICAgIC8qKiDmlbDmja7jgIIgKi9cbiAgICBEQVRBOiBcIkRBVEFcIixcbiAgICAvKiog5rSe5a+f44CCICovXG4gICAgSU5TSUdIVFNfV09SS1NQQUNFOiBcIklOU0lHSFRTX1dPUktTUEFDRVwiLFxuICAgIC8qKiDlpKflsY/jgIIgKi9cbiAgICBNQVBfREFTSEJPQVJEOiBcIk1BUF9EQVNIQk9BUkRcIlxufVxuXG4vKipcbiAqIEBlbnVtIE9yZGVyQnlcbiAqIEBkZXNjcmlwdGlvbiBpcG9ydGFs6LWE5rqQ5o6S5bqP5a2X5q6144CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdmVyc2lvbiAxMC4wLjFcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uT3JkZXJCeS5VUERBVEVUSU1FO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgT3JkZXJCeSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBPcmRlckJ5LlVQREFURVRJTUU7XG4gKiBgYGBcbiAqL1xudmFyIE9yZGVyQnkgPSB7XG4gICAgLyoqIOaMieabtOaWsOaXtumXtOaOkuW6jyAqL1xuICAgIFVQREFURVRJTUU6IFwiVVBEQVRFVElNRVwiLFxuICAgIC8qKiDmjInng63luqYo5Y+v6IO95piv6K6/6Zeu6YeP44CB5LiL6L296YePKeaOkuW6jyAqL1xuICAgIEhFQVRMRVZFTDogXCJIRUFUTEVWRUxcIixcbiAgICAvKiog5oyJ55u45YWz5oCn5o6S5bqPICovXG4gICAgUkVMRVZBTkNFOiBcIlJFTEVWQU5DRVwiXG59XG5cbi8qKlxuICogQGVudW0gT3JkZXJUeXBlXG4gKiBAZGVzY3JpcHRpb24gaXBvcnRhbOi1hOa6kOWNh+W6j+i/mOaYr+mZjeW6j+i/h+a7pFxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHZlcnNpb24gMTAuMC4xXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9Lk9yZGVyVHlwZS5BU0M7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBPcmRlclR5cGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gT3JkZXJUeXBlLkFTQztcbiAqIGBgYFxuICovXG52YXIgT3JkZXJUeXBlID0ge1xuICAgIC8qKiDljYfluo8gKi9cbiAgICBBU0M6IFwiQVNDXCIsXG4gICAgLyoqIOmZjeW6jyAqL1xuICAgIERFU0M6IFwiREVTQ1wiXG59XG5cbi8qKlxuICogQGVudW0gU2VhcmNoVHlwZVxuICogQGRlc2NyaXB0aW9uIGlwb3J0YWzotYTmupDmn6Xor6LnmoTojIPlm7Tov5vooYzov4fmu6RcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB2ZXJzaW9uIDEwLjAuMVxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5TZWFyY2hUeXBlLlBVQkxJQztcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFNlYXJjaFR5cGUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gU2VhcmNoVHlwZS5QVUJMSUM7XG4gKiBgYGBcbiAqL1xudmFyIFNlYXJjaFR5cGUgPSB7XG4gICAgLyoqIOWFrOW8gOi1hOa6kOOAgiAqL1xuICAgIFBVQkxJQzogXCJQVUJMSUNcIixcbiAgICAvKiog5oiR55qE6LWE5rqQ44CCICovXG4gICAgTVlfUkVTOiBcIk1ZX1JFU1wiLFxuICAgIC8qKiDmiJHnmoTnvqTnu4TotYTmupDjgIIgKi9cbiAgICBNWUdST1VQX1JFUzogXCJNWUdST1VQX1JFU1wiLFxuICAgIC8qKiDmiJHnmoTpg6jpl6jotYTmupDjgIIgKi9cbiAgICBNWURFUEFSVE1FTlRfUkVTOiBcIk1ZREVQQVJUTUVOVF9SRVNcIixcbiAgICAvKiog5YiG5Lqr57uZ5oiR55qE6LWE5rqQ44CCICovXG4gICAgU0hBUkVUT01FX1JFUzogXCJTSEFSRVRPTUVfUkVTXCJcbn1cblxuLyoqXG4gKiBAZW51bSBBZ2dyZWdhdGlvblR5cGVzXG4gKiBAZGVzY3JpcHRpb24gaXBvcnRhbOi1hOa6kOiBmuWQiOafpeivoueahOexu+Wei1xuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHZlcnNpb24gMTAuMC4xXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LkFnZ3JlZ2F0aW9uVHlwZXMuVEFHO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgQWdncmVnYXRpb25UeXBlcyB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBBZ2dyZWdhdGlvblR5cGVzLlRBRztcbiAqIGBgYFxuICovXG52YXIgQWdncmVnYXRpb25UeXBlcyA9IHtcbiAgICAvKiog5qCH562+ICovXG4gICAgVEFHOiBcIlRBR1wiLFxuICAgIC8qKiDotYTmupDnsbvlnosgKi9cbiAgICBUWVBFOiBcIlRZUEVcIlxufVxuXG4vKipcbiAqIEBlbnVtIFBlcm1pc3Npb25UeXBlXG4gKiBAZGVzY3JpcHRpb24gaXBvcnRhbOi1hOa6kOadg+mZkOexu+Wei+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHZlcnNpb24gMTAuMC4xXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LlBlcm1pc3Npb25UeXBlLlNFQVJDSDtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFBlcm1pc3Npb25UeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFBlcm1pc3Npb25UeXBlLlNFQVJDSDtcbiAqIGBgYFxuICovXG52YXIgUGVybWlzc2lvblR5cGUgPSB7XG4gICAgLyoqIOWPr+ajgOe0oiAqL1xuICAgIFNFQVJDSDpcIlNFQVJDSFwiLFxuICAgIC8qKiDlj6/mn6XnnIsgKi9cbiAgICBSRUFEOiBcIlJFQURcIixcbiAgICAvKiog5Y+v57yW6L6RICovXG4gICAgUkVBRFdSSVRFOiBcIlJFQURXUklURVwiLFxuICAgIC8qKiDlj6/liKDpmaQgKi9cbiAgICBERUxFVEU6IFwiREVMRVRFXCIsXG4gICAgLyoqIOWPr+S4i+i9ve+8jOWMheaLrOWPr+ivu+OAgeWPr+ajgOe0oiAqL1xuICAgIERPV05MT0FEOlwiRE9XTkxPQURcIlxufVxuXG4vKipcbiAqIEBlbnVtIEVudGl0eVR5cGVcbiAqIEBkZXNjcmlwdGlvbiBpcG9ydGFs6LWE5rqQ5a6e5L2T57G75Z6L44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdmVyc2lvbiAxMC4wLjFcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uRW50aXR5VHlwZS5ERVBBUlRNRU5UO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgRW50aXR5VHlwZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBFbnRpdHlUeXBlLkRFUEFSVE1FTlQ7XG4gKiBgYGBcbiAqL1xudmFyIEVudGl0eVR5cGUgPSB7XG4gICAgLyoqIOmDqOmXqCAqL1xuICAgIERFUEFSVE1FTlQ6IFwiREVQQVJUTUVOVFwiLFxuICAgIC8qKiDnlKjmiLfnu4QgKi9cbiAgICBHUk9VUDogXCJHUk9VUFwiLFxuICAgIC8qKiDnvqTnu4QgKi9cbiAgICBJUE9SVEFMR1JPVVA6IFwiSVBPUlRBTEdST1VQXCIsXG4gICAgLyoqIOinkuiJsiAqL1xuICAgIFJPTEU6IFwiUk9MRVwiLFxuICAgIC8qKiDnlKjmiLcgKi9cbiAgICBVU0VSOiBcIlVTRVJcIlxufVxuXG4vKipcbiAqIEBlbnVtIERhdGFJdGVtVHlwZVxuICogQGRlc2NyaXB0aW9uIGlwb3J0YWzmlbDmja7nsbvlnovjgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgQ29uc3RhbnRcbiAqIEB2ZXJzaW9uIDEwLjAuMVxuICogQHR5cGUge3N0cmluZ31cbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5EYXRhSXRlbVR5cGUuR0VPSlNPTjtcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IERhdGFJdGVtVHlwZSB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBEYXRhSXRlbVR5cGUuR0VPSlNPTjtcbiAqIGBgYFxuICovXG52YXIgRGF0YUl0ZW1UeXBlID0ge1xuICAgIC8qKiBnZW9qc29u5pWw5o2u44CCICovXG4gICAgR0VPSlNPTjogXCJHRU9KU09OXCIsXG4gICAgLyoqIFVHQ1Y1X01WVCAgKi9cbiAgICBVR0NWNV9NVlQ6IFwiVUdDVjVfTVZUXCIsXG4gICAgLyoqIGpzb27mlbDmja4gICovXG4gICAgSlNPTjogXCJKU09OXCIsXG4gICAgLyoqIEFVRElPICovXG4gICAgQVVESU86IFwiQVVESU9cIixcbiAgICAvKiogQ09MT1IgKi9cbiAgICBDT0xPUjogXCJDT0xPUlwiLFxuICAgIC8qKiBDT0xPUlNDSEVNRSAqL1xuICAgIENPTE9SU0NIRU1FOiBcIkNPTE9SU0NIRU1FXCIsXG4gICAgLyoqIENTViAqL1xuICAgIENTVjogXCJDU1ZcIixcbiAgICAvKiogRVhDRUwgKi9cbiAgICBFWENFTDogXCJFWENFTFwiLFxuICAgIC8qKiBGSUxMU1lNQk9MICovXG4gICAgRklMTFNZTUJPTDogXCJGSUxMU1lNQk9MXCIsXG4gICAgLyoqIElNQUdFICovXG4gICAgSU1BR0U6IFwiSU1BR0VcIixcbiAgICAvKiogTEFZRVJURU1QTEFURSAqL1xuICAgIExBWUVSVEVNUExBVEU6IFwiTEFZRVJURU1QTEFURVwiLFxuICAgIC8qKiBMQVlPVVRURU1QTEFURSAqL1xuICAgIExBWU9VVFRFTVBMQVRFOiBcIkxBWU9VVFRFTVBMQVRFXCIsXG4gICAgLyoqIExJTkVTWU1CT0wgKi9cbiAgICBMSU5FU1lNQk9MOiBcIkxJTkVTWU1CT0xcIixcbiAgICAvKiogTUFQVEVNUExBVEUgKi9cbiAgICBNQVBURU1QTEFURTogXCJNQVBURU1QTEFURVwiLFxuICAgIC8qKiBNQVJLRVJTWU1CT0wgKi9cbiAgICBNQVJLRVJTWU1CT0w6IFwiTUFSS0VSU1lNQk9MXCIsXG4gICAgLyoqIE1CVElMRVMgKi9cbiAgICBNQlRJTEVTOiBcIk1CVElMRVNcIixcbiAgICAvKiogUEhPVE9TICovXG4gICAgUEhPVE9TOiBcIlBIT1RPU1wiLFxuICAgIC8qKiBTSFAgKi9cbiAgICBTSFA6IFwiU0hQXCIsXG4gICAgLyoqIFNNVElMRVMgKi9cbiAgICBTTVRJTEVTOiBcIlNNVElMRVNcIixcbiAgICAvKiogU1ZUSUxFUyAqL1xuICAgIFNWVElMRVM6IFwiU1ZUSUxFU1wiLFxuICAgIC8qKiBUSEVNRVRFTVBMQVRFICovXG4gICAgVEhFTUVURU1QTEFURTogXCJUSEVNRVRFTVBMQVRFXCIsXG4gICAgLyoqIFRQSyAqL1xuICAgIFRQSzogXCJUUEtcIixcbiAgICAvKiogVURCICovXG4gICAgVURCOiBcIlVEQlwiLFxuICAgIC8qKiBVR0NWNSAqL1xuICAgIFVHQ1Y1OiBcIlVHQ1Y1XCIsXG4gICAgLyoqIFVOS05PV04gKi9cbiAgICBVTktOT1dOOiBcIlVOS05PV05cIixcbiAgICAvKiogVklERU8gKi9cbiAgICBWSURFTzogXCJWSURFT1wiLFxuICAgIC8qKiBXT1JLRU5WSVJPTk1FTlQgKi9cbiAgICBXT1JLRU5WSVJPTk1FTlQ6IFwiV09SS0VOVklST05NRU5UXCIsXG4gICAgLyoqIFdPUktTUEFDRSAqL1xuICAgIFdPUktTUEFDRTogXCJXT1JLU1BBQ0VcIlxufVxuXG4vKipcbiAqIEBlbnVtIFdlYkV4cG9ydEZvcm1hdFR5cGVcbiAqIEBkZXNjcmlwdGlvbiBXZWIg5omT5Y2w6L6T5Ye655qE5qC85byP44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdmVyc2lvbiAxMC4wLjFcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uV2ViRXhwb3J0Rm9ybWF0VHlwZS5QTkc7XG4gKlxuICogPC9zY3JpcHQ+XG4gKiAvLyBFUzYgSW1wb3J0XG4gKiBpbXBvcnQgeyBXZWJFeHBvcnRGb3JtYXRUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFdlYkV4cG9ydEZvcm1hdFR5cGUuUE5HO1xuICogYGBgXG4gKi9cbnZhciBXZWJFeHBvcnRGb3JtYXRUeXBlID0ge1xuICAgIC8qKiBwbmcgKi9cbiAgICBQTkc6IFwiUE5HXCIsXG4gICAgLyoqIHBkZiAqL1xuICAgIFBERjogXCJQREZcIlxufVxuXG4vKipcbiAqIEBlbnVtIFdlYlNjYWxlT3JpZW50YXRpb25UeXBlXG4gKiBAZGVzY3JpcHRpb24gV2ViIOavlOS+i+WwuueahOaWueS9jeagt+W8j+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHZlcnNpb24gMTAuMC4xXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LldlYlNjYWxlT3JpZW50YXRpb25UeXBlLkhPUklaT05UQUxMQUJFTFNCRUxPVztcbiAqXG4gKiA8L3NjcmlwdD5cbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IFdlYlNjYWxlT3JpZW50YXRpb25UeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFdlYlNjYWxlT3JpZW50YXRpb25UeXBlLkhPUklaT05UQUxMQUJFTFNCRUxPVztcbiAqIGBgYFxuICovXG52YXIgV2ViU2NhbGVPcmllbnRhdGlvblR5cGUgPSB7XG4gICAgLyoqIGhvcml6b250YWwgbGFiZWxzIGJlbG93ICovXG4gICAgSE9SSVpPTlRBTExBQkVMU0JFTE9XOiBcIkhPUklaT05UQUxMQUJFTFNCRUxPV1wiLFxuICAgIC8qKiBob3Jpem9udGFsIGxhYmVscyBhYm92ZSAqL1xuICAgIEhPUklaT05UQUxMQUJFTFNBQk9WRTogXCJIT1JJWk9OVEFMTEFCRUxTQUJPVkVcIixcbiAgICAvKiogdmVydGljYWwgbGFiZWxzIGxlZnQgKi9cbiAgICBWRVJUSUNBTExBQkVMU0xFRlQ6IFwiVkVSVElDQUxMQUJFTFNMRUZUXCIsXG4gICAgLyoqIHZlcnRpY2FsIGxhYmVscyByaWdodCAqL1xuICAgIFZFUlRJQ0FMTEFCRUxTUklHSFQ6IFwiVkVSVElDQUxMQUJFTFNSSUdIVFwiXG59XG5cbi8qKlxuICogQGVudW0gV2ViU2NhbGVUeXBlXG4gKiBAZGVzY3JpcHRpb24gV2ViIOavlOS+i+WwuueahOagt+W8j+OAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBDb25zdGFudFxuICogQHZlcnNpb24gMTAuMC4xXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LldlYlNjYWxlVHlwZS5MSU5FO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgV2ViU2NhbGVUeXBlIH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFdlYlNjYWxlVHlwZS5MSU5FO1xuICogYGBgXG4gKi9cbnZhciBXZWJTY2FsZVR5cGUgPSB7XG4gICAgLyoqIGxpbmUgKi9cbiAgICBMSU5FOiBcIkxJTkVcIixcbiAgICAvKiogYmFyICovXG4gICAgQkFSOiBcIkJBUlwiLFxuICAgIC8qKiBiYXIgc3ViICovXG4gICAgQkFSX1NVQjogXCJCQVJfU1VCXCJcbn1cblxuLyoqXG4gKiBAZW51bSBXZWJTY2FsZVVuaXRcbiAqIEBkZXNjcmlwdGlvbiBXZWIg5q+U5L6L5bC655qE5Y2V5L2N5Yi244CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIENvbnN0YW50XG4gKiBAdmVyc2lvbiAxMC4wLjFcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uV2ViU2NhbGVVbml0Lk1FVEVSO1xuICpcbiAqIDwvc2NyaXB0PlxuICogLy8gRVM2IEltcG9ydFxuICogaW1wb3J0IHsgV2ViU2NhbGVVbml0IH0gZnJvbSAne25wbX0nO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IFdlYlNjYWxlVW5pdC5NRVRFUjtcbiAqIGBgYFxuICovXG52YXIgV2ViU2NhbGVVbml0ID0ge1xuICAgIC8qKiDnsbMgKi9cbiAgICBNRVRFUjogXCJNRVRFUlwiLFxuICAgIC8qKiDoi7HlsLogKi9cbiAgICBGT09UOiBcIkZPT1RcIixcbiAgICAvKiog5bqmICovXG4gICAgREVHUkVFUzogXCJERUdSRUVTXCJcbn1cbmV4cG9ydCB7XG4gICAgRGF0YUZvcm1hdCxcbiAgICBTZXJ2ZXJUeXBlLFxuICAgIEdlb21ldHJ5VHlwZSxcbiAgICBRdWVyeU9wdGlvbixcbiAgICBKb2luVHlwZSxcbiAgICBTcGF0aWFsUXVlcnlNb2RlLFxuICAgIFNwYXRpYWxSZWxhdGlvblR5cGUsXG4gICAgTWVhc3VyZU1vZGUsXG4gICAgVW5pdCxcbiAgICBCdWZmZXJSYWRpdXNVbml0LFxuICAgIEVuZ2luZVR5cGUsXG4gICAgVGhlbWVHcmFwaFRleHRGb3JtYXQsXG4gICAgVGhlbWVHcmFwaFR5cGUsXG4gICAgR3JhcGhBeGVzVGV4dERpc3BsYXlNb2RlLFxuICAgIEdyYWR1YXRlZE1vZGUsXG4gICAgUmFuZ2VNb2RlLFxuICAgIFRoZW1lVHlwZSxcbiAgICBDb2xvckdyYWRpZW50VHlwZSxcbiAgICBUZXh0QWxpZ25tZW50LFxuICAgIEZpbGxHcmFkaWVudE1vZGUsXG4gICAgQWxvbmdMaW5lRGlyZWN0aW9uLFxuICAgIExhYmVsQmFja1NoYXBlLFxuICAgIExhYmVsT3Zlckxlbmd0aE1vZGUsXG4gICAgRGlyZWN0aW9uVHlwZSxcbiAgICBTaWRlVHlwZSxcbiAgICBTdXBwbHlDZW50ZXJUeXBlLFxuICAgIFR1cm5UeXBlLFxuICAgIEJ1ZmZlckVuZFR5cGUsXG4gICAgT3ZlcmxheU9wZXJhdGlvblR5cGUsXG4gICAgT3V0cHV0VHlwZSxcbiAgICBTbW9vdGhNZXRob2QsXG4gICAgU3VyZmFjZUFuYWx5c3RNZXRob2QsXG4gICAgRGF0YVJldHVybk1vZGUsXG4gICAgRWRpdFR5cGUsXG4gICAgVHJhbnNmZXJUYWN0aWMsXG4gICAgVHJhbnNmZXJQcmVmZXJlbmNlLFxuICAgIEdyaWRUeXBlLFxuICAgIENvbG9yU3BhY2VUeXBlLFxuICAgIExheWVyVHlwZSxcbiAgICBVR0NMYXllclR5cGUsXG4gICAgU3RhdGlzdGljTW9kZSxcbiAgICBQaXhlbEZvcm1hdCxcbiAgICBTZWFyY2hNb2RlLFxuICAgIEludGVycG9sYXRpb25BbGdvcml0aG1UeXBlLFxuICAgIFZhcmlvZ3JhbU1vZGUsXG4gICAgRXhwb25lbnQsXG4gICAgQ2xpZW50VHlwZSxcbiAgICBDaGFydFR5cGUsXG4gICAgQ2xpcEFuYWx5c3RNb2RlLFxuICAgIEFuYWx5c3RBcmVhVW5pdCxcbiAgICBBbmFseXN0U2l6ZVVuaXQsXG4gICAgU3RhdGlzdGljQW5hbHlzdE1vZGUsXG4gICAgU3VtbWFyeVR5cGUsXG4gICAgVG9wb2xvZ3lWYWxpZGF0b3JSdWxlLFxuICAgIEJ1Y2tldEFnZ1R5cGUsXG4gICAgTWV0cmljc0FnZ1R5cGUsXG4gICAgR2V0RmVhdHVyZU1vZGUsXG4gICAgUmFzdGVyRnVuY3Rpb25UeXBlLFxuICAgIFJlc291cmNlVHlwZSxcbiAgICBPcmRlckJ5LFxuICAgIE9yZGVyVHlwZSxcbiAgICBTZWFyY2hUeXBlLFxuICAgIEFnZ3JlZ2F0aW9uVHlwZXMsXG4gICAgUGVybWlzc2lvblR5cGUsXG4gICAgRW50aXR5VHlwZSxcbiAgICBEYXRhSXRlbVR5cGUsXG4gICAgV2ViRXhwb3J0Rm9ybWF0VHlwZSxcbiAgICBXZWJTY2FsZU9yaWVudGF0aW9uVHlwZSxcbiAgICBXZWJTY2FsZVR5cGUsXG4gICAgV2ViU2NhbGVVbml0XG59XG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NvbW1vbnR5cGVzL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7IE11bHRpUG9pbnQgfSBmcm9tICcuLi9jb21tb250eXBlcy9nZW9tZXRyeS9NdWx0aVBvaW50JztcbmltcG9ydCB7IExpbmVhclJpbmcgfSBmcm9tICcuLi9jb21tb250eXBlcy9nZW9tZXRyeS9MaW5lYXJSaW5nJztcbmltcG9ydCB7IExpbmVTdHJpbmcgfSBmcm9tICcuLi9jb21tb250eXBlcy9nZW9tZXRyeS9MaW5lU3RyaW5nJztcbmltcG9ydCB7IE11bHRpTGluZVN0cmluZyB9IGZyb20gJy4uL2NvbW1vbnR5cGVzL2dlb21ldHJ5L011bHRpTGluZVN0cmluZyc7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vY29tbW9udHlwZXMvZ2VvbWV0cnkvUG9seWdvbic7XG5pbXBvcnQgeyBNdWx0aVBvbHlnb24gfSBmcm9tICcuLi9jb21tb250eXBlcy9nZW9tZXRyeS9NdWx0aVBvbHlnb24nO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4uL2NvbW1vbnR5cGVzL2dlb21ldHJ5L0NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgU2VydmVyU3R5bGUgfSBmcm9tICcuL1NlcnZlclN0eWxlJztcbmltcG9ydCB7IFJvdXRlIH0gZnJvbSAnLi9Sb3V0ZSc7XG5pbXBvcnQgeyBVdGlsIH0gZnJvbSAnLi4vY29tbW9udHlwZXMvVXRpbCc7XG5pbXBvcnQgeyBHZW9tZXRyeVR5cGUgfSBmcm9tICcuLi9SRVNUJztcblxuLyoqXG4gKiBAY2xhc3MgU2VydmVyR2VvbWV0cnlcbiAqIEBkZXByZWNhdGVkY2xhc3MgU3VwZXJNYXAuU2VydmVyR2VvbWV0cnlcbiAqIEBjYXRlZ29yeSAgaVNlcnZlciBEYXRhIEZlYXR1cmVcbiAqIEBjbGFzc2Rlc2Mg5pyN5Yqh56uv5Yeg5L2V5a+56LGh57G744CC6K+l57G75o+P6L+w5Yeg5L2V5a+56LGh77yI55+i6YeP77yJ55qE54m55b6B5pWw5o2u77yI5Z2Q5qCH54K55a+544CB5Yeg5L2V5a+56LGh55qE57G75Z6L562J77yJ44CC5Z+65LqO5pyN5Yqh56uv55qE56m66Ze05YiG5p6Q44CB56m66Ze05YWz57O76L+Q566X44CB5p+l6K+i562JIEdJUyDmnI3liqHlip/og73kvb/nlKjmnI3liqHnq6/lh6DkvZXlr7nosaHjgIJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0g5Y+C5pWw44CCXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5pZCAtIOacjeWKoeerr+WHoOS9leWvueixoeWUr+S4gOagh+ivhuespuOAglxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3B0aW9ucy5wYXJ0cyAtIOacjeWKoeerr+WHoOS9leWvueixoeS4reWQhOS4quWtkOWvueixoeaJgOWMheWQq+eahOiKgueCueS4quaVsOOAglxuICogQHBhcmFtIHtBcnJheS48R2VvbWV0cnlQb2ludD59IG9wdGlvbnMucG9pbnRzIC0g57uE5oiQ5Yeg5L2V5a+56LGh55qE6IqC54K555qE5Z2Q5qCH5a+55pWw57uE44CCXG4gKiBAcGFyYW0ge0dlb21ldHJ5VHlwZX0gb3B0aW9ucy50eXBlIC0g5Yeg5L2V5a+56LGh55qE57G75Z6L44CCXG4gKiBAcGFyYW0ge1NlcnZlclN0eWxlfSBbb3B0aW9ucy5zdHlsZV0gLSDmnI3liqHnq6/lh6DkvZXlr7nosaHnmoTpo47moLzjgIJcbiAqIEB1c2FnZVxuICovXG5leHBvcnQgY2xhc3MgU2VydmVyR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gU2VydmVyR2VvbWV0cnkucHJvdG90eXBlLmlkXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDmnI3liqHnq6/lh6DkvZXlr7nosaHllK/kuIDmoIfor4bnrKbjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTZXJ2ZXJTdHlsZX0gW1NlcnZlckdlb21ldHJ5LnByb3RvdHlwZS5zdHlsZV1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOacjeWKoeerr+WHoOS9leWvueixoeeahOmjjuagvO+8iFNlcnZlclN0eWxl77yJ44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IFNlcnZlckdlb21ldHJ5LnByb3RvdHlwZS5wYXJ0c1xuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5pyN5Yqh56uv5Yeg5L2V5a+56LGh5Lit5ZCE5Liq5a2Q5a+56LGh5omA5YyF5ZCr55qE6IqC54K55Liq5pWw44CCPGJyPlxuICAgICAgICAgKiAxLuWHoOS9leWvueixoeS7jue7k+aehOS4iuWPr+S7peWIhuS4uueugOWNleWHoOS9leWvueixoeWSjOWkjeadguWHoOS9leWvueixoeOAglxuICAgICAgICAgKiDnroDljZXlh6DkvZXlr7nosaHkuI7lpI3mnYLlh6DkvZXlr7nosaHnmoTljLrliKvvvJrnroDljZXnmoTlh6DkvZXlr7nosaHkuIDoiKzkuLrljZXkuIDlr7nosaHvvIxcbiAgICAgICAgICog6ICM5aSN5p2C55qE5Yeg5L2V5a+56LGh55Sx5aSa5Liq566A5Y2V5a+56LGh57uE5oiQ5oiW57uP6L+H5LiA5a6a55qE56m66Ze06L+Q566X5LmL5ZCO5Lqn55Sf77yMXG4gICAgICAgICAqIOWmgu+8muefqeW9ouS4uueugOWNleeahOWMuuWfn+Wvueixoe+8jOiAjOS4reepuueahOefqeW9ouS4uuWkjeadgueahOWMuuWfn+WvueixoeOAgjxicj5cbiAgICAgICAgICogMi7pgJrluLjmg4XlhrXvvIzkuIDkuKrnroDljZXlh6DkvZXlr7nosaHnmoTlrZDlr7nosaHlsLHmmK/lroPmnKzouqvvvIxcbiAgICAgICAgICog5Zug5q2k5a+55LqO566A5Y2V5a+56LGh5p2l6K+055qE6K+l5a2X5q615Li66ZW/5bqm5Li6MeeahOaVtOWei+aVsOe7hO+8jFxuICAgICAgICAgKiDor6XlrZfmrrXnmoTlgLzlsLHmmK/ov5nkuKrnroDljZXlr7nosaHoioLngrnnmoTkuKrmlbDjgIJcbiAgICAgICAgICog5aaC5p6c5LiA5Liq5Yeg5L2V5a+56LGh5piv55Sx5Yeg5Liq566A5Y2V5a+56LGh57uE5ZCI6ICM5oiQ55qE77yMXG4gICAgICAgICAqIOS+i+Wmgu+8jOS4gOS4quWym+eKtuWHoOS9leWvueixoeeUsSAzIOS4queugOWNleeahOWkmui+ueW9oue7hOaIkOiAjOaIkO+8jFxuICAgICAgICAgKiDpgqPkuYjov5nkuKrlspvnirbnmoTlh6DkvZXlr7nosaHnmoQgUGFydHMg5a2X5q615YC85bCx5piv5LiA5Liq6ZW/5bqm5Li6IDMg55qE5pW05Z6L5pWw57uE77yMXG4gICAgICAgICAqIOaVsOe7hOS4reavj+S4quaIkOWRmOeahOWAvOWIhuWIq+S7o+ihqOi/meS4ieS4quWkmui+ueW9ouaJgOWMheWQq+eahOiKgueCueS4quaVsOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJ0cyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxHZW9tZXRyeVBvaW50Pn0gU2VydmVyR2VvbWV0cnkucHJvdG90eXBlLnBvaW50c1xuICAgICAgICAgKiBAZGVzY3JpcHRpb24g57uE5oiQ5Yeg5L2V5a+56LGh55qE6IqC54K555qE5Z2Q5qCH5a+55pWw57uE44CCPGJyPlxuICAgICAgICAgKiAxLuaJgOacieWHoOS9leWvueixoe+8iOeCueOAgee6v+OAgemdou+8iemDveaYr+eUseS4gOS6m+eugOWNleeahOeCueWdkOagh+e7hOaIkOeahO+8jFxuICAgICAgICAgKiDor6XlrZfmrrXlrZjmlL7kuobnu4TmiJDlh6DkvZXlr7nosaHnmoTngrnlnZDmoIfnmoTmlbDnu4TjgIJcbiAgICAgICAgICog5a+55LqO566A5Y2V55qE6Z2i5a+56LGh77yM5LuW55qE6LW354K55ZKM57uI54K555qE5Z2Q5qCH54K555u45ZCM44CCPGJyPlxuICAgICAgICAgKiAyLuWvueS6juWkjeadgueahOWHoOS9leWvueixoe+8jOagueaNriBQYXJ0cyDlsZ7mgKfmnaXnoa7lrprmr4/kuIDkuKrnu4TmiJDlpI3mnYLlh6DkvZXlr7nosaHnmoTnroDljZXlr7nosaHmiYDlr7nlupTnmoToioLngrnnmoTkuKrmlbDvvIxcbiAgICAgICAgICog5LuO6ICM56Gu5a6aIFBvaW50cyDlrZfmrrXkuK3lnZDmoIflr7nnmoTliIbphY3lvZLlsZ7pl67popjjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9pbnRzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7R2VvbWV0cnlUeXBlfSBTZXJ2ZXJHZW9tZXRyeS5wcm90b3R5cGUudHlwZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5Yeg5L2V5a+56LGh55qE57G75Z6L77yIR2VvbWV0cnlUeXBl77yJ44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IFNlcnZlckdlb21ldHJ5LnByb3RvdHlwZS5wcmpDb29yZFN5c1xuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5oqV5b2x5Z2Q5qCH5Y+C5pWw77yM546w5LuF5Zyo57yT5Yay5Yy65YiG5p6Q5Lit5pyJ5pWI44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByakNvb3JkU3lzID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIFV0aWwuZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gJ1N1cGVyTWFwLlNlcnZlckdlb21ldHJ5JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU2VydmVyR2VvbWV0cnkucHJvdG90eXBlLmRlc3Ryb3lcbiAgICAgKiBAZGVzY3JpcHRpb24g6YeK5pS+6LWE5rqQ77yM5bCG5byV55So6LWE5rqQ55qE5bGe5oCn572u56m644CCXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuaWQgPSBudWxsO1xuICAgICAgICBtZS5zdHlsZSA9IG51bGw7XG4gICAgICAgIG1lLnBhcnRzID0gbnVsbDtcbiAgICAgICAgbWUucGFydFRvcG8gPSBudWxsO1xuICAgICAgICBtZS5wb2ludHMgPSBudWxsO1xuICAgICAgICBtZS50eXBlID0gbnVsbDtcbiAgICAgICAgbWUucHJqQ29vcmRTeXMgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBTZXJ2ZXJHZW9tZXRyeS5wcm90b3R5cGUudG9HZW9tZXRyeVxuICAgICAqIEBkZXNjcmlwdGlvbiDlsIbmnI3liqHnq6/lh6DkvZXlr7nosaEgU2VydmVyR2VvbWV0cnkg6L2s5o2i5Li65a6i5oi356uv5Yeg5L2V5a+56LGhIEdlb21ldHJ544CCXG4gICAgICogQHJldHVybnMge0dlb21ldHJ5fSDovazmjaLlkI7nmoTlrqLmiLfnq6/lh6DkvZXlr7nosaHjgIJcbiAgICAgKi9cbiAgICB0b0dlb21ldHJ5KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZ2VvVHlwZSA9IG1lLnR5cGU7XG4gICAgICAgIHN3aXRjaCAoZ2VvVHlwZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0lOVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUudG9HZW9Qb2ludCgpO1xuICAgICAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUudG9HZW9MaW5lKCk7XG4gICAgICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FTTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUudG9HZW9MaW5lbSgpO1xuICAgICAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUkVHSU9OOlxuICAgICAgICAgICAgICAgIHJldHVybiBtZS50b0dlb1JlZ2lvbigpO1xuICAgICAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9JTlRFUFM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLnRvR2VvUG9pbnQoKTtcbiAgICAgICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVFUFM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLnRvR2VvTGluZUVQUygpO1xuICAgICAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUkVHSU9ORVBTOlxuICAgICAgICAgICAgICAgIHJldHVybiBtZS50b0dlb1JlZ2lvbkVQUygpO1xuICAgICAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuR0VPQ09NUE9VTkQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLnRyYW5zZm9ybUdlb0NvbXBvdW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU2VydmVyR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvUG9pbnRcbiAgICAgKiBAZGVzY3JpcHRpb24g5bCG5pyN5Yqh56uv55qE54K55Yeg5L2V5a+56LGh6L2s5o2i5Li65a6i5oi356uv5Yeg5L2V5a+56LGh44CC5YyF5ousIFBvaW5044CBTXVsdGlQb2ludOOAglxuICAgICAqIEByZXR1cm5zIHtHZW9tZXRyeX0g6L2s5o2i5ZCO55qE5a6i5oi356uv5Yeg5L2V5a+56LGh44CCXG4gICAgICovXG4gICAgdG9HZW9Qb2ludCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgIGdlb1BhcnRzID0gbWUucGFydHMgfHwgW10sXG4gICAgICAgICAgICBnZW9Qb2ludHMgPSBtZS5wb2ludHMgfHwgW10sXG4gICAgICAgICAgICBsZW4gPSBnZW9QYXJ0cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChnZW9Qb2ludHNbMF0ueCwgZ2VvUG9pbnRzWzBdLnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwb2ludExpc3QucHVzaChuZXcgUG9pbnQoZ2VvUG9pbnRzW2ldLngsIGdlb1BvaW50c1tpXS55KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlQb2ludChwb2ludExpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU2VydmVyR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvTGluZVxuICAgICAqIEBkZXNjcmlwdGlvbiDlsIbmnI3liqHnq6/nmoTnur/lh6DkvZXlr7nosaHovazmjaLkuLrlrqLmiLfnq6/lh6DkvZXlr7nosaHjgILljIXmi6wgR2VvbWV0cnlMaW5lYXJSaW5n44CBR2VvbWV0cnlMaW5lU3RyaW5n44CBR2VvbWV0cnlNdWx0aUxpbmVTdHJpbmfjgIJcbiAgICAgKiBAcmV0dXJucyB7R2VvbWV0cnl9IOi9rOaNouWQjueahOWuouaIt+err+WHoOS9leWvueixoeOAglxuICAgICAqL1xuICAgIHRvR2VvTGluZSgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgIGdlb1BhcnRzID0gbWUucGFydHMgfHwgW10sXG4gICAgICAgICAgICBnZW9Qb2ludHMgPSBtZS5wb2ludHMgfHwgW10sXG4gICAgICAgICAgICBsZW4gPSBnZW9QYXJ0cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvUGFydHNbMF07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwb2ludExpc3QucHVzaChuZXcgUG9pbnQoZ2VvUG9pbnRzW2ldLngsIGdlb1BvaW50c1tpXS55KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8v5Yik5pat57q/5piv5ZCm6Zet5ZCI77yM5aaC5p6c6Zet5ZCI77yM5YiZ6L+U5ZueTGluZWFyUmluZ++8jOWQpuWImei/lOWbnkxpbmVTdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRMaXN0WzBdLmVxdWFscyhwb2ludExpc3RbZ2VvUGFydHNbMF0gLSAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHBvaW50TGlzdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHBvaW50TGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZUxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnZW9QYXJ0c1tpXTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludExpc3QucHVzaChuZXcgUG9pbnQoZ2VvUG9pbnRzW2pdLngsIGdlb1BvaW50c1tqXS55KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluZUxpc3QucHVzaChuZXcgTGluZVN0cmluZyhwb2ludExpc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvUG9pbnRzLnNwbGljZSgwLCBnZW9QYXJ0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKGxpbmVMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFNlcnZlckdlb21ldHJ5LnByb3RvdHlwZS50b0dlb0xpbmVFUFNcbiAgICAgKiBAZGVzY3JpcHRpb24g5bCG5pyN5Yqh56uv55qE57q/5Yeg5L2V5a+56LGh6L2s5o2i5Li65a6i5oi356uv5Yeg5L2V5a+56LGh44CC5YyF5ousIEdlb21ldHJ5TGluZWFyUmluZ+OAgUdlb21ldHJ5TGluZVN0cmluZ+OAgUdlb21ldHJ5TXVsdGlMaW5lU3RyaW5n44CCXG4gICAgICogQHJldHVybnMge0dlb21ldHJ5fSDovazmjaLlkI7nmoTlrqLmiLfnq6/lh6DkvZXlr7nosaHjgIJcbiAgICAgKi9cbiAgICB0b0dlb0xpbmVFUFMoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICBnZW9QYXJ0cyA9IG1lLnBhcnRzIHx8IFtdLFxuICAgICAgICAgICAgZ2VvUG9pbnRzID0gbWUucG9pbnRzIHx8IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBwb2ludExpc3QsXG4gICAgICAgICAgICBsaW5lTGlzdCxcbiAgICAgICAgICAgIGxpbmVFUFMsXG4gICAgICAgICAgICBsZW4gPSBnZW9QYXJ0cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgcG9pbnRMaXN0ID0gW107IGkgPCBnZW9QYXJ0c1swXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50TGlzdC5wdXNoKG5ldyBQb2ludChnZW9Qb2ludHNbaV0ueCwgZ2VvUG9pbnRzW2ldLnksIGdlb1BvaW50c1tpXS50eXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8v5Yik5pat57q/5piv5ZCm6Zet5ZCI77yM5aaC5p6c6Zet5ZCI77yM5YiZ6L+U5ZueTGluZWFyUmluZ++8jOWQpuWImei/lOWbnkxpbmVTdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRMaXN0WzBdLmVxdWFscyhwb2ludExpc3RbZ2VvUGFydHNbMF0gLSAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUVQUyA9IExpbmVTdHJpbmcuY3JlYXRlTGluZUVQUyhwb2ludExpc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmVhclJpbmcobGluZUVQUyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUVQUyA9IExpbmVTdHJpbmcuY3JlYXRlTGluZUVQUyhwb2ludExpc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmVTdHJpbmcobGluZUVQUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsaW5lTGlzdCA9IFtdOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgcG9pbnRMaXN0ID0gW107IGogPCBnZW9QYXJ0c1tpXTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludExpc3QucHVzaChuZXcgUG9pbnQoZ2VvUG9pbnRzW2pdLngsIGdlb1BvaW50c1tqXS55KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluZUVQUyA9IExpbmVTdHJpbmcuY3JlYXRlTGluZUVQUyhwb2ludExpc3QpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lTGlzdC5wdXNoKG5ldyBMaW5lU3RyaW5nKGxpbmVFUFMpKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvUG9pbnRzLnNwbGljZSgwLCBnZW9QYXJ0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKGxpbmVMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFNlcnZlckdlb21ldHJ5LnByb3RvdHlwZS50b0dlb0xpbmVtXG4gICAgICogQGRlc2NyaXB0aW9uIOWwhuacjeWKoeerr+eahOi3r+eUsee6v+WHoOS9leWvueixoei9rOaNouS4uuWuouaIt+err+WHoOS9leWvueixoeOAguWMheaLrCBMaW5lYXJSaW5n44CBTGluZVN0cmluZ+OAgU11bHRpTGluZVN0cmluZ+OAglxuICAgICAqIEByZXR1cm5zIHtHZW9tZXRyeX0g6L2s5o2i5ZCO55qE5a6i5oi356uv5Yeg5L2V5a+56LGh44CCXG4gICAgICovXG4gICAgdG9HZW9MaW5lbSgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFJvdXRlLmZyb21Kc29uKG1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU2VydmVyR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvUmVnaW9uXG4gICAgICogQGRlc2NyaXB0aW9uIOWwhuacjeWKoeerr+eahOmdouWHoOS9leWvueixoei9rOaNouS4uuWuouaIt+err+WHoOS9leWvueixoeOAguexu+Wei+S4uiBHZW9tZXRyeVBvbHlnb27jgIJcbiAgICAgKiBAcmV0dXJucyB7R2VvbWV0cnl9IOi9rOaNouWQjueahOWuouaIt+err+WHoOS9leWvueixoeOAglxuICAgICAqL1xuICAgIHRvR2VvUmVnaW9uKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZ2VvUGFydHMgPSBtZS5wYXJ0cyB8fCBbXSxcbiAgICAgICAgICAgIGdlb1RvcG8gPSBtZS5wYXJ0VG9wbyB8fCBbXSxcbiAgICAgICAgICAgIGdlb1BvaW50cyA9IG1lLnBvaW50cyB8fCBbXSxcbiAgICAgICAgICAgIGxlbiA9IGdlb1BhcnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9seWdvbkFycmF5ID0gW107XG4gICAgICAgIHZhciBwb2ludExpc3QgPSBbXTtcbiAgICAgICAgaWYgKGxlbiA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb1BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBvaW50TGlzdC5wdXNoKG5ldyBQb2ludChnZW9Qb2ludHNbaV0ueCwgZ2VvUG9pbnRzW2ldLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvbHlnb25BcnJheS5wdXNoKG5ldyBQb2x5Z29uKFtuZXcgTGluZWFyUmluZyhwb2ludExpc3QpXSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24ocG9seWdvbkFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICAvL+WkhOeQhuWkjeadgumdolxuICAgICAgICB2YXIgQ0NXQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGFyZWFBcnJheSA9IFtdO1xuICAgICAgICB2YXIgcG9seWdvbkFycmF5VGVtcCA9IFtdO1xuICAgICAgICB2YXIgcG9seWdvbkJvdW5kcyA9IFtdO1xuICAgICAgICAvL3BvbHlvbuWym+a0nuagh+ivhuaVsOe7hO+8jOWIneWni+mDveaYr+Wym+OAglxuICAgICAgICB2YXIgQ0NXSWRlbnQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvaW50SW5kZXggPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ2VvUGFydHNbaV07IGorKykge1xuICAgICAgICAgICAgICAgIHBvaW50TGlzdC5wdXNoKG5ldyBQb2ludChnZW9Qb2ludHNbcG9pbnRJbmRleCArIGpdLngsIGdlb1BvaW50c1twb2ludEluZGV4ICsgal0ueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRJbmRleCArPSBnZW9QYXJ0c1tpXTtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oW25ldyBMaW5lYXJSaW5nKHBvaW50TGlzdCldKTtcbiAgICAgICAgICAgIHBvaW50TGlzdCA9IFtdO1xuICAgICAgICAgICAgcG9seWdvbkFycmF5VGVtcC5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgICAgaWYgKGdlb1RvcG8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcG9seWdvbkJvdW5kcy5wdXNoKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ0NXSWRlbnQucHVzaCgxKTtcbiAgICAgICAgICAgIGFyZWFBcnJheS5wdXNoKHBvbHlnb24uZ2V0QXJlYSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvL2lTZXJ2ZXIgOUTmlrDlop7lrZfmrrVcbiAgICAgICAgaWYgKGdlb1RvcG8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvL+agueaNrumdouenr+aOkuW6j1xuICAgICAgICAgICAgU2VydmVyR2VvbWV0cnkuYnViYmxlU29ydChhcmVhQXJyYXksIHBvbHlnb25BcnJheVRlbXAsIGdlb1RvcG8sIHBvbHlnb25Cb3VuZHMpO1xuICAgICAgICAgICAgLy/lspvmtJ7lupXlsYLliKTmlq3ljp/liJnvvJrlsIbmiYDmnInnmoTlrZDlr7nosaHmjInnhafpnaLnp6/mjpLluo/vvIzpnaLnp6/mnIDlpKfnmoTnm7TmjqXliKTlrprkuLrlspvvvIgx77yJ77yM5LuO6Z2i56ev5qyh5aSn55qE5byA5aeL5aSE55CG77yMXG4gICAgICAgICAgICAvLyDlpoLmnpzlj5HnjrDor6Xlr7nosaHlnKjmn5DkuKrpnaLnp6/lpKfkuo7lroPnmoTlr7nosaHkuYvkuK3vvIjljbPooqvljIXlkKvvvInvvIzliJnmoLnmja7ljIXlkKvlroPnmoTlr7nosaHnmoTmoIfor4bvvIgxIG9yIC0x77yJ77yM5oyH5a6a5YW25qCH6K+G77yILTEgb3IgMe+8ie+8jFxuICAgICAgICAgICAgLy8g5L6d5qyh5aSE55CG5a6M5omA5pyJ5a+56LGh77yM5bCx5b6X5Yiw5LqG5LiA5Liq5qCH6K+G5pWw57uE77yMMeihqOekuuWym++8jC0x6KGo56S65rSeXG4gICAgICAgICAgICAvL+ebruagh3BvbHlnb27ntKLlvJXliJfooaggLTHmoIfnpLrmsqHmnInooqvku7vkvZVwb2x5Z29u5YyF5ZCr77yMXG4gICAgICAgICAgICB2YXIgdGFyZ2V0QXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9seWdvbkFycmF5VGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXlbaV0gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHlnb25Cb3VuZHNbal0uY29udGFpbnNCb3VuZHMocG9seWdvbkJvdW5kc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENDV0lkZW50W2ldID0gQ0NXSWRlbnRbal0gKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDQ1dJZGVudFtpXSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRBcnJheVtpXSA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbkFycmF5VGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChDQ1dJZGVudFtpXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFycmF5LnB1c2gocG9seWdvbkFycmF5VGVtcFtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFycmF5W3RhcmdldEFycmF5W2ldXS5jb21wb25lbnRzID0gcG9seWdvbkFycmF5W3RhcmdldEFycmF5W2ldXS5jb21wb25lbnRzLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcnJheVRlbXBbaV0uY29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAvL+WNoOS9jVxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXJyYXkucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9seWdvbkFycmF5ID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlnb25BcnJheVRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2VvVG9wb1tpXSAmJiBnZW9Ub3BvW2ldID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIENDV0FycmF5ID0gQ0NXQXJyYXkuY29uY2F0KHBvbHlnb25BcnJheVRlbXBbaV0uY29tcG9uZW50cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKENDV0FycmF5Lmxlbmd0aCA+IDAgJiYgcG9seWdvbkFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcnJheVtwb2x5Z29uQXJyYXkubGVuZ3RoIC0gMV0uY29tcG9uZW50cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFycmF5W3BvbHlnb25BcnJheS5sZW5ndGggLSAxXS5jb21wb25lbnRzLmNvbmNhdChDQ1dBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBDQ1dBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcnJheS5wdXNoKHBvbHlnb25BcnJheVRlbXBbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2x5TGVuZ3RoID0gcG9seWdvbkFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcnJheVtwb2x5TGVuZ3RoIC0gMV0uY29tcG9uZW50cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFycmF5W3BvbHlMZW5ndGggLSAxXS5jb21wb25lbnRzLmNvbmNhdChDQ1dBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMCwgbGVuZ3RoID0gQ0NXQXJyYXkubGVuZ3RoOyBrIDwgbGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXJyYXkucHVzaChuZXcgUG9seWdvbihDQ1dBcnJheSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlQb2x5Z29uKHBvbHlnb25BcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFNlcnZlckdlb21ldHJ5LnByb3RvdHlwZS50b0dlb1JlZ2lvbkVQU1xuICAgICAqIEBkZXNjcmlwdGlvbiDlsIbmnI3liqHnq6/nmoTpnaLlh6DkvZXlr7nosaHovazmjaLkuLrlrqLmiLfnq6/lh6DkvZXlr7nosaHjgILnsbvlnovkuLogUG9seWdvbuOAglxuICAgICAqIEByZXR1cm5zIHtHZW9tZXRyeX0g6L2s5o2i5ZCO55qE5a6i5oi356uv5Yeg5L2V5a+56LGh44CCXG4gICAgICovXG4gICAgdG9HZW9SZWdpb25FUFMoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICBnZW9QYXJ0cyA9IG1lLnBhcnRzIHx8IFtdLFxuICAgICAgICAgICAgZ2VvVG9wbyA9IG1lLnBhcnRUb3BvIHx8IFtdLFxuICAgICAgICAgICAgZ2VvUG9pbnRzID0gbWUucG9pbnRzIHx8IFtdLFxuICAgICAgICAgICAgbGVuID0gZ2VvUGFydHMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW4gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvbHlnb25BcnJheSA9IFtdO1xuICAgICAgICB2YXIgcG9pbnRMaXN0ID0gW107XG4gICAgICAgIHZhciBsaW5lRVBTO1xuICAgICAgICBpZiAobGVuID09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRMaXN0LnB1c2gobmV3IFBvaW50KGdlb1BvaW50c1tpXS54LCBnZW9Qb2ludHNbaV0ueSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lRVBTID0gTGluZVN0cmluZy5jcmVhdGVMaW5lRVBTKHBvaW50TGlzdCk7XG4gICAgICAgICAgICBwb2x5Z29uQXJyYXkucHVzaChuZXcgUG9seWdvbihbbmV3IExpbmVhclJpbmcobGluZUVQUyldKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE11bHRpUG9seWdvbihwb2x5Z29uQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIC8v5aSE55CG5aSN5p2C6Z2iXG4gICAgICAgIHZhciBDQ1dBcnJheSA9IFtdO1xuICAgICAgICB2YXIgYXJlYUFycmF5ID0gW107XG4gICAgICAgIHZhciBwb2x5Z29uQXJyYXlUZW1wID0gW107XG4gICAgICAgIHZhciBwb2x5Z29uQm91bmRzID0gW107XG4gICAgICAgIC8vcG9seW9u5bKb5rSe5qCH6K+G5pWw57uE77yM5Yid5aeL6YO95piv5bKb44CCXG4gICAgICAgIHZhciBDQ1dJZGVudCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9pbnRJbmRleCA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnZW9QYXJ0c1tpXTsgaisrKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRMaXN0LnB1c2gobmV3IFBvaW50KGdlb1BvaW50c1twb2ludEluZGV4ICsgal0ueCwgZ2VvUG9pbnRzW3BvaW50SW5kZXggKyBqXS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludEluZGV4ICs9IGdlb1BhcnRzW2ldO1xuXG4gICAgICAgICAgICBsaW5lRVBTID0gTGluZVN0cmluZy5jcmVhdGVMaW5lRVBTKHBvaW50TGlzdCk7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKFtuZXcgTGluZWFyUmluZyhsaW5lRVBTKV0pO1xuICAgICAgICAgICAgcG9pbnRMaXN0ID0gW107XG4gICAgICAgICAgICBwb2x5Z29uQXJyYXlUZW1wLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICBpZiAoZ2VvVG9wby5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uQm91bmRzLnB1c2gocG9seWdvbi5nZXRCb3VuZHMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDQ1dJZGVudC5wdXNoKDEpO1xuICAgICAgICAgICAgYXJlYUFycmF5LnB1c2gocG9seWdvbi5nZXRBcmVhKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vaVNlcnZlciA5ROaWsOWinuWtl+autVxuICAgICAgICBpZiAoZ2VvVG9wby5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8v5qC55o2u6Z2i56ev5o6S5bqPXG4gICAgICAgICAgICBTZXJ2ZXJHZW9tZXRyeS5idWJibGVTb3J0KGFyZWFBcnJheSwgcG9seWdvbkFycmF5VGVtcCwgZ2VvVG9wbywgcG9seWdvbkJvdW5kcyk7XG4gICAgICAgICAgICAvL+Wym+a0nuW6leWxguWIpOaWreWOn+WIme+8muWwhuaJgOacieeahOWtkOWvueixoeaMieeFp+mdouenr+aOkuW6j++8jOmdouenr+acgOWkp+eahOebtOaOpeWIpOWumuS4uuWym++8iDHvvInvvIzku47pnaLnp6/mrKHlpKfnmoTlvIDlp4vlpITnkIbvvIxcbiAgICAgICAgICAgIC8vIOWmguaenOWPkeeOsOivpeWvueixoeWcqOafkOS4qumdouenr+Wkp+S6juWug+eahOWvueixoeS5i+S4re+8iOWNs+iiq+WMheWQq++8ie+8jOWImeagueaNruWMheWQq+Wug+eahOWvueixoeeahOagh+ivhu+8iDEgb3IgLTHvvInvvIzmjIflrprlhbbmoIfor4bvvIgtMSBvciAx77yJ77yMXG4gICAgICAgICAgICAvLyDkvp3mrKHlpITnkIblrozmiYDmnInlr7nosaHvvIzlsLHlvpfliLDkuobkuIDkuKrmoIfor4bmlbDnu4TvvIwx6KGo56S65bKb77yMLTHooajnpLrmtJ5cbiAgICAgICAgICAgIC8v55uu5qCHcG9seWdvbue0ouW8leWIl+ihqCAtMeagh+ekuuayoeacieiiq+S7u+S9lXBvbHlnb27ljIXlkKvvvIxcbiAgICAgICAgICAgIHZhciB0YXJnZXRBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2x5Z29uQXJyYXlUZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBcnJheVtpXSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvbkJvdW5kc1tqXS5jb250YWluc0JvdW5kcyhwb2x5Z29uQm91bmRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ0NXSWRlbnRbaV0gPSBDQ1dJZGVudFtqXSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENDV0lkZW50W2ldIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFycmF5W2ldID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uQXJyYXlUZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKENDV0lkZW50W2ldID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXJyYXkucHVzaChwb2x5Z29uQXJyYXlUZW1wW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXJyYXlbdGFyZ2V0QXJyYXlbaV1dLmNvbXBvbmVudHMgPSBwb2x5Z29uQXJyYXlbdGFyZ2V0QXJyYXlbaV1dLmNvbXBvbmVudHMuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFycmF5VGVtcFtpXS5jb21wb25lbnRzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIC8v5Y2g5L2NXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcnJheS5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2x5Z29uQXJyYXkgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbkFycmF5VGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChnZW9Ub3BvW2ldICYmIGdlb1RvcG9baV0gPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgQ0NXQXJyYXkgPSBDQ1dBcnJheS5jb25jYXQocG9seWdvbkFycmF5VGVtcFtpXS5jb21wb25lbnRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ0NXQXJyYXkubGVuZ3RoID4gMCAmJiBwb2x5Z29uQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFycmF5W3BvbHlnb25BcnJheS5sZW5ndGggLSAxXS5jb21wb25lbnRzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXJyYXlbcG9seWdvbkFycmF5Lmxlbmd0aCAtIDFdLmNvbXBvbmVudHMuY29uY2F0KENDV0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIENDV0FycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFycmF5LnB1c2gocG9seWdvbkFycmF5VGVtcFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbHlMZW5ndGggPSBwb2x5Z29uQXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9seUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFycmF5W3BvbHlMZW5ndGggLSAxXS5jb21wb25lbnRzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXJyYXlbcG9seUxlbmd0aCAtIDFdLmNvbXBvbmVudHMuY29uY2F0KENDV0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwLCBsZW5ndGggPSBDQ1dBcnJheS5sZW5ndGg7IGsgPCBsZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcnJheS5wdXNoKG5ldyBQb2x5Z29uKENDV0FycmF5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24ocG9seWdvbkFycmF5KTtcbiAgICB9XG4gICAgdHJhbnNmb3JtR2VvQ29tcG91bmQoKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGdlb1BhcnRzID0gbWUuZ2VvUGFydHMgfHwgW10sXG4gICAgICAgICAgICBsZW4gPSBnZW9QYXJ0cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2VvbWV0cnlMaXN0ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvUGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgZ2VvbWV0cnlMaXN0LnB1c2gobmV3IFNlcnZlckdlb21ldHJ5KGdlb21ldHJ5KS50b0dlb21ldHJ5KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbihnZW9tZXRyeUxpc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBTZXJ2ZXJHZW9tZXRyeS5wcm90b3R5cGUuZnJvbUpzb25cbiAgICAgKiBAZGVzY3JpcHRpb24g5bCGIEpTT04g5a+56LGh6KGo56S65pyN5Yqh56uv5Yeg5L2V5a+56LGh6L2s5o2i5Li6IFNlcnZlckdlb21ldHJ544CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGpzb25PYmplY3QgLSDopoHovazmjaLnmoQgSlNPTiDlr7nosaHjgIJcbiAgICAgKiBAcmV0dXJucyB7U2VydmVyR2VvbWV0cnl9IOi9rOaNouWQjueahCBTZXJ2ZXJHZW9tZXRyeSDlr7nosaHjgIJcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvbk9iamVjdCkge1xuICAgICAgICBpZiAoIWpzb25PYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlcnZlckdlb21ldHJ5KHtcbiAgICAgICAgICAgIGlkOiBqc29uT2JqZWN0LmlkLFxuICAgICAgICAgICAgc3R5bGU6IFNlcnZlclN0eWxlLmZyb21Kc29uKGpzb25PYmplY3Quc3R5bGUpLFxuICAgICAgICAgICAgcGFydHM6IGpzb25PYmplY3QucGFydHMsXG4gICAgICAgICAgICBwYXJ0VG9wbzoganNvbk9iamVjdC5wYXJ0VG9wbyxcbiAgICAgICAgICAgIHBvaW50czoganNvbk9iamVjdC5wb2ludHMsXG4gICAgICAgICAgICBjZW50ZXI6IGpzb25PYmplY3QuY2VudGVyLFxuICAgICAgICAgICAgbGVuZ3RoOiBqc29uT2JqZWN0Lmxlbmd0aCxcbiAgICAgICAgICAgIG1heE06IGpzb25PYmplY3QubWF4TSxcbiAgICAgICAgICAgIG1pbk06IGpzb25PYmplY3QubWluTSxcbiAgICAgICAgICAgIHR5cGU6IGpzb25PYmplY3QudHlwZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gU2VydmVyR2VvbWV0cnkucHJvdG90eXBlLmZyb21HZW9tZXRyeVxuICAgICAqIEBkZXNjcmlwdGlvbiDlsIblrqLmiLfnq68gR2VvbWV0cnkg6L2s5o2i5oiQ5pyN5Yqh56uvIFNlcnZlckdlb21ldHJ544CCXG4gICAgICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgLSDopoHovazmjaLnmoTlrqLmiLfnq68gR2VvbWV0cnkg5a+56LGh44CCXG4gICAgICogQHJldHVybnMge1NlcnZlckdlb21ldHJ5fSDovazmjaLlkI7nmoQgU2VydmVyR2VvbWV0cnkg5a+56LGh44CCXG4gICAgICovXG4gICAgc3RhdGljIGZyb21HZW9tZXRyeShnZW9tZXRyeSkge1xuICAgICAgICBpZiAoIWdlb21ldHJ5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkID0gMCxcbiAgICAgICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgICAgICBwb2ludHMgPSBbXSxcbiAgICAgICAgICAgIHR5cGUgPSBudWxsLFxuICAgICAgICAgICAgaWNvbXBvbmVudHMgPSBnZW9tZXRyeS5jb21wb25lbnRzLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2VvbWV0cnkuQ0xBU1NfTkFNRSxcbiAgICAgICAgICAgIHByakNvb3JkU3lzID0geyBlcHNnQ29kZTogZ2VvbWV0cnkuU1JJRCB9O1xuXG4gICAgICAgIGlmICghaXNOYU4oZ2VvbWV0cnkuaWQpKSB7XG4gICAgICAgICAgICBpZCA9IGdlb21ldHJ5LmlkO1xuICAgICAgICB9XG4gICAgICAgIC8v5Z2R54i555qE5pS55rOV77yM5rKh5rOV77yM5Li65LqG5pSv5oyB5oCB5Yq/5qCH57uY77yM5pyJ5pe26Ze05bCx5b6X5YWo5pS5XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNsYXNzTmFtZSAhPSAnU3VwZXJNYXAuR2VvbWV0cnkuTGluZWFyUmluZycgJiZcbiAgICAgICAgICAgIGNsYXNzTmFtZSAhPSAnU3VwZXJNYXAuR2VvbWV0cnkuTGluZVN0cmluZycgJiZcbiAgICAgICAgICAgIChnZW9tZXRyeSBpbnN0YW5jZW9mIE11bHRpUG9pbnQgfHwgZ2VvbWV0cnkgaW5zdGFuY2VvZiBNdWx0aUxpbmVTdHJpbmcpXG4gICAgICAgICkge1xuICAgICAgICAgICAgbGV0IGlsZW4gPSBpY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRpY2VzID0gaWNvbXBvbmVudHNbaV0uZ2V0VmVydGljZXMoKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFydFBvaW50c0NvdW50ID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydFBvaW50c0NvdW50KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhcnRQb2ludHNDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyBQb2ludCh2ZXJ0aWNlc1tqXS54LCB2ZXJ0aWNlc1tqXS55KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy/ov5nph4xjbGFzc05hbWXkuI3mmK/lpJrngrnlsLHlhajpg6jmmK/nrpfnur9cbiAgICAgICAgICAgIHR5cGUgPSBjbGFzc05hbWUgPT0gJ1N1cGVyTWFwLkdlb21ldHJ5Lk11bHRpUG9pbnQnID8gR2VvbWV0cnlUeXBlLlBPSU5UIDogR2VvbWV0cnlUeXBlLkxJTkU7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24pIHtcbiAgICAgICAgICAgIGxldCBpbGVuID0gaWNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9seWdvbiA9IGljb21wb25lbnRzW2ldLFxuICAgICAgICAgICAgICAgICAgICBsaW5lYXJSaW5nT2ZQb2x5Z29uID0gcG9seWdvbi5jb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgICBsaW5lYXJSaW5nT2ZQb2x5Z29uTGVuID0gbGluZWFyUmluZ09mUG9seWdvbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lYXJSaW5nT2ZQb2x5Z29uTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVydGljZXMgPSBsaW5lYXJSaW5nT2ZQb2x5Z29uW2pdLmdldFZlcnRpY2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRQb2ludHNDb3VudCA9IHZlcnRpY2VzLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydFBvaW50c0NvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBwYXJ0UG9pbnRzQ291bnQgLSAxOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyBQb2ludCh2ZXJ0aWNlc1trXS54LCB2ZXJ0aWNlc1trXS55KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUG9pbnQodmVydGljZXNbMF0ueCwgdmVydGljZXNbMF0ueSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlID0gR2VvbWV0cnlUeXBlLlJFR0lPTjtcbiAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICAgICAgICAgIGxldCBpbGVuID0gaWNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IGljb21wb25lbnRzW2ldLmdldFZlcnRpY2VzKCk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnRQb2ludHNDb3VudCA9IHZlcnRpY2VzLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0UG9pbnRzQ291bnQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFydFBvaW50c0NvdW50IC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChuZXcgUG9pbnQodmVydGljZXNbal0ueCwgdmVydGljZXNbal0ueSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChuZXcgUG9pbnQodmVydGljZXNbMF0ueCwgdmVydGljZXNbMF0ueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZSA9IEdlb21ldHJ5VHlwZS5SRUdJT047XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmdldFZlcnRpY2VzKCk7XG4gICAgICAgICAgICBsZXQgZ2VvbWV0cnlWZXJ0aWNlc0NvdW50ID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnZW9tZXRyeVZlcnRpY2VzQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyBQb2ludCh2ZXJ0aWNlc1tqXS54LCB2ZXJ0aWNlc1tqXS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gobmV3IFBvaW50KHZlcnRpY2VzWzBdLngsIHZlcnRpY2VzWzBdLnkpKTtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeVZlcnRpY2VzQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRzLnB1c2goZ2VvbWV0cnlWZXJ0aWNlc0NvdW50KTtcbiAgICAgICAgICAgIHR5cGUgPSBnZW9tZXRyeSBpbnN0YW5jZW9mIFBvaW50ID8gR2VvbWV0cnlUeXBlLlBPSU5UIDogR2VvbWV0cnlUeXBlLkxJTkU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFNlcnZlckdlb21ldHJ5KHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHN0eWxlOiBudWxsLFxuICAgICAgICAgICAgcGFydHM6IHBhcnRzLFxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgcHJqQ29vcmRTeXM6IHByakNvb3JkU3lzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBTZXJ2ZXJHZW9tZXRyeS5wcm90b3R5cGUuSXNDbG9ja1dpc2VcbiAgICAgKiBAZGVzY3JpcHRpb24g5Yik5patIGxpbmVhclJpbmcg5Lit55qE54K555qE6aG65bqP44CC6L+U5Zue5YC85aSn5LqOIDDvvIzpgIbml7bpkojvvJvlsI/kuo4gMO+8jOmhuuaXtumSiOOAglxuICAgICAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IC0g6KaB6L2s5o2i55qE5a6i5oi356uvIEdlb21ldHJ5IOWvueixoeOAglxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IOi/lOWbnuWAvOWkp+S6jiAw77yM6YCG5pe26ZKI77yb5bCP5LqOIDDvvIzpobrml7bpkojjgIJcbiAgICAgKi9cbiAgICBzdGF0aWMgSXNDbG9ja1dpc2UocG9pbnRzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IHBvaW50c1swXS55ICogKHBvaW50c1tsZW5ndGggLSAxXS54IC0gcG9pbnRzWzFdLngpO1xuICAgICAgICBwb2ludHMucHVzaChwb2ludHNbMF0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzICs9IHBvaW50c1tpXS55ICogKHBvaW50c1tpIC0gMV0ueCAtIHBvaW50c1tpICsgMV0ueCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMgKiAwLjU7XG4gICAgfVxuXG4gICAgc3RhdGljIGJ1YmJsZVNvcnQoYXJlYUFycmF5LCBwb2ludExpc3QsIGdlb1RvcG8sIHBvbHlnb25Cb3VuZHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmVhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJlYUFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZWFBcnJheVtpXSA+IGFyZWFBcnJheVtqXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGFyZWFBcnJheVtqXTtcbiAgICAgICAgICAgICAgICAgICAgYXJlYUFycmF5W2pdID0gYXJlYUFycmF5W2ldO1xuICAgICAgICAgICAgICAgICAgICBhcmVhQXJyYXlbaV0gPSBkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHBvaW50TGlzdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRMaXN0W2pdID0gcG9pbnRMaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludExpc3RbaV0gPSBiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VvVG9wbyAmJiBnZW9Ub3BvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gZ2VvVG9wb1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb1RvcG9bal0gPSBnZW9Ub3BvW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvVG9wb1tpXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHlnb25Cb3VuZHMgJiYgcG9seWdvbkJvdW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHBvbHlnb25Cb3VuZHNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQm91bmRzW2pdID0gcG9seWdvbkJvdW5kc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25Cb3VuZHNbaV0gPSBmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG5pbXBvcnQge1V0aWx9IGZyb20gJy4vVXRpbCc7XG5cbi8qKlxuICogQGNsYXNzIEZlYXR1cmVcbiAqIEBkZXByZWNhdGVkY2xhc3MgU3VwZXJNYXAuRmVhdHVyZVxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBHZW9tZXRyeVxuICogQGNsYXNzZGVzYyDopoHntKDnsbvnu4TlkIjkuoblnLDnkIblkozlsZ7mgKfvvIxGZWF0dXJlIOexu+WQjOaXtuWFt+aciSBtYXJrZXIg5ZKMIGxvbmxhdCDlsZ7mgKfjgIJcbiAqIEBwYXJhbSB7U3VwZXJNYXAuTGF5ZXJ9IGxheWVyIC0g5Zu+5bGC44CCXG4gKiBAcGFyYW0ge0xvbkxhdH0gbG9ubGF0IC0g57uP57qs5bqm44CCXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIOaVsOaNruWvueixoeOAglxuICogQHVzYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWF0dXJlIHtcblxuXG4gICAgY29uc3RydWN0b3IobGF5ZXIsIGxvbmxhdCwgZGF0YSkge1xuICAgICAgICB0aGlzLkNMQVNTX05BTUUgPSBcIlN1cGVyTWFwLkZlYXR1cmVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEBtZW1iZXIge1N1cGVyTWFwLkxheWVyfSBGZWF0dXJlLnByb3RvdHlwZS5sYXllclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5Zu+5bGC44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gRmVhdHVyZS5wcm90b3R5cGUuaWRcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOimgee0oCBJROOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IFV0aWwuY3JlYXRlVW5pcXVlSUQodGhpcy5DTEFTU19OQU1FICsgXCJfXCIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtMb25MYXR9IEZlYXR1cmUucHJvdG90eXBlLmxvbmxhdFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g57uP57qs5bqm44CCXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvbmxhdCA9IGxvbmxhdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBGZWF0dXJlLnByb3RvdHlwZS5kYXRhXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDmlbDmja7lr7nosaHjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IChkYXRhICE9IG51bGwpID8gZGF0YSA6IHt9O1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEZlYXR1cmUucHJvdG90eXBlLmRlc3Ryb3lcbiAgICAgKiBAZGVzY3JpcHRpb24g6YeK5pS+55u45YWz6LWE5rqQ44CCXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgIHRoaXMubG9ubGF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB9XG59XG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG5pbXBvcnQge0ZlYXR1cmV9IGZyb20gJy4vRmVhdHVyZSc7XG5pbXBvcnQge1V0aWx9IGZyb20gJy4vVXRpbCc7XG5cbi8qKlxuICogQGNsYXNzIEZlYXR1cmVWZWN0b3JcbiAqIEBhbGlhc2NsYXNzIEZlYXR1cmUuVmVjdG9yXG4gKiBAZGVwcmVjYXRlZGNsYXNzIFN1cGVyTWFwLkZlYXR1cmUuVmVjdG9yXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIEdlb21ldHJ5XG4gKiBAY2xhc3NkZXNjIOefoumHj+imgee0oOexu+OAguivpeexu+WFt+aciSBHZW9tZXRyeSDlsZ7mgKflrZjmlL7lh6DkvZXkv6Hmga/vvIxcbiAqIGF0dHJpYnV0ZXMg5bGe5oCn5a2Y5pS+6Z2e5Yeg5L2V5L+h5oGv77yM5Y+m5aSW6L+Y5YyF5ZCr5LqGIHN0eWxlIOWxnuaAp++8jOeUqOadpeWumuS5ieefoumHj+imgee0oOeahOagt+W8j++8jFxuICog5YW25Lit77yM6buY6K6k55qE5qC35byP5ZyoIHtAbGluayBGZWF0dXJlVmVjdG9yLnN0eWxlfSDnsbvkuK3lrprkuYnvvIzlpoLmnpzmsqHmnInnibnliKvnmoTmjIflrprlsIbkvb/nlKjpu5jorqTnmoTmoLflvI/jgIJcbiAqIEBleHRlbmRzIHtGZWF0dXJlfVxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgLSDopoHntKDnmoTlh6DkvZXkv6Hmga/jgIJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gLSDmj4/ov7DopoHntKDnmoTku7vmhI/nmoTlj6/luo/liJfljJblsZ7mgKfvvIzlsIbopoHmmKDlsITliLAgYXR0cmlidXRlcyDlsZ7mgKfkuK3nmoTlr7nosaHjgIJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVdIC0g5qC35byP5a+56LGh44CCXG4gKiBAZXhhbXBsZVxuICogdmFyIGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5UG9pbnQoLTExNSwxMCk7XG4gKiAgdmFyIHN0eWxlID0ge1xuICAgICAqICAgICAgc3Ryb2tlQ29sb3I6XCIjMzM5OTMzXCIsXG4gICAgICogICAgICBzdHJva2VPcGFjaXR5OjEsXG4gICAgICogICAgICBzdHJva2VXaWR0aDozLFxuICAgICAqICAgICAgcG9pbnRSYWRpdXM6NlxuICAgICAqICB9XG4gKiAgdmFyIHBvaW50RmVhdHVyZSA9IG5ldyBGZWF0dXJlVmVjdG9yKGdlb21ldHJ5LG51bGwsc3R5bGUpO1xuICogIHZlY3RvckxheWVyLmFkZEZlYXR1cmVzKHBvaW50RmVhdHVyZSk7XG4gKiBAdXNhZ2VcbiAqL1xuLy8gVFJBU0ggVEhJU1xuZXhwb3J0IGNvbnN0IFN0YXRlID0ge1xuICAvKiogc3RhdGVzICovXG4gIFVOS05PV046ICdVbmtub3duJyxcbiAgSU5TRVJUOiAnSW5zZXJ0JyxcbiAgVVBEQVRFOiAnVXBkYXRlJyxcbiAgREVMRVRFOiAnRGVsZXRlJ1xufTtcbmV4cG9ydCBjbGFzcyBWZWN0b3IgZXh0ZW5kcyBGZWF0dXJlIHtcblxuXG4gICAgY29uc3RydWN0b3IoZ2VvbWV0cnksIGF0dHJpYnV0ZXMsIHN0eWxlKSB7XG4gICAgICAgIHN1cGVyKG51bGwsIG51bGwsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBGZWF0dXJlVmVjdG9yLnByb3RvdHlwZS5maWRcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIGZpZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtHZW9tZXRyeX0gRmVhdHVyZVZlY3Rvci5wcm90b3R5cGUuZ2VvbWV0cnlcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOWtmOaUvuWHoOS9leS/oeaBr+OAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkgOiBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEZlYXR1cmVWZWN0b3IucHJvdG90eXBlLmF0dHJpYnV0ZXNcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOaPj+i/sOimgee0oOeahOS7u+aEj+eahOWPr+W6j+WIl+WMluWxnuaAp+OAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFV0aWwuZXh0ZW5kKHRoaXMuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm91bmRzfSBGZWF0dXJlVmVjdG9yLnByb3RvdHlwZS5ib3VuZHNcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOmZkOWItuimgee0oOWHoOS9leeahOi+ueeVjOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IEZlYXR1cmVWZWN0b3IucHJvdG90eXBlLnN0YXRlXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBzdGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gRmVhdHVyZVZlY3Rvci5wcm90b3R5cGUuc3R5bGVcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOimgee0oOeahOagt+W8j+WxnuaAp++8jOWcsOWbvuafpeivoui/lOWbnueahCBmZWF0dXJlIOeahCBzdHlsZe+8jDhDIOWPmOS4um51bGzjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZSA/IHN0eWxlIDogbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBGZWF0dXJlVmVjdG9yLnByb3RvdHlwZS51cmxcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOWmguaenOiuvue9ruS6hui/meS4quWxnuaAp++8jOWcqOabtOaWsOaIluiAheWIoOmZpOimgee0oOaXtumcgOimgeiAg+iZkSB7QGxpbmsgSFRUUH0g44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVybCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5sb25sYXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuQ0xBU1NfTkFNRSA9IFwiU3VwZXJNYXAuRmVhdHVyZS5WZWN0b3JcIjtcblxuICAgICAgICBWZWN0b3Iuc3R5bGUgPSB7XG4gICAgICAgICAgICAnZGVmYXVsdCc6IHtcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IFwiI2VlOTkwMFwiLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjQsXG4gICAgICAgICAgICAgICAgaG92ZXJGaWxsQ29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICBob3ZlckZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwiI2VlOTkwMFwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgICAgIGhvdmVyU3Ryb2tlQ29sb3I6IFwicmVkXCIsXG4gICAgICAgICAgICAgICAgaG92ZXJTdHJva2VPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGhvdmVyU3Ryb2tlV2lkdGg6IDAuMixcbiAgICAgICAgICAgICAgICBwb2ludFJhZGl1czogNixcbiAgICAgICAgICAgICAgICBob3ZlclBvaW50UmFkaXVzOiAxLFxuICAgICAgICAgICAgICAgIGhvdmVyUG9pbnRVbml0OiBcIiVcIixcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcInZpc2libGVQYWludGVkXCIsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcImluaGVyaXRcIixcbiAgICAgICAgICAgICAgICBmb250Q29sb3I6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIGxhYmVsQWxpZ246IFwiY21cIixcbiAgICAgICAgICAgICAgICBsYWJlbE91dGxpbmVDb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIGxhYmVsT3V0bGluZVdpZHRoOiAzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3NlbGVjdCc6IHtcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IFwiYmx1ZVwiLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjQsXG4gICAgICAgICAgICAgICAgaG92ZXJGaWxsQ29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICBob3ZlckZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwiYmx1ZVwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgICAgIGhvdmVyU3Ryb2tlQ29sb3I6IFwicmVkXCIsXG4gICAgICAgICAgICAgICAgaG92ZXJTdHJva2VPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGhvdmVyU3Ryb2tlV2lkdGg6IDAuMixcbiAgICAgICAgICAgICAgICBwb2ludFJhZGl1czogNixcbiAgICAgICAgICAgICAgICBob3ZlclBvaW50UmFkaXVzOiAxLFxuICAgICAgICAgICAgICAgIGhvdmVyUG9pbnRVbml0OiBcIiVcIixcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcInZpc2libGVQYWludGVkXCIsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICBmb250Q29sb3I6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIGxhYmVsQWxpZ246IFwiY21cIixcbiAgICAgICAgICAgICAgICBsYWJlbE91dGxpbmVDb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIGxhYmVsT3V0bGluZVdpZHRoOiAzXG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndGVtcG9yYXJ5Jzoge1xuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogXCIjNjZjY2NjXCIsXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMixcbiAgICAgICAgICAgICAgICBob3ZlckZpbGxDb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIGhvdmVyRmlsbE9wYWNpdHk6IDAuOCxcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogXCIjNjZjY2NjXCIsXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaHN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgICAgICAgICAgaG92ZXJTdHJva2VDb2xvcjogXCJyZWRcIixcbiAgICAgICAgICAgICAgICBob3ZlclN0cm9rZU9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgaG92ZXJTdHJva2VXaWR0aDogMC4yLFxuICAgICAgICAgICAgICAgIHBvaW50UmFkaXVzOiA2LFxuICAgICAgICAgICAgICAgIGhvdmVyUG9pbnRSYWRpdXM6IDEsXG4gICAgICAgICAgICAgICAgaG92ZXJQb2ludFVuaXQ6IFwiJVwiLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwidmlzaWJsZVBhaW50ZWRcIixcbiAgICAgICAgICAgICAgICAvL2N1cnNvcjpcImluaGVyaXRcIixcbiAgICAgICAgICAgICAgICBjdXJzb3I6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgbGFiZWxBbGlnbjogXCJjbVwiLFxuICAgICAgICAgICAgICAgIGxhYmVsT3V0bGluZUNvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgbGFiZWxPdXRsaW5lV2lkdGg6IDNcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZWxldGUnOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRmVhdHVyZVZlY3Rvci5wcm90b3R5cGUuZGVzdHJveVxuICAgICAqIEBkZXNjcmlwdGlvbiDph4rmlL7otYTmupDvvIzlsIblvJXnlKjotYTmupDnmoTlsZ7mgKfnva7nqbrjgIJcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5sYXllcikge1xuICAgICAgICAgICAgdGhpcy5sYXllci5yZW1vdmVGZWF0dXJlcyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubGF5ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRmVhdHVyZVZlY3Rvci5wcm90b3R5cGUuY2xvbmVcbiAgICAgKiBAZGVzY3JpcHRpb24g5aSN5Yi255+i6YeP6KaB57Sg77yM5bm26L+U5Zue5aSN5Yi25ZCO55qE5paw5a+56LGh44CCXG4gICAgICogQHJldHVybnMge0ZlYXR1cmVWZWN0b3J9IOebuOWQjOimgee0oOeahOaWsOeahOefoumHj+imgee0oOOAglxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkgPyB0aGlzLmdlb21ldHJ5LmNsb25lKCkgOiBudWxsLFxuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgdGhpcy5zdHlsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEZlYXR1cmVWZWN0b3IucHJvdG90eXBlLnRvU3RhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24g6K6+572u5paw54q25oCB44CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlIC0g54q25oCB44CCXG4gICAgICovXG4gICAgdG9TdGF0ZShzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09IFN0YXRlLlVQREFURSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5VTktOT1dOOlxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuREVMRVRFOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuVVBEQVRFOlxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSU5TRVJUOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gU3RhdGUuSU5TRVJUKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLlVOS05PV046XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFN0YXRlLkRFTEVURSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JTlNFUlQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmZWF0dXJlIHNob3VsZCBiZSBkZXN0cm95ZWRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5ERUxFVEU6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuVU5LTk9XTjpcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLlVQREFURTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gU3RhdGUuVU5LTk9XTikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRmVhdHVyZVZlY3Rvci5zdHlsZVxuICogQGRlc2NyaXB0aW9uIEZlYXR1cmUg5pyJ5aSn6YeP55qE5qC35byP5bGe5oCn77yM5aaC5p6c5rKh5pyJ54m55Yir55qE5oyH5a6a5bCG5L2/55So6buY6K6k55qE5qC35byP77yMXG4gKiDlpKfpg6jliIbmoLflvI/pgJrov4cgU1ZHIOagh+WHhuWumuS5ieWxnuaAp+OAglxuICogLSBmaWxsIHByb3BlcnRpZXMg6LWE5paZ5LuL57uN77yae0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYWludGluZy5odG1sI0ZpbGxQcm9wZXJ0aWVzfVxuICogLSBzdHJva2UgcHJvcGVydGllcyDotYTmlpnku4vnu43vvJp7QGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhaW50aW5nLmh0bWwjU3Ryb2tlUHJvcGVydGllc31cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZpbGxdIC0g5LiN6ZyA6KaB5aGr5YWF5YiZ6K6+572u5Li6IGZhbHNl44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpbGxDb2xvcj0nI2VlOTkwMCddIC0g5Y2B5YWt6L+b5Yi25aGr5YWF6aKc6Imy44CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZpbGxPcGFjaXR5PTAuNF0gLSDloavlhYXkuI3pgI/mmI7luqbjgIJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N0cm9rZV0gLSDkuI3pnIDopoHmj4/ovrnliJnorr7kuLogZmFsc2XjgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3Ryb2tlQ29sb3I9JyNlZTk5MDAnXSAtIOWNgeWFrei/m+WItuaPj+i+ueminOiJsuOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdHJva2VPcGFjaXR5PTAuNF0gLSDmj4/ovrnnmoTkuI3pgI/mmI7luqYoMC0xKeOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdHJva2VXaWR0aD0xXSAtIOWDj+e0oOaPj+i+ueWuveW6puOAglxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdHJva2VMaW5lY2FwPSdyb3VuZCddIC0gc3Ryb2tlTGluZWNhcCDmnInkuInnp43nsbvlnosgYnV0dO+8jHJvdW5k77yMc3F1YXJl44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3N0cm9rZURhc2hzdHlsZT0nc29saWQnXSAtIOaciSBkb3TvvIxkYXNo77yMZGFzaGRvdO+8jGxvbmdkYXNo77yMbG9uZ2Rhc2hkb3TvvIxzb2xpZCDlh6Dnp43moLflvI/jgIJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyYXBoaWNdIC0g5LiN6ZyA6KaB5YiZ6K6+572u5Li6IGZhbHNl44CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BvaW50UmFkaXVzPTZdIC0g5YOP57Sg54K55Y2K5b6E44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BvaW50ZXJFdmVudHM9J3Zpc2libGVQYWludGVkJ10gLSBwb2ludGVyRXZlbnRz44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2N1cnNvcl0gLSBjdXJzb3LjgIJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsbG93Um90YXRlPSdmYWxzZSddIC0g5piv5ZCm5YWB6K645Zu+5qCH6ZqP552A6L+Q6KGM5pa55ZCR5peL6L2s44CC55So5LqO5pe256m65pWw5o2u5Zu+5bGC44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2V4dGVybmFsR3JhcGhpY10gLSDov57mjqXliLDnlKjmnaXmuLLmn5PngrnnmoTlpJbpg6jnmoTlm77lvaLjgIJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZ3JhcGhpY1dpZHRoXSAtIOWklumDqOWbvuihqOeahOWDj+e0oOWuveW6puOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtncmFwaGljSGVpZ2h0XSAtIOWklumDqOWbvuihqOeahOmrmOWuveW6puOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtncmFwaGljT3BhY2l0eV0gLSDlpJbpg6jlm77ooajnmoTkuI3pgI/mmI7luqYoMC0xKeOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtncmFwaGljWE9mZnNldF0gLSDlpJbpg6jlm77ooajmsr/nnYB45pa55ZCR55qE5YGP56e76YeP44CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2dyYXBoaWNZT2Zmc2V0XSAtIOWklumDqOWbvuihqOayv+edgHnmlrnlkJHnmoTlgY/np7vph48gUGl4ZWzjgIJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb25dIC0g5LiA5Liq5Zu+6KGo5rK/552A5YW25Lit5b+D54K577yI5oiW6ICF5YGP56e75Lit5b+D5oyH5a6a54K577yJ5Zyo6aG65pe26ZKI5pa55ZCR5peL6L2s44CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2dyYXBoaWNaSW5kZXhdIC0g5riy5p+T5pe25L2/55So55qE57Si5byV5YC844CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dyYXBoaWNOYW1lPSdjaXJjbGUnXSAtIOa4suafk+eCueaXtuWbvuagh+S9v+eUqOeahOWQjeWtl+OAguaUr+aMgVwiY2lyY2xlXCIgLCBcInNxdWFyZVwiLCBcInN0YXJcIiwgXCJ4XCIsIFwiY3Jvc3NcIiwgXCJ0cmlhbmdsZVwi44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dyYXBoaWNUaXRsZV0gLSDlpJbpg6jlm77ooajnmoTmj5DnpLrmoYbjgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYmFja2dyb3VuZEdyYXBoaWNdIC0g5aSW6YOo5Zu+6KGo55qE6IOM5pmv44CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2JhY2tncm91bmRHcmFwaGljWkluZGV4XSAtIOiDjOaZr+Wbvua4suafk+aXtuS9v+eUqOeahOe0ouW8leWAvOOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYWNrZ3JvdW5kWE9mZnNldF0gLSDog4zmma/lm77lnKggeCDovbTnmoTlgY/np7vph4/jgIJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFja2dyb3VuZFlPZmZzZXRdIC0g6IOM5pmv5Zu+5ZyoIHkg6L2055qE5YGP56e76YeP44CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2JhY2tncm91bmRIZWlnaHRdIC0g6IOM5pmv5Zu+55qE6auY5bqm44CC5aaC5p6c5rKh5pyJ6K6+572u77yM5bCG55SoIGdyYXBoaWNIZWlnaHTjgIJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFja2dyb3VuZFdpZHRoXSAtIOiDjOaZr+WbvueahOWuveW6puOAguWmguaenOayoeacieiuvue9ru+8jOWwhueUqCBncmFwaGljV2lkdGjjgIJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lzVW5pY29kZT1mYWxzZV0gLSDov5nkuKrlsZ7mgKfopoHphY3lkIggbGFiZWwg5bGe5oCn5p2l55So77yM5b2T5Li6IHRydWXml7bvvIxsYWJlbCDlsLHlj6/ku6Xkvb/nlKggdW5pY29kZSDnvJbnoIHvvIxcbiAqIOavlOWmgiBcImFcIiDnmoQgdW5pY29kZSDljYHlha3ov5vliLbnvJbnoIHkuLogNjHvvIzliJkgbGFiZWwg5bGe5oCn5Y+v5Lul5Li6IFwiJiN4NjE7XCIs5YW25LitIFwiJiNcIiDkuLrliY3nvIDvvIzmoIflv5fov5nkuKrkuLogdW5pY29kZSDnvJbnoIHvvIxcbiAqIFwieFwiIOaYr+aMhyAxNiDov5vliLYs6L+Z5pe26aG16Z2i5pi+56S655qE5pivIFwiYVwi77yb5b2T5q2k5YC85Li6IGZhbHNlIOeahOaXtuWAme+8jGxhYmVsIOeahOWGheWuueS8muiiq+ebtOaOpei+k+WHuu+8jFxuICog5q+U5aaC77yMbGFiZWwg5Li6IFwiJiN4NjE7XCLvvIzov5nml7bpobXpnaLmmL7npLrnmoTkuZ/mmK8gXCImI3g2MTtcIuOAglxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbF0gLSDlj6/pgInnmoTmoIfnrb7mlofmnKzjgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFiZWxBbGlnbj0nY20nXSAtIOagh+etvuWvuem9kO+8jOaYr+eUseS4pOS4quWtl+espue7hOaIkOeahOWtl+espuS4su+8jOWmgu+8mlwibHRcIiwgXCJjbVwiLCBcInJiXCLvvIxcbiAqIOWFtuS4reesrOS4gOS4quWtl+espuS7o+ihqOawtOW5s+aWueWQkeS4iueahOWvuem9kO+8jFwibFwiPWxlZnQsIFwiY1wiPWNlbnRlciwgXCJyXCI9cmlnaHTvvJtcbiAqIOesrOS6jOS4quWtl+espuS7o+ihqOWeguebtOaWueWQkeS4iueahOWvuem9kO+8jFwidFwiPXRvcCwgXCJtXCI9bWlkZGxlLCBcImJcIj1ib3R0b23jgIJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGFiZWxYT2Zmc2V0XSAtIOagh+etvuWcqCB4IOi9tOaWueWQkeeahOWBj+enu+mHj+OAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsYWJlbFlPZmZzZXRdIC0g5qCH562+5ZyoIHkg6L205pa55ZCR55qE5YGP56e76YeP44CCXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsYWJlbFNlbGVjdD1mYWxzZV0gLSDlpoLmnpzorr7kuLogdHJ1Ze+8jOagh+etvuWPr+S7pemAieeUqCBTZWxlY3RGZWF0dXJlIOaIluiAhSBzaW1pbGFyIOaOp+S7tuOAglxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtmb250Q29sb3I9JyMwMDAwMDAnXSAtIOagh+etvuWtl+S9k+minOiJsuOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmb250T3BhY2l0eV0gLSDmoIfnrb7pgI/mmI7luqYgKDAtMSnjgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZm9udEZhbWlseV0gLSDmoIfnrb7nmoTlrZfkvZPnsbvlnovjgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZm9udFNpemVdIC0g5qCH562+55qE5a2X5L2T5aSn5bCP44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZvbnRTdHlsZV0gLSDmoIfnrb7nmoTlrZfkvZPmoLflvI/jgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZm9udFdlaWdodF0gLSDmoIfnrb7nmoTlrZfkvZPnspfnu4bjgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZGlzcGxheV0gLSDlpoLmnpwgZGlzcGxheSDlsZ7mgKforr7nva7kuLog4oCcbm9uZeKAne+8jOespuWPt+WwhuayoeacieS7u+S9leaViOaenOOAglxuICogQGV4YW1wbGVcbiAqICAvLyBsYWJlbOeahOeUqOazleWmguS4i++8mlxuICogIGZ1bmN0aW9uIGFkZEdlb1Rlc3QoKXtcbiAqICB2YXIgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnlQb2ludCgxMDUsIDM1KTtcbiAqICB2YXIgcG9pbnRGZWF0dXJlID0gbmV3IEZlYXR1cmVWZWN0b3IoZ2VvbWV0cnkpO1xuICogIHZhciBzdHlsZVRlc3QgPSB7XG4gKiAgICAgICAgbGFiZWw6XCJzdXBlcm1hcFwiLFxuICogICAgICAgIGZvbnRDb2xvcjpcIiMwMDAwZmZcIixcbiAqICAgICAgICBmb250T3BhY2l0eTpcIjAuNVwiLFxuICogICAgICAgIGZvbnRGYW1pbHk6XCLpmrbkuaZcIixcbiAqICAgICAgICBmb250U2l6ZTpcIjhlbVwiLFxuICogICAgICAgIGZvbnRXZWlnaHQ6XCJib2xkXCIsXG4gKiAgICAgICAgZm9udFN0eWxlOlwiaXRhbGljXCIsXG4gKiAgICAgICAgbGFiZWxTZWxlY3Q6XCJ0cnVlXCIsXG4gKiAgICAgfVxuICogICAgICAgICAgIHBvaW50RmVhdHVyZS5zdHlsZSA9IHN0eWxlVGVzdDtcbiAqICAgICAgICAgIHZlY3RvckxheWVyLmFkZEZlYXR1cmVzKFtwb2ludEZlYXR1cmVdKTtcbiAqIH1cbiAgICAgKi9cblxuXG4iLCIvKiBDb3B5cmlnaHTCqSAyMDAwIC0gMjAyMiBTdXBlck1hcCBTb2Z0d2FyZSBDby5MdGQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgaXMgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5odG1sLiovXG5pbXBvcnQge1V0aWx9IGZyb20gJy4uL2NvbW1vbnR5cGVzL1V0aWwnO1xuXG4vKipcbiAqIEBjbGFzcyBGb3JtYXRcbiAqIEBkZXByZWNhdGVkY2xhc3MgU3VwZXJNYXAuRm9ybWF0XG4gKiBAY2xhc3NkZXNjIOivu+WGmeWQhOenjeagvOW8j+eahOagvOW8j+exu+Wfuuexu+OAguWFtuWtkOexu+W6lOivpeWMheWQq+W5tuWunueOsCByZWFkIOWSjCB3cml0ZSDmlrnms5XjgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgRm9ybWF0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIOWPr+mAieWPguaVsOOAglxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5rZWVwRGF0YT1mYWxzZV0gLSDlpoLmnpzorr7nva7kuLogdHJ1Ze+8jCBkYXRhIOWxnuaAp+S8muaMh+WQkeiiq+ino+aekOeahOWvueixoe+8iOS+i+WmgiBKU09OIOaIliB4bWwg5pWw5o2u5a+56LGh77yJ44CCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZGF0YV0gLSDlvZMga2VlcERhdGEg5bGe5oCn6K6+572u5Li6IHRydWXvvIzov5nmmK/kvKDpgJLnu5kgcmVhZCDmk43kvZznmoTopoHooqvop6PmnpDnmoTlrZfnrKbkuLLjgIJcbiAqIEB1c2FnZVxuICovXG5leHBvcnQgY2xhc3MgRm9ybWF0IHtcblxuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBGb3JtYXQucHJvdG90eXBlLmRhdGFcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOW9kyBrZWVwRGF0YSDlsZ7mgKforr7nva7kuLogdHJ1Ze+8jOi/meaYr+S8oOmAkue7mSByZWFkIOaTjeS9nOeahOimgeiiq+ino+aekOeahOWtl+espuS4suOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBbRm9ybWF0LnByb3RvdHlwZS5rZWVwRGF0YT1mYWxzZV1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOS/neaMgeacgOi/keivu+WIsOeahOaVsOaNrueahOW8leeUqO+8iOmAmui/hyBkYXRhIOWxnuaAp++8ieOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwRGF0YSA9IGZhbHNlO1xuXG4gICAgICAgIFV0aWwuZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIHRoaXMuQ0xBU1NfTkFNRSA9IFwiU3VwZXJNYXAuRm9ybWF0XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEZvcm1hdC5wcm90b3R5cGUuZGVzdHJveVxuICAgICAqIEBkZXNjcmlwdGlvbiDplIDmr4Hor6XmoLzlvI/nsbvvvIzph4rmlL7nm7jlhbPotYTmupDjgIJcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvL+eUqOadpemUgOavgeivpeagvOW8j+exu++8jOmHiuaUvuebuOWFs+i1hOa6kFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBGb3JtYXQucHJvdG90eXBlLnJlYWRcbiAgICAgKiBAZGVzY3JpcHRpb24g5p2l5LuO5a2X56ym5Liy5Lit6K+75Y+W5pWw5o2u44CCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSDor7vlj5bnmoTmlbDmja7jgIJcbiAgICAgKi9cbiAgICByZWFkKGRhdGEpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAvL+eUqOadpeS7juWtl+espuS4suS4reivu+WPluaVsOaNrlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBGb3JtYXQucHJvdG90eXBlLndyaXRlXG4gICAgICogQGRlc2NyaXB0aW9uIOWwhuWvueixoeWGmeaIkOWtl+espuS4suOAglxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSDlj6/luo/liJfljJbnmoTlr7nosaHjgIJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSDlr7nosaHovazljJblkI7nmoTlrZfnrKbkuLLjgIJcbiAgICAgKi9cbiAgICB3cml0ZShvYmplY3QpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAvL+eUqOadpeWGmeWtl+espuS4slxuICAgIH1cbn1cbiIsIi8qIENvcHlyaWdodMKpIDIwMDAgLSAyMDIyIFN1cGVyTWFwIFNvZnR3YXJlIENvLkx0ZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgcHJvZ3JhbSBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cbmltcG9ydCB7XG4gICAgRm9ybWF0XG59IGZyb20gJy4vRm9ybWF0JztcblxuLyoqXG4gKiBAY2xhc3MgSlNPTkZvcm1hdFxuICogQGFsaWFzY2xhc3MgRm9ybWF0LkpTT05cbiAqIEBkZXByZWNhdGVkY2xhc3MgU3VwZXJNYXAuRm9ybWF0LkpTT05cbiAqIEBjbGFzc2Rlc2Mg5a6J5YWo55qE6K+75YaZIEpTT04g55qE6Kej5p6Q57G744CC5L2/55SoIHtAbGluayBKU09ORm9ybWF0fSDmnoTpgKDlh73mlbDliJvlu7rmlrDlrp7kvovjgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgRm9ybWF0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0g5Y+v6YCJ5Y+C5pWw44CCXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5kZW50PVwiICAgIFwiXSAtIOeUqOS6juagvOW8j+WMlui+k+WHuu+8jGluZGVudCDlrZfnrKbkuLLkvJrlnKjmr4/mrKHnvKnov5vnmoTml7blgJnkvb/nlKjkuIDmrKHjgIJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcGFjZT1cIiBcIl0gLSDnlKjkuo7moLzlvI/ljJbovpPlh7rvvIxzcGFjZSDlrZfnrKbkuLLkvJrlnKjlkI3lgLzlr7nnmoQgXCI6XCIg5ZCO6L655re75Yqg44CCXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmV3bGluZT1cIlxcblwiXSAtIOeUqOS6juagvOW8j+WMlui+k+WHuiwgbmV3bGluZSDlrZfnrKbkuLLkvJrnlKjlnKjmr4/kuIDkuKrlkI3lgLzlr7nmiJbmlbDnu4TpobnmnKvlsL7jgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZXZlbD0wXSAtIOeUqOS6juagvOW8j+WMlui+k+WHuiwg6KGo56S655qE5piv57yp6L+b57qn5Yir44CCXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXR0eT1mYWxzZV0gLSDmmK/lkKblnKjluo/liJfljJbnmoTml7blgJnkvb/nlKjpop3lpJbnmoTnqbrmoLzmjqfliLbnu5PmnoTjgILlnKggd3JpdGUg5pa55rOV5Lit5L2/55So44CCXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm5hdGl2ZUpTT05dIC0g6ZyA6KaB6KKr5rOo5YaM55qE55uR5ZCs5Zmo5a+56LGh44CCXG4gKiBAZXh0ZW5kcyB7Rm9ybWF0fVxuICogQHVzYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBKU09ORm9ybWF0IGV4dGVuZHMgRm9ybWF0IHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IFtKU09ORm9ybWF0LnByb3RvdHlwZS5pbmRlbnQ9XCIgICAgXCJdXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDnlKjkuo7moLzlvI/ljJbovpPlh7rvvIxpbmRlbnQg5a2X56ym5Liy5Lya5Zyo5q+P5qyh57yp6L+b55qE5pe25YCZ5L2/55So5LiA5qyh44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGVudCA9IFwiICAgIFwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IFtKU09ORm9ybWF0LnByb3RvdHlwZS5zcGFjZT1cIiBcIl1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOeUqOS6juagvOW8j+WMlui+k+WHuu+8jHNwYWNlIOWtl+espuS4suS8muWcqOWQjeWAvOWvueeahCBcIjpcIiDlkI7ovrnmt7vliqDjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3BhY2UgPSBcIiBcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBbSlNPTkZvcm1hdC5wcm90b3R5cGUubmV3bGluZT1cIlxcblwiXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g55So5LqO5qC85byP5YyW6L6T5Ye6LCBuZXdsaW5lIOWtl+espuS4suS8mueUqOWcqOavj+S4gOS4quWQjeWAvOWvueaIluaVsOe7hOmhueacq+WwvuOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXdsaW5lID0gXCJcXG5cIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBbSlNPTkZvcm1hdC5wcm90b3R5cGUubGV2ZWw9MF1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOeUqOS6juagvOW8j+WMlui+k+WHuiwg6KGo56S655qE5piv57yp6L+b57qn5Yir44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxldmVsID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gW0pTT05Gb3JtYXQucHJvdG90eXBlLnByZXR0eT1mYWxzZV1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOaYr+WQpuWcqOW6j+WIl+WMlueahOaXtuWAmeS9v+eUqOmineWklueahOepuuagvOaOp+WItue7k+aehOOAguWcqCB3cml0ZSDmlrnms5XkuK3kvb/nlKjjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldHR5ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IEpTT05Gb3JtYXQucHJvdG90eXBlLm5hdGl2ZUpTT05cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOWIpOaWrea1j+iniOWZqOaYr+WQpuWOn+eUn+aUr+aMgSBKU09OIOagvOW8j+aVsOaNruOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYXRpdmVKU09OID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhISh3aW5kb3cuSlNPTiAmJiB0eXBlb2YgSlNPTi5wYXJzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBKU09OLnN0cmluZ2lmeSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICB0aGlzLkNMQVNTX05BTUUgPSBcIlN1cGVyTWFwLkZvcm1hdC5KU09OXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIEpTT05Gb3JtYXQucHJvdG90eXBlLnNlcmlhbGl6ZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5o+Q5L6b5LiA5Lqb57G75Z6L5a+56LGh6L2sIEpTT04g5a2X56ym5Liy55qE5pa55rOV44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEpTT05Gb3JtYXQuc2VyaWFsaXplLm9iamVjdFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOaKiuWvueixoei9rOaNouS4uiBKU09OIOWtl+espuS4suOAglxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIOWPr+W6j+WIl+WMlueahOWvueixoeOAglxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gSlNPTiDlrZfnrKbkuLLjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ29iamVjdCc6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJlZSBzcGVjaWFsIG9iamVjdHMgdGhhdCB3ZSB3YW50IHRvIHRyZWF0IGRpZmZlcmVudGx5XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUuZGF0ZS5hcHBseSh0aGlzLCBbb2JqZWN0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZS5hcnJheS5hcHBseSh0aGlzLCBbb2JqZWN0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwaWVjZXMgPSBbJ3snXTtcbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsICs9IDE7XG4gICAgICAgICAgICAgICAgdmFyIGtleSwga2V5SlNPTiwgdmFsdWVKU09OO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFkZENvbW1hID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlIGNhbGxzIG5lZWQgdG8gYWxsb3cgZm9yIHN1Yi1jbGFzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5SlNPTiA9IHRoaXMud3JpdGUuYXBwbHkodGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBba2V5LCB0aGlzLnByZXR0eV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVKU09OID0gdGhpcy53cml0ZS5hcHBseSh0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvYmplY3Rba2V5XSwgdGhpcy5wcmV0dHldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlKU09OICE9IG51bGwgJiYgdmFsdWVKU09OICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGllY2VzLnB1c2goJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGllY2VzLnB1c2godGhpcy53cml0ZU5ld2xpbmUoKSwgdGhpcy53cml0ZUluZGVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlKU09OLCAnOicsIHRoaXMud3JpdGVTcGFjZSgpLCB2YWx1ZUpTT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1hID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubGV2ZWwgLT0gMTtcbiAgICAgICAgICAgICAgICBwaWVjZXMucHVzaCh0aGlzLndyaXRlTmV3bGluZSgpLCB0aGlzLndyaXRlSW5kZW50KCksICd9Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpZWNlcy5qb2luKCcnKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEpTT05Gb3JtYXQuc2VyaWFsaXplLmFycmF5XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5oqK5pWw57uE6L2s5o2i5oiQIEpTT04g5a2X56ym5Liy44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIOWPr+W6j+WIl+WMlueahOaVsOe7hOOAglxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gSlNPTiDlrZfnrKbkuLLjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2FycmF5JzogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb247XG4gICAgICAgICAgICAgICAgdmFyIHBpZWNlcyA9IFsnWyddO1xuICAgICAgICAgICAgICAgIHRoaXMubGV2ZWwgKz0gMTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmUgY2FsbHMgbmVlZCB0byBhbGxvdyBmb3Igc3ViLWNsYXNzaW5nXG4gICAgICAgICAgICAgICAgICAgIGpzb24gPSB0aGlzLndyaXRlLmFwcGx5KHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXJyYXlbaV0sIHRoaXMucHJldHR5XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaCh0aGlzLndyaXRlTmV3bGluZSgpLCB0aGlzLndyaXRlSW5kZW50KCksIGpzb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbCAtPSAxO1xuICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKHRoaXMud3JpdGVOZXdsaW5lKCksIHRoaXMud3JpdGVJbmRlbnQoKSwgJ10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGllY2VzLmpvaW4oJycpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gSlNPTkZvcm1hdC5zZXJpYWxpemUuc3RyaW5nXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5oqK5a2X56ym5Liy6L2s5o2i5oiQIEpTT04g5a2X56ym5Liy44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0g5Y+v5bqP5YiX5YyW55qE5a2X56ym5Liy44CCXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBKU09OIOWtl+espuS4suOAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc3RyaW5nJzogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgICAgICAgICAgICAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2ltcGx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlXG4gICAgICAgICAgICAgICAgLy8gc2VxdWVuY2VzLlxuICAgICAgICAgICAgICAgIHZhciBtID0ge1xuICAgICAgICAgICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAgICAgICAgICdcIic6ICdcXFxcXCInLFxuICAgICAgICAgICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qZXNsaW50LWRpc2FibGUgbm8tY29udHJvbC1yZWdleCovXG4gICAgICAgICAgICAgICAgaWYgKC9bXCJcXFxcXFx4MDAtXFx4MWZdLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcIicgKyBzdHJpbmcucmVwbGFjZSgvKFtcXHgwMC1cXHgxZlxcXFxcIl0pL2csIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1bYl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGIuY2hhckNvZGVBdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdTAwJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihjIC8gMTYpLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGMgJSAxNikudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgICB9KSArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnXCInICsgc3RyaW5nICsgJ1wiJztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEpTT05Gb3JtYXQuc2VyaWFsaXplLm51bWJlclxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOaKiuaVsOWtl+i9rOaNouaIkCBKU09OIOWtl+espuS4suOAglxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciAtIOWPr+W6j+WIl+WMlueahOaVsOWtl+OAglxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gSlNPTiDlrZfnrKbkuLLjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ251bWJlcic6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUobnVtYmVyKSA/IFN0cmluZyhudW1iZXIpIDogXCJudWxsXCI7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBKU09ORm9ybWF0LnNlcmlhbGl6ZS5ib29sZWFuXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gVHJhbnNmb3JtIGEgYm9vbGVhbiBpbnRvIGEgSlNPTiBzdHJpbmcuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvb2wgLSBUaGUgYm9vbGVhbiB0byBiZSBzZXJpYWxpemVkLlxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gQSBKU09OIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGJvb2xlYW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdib29sZWFuJzogZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKGJvb2wpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gSlNPTkZvcm1hdC5zZXJpYWxpemUub2JqZWN0XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5bCG5pel5pyf5a+56LGh6L2s5o2i5oiQIEpTT04g5a2X56ym5Liy44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgLSDlj6/luo/liJfljJbnmoTml6XmnJ/lr7nosaHjgIJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEpTT04g5a2X56ym5Liy44CCXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdkYXRlJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXQobnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobnVtYmVyIDwgMTApID8gJzAnICsgbnVtYmVyIDogbnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAnXCInICsgZGF0ZS5nZXRGdWxsWWVhcigpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0KGRhdGUuZ2V0TW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0KGRhdGUuZ2V0RGF0ZSgpKSArICdUJyArXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdChkYXRlLmdldEhvdXJzKCkpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0KGRhdGUuZ2V0TWludXRlcygpKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdChkYXRlLmdldFNlY29uZHMoKSkgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBKU09ORm9ybWF0LnByb3RvdHlwZS5yZWFkXG4gICAgICogQGRlc2NyaXB0aW9uIOWwhuS4gOS4quespuWQiCBKU09OIOe7k+aehOeahOWtl+espuS4sui/m+ihjOino+aekOOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqc29uIC0g56ym5ZCIIEpTT04g57uT5p6E55qE5a2X56ym5Liy44CCXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZmlsdGVyIC0g6L+H5ruk5pa55rOV77yM5pyA57uI57uT5p6c55qE5q+P5LiA5Liq6ZSu5YC85a+56YO95Lya6LCD55So6K+l6L+H5ruk5pa55rOV77yM5bm25Zyo5a+55bqU55qE5YC855qE5L2N572u5pu/5o2i5oiQ6K+l5pa55rOV6L+U5Zue55qE5YC844CCXG4gICAgICogQHJldHVybnMgeyhPYmplY3R8c3RyaW5nfEFycmF5fG51bWJlcnxib29sZWFuKX0g5a+56LGh77yM5pWw57uE77yM5a2X56ym5Liy5oiW5pWw5a2X44CCXG4gICAgICovXG4gICAgcmVhZChqc29uLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIG9iamVjdDtcbiAgICAgICAgaWYgKHRoaXMubmF0aXZlSlNPTikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBKU09OLnBhcnNlKGpzb24sIGZpbHRlcik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoIGlmIHRoZSByZWdleHAgdGVzdCBmYWlscy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmtlZXBEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBKU09ORm9ybWF0LnByb3RvdHlwZS53cml0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiDluo/liJfljJbkuIDkuKrlr7nosaHliLDkuIDkuKrnrKblkIggSlNPTiDmoLzlvI/nmoTlrZfnrKbkuLLjgIJcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd8QXJyYXl8bnVtYmVyfGJvb2xlYW59IHZhbHVlIC0g6ZyA6KaB6KKr5bqP5YiX5YyW55qE5a+56LGh77yM5pWw57uE77yM5a2X56ym5Liy77yM5pWw5a2X77yM5biD5bCU5YC844CCXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJldHR5PWZhbHNlXSAtIOaYr+WQpuWcqOW6j+WIl+WMlueahOaXtuWAmeS9v+eUqOmineWklueahOepuuagvOaOp+WItue7k+aehOOAguWcqCB3cml0ZSDmlrnms5XkuK3kvb/nlKjjgIJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSDnrKblkIggSlNPTiDmoLzlvI/nmoTlrZfnrKbkuLLjgIJcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlKHZhbHVlLCBwcmV0dHkpIHtcbiAgICAgICAgdGhpcy5wcmV0dHkgPSAhIXByZXR0eTtcbiAgICAgICAgdmFyIGpzb24gPSBudWxsO1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuc2VyaWFsaXplW3R5cGVdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGpzb24gPSAoIXRoaXMucHJldHR5ICYmIHRoaXMubmF0aXZlSlNPTikgP1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZVt0eXBlXS5hcHBseSh0aGlzLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcihcIlRyb3VibGUgc2VyaWFsaXppbmc6IFwiICsgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSlNPTkZvcm1hdC5wcm90b3R5cGUud3JpdGVJbmRlbnRcbiAgICAgKiBAZGVzY3JpcHRpb24g5qC55o2u57yp6L+b57qn5Yir6L6T5Ye65LiA5Liq57yp6L+b5a2X56ym5Liy44CCXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSDkuIDkuKrpgILlvZPnmoTnvKnov5vlrZfnrKbkuLLjgIJcbiAgICAgKi9cbiAgICB3cml0ZUluZGVudCgpIHtcbiAgICAgICAgdmFyIHBpZWNlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcmV0dHkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZXZlbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcGllY2VzLnB1c2godGhpcy5pbmRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWVjZXMuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEpTT05Gb3JtYXQucHJvdG90eXBlLndyaXRlTmV3bGluZVxuICAgICAqIEBkZXNjcmlwdGlvbiDlnKjmoLzlvI/ljJbovpPlh7rmqKHlvI/mg4XlhrXkuIvovpPlh7rku6PooajmlrDkuIDooYznmoTlrZfnrKbkuLLjgIJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOS7o+ihqOaWsOeahOS4gOihjOeahOWtl+espuS4suOAglxuICAgICAqL1xuICAgIHdyaXRlTmV3bGluZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnByZXR0eSkgPyB0aGlzLm5ld2xpbmUgOiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSlNPTkZvcm1hdC5wcm90b3R5cGUud3JpdGVTcGFjZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIOWcqOagvOW8j+WMlui+k+WHuuaooeW8j+aDheWGteS4i+i+k+WHuuS4gOS4quS7o+ihqOepuuagvOeahOWtl+espuS4suOAglxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOepuuagvOWtl+espuS4suOAglxuICAgICAqL1xuICAgIHdyaXRlU3BhY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wcmV0dHkpID8gdGhpcy5zcGFjZSA6ICcnO1xuICAgIH1cblxufVxuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBwcm9ncmFtIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24gYW5kIGlzIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuaHRtbC4qL1xuaW1wb3J0IHtcbiAgICBWZWN0b3Jcbn0gZnJvbSAnLi4vY29tbW9udHlwZXMvVmVjdG9yJztcbmltcG9ydCB7XG4gICAgVXRpbFxufSBmcm9tICcuLi9jb21tb250eXBlcy9VdGlsJztcbmltcG9ydCB7XG4gICAgQm91bmRzXG59IGZyb20gJy4uL2NvbW1vbnR5cGVzL0JvdW5kcyc7XG5pbXBvcnQge1xuICAgIENvbGxlY3Rpb25cbn0gZnJvbSAnLi4vY29tbW9udHlwZXMvZ2VvbWV0cnkvQ29sbGVjdGlvbic7XG5pbXBvcnQge1xuICAgIEpTT05Gb3JtYXRcbn0gZnJvbSAnLi9KU09OJztcbmltcG9ydCB7XG4gICAgUG9pbnRcbn0gZnJvbSAnLi4vY29tbW9udHlwZXMvZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtcbiAgICBNdWx0aVBvaW50XG59IGZyb20gJy4uL2NvbW1vbnR5cGVzL2dlb21ldHJ5L011bHRpUG9pbnQnO1xuaW1wb3J0IHtcbiAgICBMaW5lU3RyaW5nXG59IGZyb20gJy4uL2NvbW1vbnR5cGVzL2dlb21ldHJ5L0xpbmVTdHJpbmcnO1xuaW1wb3J0IHtcbiAgICBNdWx0aUxpbmVTdHJpbmdcbn0gZnJvbSAnLi4vY29tbW9udHlwZXMvZ2VvbWV0cnkvTXVsdGlMaW5lU3RyaW5nJztcbmltcG9ydCB7XG4gICAgTGluZWFyUmluZ1xufSBmcm9tICcuLi9jb21tb250eXBlcy9nZW9tZXRyeS9MaW5lYXJSaW5nJztcbmltcG9ydCB7XG4gICAgUG9seWdvblxufSBmcm9tICcuLi9jb21tb250eXBlcy9nZW9tZXRyeS9Qb2x5Z29uJztcbmltcG9ydCB7XG4gICAgTXVsdGlQb2x5Z29uXG59IGZyb20gJy4uL2NvbW1vbnR5cGVzL2dlb21ldHJ5L011bHRpUG9seWdvbic7XG5pbXBvcnQge1xuICAgIFNlcnZlckdlb21ldHJ5XG59IGZyb20gJy4uL2lTZXJ2ZXIvU2VydmVyR2VvbWV0cnknO1xuXG4vKipcbiAqIEBjbGFzcyBHZW9KU09ORm9ybWF0XG4gKiBAYWxpYXNjbGFzcyBGb3JtYXQuR2VvSlNPTlxuICogQGRlcHJlY2F0ZWRjbGFzcyBTdXBlck1hcC5Gb3JtYXQuR2VvSlNPTlxuICogQGNsYXNzZGVzYyAgR2VvSlNPTiDnmoTor7vlkozlhpnjgILkvb/nlKgge0BsaW5rIEdlb0pTT05PYmplY3R9IOaehOmAoOWZqOWIm+W7uuS4gOS4qiBHZW9KU09OIOino+aekOWZqOOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBGb3JtYXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSDlj6/pgInlj4LmlbDjgIJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbmRlbnQ9XCIgICAgXCJdIC0g55So5LqO5qC85byP5YyW6L6T5Ye677yMaW5kZW50IOWtl+espuS4suS8muWcqOavj+asoee8qei/m+eahOaXtuWAmeS9v+eUqOS4gOasoeOAglxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNwYWNlPVwiIFwiXSAtIOeUqOS6juagvOW8j+WMlui+k+WHuu+8jHNwYWNlIOWtl+espuS4suS8muWcqOWQjeWAvOWvueeahCBcIjpcIiDlkI7ovrnmt7vliqDjgIJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uZXdsaW5lPVwiXFxuXCJdIC0g55So5LqO5qC85byP5YyW6L6T5Ye6LCBuZXdsaW5lIOWtl+espuS4suS8mueUqOWcqOavj+S4gOS4quWQjeWAvOWvueaIluaVsOe7hOmhueacq+WwvuOAglxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxldmVsPTBdIC0g55So5LqO5qC85byP5YyW6L6T5Ye6LCDooajnpLrnmoTmmK/nvKnov5vnuqfliKvjgIJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJldHR5PWZhbHNlXSAtIOaYr+WQpuWcqOW6j+WIl+WMlueahOaXtuWAmeS9v+eUqOmineWklueahOepuuagvOaOp+WItue7k+aehOOAguWcqCB3cml0ZSDmlrnms5XkuK3kvb/nlKjjgIJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubmF0aXZlSlNPTl0gLSDpnIDopoHooqvms6jlhoznmoTnm5HlkKzlmajlr7nosaHjgIJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlRXh0cmFEaW1zPXRydWVdIC0g5b+955Wl57u05bqm6LaF6L+HIDIg55qE5Yeg5L2V6KaB57Sg44CCXG4gKiBAZXh0ZW5kcyB7SlNPTkZvcm1hdH1cbiAqIEB1c2FnZVxuICovXG5leHBvcnQgY2xhc3MgR2VvSlNPTiBleHRlbmRzIEpTT05Gb3JtYXQge1xuXG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gW0dlb0pTT05Gb3JtYXQucHJvdG90eXBlLmlnbm9yZUV4dHJhRGltcz10cnVlXVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5b+955Wl57u05bqm6LaF6L+HIDIg55qE5Yeg5L2V6KaB57Sg44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlnbm9yZUV4dHJhRGltcyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gXCJTdXBlck1hcC5Gb3JtYXQuR2VvSlNPTlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBHZW9KU09ORm9ybWF0LnByb3RvdHlwZS5wYXJzZUNvb3Jkc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5LiA5Liq5bGe5oCn5ZCN5a+55bqU552AIEdlb0pTT04g5a+56LGh55qE5Yeg5L2V57G75Z6L55qE5a+56LGh44CC5q+P5Liq5bGe5oCn5YW25a6e6YO95piv5LiA5Liq5a6e6ZmF5LiK5YGa6Kej5p6Q55So55qE5pa55rOV44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcnNlQ29vcmRzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5wYXJzZUNvb3Jkcy5wb2ludFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOWwhuS4gOe7hOWdkOagh+i9rOaIkOS4gOS4qiB7QGxpbmsgR2VvbWV0cnl9IOWvueixoeOAglxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFycmF5IC0gR2VvSlNPTiDniYfmrrXkuK3nmoTkuIDnu4TlnZDmoIfjgIJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtHZW9tZXRyeX0g5LiA5Liq5Yeg5L2V5a+56LGh44CCXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwicG9pbnRcIjogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWdub3JlRXh0cmFEaW1zID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICBhcnJheS5sZW5ndGggIT0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIk9ubHkgMkQgcG9pbnRzIGFyZSBzdXBwb3J0ZWQ6IFwiICsgYXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoYXJyYXlbMF0sIGFycmF5WzFdKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEdlb0pTT05Gb3JtYXQucGFyc2VDb29yZHMubXVsdGlwb2ludFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOWwhuWdkOagh+e7hOaVsOe7hOi9rOWMluaIkOS4uuS4gOS4qiB7QGxpbmsgR2VvbWV0cnl9IOWvueixoeOAglxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFycmF5IC0gR2VvSlNPTiDniYfmrrXkuK3nmoTlnZDmoIfnu4TmlbDnu4TjgIJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtHZW9tZXRyeX0g5LiA5Liq5Yeg5L2V5a+56LGh44CCXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwibXVsdGlwb2ludFwiOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMucGFyc2VDb29yZHNbXCJwb2ludFwiXS5hcHBseSh0aGlzLCBbYXJyYXlbaV1dKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlQb2ludChwb2ludHMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5wYXJzZUNvb3Jkcy5saW5lc3RyaW5nXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5bCG5Z2Q5qCH57uE5pWw57uE6L2s5YyW5oiQ5Li65LiA5LiqIHtAbGluayBHZW9tZXRyeX0g5a+56LGh44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyYXkgLSBHZW9KU09OIOeJh+auteS4reeahOWdkOagh+e7hOaVsOe7hOOAglxuICAgICAgICAgICAgICogQHJldHVybnMge0dlb21ldHJ5fSDkuIDkuKrlh6DkvZXlr7nosaHjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJsaW5lc3RyaW5nXCI6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5wYXJzZUNvb3Jkc1tcInBvaW50XCJdLmFwcGx5KHRoaXMsIFthcnJheVtpXV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHBvaW50cyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBHZW9KU09ORm9ybWF0LnBhcnNlQ29vcmRzLm11bHRpbGluZXN0cmluZ1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOWwhuWdkOagh+e7hOaVsOe7hOi9rOWMluaIkOS4uuS4gOS4qiB7QGxpbmsgR2VvbWV0cnl9IOWvueixoeOAglxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFycmF5IC0gR2VvSlNPTiDniYfmrrXkuK3nmoTlnZDmoIfnu4TmlbDnu4TjgIJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtHZW9tZXRyeX0g5LiA5Liq5Yeg5L2V5a+56LGh44CCXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwibXVsdGlsaW5lc3RyaW5nXCI6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB0aGlzLnBhcnNlQ29vcmRzW1wibGluZXN0cmluZ1wiXS5hcHBseSh0aGlzLCBbYXJyYXlbaV1dKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcobGluZXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5wYXJzZUNvb3Jkcy5wb2x5Z29uXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5bCG5Z2Q5qCH57uE5pWw57uE6L2s5YyW5oiQ5Li65LiA5LiqIHtAbGluayBHZW9tZXRyeX0g5a+56LGh44CCXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7R2VvbWV0cnl9IOS4gOS4quWHoOS9leWvueixoeOAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInBvbHlnb25cIjogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJpbmdzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHIsIGw7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gdGhpcy5wYXJzZUNvb3Jkc1tcImxpbmVzdHJpbmdcIl0uYXBwbHkodGhpcywgW2FycmF5W2ldXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHIgPSBuZXcgTGluZWFyUmluZyhsLmNvbXBvbmVudHMpO1xuICAgICAgICAgICAgICAgICAgICByaW5ncy5wdXNoKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24ocmluZ3MpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5wYXJzZUNvb3Jkcy5tdWx0aXBvbHlnb25cbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDlsIblnZDmoIfnu4TmlbDnu4TovazljJbmiJDkuLrkuIDkuKoge0BsaW5rIEdlb21ldHJ5fSDlr7nosaHjgIJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheSAtIEdlb0pTT04g54mH5q615Lit55qE5Z2Q5qCH57uE5pWw57uE44CCXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7R2VvbWV0cnl9IOS4gOS4quWHoOS9leWvueixoeOAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm11bHRpcG9seWdvblwiOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9seXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5wYXJzZUNvb3Jkc1tcInBvbHlnb25cIl0uYXBwbHkodGhpcywgW2FycmF5W2ldXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlQb2x5Z29uKHBvbHlzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEdlb0pTT05Gb3JtYXQucGFyc2VDb29yZHMuYm94XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5bCG5Z2Q5qCH57uE5pWw57uE6L2s5YyW5oiQ5Li65LiA5LiqIHtAbGluayBHZW9tZXRyeX0g5a+56LGh44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEdlb0pTT04g54mH5q615Lit55qE5Z2Q5qCH57uE5pWw57uE44CCXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7R2VvbWV0cnl9IOS4gOS4quWHoOS9leWvueixoeOAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJveFwiOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJHZW9KU09OIGJveCBjb29yZGluYXRlcyBtdXN0IGhhdmUgMiBlbGVtZW50c1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24oW1xuICAgICAgICAgICAgICAgICAgICBuZXcgTGluZWFyUmluZyhbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUG9pbnQoYXJyYXlbMF1bMF0sIGFycmF5WzBdWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQb2ludChhcnJheVsxXVswXSwgYXJyYXlbMF1bMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFBvaW50KGFycmF5WzFdWzBdLCBhcnJheVsxXVsxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUG9pbnQoYXJyYXlbMF1bMF0sIGFycmF5WzFdWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQb2ludChhcnJheVswXVswXSwgYXJyYXlbMF1bMV0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gR2VvSlNPTkZvcm1hdC5wcm90b3R5cGUuZXh0cmFjdFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5LiA5Liq5bGe5oCn5ZCN5a+55bqU552AR2VvSlNPTuexu+Wei+eahOWvueixoeOAguWFtuWAvOS4uuebuOW6lOeahOWunumZheeahOino+aekOaWueazleOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHRyYWN0ID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5leHRyYWN0LmZlYXR1cmVcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDov5Tlm57kuIDkuKrooajnpLrljZXkuKropoHntKDlr7nosaHnmoQgR2VvSlNPTiDnmoTkuIDpg6jliIbjgIJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3VwZXJNYXAuU2VydmVyRmVhdHVyZX0gZmVhdHVyZSAtIGlTZXJ2ZXIg6KaB57Sg5a+56LGh44CCXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSDkuIDkuKrooajnpLrngrnnmoTlr7nosaHjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2ZlYXR1cmUnOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBnZW9tID0gdGhpcy5leHRyYWN0Lmdlb21ldHJ5LmFwcGx5KHRoaXMsIFtmZWF0dXJlLmdlb21ldHJ5XSk7XG4gICAgICAgICAgICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHRoaXMuY3JlYXRlQXR0cmlidXRlcyhmZWF0dXJlKSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW9tZXRyeVwiOiBnZW9tXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5ICYmIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ1RFWFQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb24ucHJvcGVydGllcy50ZXh0cyA9IGZlYXR1cmUuZ2VvbWV0cnkudGV4dHM7XG4gICAgICAgICAgICAgICAgICAgIGpzb24ucHJvcGVydGllcy50ZXh0U3R5bGUgPSBmZWF0dXJlLmdlb21ldHJ5LnRleHRTdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuZmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb24uaWQgPSBmZWF0dXJlLmZpZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuSUQpIHtcbiAgICAgICAgICAgICAgICAgICAganNvbi5pZCA9IGZlYXR1cmUuSUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBHZW9KU09ORm9ybWF0LmV4dHJhY3QuZ2VvbWV0cnlcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDov5Tlm57kuIDkuKrooajnpLrljZXkuKrlh6DkvZXlr7nosaHnmoQgR2VvSlNPTiDnmoTkuIDpg6jliIbjgIJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnZW9tZXRyeSAtIGlTZXJ2ZXIg5Yeg5L2V5a+56LGh44CCXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSDkuIDkuKrooajnpLrlh6DkvZXkvZPnmoTlr7nosaHjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2dlb21ldHJ5JzogZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGdlb21ldHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZ2VvbWV0cnkucGFydHMgJiYgZ2VvbWV0cnkucG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnBhcnRzID0gW2dlb21ldHJ5LnBvaW50cy5sZW5ndGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZ2VvID0gZ2VvbWV0cnkuaGFzT3duUHJvcGVydHkoJ2dlb21ldHJ5VHlwZScpXG4gICAgICAgICAgICAgICAgICAgID8gZ2VvbWV0cnlcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgU2VydmVyR2VvbWV0cnkoZ2VvbWV0cnkpLnRvR2VvbWV0cnkoKSB8fCBnZW9tZXRyeTtcbiAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnlUeXBlID0gZ2VvLmdlb21ldHJ5VHlwZSB8fCBnZW8udHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoZ2VvbWV0cnlUeXBlID09PSBcIkxpbmVhclJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeVR5cGUgPSBcIkxpbmVTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gXCJMSU5FTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5VHlwZSA9IFwiTXVsdGlMaW5lU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmV4dHJhY3RbZ2VvbWV0cnlUeXBlLnRvTG93ZXJDYXNlKCldLmFwcGx5KHRoaXMsIFtnZW9dKTtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeVR5cGUgPSBnZW9tZXRyeVR5cGUgPT09ICdURVhUJyA/ICdQb2ludCcgOiBnZW9tZXRyeVR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIGpzb247XG4gICAgICAgICAgICAgICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gXCJDb2xsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAganNvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW9tZXRyaWVzXCI6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqc29uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IGdlb21ldHJ5VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogZGF0YVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5leHRyYWN0LnBvaW50XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5LuO5LiA5Liq54K55a+56LGh5Lit6L+U5Zue5LiA5Liq5Z2Q5qCH57uE44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0dlb21ldHJ5UG9pbnR9IHBvaW50IC0g5LiA5Liq54K55a+56LGh44CCXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IOS4gOS4quihqOekuuS4gOS4queCueeahOWdkOagh+e7hOOAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAncG9pbnQnOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IFtwb2ludC54LCBwb2ludC55XTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICE9PSBcInhcIiAmJiBuYW1lICE9PSBcInlcIiAmJiBwb2ludFtuYW1lXSAhPT0gbnVsbCAmJiAhaXNOYU4ocG9pbnRbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnB1c2gocG9pbnRbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5leHRyYWN0LnBvaW50XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5LuO5LiA5Liq5paH5pys5a+56LGh5Lit6L+U5Zue5LiA5Liq5Z2Q5qCH57uE44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2VvIC0g5LiA5Liq5paH5pys5a+56LGh44CCXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IOS4gOS4quihqOekuuS4gOS4queCueeahOWdkOagh+e7hOOAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAndGV4dCc6IGZ1bmN0aW9uIChnZW8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2dlby5wb2ludHNbMF0ueCwgZ2VvLnBvaW50c1swXS55XTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEdlb0pTT05Gb3JtYXQuZXh0cmFjdC5tdWx0aXBvaW50XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5LuO5LiA5Liq5aSa54K55a+56LGh5Lit6L+U5LiA5Liq5Z2Q5qCH57uE5pWw57uE44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0dlb21ldHJ5TXVsdGlQb2ludH0gbXVsdGlwb2ludCAtIOWkmueCueWvueixoeOAglxuICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5fSDkuIDkuKrooajnpLrlpJrngrnnmoTlnZDmoIfnu4TmlbDnu4TjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ211bHRpcG9pbnQnOiBmdW5jdGlvbiAobXVsdGlwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtdWx0aXBvaW50LmNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh0aGlzLmV4dHJhY3QucG9pbnQuYXBwbHkodGhpcywgW211bHRpcG9pbnQuY29tcG9uZW50c1tpXV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5leHRyYWN0LmxpbmVzdHJpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDku47kuIDkuKrnur/lr7nosaHkuK3ov5Tlm57kuIDkuKrlnZDmoIfnu4TmlbDnu4TjgIJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TGluZXN0cmluZ30gbGluZXN0cmluZyAtIOe6v+WvueixoeOAglxuICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5fSDkuIDkuKrooajnpLrnur/lr7nosaHnmoTlnZDmoIfnu4TmlbDnu4TjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2xpbmVzdHJpbmcnOiBmdW5jdGlvbiAobGluZXN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lc3RyaW5nLmNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh0aGlzLmV4dHJhY3QucG9pbnQuYXBwbHkodGhpcywgW2xpbmVzdHJpbmcuY29tcG9uZW50c1tpXV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5leHRyYWN0Lm11bHRpbGluZXN0cmluZ1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOS7juS4gOS4quWkmue6v+WvueixoeS4rei/lOWbnuS4gOS4que6v+aVsOe7hOOAglxuICAgICAgICAgICAgICogQHBhcmFtIHtHZW9tZXRyeU11bHRpTGluZVN0cmluZ30gbXVsdGlsaW5lc3RyaW5nIC0g5aSa57q/5a+56LGh44CCXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5fSDkuIDkuKrooajnpLrlpJrnur/nmoTnur/mlbDnu4TjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ211bHRpbGluZXN0cmluZyc6IGZ1bmN0aW9uIChtdWx0aWxpbmVzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbXVsdGlsaW5lc3RyaW5nLmNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh0aGlzLmV4dHJhY3QubGluZXN0cmluZy5hcHBseSh0aGlzLCBbbXVsdGlsaW5lc3RyaW5nLmNvbXBvbmVudHNbaV1dKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEdlb0pTT05Gb3JtYXQuZXh0cmFjdC5wb2x5Z29uXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5LuO5LiA5Liq6Z2i5a+56LGh5Lit6L+U5Zue5LiA57uE57q/546v44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0dlb21ldHJ5UG9seWdvbn0gcG9seWdvbiAtIOmdouWvueixoeOAglxuICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5fSDkuIDnu4TooajnpLrpnaLnmoTnur/njq/jgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3BvbHlnb24nOiBmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2x5Z29uLmNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh0aGlzLmV4dHJhY3QubGluZXN0cmluZy5hcHBseSh0aGlzLCBbcG9seWdvbi5jb21wb25lbnRzW2ldXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBHZW9KU09ORm9ybWF0LmV4dHJhY3QubXVsdGlwb2x5Z29uXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5LuO5LiA5Liq5aSa6Z2i5a+56LGh5Lit6L+U5Zue5LiA57uE6Z2i44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0dlb21ldHJ5TXVsdGlQb2x5Z29ufSBtdWx0aXBvbHlnb24gLSDlpJrpnaLlr7nosaHjgIJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0g5LiA57uE6KGo56S65aSa6Z2i55qE6Z2i44CCXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdtdWx0aXBvbHlnb24nOiBmdW5jdGlvbiAobXVsdGlwb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG11bHRpcG9seWdvbi5jb21wb25lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2godGhpcy5leHRyYWN0LnBvbHlnb24uYXBwbHkodGhpcywgW211bHRpcG9seWdvbi5jb21wb25lbnRzW2ldXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBHZW9KU09ORm9ybWF0LmV4dHJhY3QuY29sbGVjdGlvblxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOS7juS4gOS4quWHoOS9leimgee0oOmbhuWQiOS4reS4gOe7hOWHoOS9leimgee0oOaVsOe7hOOAglxuICAgICAgICAgICAgICogQHBhcmFtIHtHZW9tZXRyeUNvbGxlY3Rpb259IGNvbGxlY3Rpb24gLSDlh6DkvZXopoHntKDpm4blkIjjgIJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0g5LiA57uE6KGo56S65Yeg5L2V6KaB57Sg6ZuG5ZCI55qE5Yeg5L2V6KaB57Sg5pWw57uE44CCXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdjb2xsZWN0aW9uJzogZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gY29sbGVjdGlvbi5jb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gdGhpcy5leHRyYWN0Lmdlb21ldHJ5LmFwcGx5KHRoaXMsIFtjb2xsZWN0aW9uLmNvbXBvbmVudHNbaV1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9KU09ORm9ybWF0LnByb3RvdHlwZS5yZWFkXG4gICAgICogQGRlc2NyaXB0aW9uIOWwhiBHZW9KU09OIOWvueixoeaIluiAhUdlb0pTT04g5a+56LGh5a2X56ym5Liy6L2s5o2i5Li6IFN1cGVyTWFwIEZlYXR1cmUg5a+56LGh44CCXG4gICAgICogQHBhcmFtIHtHZW9KU09OT2JqZWN0fSBqc29uIC0gR2VvSlNPTiDlr7nosaHjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9J0ZlYXVyZUNvbGxlY3Rpb24nXSAtIOWPr+mAieeahOWtl+espuS4su+8jOWug+WGs+WumuS6hui+k+WHuueahOagvOW8j+OAguaUr+aMgeeahOWAvOacie+8mlwiR2VvbWV0cnlcIixcIkZlYXR1cmVcIu+8jOWSjCBcIkZlYXR1cmVDb2xsZWN0aW9uXCLvvIzlpoLmnpzmraTlgLzkuLpudWxs44CCXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZmlsdGVyIC0g5a+56LGh5Lit5q+P5Liq5bGC5qyh5q+P5Liq6ZSu5YC85a+56YO95Lya6LCD55So5q2k5Ye95pWw5b6X5Ye65LiA5Liq57uT5p6c44CC5q+P5Liq5YC86YO95Lya6KKrIGZpbHRlciDlh73mlbDnmoTnu5PmnpzmiYDmm7/mjaLmjonjgILov5nkuKrlh73mlbDlj6/ooqvnlKjmnaXlsIbmn5Dkupvlr7nosaHovazljJbmiJDmn5DkuKrnsbvnm7jlupTnmoTlr7nosaHvvIzmiJbogIXlsIbml6XmnJ/lrZfnrKbkuLLovazljJbmiJBEYXRl5a+56LGh44CCXG4gICAgICogQHJldHVybnMge09iamVjdH0gIOi/lOWbnuWAvOS+nei1luS6jiB0eXBlIOWPguaVsOeahOWAvOOAglxuICAgICAqICAgICAt5aaC5p6cIHR5cGUg562J5LqOIFwiRmVhdHVyZUNvbGxlY3Rpb25cIu+8jOi/lOWbnuWAvOWwhuS8muaYryB7QGxpbmsgRmVhdHVyZVZlY3Rvcn0g5pWw57uE44CCXG4gICAgICogICAgIC3lpoLmnpwgdHlwZSDkuLogXCJHZW9tZXRyeVwiLOi+k+WFpeeahCBKU09OIOWvueixoeW/hemhu+ihqOekuuS4gOS4quWUr+S4gOeahOWHoOS9leS9k++8jOeEtuWQjui/lOWbnuWAvOWwseS8muaYryB7QGxpbmsgR2VvbWV0cnl944CCXG4gICAgICogICAgIC3lpoLmnpwgdHlwZSDkuLogXCJGZWF0dXJlXCLvvIzovpPlhaXnmoQgSlNPTiDlr7nosaHkuZ/lv4XpobvooajnpLrnmoTkuIDkuKropoHntKDvvIzov5nmoLfov5Tlm57lgLzmiY3kvJrmmK8ge0BsaW5rIEZlYXR1cmVWZWN0b3J944CCXG4gICAgICovXG5cbiAgICByZWFkKGpzb24sIHR5cGUsIGZpbHRlcikge1xuICAgICAgICB0eXBlID0gKHR5cGUpID8gdHlwZSA6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIjtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBudWxsO1xuICAgICAgICB2YXIgb2JqID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9iaiA9IHN1cGVyLnJlYWQoanNvbiwgZmlsdGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IGpzb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcihcIkJhZCBKU09OOiBcIiArIGpzb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAob2JqLnR5cGUpICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcihcIkJhZCBHZW9KU09OIC0gbm8gdHlwZTogXCIgKyBqc29uKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVmFsaWRUeXBlKG9iaiwgdHlwZSkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJHZW9tZXRyeVwiOlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHRoaXMucGFyc2VHZW9tZXRyeShvYmopO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJGZWF0dXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gdGhpcy5wYXJzZUZlYXR1cmUob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMudHlwZSA9IFwiRmVhdHVyZVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJGZWF0dXJlQ29sbGVjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdHlwZSBGZWF0dXJlQ29sbGVjdGlvbiwgd2UgYWxsb3cgaW5wdXQgdG8gYmUgYW55IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRmVhdHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnBhcnNlRmVhdHVyZShvYmopKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJGZWF0dXJlQ29sbGVjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmouZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnBhcnNlRmVhdHVyZShvYmouZmVhdHVyZXNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdlb20gPSB0aGlzLnBhcnNlR2VvbWV0cnkob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBWZWN0b3IoZ2VvbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9KU09ORm9ybWF0LnByb3RvdHlwZS53cml0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBpU2VydmVyIEdlb21ldHJ5IEpTT04g5a+56LGhIOi9rCBHZW9KU09O5a+56LGh5a2X56ym5Liy44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIGlTZXJ2ZXIgR2VvbWV0cnkgSlNPTiDlr7nosaHjgIJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmV0dHk9ZmFsc2VdIC0g5piv5ZCm5L2/55So5o2i6KGM5ZKM57yp6L+b5p2l5o6n5Yi26L6T5Ye644CCXG4gICAgICogQHJldHVybnMge0dlb0pTT05PYmplY3R9IOS4gOS4qiBHZW9KU09OIOWtl+espuS4su+8jOWug+ihqOekuuS6hui+k+WFpeeahOWHoOS9leWvueixoe+8jOimgee0oOWvueixoe+8jOaIluiAheimgee0oOWvueixoeaVsOe7hOOAglxuICAgICAqL1xuICAgIHdyaXRlKG9iaiwgcHJldHR5KSB7XG4gICAgICAgIHJldHVybiBzdXBlci53cml0ZSh0aGlzLnRvR2VvSlNPTihvYmopLCBwcmV0dHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5wcm90b3R5cGUuZnJvbUdlb0pTT05cbiAgICAgKiBAdmVyc2lvbiA5LjEuMVxuICAgICAqIEBkZXNjcmlwdGlvbiDlsIYgR2VvSlNPTiDlr7nosaHmiJbogIVHZW9KU09OIOWvueixoeWtl+espuS4sui9rOaNouS4umlTZXJ2ZXIgRmVhdHVyZSBKU09O44CCXG4gICAgICogQHBhcmFtIHtHZW9KU09OT2JqZWN0fSBqc29uIC0gR2VvSlNPTiDlr7nosaHjgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9J0ZlYXVyZUNvbGxlY3Rpb24nXSAtIOWPr+mAieeahOWtl+espuS4su+8jOWug+WGs+WumuS6hui+k+WHuueahOagvOW8j+OAguaUr+aMgeeahOWAvOacie+8mlwiR2VvbWV0cnlcIixcIkZlYXR1cmVcIu+8jOWSjCBcIkZlYXR1cmVDb2xsZWN0aW9uXCLvvIzlpoLmnpzmraTlgLzkuLpudWxs44CCXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZmlsdGVyIC0g5a+56LGh5Lit5q+P5Liq5bGC5qyh5q+P5Liq6ZSu5YC85a+56YO95Lya6LCD55So5q2k5Ye95pWw5b6X5Ye65LiA5Liq57uT5p6c44CC5q+P5Liq5YC86YO95Lya6KKrIGZpbHRlciDlh73mlbDnmoTnu5PmnpzmiYDmm7/mjaLmjonjgILov5nkuKrlh73mlbDlj6/ooqvnlKjmnaXlsIbmn5Dkupvlr7nosaHovazljJbmiJDmn5DkuKrnsbvnm7jlupTnmoTlr7nosaHvvIzmiJbogIXlsIbml6XmnJ/lrZfnrKbkuLLovazljJbmiJBEYXRl5a+56LGh44CCXG4gICAgICogQHJldHVybnMge09iamVjdH0gIGlTZXJ2ZXIgRmVhdHVyZSBKU09O44CCXG4gICAgICovXG4gICAgZnJvbUdlb0pTT04oanNvbiwgdHlwZSwgZmlsdGVyKSB7XG4gICAgICAgIGxldCBmZWF0dXJlID0gdGhpcy5yZWFkKGpzb24sIHR5cGUsIGZpbHRlcik7XG4gICAgICAgIGlmICghVXRpbC5pc0FycmF5KGZlYXR1cmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9pU2V2cmVyRmVhdHVyZShmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmVhdHVyZS5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2lTZXZyZXJGZWF0dXJlKGVsZW1lbnQpO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9KU09ORm9ybWF0LnByb3RvdHlwZS50b0dlb0pTT05cbiAgICAgKiBAdmVyc2lvbiA5LjEuMVxuICAgICAqIEBkZXNjcmlwdGlvbiDlsIYgaVNlcnZlciBGZWF0dXJlIEpTT04g5a+56LGh6L2s5o2i5Li6IEdlb0pTT04g5a+56LGh44CCXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIGlTZXJ2ZXIgRmVhdHVyZSBKU09O44CCXG4gICAgICogQHJldHVybnMge0dlb0pTT05PYmplY3R9ICBHZW9KU09OIOWvueixoeOAglxuICAgICAqL1xuICAgIHRvR2VvSlNPTihvYmopIHtcbiAgICAgICAgdmFyIGdlb2pzb24gPSB7XG4gICAgICAgICAgICBcInR5cGVcIjogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoVXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGdlb2pzb24udHlwZSA9IFwiRmVhdHVyZUNvbGxlY3Rpb25cIjtcbiAgICAgICAgICAgIHZhciBudW1GZWF0dXJlcyA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICBnZW9qc29uLmZlYXR1cmVzID0gbmV3IEFycmF5KG51bUZlYXR1cmVzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRmVhdHVyZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gb2JqW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0dlb21ldHJ5KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuZ2VvbWV0cnkgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBnZW9qc29uLmZlYXR1cmVzW2ldID0gdGhpcy5leHRyYWN0LmZlYXR1cmUuYXBwbHkodGhpcywgW2ZlYXR1cmVdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZW9qc29uLmZlYXR1cmVzW2ldID0gdGhpcy5leHRyYWN0LmZlYXR1cmUuYXBwbHkodGhpcywgW2VsZW1lbnRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNHZW9tZXRyeShvYmopKSB7XG4gICAgICAgICAgICBsZXQgZmVhdHVyZSA9IHt9O1xuICAgICAgICAgICAgZmVhdHVyZS5nZW9tZXRyeSA9IG9iajtcbiAgICAgICAgICAgIGdlb2pzb24gPSB0aGlzLmV4dHJhY3QuZmVhdHVyZS5hcHBseSh0aGlzLCBbZmVhdHVyZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VvanNvbiA9IHRoaXMuZXh0cmFjdC5mZWF0dXJlLmFwcGx5KHRoaXMsIFtvYmpdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzR2VvbWV0cnkoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiAoaW5wdXQuaGFzT3duUHJvcGVydHkoXCJwYXJ0c1wiKSAmJiBpbnB1dC5oYXNPd25Qcm9wZXJ0eShcInBvaW50c1wiKSkgfHwgaW5wdXQuaGFzT3duUHJvcGVydHkoXCJnZW9QYXJ0c1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9qc29uO1xuXG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAZnVuY3Rpb24gR2VvSlNPTkZvcm1hdC5wcm90b3R5cGUuaXNWYWxpZFR5cGVcbiAgICAgKiAgQGRlc2NyaXB0aW9uIOajgOafpeS4gOS4qiBHZW9KU09OIOWvueixoeaYr+WQpuWSjOe7meWumueahOexu+Wei+ebuOespueahOWQiOazleeahOWvueixoeOAglxuICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gR2VvSlNPTiDmmK/lkKbmmK/nu5nlrprnsbvlnovnmoTlkIjms5Xlr7nosaHjgIJcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBpc1ZhbGlkVHlwZShvYmosIHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkdlb21ldHJ5XCI6XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgW1wiUG9pbnRcIiwgXCJNdWx0aVBvaW50XCIsIFwiTGluZVN0cmluZ1wiLCBcIk11bHRpTGluZVN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJQb2x5Z29uXCIsIFwiTXVsdGlQb2x5Z29uXCIsIFwiQm94XCIsIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqLnR5cGUpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmVycm9yKFwiVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAvLyBvYmoudHlwZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGZWF0dXJlQ29sbGVjdGlvblwiOlxuICAgICAgICAgICAgICAgIC8vIGFsbG93IGZvciBhbnkgdHlwZSB0byBiZSBjb252ZXJ0ZWQgdG8gYSBmZWF0dXJlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGZvciBGZWF0dXJlIHR5cGVzIG11c3QgbWF0Y2hcbiAgICAgICAgICAgICAgICBpZiAob2JqLnR5cGUgPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdHlwZXMgZnJvbSBcIiArXG4gICAgICAgICAgICAgICAgICAgIC8vb2JqLnR5cGUgKyBcIiB0byBcIiArIHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb0pTT05Gb3JtYXQucHJvdG90eXBlLnBhcnNlRmVhdHVyZVxuICAgICAqIEBkZXNjcmlwdGlvbiDlsIbkuIDkuKogR2VvSlNPTiDkuK3nmoQgZmVhdHVyZSDovazljJbmiJAge0BsaW5rIEZlYXR1cmVWZWN0b3J9PiDlr7nosaHjgIJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7R2VvSlNPTk9iamVjdH0gb2JqIC0g5LuOIEdlb0pTT04g5a+56LGh5Lit5Yib5bu65LiA5Liq5a+56LGh44CCXG4gICAgICogQHJldHVybnMge0ZlYXR1cmVWZWN0b3J9IOS4gOS4quimgee0oOOAglxuICAgICAqL1xuICAgIHBhcnNlRmVhdHVyZShvYmopIHtcbiAgICAgICAgdmFyIGZlYXR1cmUsIGdlb21ldHJ5LCBhdHRyaWJ1dGVzLCBiYm94O1xuICAgICAgICBhdHRyaWJ1dGVzID0gKG9iai5wcm9wZXJ0aWVzKSA/IG9iai5wcm9wZXJ0aWVzIDoge307XG4gICAgICAgIGJib3ggPSAob2JqLmdlb21ldHJ5ICYmIG9iai5nZW9tZXRyeS5iYm94KSB8fCBvYmouYmJveDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gdGhpcy5wYXJzZUdlb21ldHJ5KG9iai5nZW9tZXRyeSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGJhZCBnZW9tZXRyaWVzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZSA9IG5ldyBWZWN0b3IoZ2VvbWV0cnksIGF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoYmJveCkge1xuICAgICAgICAgICAgZmVhdHVyZS5ib3VuZHMgPSBCb3VuZHMuZnJvbUFycmF5KGJib3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouaWQpIHtcbiAgICAgICAgICAgIGZlYXR1cmUuZmlkID0gb2JqLmlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEdlb0pTT05Gb3JtYXQucHJvdG90eXBlLnBhcnNlR2VvbWV0cnlcbiAgICAgKiBAZGVzY3JpcHRpb24g5bCG5LiA5LiqIEdlb0pTT04g5Lit55qE5Yeg5L2V6KaB57Sg6L2s5YyW5oiQIHtAbGluayBHZW9tZXRyeX0g5a+56LGh44CCXG4gICAgICogQHBhcmFtIHtHZW9KU09OT2JqZWN0fSBvYmogLSDku44gR2VvSlNPTiDlr7nosaHkuK3liJvlu7rkuIDkuKrlr7nosaHjgIJcbiAgICAgKiBAcmV0dXJucyB7R2VvbWV0cnl9IOS4gOS4quWHoOS9leimgee0oOOAglxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcGFyc2VHZW9tZXRyeShvYmopIHtcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2VvbWV0cnk7XG4gICAgICAgIGlmIChvYmoudHlwZSA9PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIShVdGlsLmlzQXJyYXkob2JqLmdlb21ldHJpZXMpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiR2VvbWV0cnlDb2xsZWN0aW9uIG11c3QgaGF2ZSBnZW9tZXRyaWVzIGFycmF5OiBcIiArIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW1HZW9tID0gb2JqLmdlb21ldHJpZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBuZXcgQXJyYXkobnVtR2VvbSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUdlb207ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaV0gPSB0aGlzLnBhcnNlR2VvbWV0cnkuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsIFtvYmouZ2VvbWV0cmllc1tpXV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgQ29sbGVjdGlvbihjb21wb25lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKFV0aWwuaXNBcnJheShvYmouY29vcmRpbmF0ZXMpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiR2VvbWV0cnkgbXVzdCBoYXZlIGNvb3JkaW5hdGVzIGFycmF5OiBcIiArIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZUNvb3Jkc1tvYmoudHlwZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZTogXCIgKyBvYmoudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSB0aGlzLnBhcnNlQ29vcmRzW29iai50eXBlLnRvTG93ZXJDYXNlKCldLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLCBbb2JqLmNvb3JkaW5hdGVzXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWFsIHdpdGggYmFkIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBHZW9KU09ORm9ybWF0LnByb3RvdHlwZS5jcmVhdGVDUlNPYmplY3RcbiAgICAgKiBAZGVzY3JpcHRpb24g5LuO5LiA5Liq6KaB57Sg5a+56LGh5Lit5Yib5bu65LiA5Liq5Z2Q5qCH5Y+C6ICD57O75a+56LGh44CCXG4gICAgICogQHBhcmFtIHtGZWF0dXJlVmVjdG9yfSBvYmplY3QgLSDopoHntKDlr7nosaHjgIJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtHZW9KU09OT2JqZWN0fSDkuIDkuKrlj6/kvZzkuLogR2VvSlNPTiDlr7nosaHnmoQgQ1JTIOWxnuaAp+S9v+eUqOeahOWvueixoeOAglxuICAgICAqL1xuICAgIGNyZWF0ZUNSU09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIHByb2ogPSBvYmplY3QubGF5ZXIucHJvamVjdGlvbi50b1N0cmluZygpO1xuICAgICAgICB2YXIgY3JzID0ge307XG4gICAgICAgIGlmIChwcm9qLm1hdGNoKC9lcHNnOi9pKSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChwcm9qLnN1YnN0cmluZyhwcm9qLmluZGV4T2YoXCI6XCIpICsgMSkpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT0gNDMyNikge1xuICAgICAgICAgICAgICAgIGNycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODRcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3JzID0ge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJuYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJFUFNHOlwiICsgY29kZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JzO1xuICAgIH1cbiAgICBfdG9pU2V2cmVyRmVhdHVyZShmZWF0dXJlKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBmZWF0dXJlLmF0dHJpYnV0ZXM7XG4gICAgICAgIGNvbnN0IGF0dHJOYW1lcyA9IFtdO1xuICAgICAgICBjb25zdCBhdHRyVmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgYXR0ck5hbWVzLnB1c2goYXR0cik7XG4gICAgICAgICAgICBhdHRyVmFsdWVzLnB1c2goYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RmVhdHVyZSA9IHtcbiAgICAgICAgICAgIGZpZWxkTmFtZXM6IGF0dHJOYW1lcyxcbiAgICAgICAgICAgIGZpZWxkVmFsdWVzOiBhdHRyVmFsdWVzLFxuICAgICAgICAgICAgZ2VvbWV0cnk6IFNlcnZlckdlb21ldHJ5LmZyb21HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5KVxuICAgICAgICB9O1xuICAgICAgICBuZXdGZWF0dXJlLmdlb21ldHJ5LmlkID0gZmVhdHVyZS5maWQ7XG4gICAgICAgIHJldHVybiBuZXdGZWF0dXJlO1xuICAgIH1cbiAgICBjcmVhdGVBdHRyaWJ1dGVzKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICBwcm9jZXNzRmllbGRzQXR0cmlidXRlcyhmZWF0dXJlLCBhdHRyKTtcbiAgICAgICAgdmFyIGV4Y2VwdEtleXMgPSBbXCJmaWVsZE5hbWVzXCIsIFwiZmllbGRWYWx1ZXNcIiwgXCJnZW9tZXRyeVwiLCBcInN0cmluZ0lEXCIsIFwiSURcIl07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBmZWF0dXJlKSB7XG4gICAgICAgICAgICBpZiAoZXhjZXB0S2V5cy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cltrZXldID0gZmVhdHVyZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0ZpZWxkc0F0dHJpYnV0ZXMoZmVhdHVyZSwgYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCEoZmVhdHVyZS5oYXNPd25Qcm9wZXJ0eShcImZpZWxkTmFtZXNcIikgJiYgZmVhdHVyZS5oYXNPd25Qcm9wZXJ0eShcImZpZWxkVmFsdWVzXCIpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYW1lcyA9IGZlYXR1cmUuZmllbGROYW1lcyxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBmZWF0dXJlLmZpZWxkVmFsdWVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBuYW1lcykge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbbmFtZXNbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVW5pdCB9IGZyb20gJy4uL1JFU1QnO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRNZXRlclBlck1hcFVuaXRcbiAqIEBkZXNjcmlwdGlvbiDljZXkvY3mjaLnrpfvvIzmiornsbN85bqmfOWNg+exs3zoi7Hlr7h86Iux5bC65o2i5oiQ57Gz44CCXG4gKiBAY2F0ZWdvcnkgQmFzZVR5cGVzIFV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXBVbml0IOWcsOWbvuWNleS9jeOAglxuICogQHJldHVybnMge251bWJlcn0g6L+U5Zue5Zyw5Zu+55qE6Led56a75Y2V5L2N44CCXG4gKiBAdXNhZ2VcbiAqIGBgYFxuICogLy8g5rWP6KeI5ZmoXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxuICogPHNjcmlwdD5cbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uZ2V0TWV0ZXJQZXJNYXBVbml0KG1hcFVuaXQpO1xuICpcbiAqIDwvc2NyaXB0PlxuICpcbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IGdldE1ldGVyUGVyTWFwVW5pdCB9IGZyb20gJ3tucG19JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBnZXRNZXRlclBlck1hcFVuaXQobWFwVW5pdCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHZhciBnZXRNZXRlclBlck1hcFVuaXQgPSBmdW5jdGlvbihtYXBVbml0KSB7XG4gICAgdmFyIGVhcmNoUmFkaXVzSW5NZXRlcnMgPSA2Mzc4MTM3O1xuICAgIHZhciBtZXRlclBlck1hcFVuaXQ7XG4gICAgaWYgKG1hcFVuaXQgPT09IFVuaXQuTUVURVIpIHtcbiAgICAgICAgbWV0ZXJQZXJNYXBVbml0ID0gMTtcbiAgICB9IGVsc2UgaWYgKG1hcFVuaXQgPT09IFVuaXQuREVHUkVFKSB7XG4gICAgICAgIC8vIOavj+W6puihqOekuuWkmuWwkeexs+OAglxuICAgICAgICBtZXRlclBlck1hcFVuaXQgPSAoTWF0aC5QSSAqIDIgKiBlYXJjaFJhZGl1c0luTWV0ZXJzKSAvIDM2MDtcbiAgICB9IGVsc2UgaWYgKG1hcFVuaXQgPT09IFVuaXQuS0lMT01FVEVSKSB7XG4gICAgICAgIG1ldGVyUGVyTWFwVW5pdCA9IDEuMGUtMztcbiAgICB9IGVsc2UgaWYgKG1hcFVuaXQgPT09IFVuaXQuSU5DSCkge1xuICAgICAgICBtZXRlclBlck1hcFVuaXQgPSAxIC8gMi41Mzk5OTk5OTE4ZS0yO1xuICAgIH0gZWxzZSBpZiAobWFwVW5pdCA9PT0gVW5pdC5GT09UKSB7XG4gICAgICAgIG1ldGVyUGVyTWFwVW5pdCA9IDAuMzA0ODtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWV0ZXJQZXJNYXBVbml0O1xuICAgIH1cbiAgICByZXR1cm4gbWV0ZXJQZXJNYXBVbml0O1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gZ2V0V3JhcE51bVxuICogQGRlc2NyaXB0aW9uIOiOt+WPluivpeWdkOagh+ezu+eahOe7j+e6rOW6puiMg+WbtOeahOe7j+W6puaIlue6rOW6puOAglxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBVdGlsXG4gKiBAcGFyYW0ge251bWJlcn0geCDnu4/luqbmiJbnuqzluqbjgIJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZU1heCDmmK/lkKbojrflj5bnu4/luqbmiJbnuqzluqbnmoTmnIDlpKflgLzjgIJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZU1pbiDmmK/lkKbojrflj5bnu4/luqbmiJbnuqzluqbnmoTmnIDlsI/lgLzjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZSDlnZDmoIfns7vnmoTnu4/nuqzluqbojIPlm7TjgIJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IOi/lOWbnue7j+W6puaIlue6rOW6pueahOWAvOOAglxuICogQHVzYWdlXG4gKiBgYGBcbiAqIC8vIOa1j+iniOWZqFxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cbiAqIDxzY3JpcHQ+XG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LmdldFdyYXBOdW0oeCwgaW5jbHVkZU1heCwgaW5jbHVkZU1pbiwgcmFuZ2UpO1xuICpcbiAqIDwvc2NyaXB0PlxuICpcbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IGdldFdyYXBOdW0gfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gZ2V0V3JhcE51bSh4LCBpbmNsdWRlTWF4LCBpbmNsdWRlTWluLCByYW5nZSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdyYXBOdW0oeCwgaW5jbHVkZU1heCA9IHRydWUsIGluY2x1ZGVNaW4gPSB0cnVlLCByYW5nZSA9IFstMTgwLCAxODBdKSB7XG4gICAgdmFyIG1heCA9IHJhbmdlWzFdLFxuICAgICAgICBtaW4gPSByYW5nZVswXSxcbiAgICAgICAgZCA9IG1heCAtIG1pbjtcbiAgICBpZiAoeCA9PT0gbWF4ICYmIGluY2x1ZGVNYXgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh4ID09PSBtaW4gJiYgaW5jbHVkZU1pbikge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgdmFyIHRtcCA9ICgoKHggLSBtaW4pICUgZCkgKyBkKSAlIGQ7XG4gICAgaWYgKHRtcCA9PT0gMCAmJiBpbmNsdWRlTWF4KSB7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIHJldHVybiAoKCgoeCAtIG1pbikgJSBkKSArIGQpICUgZCkgKyBtaW47XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGNvbnZlcnNpb25EZWdyZWVcbiAqIEBkZXNjcmlwdGlvbiDovazmjaLnu4/nuqzluqbjgIJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgVXRpbFxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMg57uP5bqm5oiW57qs5bqm44CCXG4gKiBAcmV0dXJucyB7c3RyaW5nfSDov5Tlm57luqbliIbnp5LjgIJcbiAqIEB1c2FnZVxuICogYGBgXG4gKiAvLyDmtY/op4jlmahcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XG4gKiA8c2NyaXB0PlxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5jb252ZXJzaW9uRGVncmVlKGRlZ3JlZXMpO1xuICpcbiAqIDwvc2NyaXB0PlxuICpcbiAqIC8vIEVTNiBJbXBvcnRcbiAqIGltcG9ydCB7IGNvbnZlcnNpb25EZWdyZWUgfSBmcm9tICd7bnBtfSc7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gY29udmVyc2lvbkRlZ3JlZShkZWdyZWVzKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVyc2lvbkRlZ3JlZShkZWdyZWVzKSB7XG4gICAgY29uc3QgZGVncmVlID0gcGFyc2VJbnQoZGVncmVlcyk7XG4gICAgbGV0IGZyYWN0aW9uID0gcGFyc2VJbnQoKGRlZ3JlZXMgLSBkZWdyZWUpICogNjApO1xuICAgIGxldCBzZWNvbmQgPSBwYXJzZUludCgoKGRlZ3JlZXMgLSBkZWdyZWUpICogNjAgLSBmcmFjdGlvbikgKiA2MCk7XG4gICAgZnJhY3Rpb24gPSBwYXJzZUludChmcmFjdGlvbiAvIDEwKSA9PT0gMCA/IGAwJHtmcmFjdGlvbn1gIDogZnJhY3Rpb247XG4gICAgc2Vjb25kID0gcGFyc2VJbnQoc2Vjb25kIC8gMTApID09PSAwID8gYDAke3NlY29uZH1gIDogc2Vjb25kO1xuICAgIHJldHVybiBgJHtkZWdyZWV9wrAke2ZyYWN0aW9ufScke3NlY29uZH1gO1xufVxuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cclxuIGltcG9ydCBMIGZyb20gJ2xlYWZsZXQnO1xyXG4gaW1wb3J0IHsgR2VvSlNPTiBhcyBHZW9KU09ORm9ybWF0IH0gZnJvbSAnQHN1cGVybWFwL2ljbGllbnQtY29tbW9uL2Zvcm1hdC9HZW9KU09OJztcclxuIGltcG9ydCB7IGdldE1ldGVyUGVyTWFwVW5pdCBhcyBNZXRlclBlck1hcFVuaXQgfSBmcm9tICdAc3VwZXJtYXAvaWNsaWVudC1jb21tb24vdXRpbC9NYXBDYWxjdWxhdGVVdGlsJztcclxuIFxyXG4gLyoqXHJcbiAqIEBmdW5jdGlvbiB0b0dlb0pTT05cclxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBVdGlsXHJcbiAqIEBkZXNjcmlwdGlvbiDlsIbkvKDlhaXlr7nosaHovazkuLogR2VvSlNPTiDmoLzlvI/jgIJcclxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUgLSDlvoXovazlj4LmlbDjgIJcclxuICogQHVzYWdlXHJcbiAqIGBgYFxyXG4gKiAvLyDmtY/op4jlmahcclxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwie2Nkbn1cIj48L3NjcmlwdD5cclxuICogPHNjcmlwdD5cclxuICogICBjb25zdCByZXN1bHQgPSB7bmFtZXNwYWNlfS5VdGlsLnRvR2VvSlNPTihmZWF0dXJlKTtcclxuICpcclxuICogPC9zY3JpcHQ+XHJcbiAqXHJcbiAqIC8vIEVTNiBJbXBvcnRcclxuICogaW1wb3J0IHsgdG9HZW9KU09OIH0gZnJvbSAne25wbX0nO1xyXG4gKlxyXG4gKiBjb25zdCByZXN1bHQgPSB0b0dlb0pTT04oZmVhdHVyZSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuIGV4cG9ydCB2YXIgdG9HZW9KU09OID0gZnVuY3Rpb24oZmVhdHVyZSkge1xyXG4gICAgaWYgKCFmZWF0dXJlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEdlb0pTT05Gb3JtYXQoKS50b0dlb0pTT04oZmVhdHVyZSk7XHJcbn07XHJcblxyXG4gLyoqXHJcbiAqIEBmdW5jdGlvbiB0b1N1cGVyTWFwR2VvbWV0cnlcclxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBVdGlsXHJcbiAqIEBkZXNjcmlwdGlvbiDlsIYgR2VvSlNPTiDlr7nosaHovazkuLogU3VwZXJNYXAg5Yeg5L2V5Zu+5b2i44CCXHJcbiAqIEBwYXJhbSB7R2VvSlNPTk9iamVjdH0gZ2VvbWV0cnkgLSBHZW9KU09OIOWvueixoeOAglxyXG4gKiBAdXNhZ2VcclxuICogYGBgXHJcbiAqIC8vIOa1j+iniOWZqFxyXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxyXG4gKiA8c2NyaXB0PlxyXG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LlV0aWwudG9TdXBlck1hcEdlb21ldHJ5KGdlb21ldHJ5KTtcclxuICpcclxuICogPC9zY3JpcHQ+XHJcbiAqXHJcbiAqIC8vIEVTNiBJbXBvcnRcclxuICogaW1wb3J0IHsgdG9TdXBlck1hcEdlb21ldHJ5IH0gZnJvbSAne25wbX0nO1xyXG4gKlxyXG4gKiBjb25zdCByZXN1bHQgPSB0b1N1cGVyTWFwR2VvbWV0cnkoZ2VvbWV0cnkpO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCB2YXIgdG9TdXBlck1hcEdlb21ldHJ5ID0gZnVuY3Rpb24oZ2VvbWV0cnkpIHtcclxuICAgIGlmICghZ2VvbWV0cnkpIHtcclxuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0LFxyXG4gICAgICAgIGZvcm1hdCA9IG5ldyBHZW9KU09ORm9ybWF0KCk7XHJcbiAgICBpZiAoWydGZWF0dXJlQ29sbGVjdGlvbicsICdGZWF0dXJlJywgJ0dlb21ldHJ5J10uaW5kZXhPZihnZW9tZXRyeS50eXBlKSAhPSAtMSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGZvcm1hdC5yZWFkKGdlb21ldHJ5LCBnZW9tZXRyeS50eXBlKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGdlb21ldHJ5LnRvR2VvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHZhciBnZW9qc29uID0gZ2VvbWV0cnkudG9HZW9KU09OKCk7XHJcbiAgICAgICAgcmVzdWx0ID0gZ2VvanNvbiA/IGZvcm1hdC5yZWFkKGdlb2pzb24sIGdlb2pzb24udHlwZSkgOiBnZW9tZXRyeTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2VydmVyUmVzdWx0ID0gcmVzdWx0IHx8IGdlb21ldHJ5O1xyXG4gICAgaWYgKEwuVXRpbC5pc0FycmF5KHJlc3VsdCkpIHtcclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBzZXJ2ZXJSZXN1bHQgPSByZXN1bHRbMF07XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBzZXJ2ZXJSZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgcmVzdWx0Lm1hcChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJSZXN1bHQucHVzaChpdGVtLmdlb21ldHJ5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNlcnZlclJlc3VsdCAmJiBzZXJ2ZXJSZXN1bHQuZ2VvbWV0cnkgPyBzZXJ2ZXJSZXN1bHQuZ2VvbWV0cnkgOiBzZXJ2ZXJSZXN1bHQ7XHJcbn07XHJcbmV4cG9ydCB2YXIgZ2V0TWV0ZXJQZXJNYXBVbml0ID0gTWV0ZXJQZXJNYXBVbml0O1xyXG5cclxuXHJcbiAvKipcclxuICogQGZ1bmN0aW9uIHJlc29sdXRpb25Ub1NjYWxlXHJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgVXRpbFxyXG4gKiBAZGVzY3JpcHRpb24g6YCa6L+H5YiG6L6o546H6K6h566X5q+U5L6L5bC644CCXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIC0g5YiG6L6o546H44CCXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkcGkgLSDlsY/luZXliIbovqjnjofjgIJcclxuICogQHBhcmFtIHtzdHJpbmd9IG1hcFVuaXQgLSDlnLDlm77ljZXkvY3jgIJcclxuICogQHJldHVybnMge251bWJlcn0g5q+U5L6L5bC644CCXHJcbiAqIEB1c2FnZVxyXG4gKiBgYGBcclxuICogLy8g5rWP6KeI5ZmoXHJcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XHJcbiAqIDxzY3JpcHQ+XHJcbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uVXRpbC5yZXNvbHV0aW9uVG9TY2FsZShyZXNvbHV0aW9uLCBkcGksIG1hcFVuaXQpO1xyXG4gKlxyXG4gKiA8L3NjcmlwdD5cclxuICpcclxuICogLy8gRVM2IEltcG9ydFxyXG4gKiBpbXBvcnQgeyByZXNvbHV0aW9uVG9TY2FsZSB9IGZyb20gJ3tucG19JztcclxuICpcclxuICogY29uc3QgcmVzdWx0ID0gcmVzb2x1dGlvblRvU2NhbGUocmVzb2x1dGlvbiwgZHBpLCBtYXBVbml0KTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgdmFyIHJlc29sdXRpb25Ub1NjYWxlID0gZnVuY3Rpb24ocmVzb2x1dGlvbiwgZHBpLCBtYXBVbml0KSB7XHJcbiAgICB2YXIgaW5jaFBlck1ldGVyID0gMSAvIDAuMDI1NDtcclxuICAgIC8vIOWcsOeQg+WNiuW+hOOAglxyXG4gICAgdmFyIG1ldGVyUGVyTWFwVW5pdCA9IGdldE1ldGVyUGVyTWFwVW5pdChtYXBVbml0KTtcclxuICAgIHZhciBzY2FsZSA9IHJlc29sdXRpb24gKiBkcGkgKiBpbmNoUGVyTWV0ZXIgKiBtZXRlclBlck1hcFVuaXQ7XHJcbiAgICBzY2FsZSA9IDEgLyBzY2FsZTtcclxuICAgIHJldHVybiBzY2FsZTtcclxufTtcclxuXHJcbiAvKipcclxuICogQGZ1bmN0aW9uIHNjYWxlVG9SZXNvbHV0aW9uXHJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgVXRpbFxyXG4gKiBAZGVzY3JpcHRpb24g6YCa6L+H5q+U5L6L5bC66K6h566X5YiG6L6o546H44CCXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIOavlOS+i+WwuuOAglxyXG4gKiBAcGFyYW0ge251bWJlcn0gZHBpIC0g5bGP5bmV5YiG6L6o546H44CCXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXBVbml0IC0g5Zyw5Zu+5Y2V5L2N44CCXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IOWIhui+qOeOh+OAglxyXG4gKiBAdXNhZ2VcclxuICogYGBgXHJcbiAqIC8vIOa1j+iniOWZqFxyXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7Y2RufVwiPjwvc2NyaXB0PlxyXG4gKiA8c2NyaXB0PlxyXG4gKiAgIGNvbnN0IHJlc3VsdCA9IHtuYW1lc3BhY2V9LlV0aWwuc2NhbGVUb1Jlc29sdXRpb24oc2NhbGUsIGRwaSwgbWFwVW5pdCk7XHJcbiAqXHJcbiAqIDwvc2NyaXB0PlxyXG4gKlxyXG4gKiAvLyBFUzYgSW1wb3J0XHJcbiAqIGltcG9ydCB7IHNjYWxlVG9SZXNvbHV0aW9uIH0gZnJvbSAne25wbX0nO1xyXG4gKlxyXG4gKiBjb25zdCByZXN1bHQgPSBzY2FsZVRvUmVzb2x1dGlvbihzY2FsZSwgZHBpLCBtYXBVbml0KTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgdmFyIHNjYWxlVG9SZXNvbHV0aW9uID0gZnVuY3Rpb24oc2NhbGUsIGRwaSwgbWFwVW5pdCkge1xyXG4gICAgdmFyIGluY2hQZXJNZXRlciA9IDEgLyAwLjAyNTQ7XHJcbiAgICB2YXIgbWV0ZXJQZXJNYXBVbml0VmFsdWUgPSBnZXRNZXRlclBlck1hcFVuaXQobWFwVW5pdCk7XHJcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHNjYWxlICogZHBpICogaW5jaFBlck1ldGVyICogbWV0ZXJQZXJNYXBVbml0VmFsdWU7XHJcbiAgICByZXNvbHV0aW9uID0gMSAvIHJlc29sdXRpb247XHJcbiAgICByZXR1cm4gcmVzb2x1dGlvbjtcclxufTtcclxuXHJcbiAvKipcclxuICogQGZ1bmN0aW9uIG5vcm1hbGl6ZVNjYWxlXHJcbiAqIEBjYXRlZ29yeSBCYXNlVHlwZXMgVXRpbFxyXG4gKiBAZGVzY3JpcHRpb24g6L2s5o2i5q+U5L6L5bC644CCXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIOavlOS+i+WwuuOAglxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSDmraPluLjnmoQgc2NhbGUg5YC844CCXHJcbiAqIEB1c2FnZVxyXG4gKiBgYGBcclxuICogLy8g5rWP6KeI5ZmoXHJcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XHJcbiAqIDxzY3JpcHQ+XHJcbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uVXRpbC5ub3JtYWxpemVTY2FsZShzY2FsZSk7XHJcbiAqXHJcbiAqICAvLyDlvIPnlKjnmoTlhpnms5VcclxuICogICBjb25zdCByZXN1bHQgPSBMLnN1cGVybWFwLlV0aWwuTm9ybWFsaXplU2NhbGUoc2NhbGUpO1xyXG4gKiAgIGNvbnN0IHJlc3VsdCA9IEwuVXRpbC5Ob3JtYWxpemVTY2FsZShzY2FsZSk7XHJcbiAqIDwvc2NyaXB0PlxyXG4gKlxyXG4gKiAvLyBFUzYgSW1wb3J0XHJcbiAqIGltcG9ydCB7IG5vcm1hbGl6ZVNjYWxlIH0gZnJvbSAne25wbX0nO1xyXG4gKlxyXG4gKiBjb25zdCByZXN1bHQgPSBub3JtYWxpemVTY2FsZShzY2FsZSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IHZhciBub3JtYWxpemVTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKSB7XHJcbiAgcmV0dXJuIHNjYWxlID4gMS4wID8gMS4wIC8gc2NhbGUgOiBzY2FsZTtcclxufTtcclxuXHJcbiAvKipcclxuICogQGZ1bmN0aW9uIGdldFJlc29sdXRpb25Gcm9tU2NhbGVEcGlcclxuICogQGNhdGVnb3J5IEJhc2VUeXBlcyBVdGlsXHJcbiAqIEBkZXNjcmlwdGlvbiDmoLnmja7mr5TkvovlsLrlkowgZHBpIOiuoeeul+Wxj+W5leWIhui+qOeOh+OAglxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgLSDmr5TkvovlsLrjgIJcclxuICogQHBhcmFtIHtudW1iZXJ9IGRwaSAtIOWbvuWDj+WIhui+qOeOh++8jOihqOekuuavj+iLseWvuOWGheeahOWDj+e0oOS4quaVsOOAglxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2Nvb3JkVW5pdF0gLSDmipXlvbHlnZDmoIfns7vnu5/nmoTlnLDlm77ljZXkvY3jgIJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtkYXR1bUF4aXM9NjM3ODEzN10gLSDlnLDnkIblnZDmoIfns7vnu5/mpK3nkIPkvZPplb/ljYrovbTjgILnlKjmiLfoh6rlrprkuYnlnLDlm77nmoQgT3B0aW9ucyDml7bvvIzoi6XmnKrmjIflrpror6Xlj4LmlbDnmoTlgLzvvIzliJkgRFBJIOm7mOiupOaMieeFpyBXR1M4NCDlj4LogIPns7vnmoTmpK3nkIPkvZPplb/ljYrovbQgNjM3ODEzNyDmnaXorqHnrpfjgIJcclxuICogQHJldHVybnMge251bWJlcn0g5b2T5YmN5q+U5L6L5bC65LiL55qE5bGP5bmV5YiG6L6o546H44CCXHJcbiAqIEB1c2FnZVxyXG4gKiBgYGBcclxuICogLy8g5rWP6KeI5ZmoXHJcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIntjZG59XCI+PC9zY3JpcHQ+XHJcbiAqIDxzY3JpcHQ+XHJcbiAqICAgY29uc3QgcmVzdWx0ID0ge25hbWVzcGFjZX0uVXRpbC5nZXRSZXNvbHV0aW9uRnJvbVNjYWxlRHBpKHNjYWxlLCBkcGksIGNvb3JkVW5pdCwgZGF0dW1BeGlzKTtcclxuICogXHJcbiAqICAgLy8g5byD55So55qE5YaZ5rOVXHJcbiAqICAgY29uc3QgcmVzdWx0ID0gTC5zdXBlcm1hcC5VdGlsLkdldFJlc29sdXRpb25Gcm9tU2NhbGVEcGkoc2NhbGUsIGRwaSwgY29vcmRVbml0LCBkYXR1bUF4aXMpO1xyXG4gKiAgIGNvbnN0IHJlc3VsdCA9IEwuVXRpbC5HZXRSZXNvbHV0aW9uRnJvbVNjYWxlRHBpKHNjYWxlLCBkcGksIGNvb3JkVW5pdCwgZGF0dW1BeGlzKTtcclxuICogPC9zY3JpcHQ+XHJcbiAqXHJcbiAqIC8vIEVTNiBJbXBvcnRcclxuICogaW1wb3J0IHsgZ2V0UmVzb2x1dGlvbkZyb21TY2FsZURwaSB9IGZyb20gJ3tucG19JztcclxuICpcclxuICogY29uc3QgcmVzdWx0ID0gZ2V0UmVzb2x1dGlvbkZyb21TY2FsZURwaShzY2FsZSwgZHBpLCBjb29yZFVuaXQsIGRhdHVtQXhpcyk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IHZhciBnZXRSZXNvbHV0aW9uRnJvbVNjYWxlRHBpID0gZnVuY3Rpb24oc2NhbGUsIGRwaSwgY29vcmRVbml0LCBkYXR1bUF4aXMpIHtcclxuICAgIHZhciByZXNvbHV0aW9uID0gbnVsbCxcclxuICAgICAgICByYXRpbyA9IDEwMDAwO1xyXG4gICAgLy/nlKjmiLfoh6rlrprkuYnlnLDlm77nmoRPcHRpb25z5pe277yM6Iul5pyq5oyH5a6a6K+l5Y+C5pWw55qE5YC877yM5YiZ57O757uf6buY6K6k5Li6NjM3ODEzN+exs++8jOWNs1dHUzg05Y+C6ICD57O755qE5qSt55CD5L2T6ZW/5Y2K6L2044CCXHJcbiAgICBkYXR1bUF4aXMgPSBkYXR1bUF4aXMgfHwgNjM3ODEzNztcclxuICAgIGNvb3JkVW5pdCA9IGNvb3JkVW5pdCB8fCAnJztcclxuICAgIGlmIChzY2FsZSA+IDAgJiYgZHBpID4gMCkge1xyXG4gICAgICAgIHNjYWxlID0gbm9ybWFsaXplU2NhbGUoc2NhbGUpO1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgY29vcmRVbml0LnRvTG93ZXJDYXNlKCkgPT09ICdkZWdyZWUnIHx8XHJcbiAgICAgICAgICAgIGNvb3JkVW5pdC50b0xvd2VyQ2FzZSgpID09PSAnZGVncmVlcycgfHxcclxuICAgICAgICAgICAgY29vcmRVbml0LnRvTG93ZXJDYXNlKCkgPT09ICdkZCdcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgLy9zY2FsZSA9IENvbW1vblV0aWwubm9ybWFsaXplU2NhbGUoc2NhbGUpO1xyXG4gICAgICAgICAgICByZXNvbHV0aW9uID0gKDAuMDI1NCAqIHJhdGlvKSAvIGRwaSAvIHNjYWxlIC8gKChNYXRoLlBJICogMiAqIGRhdHVtQXhpcykgLyAzNjApIC8gcmF0aW87XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSAoMC4wMjU0ICogcmF0aW8pIC8gZHBpIC8gc2NhbGUgLyByYXRpbztcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59O1xyXG5cclxuIiwiLyogQ29weXJpZ2h0wqkgMjAwMCAtIDIwMjIgU3VwZXJNYXAgU29mdHdhcmUgQ28uTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIHByb2dyYW0gYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBpcyBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLmh0bWwuKi9cclxuIGltcG9ydCBMLCB7IFV0aWwgYXMgTFV0aWwgfSBmcm9tICdsZWFmbGV0JztcclxuIGltcG9ydCAnLi4vY29yZS9CYXNlJztcclxuIGltcG9ydCB7IFNlY3VyaXR5TWFuYWdlciB9IGZyb20gJ0BzdXBlcm1hcC9pY2xpZW50LWNvbW1vbi9zZWN1cml0eS9TZWN1cml0eU1hbmFnZXInO1xyXG4gaW1wb3J0IHsgU2VydmVyR2VvbWV0cnkgfSBmcm9tICdAc3VwZXJtYXAvaWNsaWVudC1jb21tb24vaVNlcnZlci9TZXJ2ZXJHZW9tZXRyeSc7XHJcbiBpbXBvcnQgeyBVbml0IH0gZnJvbSAnQHN1cGVybWFwL2ljbGllbnQtY29tbW9uL1JFU1QnO1xyXG4gaW1wb3J0IHsgVXRpbCBhcyBDb21tb25VdGlsIH0gZnJvbSAnQHN1cGVybWFwL2ljbGllbnQtY29tbW9uL2NvbW1vbnR5cGVzL1V0aWwnO1xyXG4gXHJcbiBpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbiBpbXBvcnQgQXR0cmlidXRpb25zIGZyb20gJy4uL2NvcmUvQXR0cmlidXRpb25zJztcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgVGlsZWRNYXBMYXllclxyXG4gKiBAZGVwcmVjYXRlZGNsYXNzaW5zdGFuY2UgTC5zdXBlcm1hcC50aWxlZE1hcExheWVyXHJcbiAqIEBjbGFzc2Rlc2MgU3VwZXJNYXAgaVNlcnZlciDnmoQgUkVTVCDlnLDlm77mnI3liqHnmoTlm77lsYIoU3VwZXJNYXAgaVNlcnZlciBKYXZhIDZSIOWPiuS7peS4iuWIhuWdl+WKqOaAgSBSRVNUIOWbvuWxginjgILkvb/nlKggVGlsZUltYWdlIOi1hOa6kOWHuuWbvuOAglxyXG4gKiBAY2F0ZWdvcnkgaVNlcnZlciBNYXAgVGlsZVxyXG4gKiBAZXh0ZW5kcyB7TC5UaWxlTGF5ZXJ9XHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICAgbmV3IFRpbGVkTWFwTGF5ZXIodXJsKS5hZGRUbyhtYXApO1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0g5pyN5Yqh5Zyw5Z2A77yM5L6L5aaCOiBodHRwOi8ve2lwfTp7cG9ydH0vaXNlcnZlci9zZXJ2aWNlcy9tYXAtd29ybGQvcmVzdC9tYXBzL1dvcmxk44CCXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0g5Y+C5pWw44CCXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYXllcnNJRF0gLSDojrflj5bov5vooYzliIfniYfnmoTlnLDlm77lm77lsYIgSUTvvIzljbPmjIflrprov5vooYzlnLDlm77liIfniYfnmoTlm77lsYLvvIzlj6/ku6XmmK/kuLTml7blm77lsYLpm4bvvIzkuZ/lj6/ku6XmmK/lvZPliY3lnLDlm77kuK3lm77lsYLnmoTnu4TlkIhcclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWRpcmVjdD1mYWxzZV0gLSDmmK/lkKbph43lrprlkJHvvIzlpoLmnpzkuLogdHJ1Ze+8jOWImeWwhuivt+axgumHjeWumuWQkeWIsOeTpueJh+eahOecn+WunuWcsOWdgO+8m+WmguaenOS4uiBmYWxzZe+8jOWImeWTjeW6lOS9k+S4reaYr+eTpueJh+eahOWtl+iKgua1geOAglxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYW5zcGFyZW50PXRydWVdIC0g5piv5ZCm6IOM5pmv6YCP5piO44CCXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2FjaGVFbmFibGVkPXRydWVdIC0g5ZCv55So57yT5a2Y44CCXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xpcFJlZ2lvbkVuYWJsZWQ9ZmFsc2VdIC0g5piv5ZCm5ZCv55So5Zyw5Zu+6KOB5Ymq44CCXHJcbiAqIEBwYXJhbSB7TC5QYXRofSBbb3B0aW9ucy5jbGlwUmVnaW9uXSAtIOWcsOWbvuaYvuekuuijgeWJqueahOWMuuWfn+OAguaYr+S4gOS4qumdouWvueixoe+8jOW9kyBjbGlwUmVnaW9uRW5hYmxlZCA9IHRydWUg5pe25pyJ5pWI77yM5Y2z5Zyw5Zu+5Y+q5pi+56S66K+l5Yy65Z+f6KaG55uW55qE6YOo5YiG44CCXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wcmpDb29yZFN5c10gLSDor7fmsYLnmoTlnLDlm77nmoTlnZDmoIflj4LogIPns7vnu5/jgIIg5aaC77yacHJqQ29vcmRTeXM9e1wiZXBzZ0NvZGVcIjozODU3feOAglxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm92ZXJsYXBEaXNwbGF5ZWQ9ZmFsc2VdIC0g5Zyw5Zu+5a+56LGh5Zyo5ZCM5LiA6IyD5Zu05YaF5pe277yM5piv5ZCm6YeN5Y+g5pi+56S644CCXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vdmVybGFwRGlzcGxheWVkT3B0aW9uc10gLSDpgb/lhY3lnLDlm77lr7nosaHljovnm5bmmL7npLrnmoTov4fmu6TpgInpobnjgIJcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRpbGV2ZXJzaW9uXSAtIOWIh+eJh+eJiOacrOWQjeensO+8jGNhY2hlRW5hYmxlZCDkuLogdHJ1ZSDml7bmnInmlYjjgILlpoLmnpzmsqHmnInorr7nva4gdGlsZXZlcnNpb24g5Y+C5pWw77yM6ICM5LiU5b2T5YmN5Zyw5Zu+55qE5YiH54mH6ZuG5Lit5a2Y5Zyo5aSa5Liq54mI5pys77yM5YiZ6buY6K6k5L2/55So5pyA5ZCO5LiA5Liq5pu05paw54mI5pys44CCXHJcbiAqIEBwYXJhbSB7Q1JTfSBbb3B0aW9ucy5jcnNdIC0g5Z2Q5qCH57O757uf57G744CCXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aWxlUHJveHldIC0g5pyN5Yqh5Luj55CG5Zyw5Z2A44CCXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mb3JtYXQ9J3BuZyddIC0g55Om54mH6KGo6L+w57G75Z6L77yM5pSv5oyBIFwicG5nXCIg44CBXCJ3ZWJwXCLjgIFcImJtcFwiIOOAgVwianBnXCLjgIEgXCJnaWZcIiDnrYnlm77niYfmoLzlvI/jgIJcclxuICogQHBhcmFtIHsobnVtYmVyfEwuUG9pbnQpfSBbb3B0aW9ucy50aWxlU2l6ZT0yNTZdIC0g55Om54mH5aSn5bCP44CCXHJcbiAqIEBwYXJhbSB7KE5EVklQYXJhbWV0ZXJ8SGlsbHNoYWRlUGFyYW1ldGVyKX0gW29wdGlvbnMucmFzdGVyZnVuY3Rpb25dIC0g5qCF5qC85YiG5p6Q5Y+C5pWw44CCXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hdHRyaWJ1dGlvbj0nTWFwIERhdGEgPHNwYW4+wqkgPGEgaHJlZj0naHR0cDovL3N1cHBvcnQuc3VwZXJtYXAuY29tLmNuL3Byb2R1Y3QvaVNlcnZlci5hc3B4JyB0aXRsZT0nU3VwZXJNYXAgaVNlcnZlcicgdGFyZ2V0PSdfYmxhbmsnPlN1cGVyTWFwIGlTZXJ2ZXI8L2E+PC9zcGFuPiddIC0g54mI5p2D5L+h5oGv44CCXHJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHRpb25zLnN1YmRvbWFpbnNdIC0g5a2Q5Z+f5ZCN5pWw57uE44CCXHJcbiAqIEBmaXJlcyBUaWxlZE1hcExheWVyI3RpbGVzZXRzaW5mb2xvYWRlZFxyXG4gKiBAZmlyZXMgVGlsZWRNYXBMYXllciN0aWxldmVyc2lvbnNjaGFuZ2VkXHJcbiAqIEB1c2FnZVxyXG4gKi9cclxuZXhwb3J0IHZhciBUaWxlZE1hcExheWVyID0gTC5UaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgLy/lpoLmnpzmnIlsYXllcnNJRO+8jOWImeaYr+WcqOS9v+eUqOS4k+mimOWbvlxyXG4gICAgICAgIGxheWVyc0lEOiBudWxsLFxyXG4gICAgICAgIC8v5aaC5p6c5Li6IHRydWXvvIzliJnlsIbor7fmsYLph43lrprlkJHliLDnk6bniYfnmoTnnJ/lrp7lnLDlnYDvvJvlpoLmnpzkuLogZmFsc2XvvIzliJnlk43lupTkvZPkuK3mmK/nk6bniYfnmoTlrZfoioLmtYFcclxuICAgICAgICByZWRpcmVjdDogZmFsc2UsXHJcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAgICAgICAgY2FjaGVFbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIGNsaXBSZWdpb25FbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAvL+WcsOWbvuaYvuekuuijgeWJqueahOWMuuWfn1xyXG4gICAgICAgIGNsaXBSZWdpb246IG51bGwsXHJcbiAgICAgICAgLy/or7fmsYLnmoTlnLDlm77nmoTlnZDmoIflj4LogIPns7vnu5/jgIIg5aaC77yacHJqQ29vcmRTeXM9e1wiZXBzZ0NvZGVcIjozODU3fVxyXG4gICAgICAgIHByakNvb3JkU3lzOiBudWxsLFxyXG4gICAgICAgIC8v5Zyw5Zu+5a+56LGh5Zyo5ZCM5LiA6IyD5Zu05YaF5pe277yM5piv5ZCm6YeN5Y+g5pi+56S6XHJcbiAgICAgICAgb3ZlcmxhcERpc3BsYXllZDogZmFsc2UsXHJcbiAgICAgICAgLy/pgb/lhY3lnLDlm77lr7nosaHljovnm5bmmL7npLrnmoTov4fmu6TpgInpoblcclxuICAgICAgICBvdmVybGFwRGlzcGxheWVkT3B0aW9uczogbnVsbCxcclxuICAgICAgICAvL+WIh+eJh+eJiOacrOWQjeensO+8jGNhY2hlRW5hYmxlZCDkuLogdHJ1ZSDml7bmnInmlYjjgIJcclxuICAgICAgICB0aWxldmVyc2lvbjogbnVsbCxcclxuICAgICAgICBjcnM6IG51bGwsXHJcbiAgICAgICAgZm9ybWF0OiAncG5nJyxcclxuICAgICAgICAvL+WQr+eUqOaJmOeuoeWcsOWdgOOAglxyXG4gICAgICAgIHRpbGVQcm94eTpudWxsLFxyXG4gICAgICAgIGF0dHJpYnV0aW9uOiBBdHRyaWJ1dGlvbnMuQ29tbW9uLmF0dHJpYnV0aW9uLFxyXG4gICAgICAgIHN1YmRvbWFpbnM6IG51bGxcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcclxuICAgICAgICBMLlRpbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICBMLnN0YW1wKHRoaXMpO1xyXG5cclxuICAgICAgICAvL+W9k+WJjeWIh+eJh+WcqOWIh+eJh+mbhuS4reeahGluZGV4XHJcbiAgICAgICAgdGhpcy50aWxlU2V0c0luZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy50ZW1wSW5kZXggPSAtMTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGZ1bmN0aW9uIFRpbGVkTWFwTGF5ZXIucHJvdG90eXBlLm9uQWRkXHJcbiAgICAgKiBAZGVzY3JpcHRpb24g5re75Yqg5Zyw5Zu+44CCXHJcbiAgICAgKiBAcGFyYW0ge0wuTWFwfSBtYXAgLSBMZWFmbGV0IE1hcCDlr7nosaHjgIJcclxuICAgICAqL1xyXG4gICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICB0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuICAgICAgICBMLlRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBUaWxlZE1hcExheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsXHJcbiAgICAgKiBAZGVzY3JpcHRpb24g5qC55o2u6KGM5YiX5Y+36I635Y+W55Om54mH5Zyw5Z2A44CCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29vcmRzIC0g6KGM5YiX5Y+344CCXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSDnk6bniYflnLDlnYDjgIJcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0U2NhbGVGcm9tQ29vcmRzKGNvb3Jkcyk7XHJcbiAgICAgICAgdmFyIGxheWVyVXJsID0gdGhpcy5fZ2V0TGF5ZXJVcmwoKTtcclxuICAgICAgICB2YXIgdGlsZVVybCA9IGxheWVyVXJsICsgXCImc2NhbGU9XCIgKyBzY2FsZSArIFwiJng9XCIgKyBjb29yZHMueCArIFwiJnk9XCIgKyBjb29yZHMueTtcclxuICAgICAgICAvL+aUr+aMgeS7o+eQhlxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGlsZVByb3h5KSB7XHJcbiAgICAgICAgICAgIHRpbGVVcmwgPSB0aGlzLm9wdGlvbnMudGlsZVByb3h5ICsgZW5jb2RlVVJJQ29tcG9uZW50KHRpbGVVcmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5jYWNoZUVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGlsZVVybCArPSBcIiZfdD1cIiArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN1YmRvbWFpbnMpIHtcclxuICAgICAgICAgICAgdGlsZVVybCA9IEwuVXRpbC50ZW1wbGF0ZSh0aWxlVXJsLCB7czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3Jkcyl9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRpbGVVcmw7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIFRpbGVkTWFwTGF5ZXIucHJvdG90eXBlLmdldFNjYWxlXHJcbiAgICAgKiBAZGVzY3JpcHRpb24g5qC55o2u57yp5pS+57qn5Yir6I635Y+W5q+U5L6L5bC644CCXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSAtIOe8qeaUvue6p+WIq+OAglxyXG4gICAgICogQHJldHVybnMge251bWJlcn0g5q+U5L6L5bC644CCXHJcbiAgICAgKi9cclxuICAgIGdldFNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgLy/ov5Tlm57lvZPliY3mr5TkvovlsLpcclxuICAgICAgICB2YXIgeiA9IHpvb20gfHwgbWUuX21hcC5nZXRab29tKCk7XHJcbiAgICAgICAgcmV0dXJuIG1lLnNjYWxlc1t6XTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gVGlsZWRNYXBMYXllci5wcm90b3R5cGUuZ2V0U2NhbGVGcm9tQ29vcmRzXHJcbiAgICAgKiBAZGVzY3JpcHRpb24g6YCa6L+H6KGM5YiX5Y+36I635Y+W5q+U5L6L5bC644CCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29vcmRzIC0g6KGM5YiX5Y+344CCXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSDmr5TkvovlsLrjgIJcclxuICAgICAqL1xyXG4gICAgZ2V0U2NhbGVGcm9tQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcbiAgICAgICAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgICAgICAgc2NhbGU7XHJcbiAgICAgICAgaWYgKG1lLnNjYWxlcyAmJiBtZS5zY2FsZXNbY29vcmRzLnpdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZS5zY2FsZXNbY29vcmRzLnpdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZS5zY2FsZXMgPSBtZS5zY2FsZXMgfHwge307XHJcbiAgICAgICAgc2NhbGUgPSBtZS5nZXREZWZhdWx0U2NhbGUoY29vcmRzKTtcclxuICAgICAgICBtZS5zY2FsZXNbY29vcmRzLnpdID0gc2NhbGU7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZnVuY3Rpb24gVGlsZWRNYXBMYXllci5wcm90b3R5cGUuZ2V0RGVmYXVsdFNjYWxlXHJcbiAgICAgKiBAZGVzY3JpcHRpb24g6I635Y+W6buY6K6k5q+U5L6L5bC65L+h5oGv44CCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29vcmRzIC0g5Z2Q5qCH5a+56LGh5Y+C5pWw44CCXHJcbiAgICAgKi9cclxuICAgIGdldERlZmF1bHRTY2FsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG4gICAgICAgIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgICAgICAgIGNycyA9IG1lLl9jcnM7XHJcbiAgICAgICAgaWYgKGNycy5zY2FsZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNycy5zY2FsZXNbY29vcmRzLnpdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlQm91bmRzID0gbWUuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xyXG4gICAgICAgICAgICB2YXIgbmUgPSBjcnMucHJvamVjdCh0aWxlQm91bmRzLmdldE5vcnRoRWFzdCgpKTtcclxuICAgICAgICAgICAgdmFyIHN3ID0gY3JzLnByb2plY3QodGlsZUJvdW5kcy5nZXRTb3V0aFdlc3QoKSk7XHJcbiAgICAgICAgICAgIHZhciB0aWxlU2l6ZSA9IG1lLm9wdGlvbnMudGlsZVNpemU7XHJcbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhuZS54IC0gc3cueCkgLyB0aWxlU2l6ZSxcclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKG5lLnkgLSBzdy55KSAvIHRpbGVTaXplXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHZhciBtYXBVbml0ID0gVW5pdC5NRVRFUjtcclxuICAgICAgICAgICAgaWYgKGNycy5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBjcnMuY29kZS5zcGxpdCgnOicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5ICYmIGFycmF5Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHBhcnNlSW50KGFycmF5WzFdKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXBVbml0ID0gY29kZSAmJiBjb2RlID49IDQwMDAgJiYgY29kZSA8PSA1MDAwID8gVW5pdC5ERUdSRUUgOiBVbml0Lk1FVEVSO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBVdGlsLnJlc29sdXRpb25Ub1NjYWxlKHJlc29sdXRpb24sIDk2LCBtYXBVbml0KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBUaWxlZE1hcExheWVyLnByb3RvdHlwZS5zZXRUaWxlU2V0c0luZm9cclxuICAgICAqIEBkZXNjcmlwdGlvbiDorr7nva7nk6bniYfpm4bkv6Hmga/jgIJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aWxlU2V0cyAtIOeTpueJh+WvueixoembhuOAglxyXG4gICAgICovXHJcbiAgICBzZXRUaWxlU2V0c0luZm86IGZ1bmN0aW9uICh0aWxlU2V0cykge1xyXG4gICAgICAgIHRoaXMudGlsZVNldHMgPSB0aWxlU2V0cztcclxuICAgICAgICBpZiAoTC5VdGlsLmlzQXJyYXkodGhpcy50aWxlU2V0cykpIHtcclxuICAgICAgICAgICAgdGhpcy50aWxlU2V0cyA9IHRoaXMudGlsZVNldHNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy50aWxlU2V0cykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBldmVudCBUaWxlZE1hcExheWVyI3RpbGVzZXRzaW5mb2xvYWRlZFxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDnk6bniYfpm4bkv6Hmga/orr7nva7lrozmiJDlkI7op6blj5HjgIJcclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxPYmplY3Q+fSB0aWxlVmVyc2lvbnMgIC0g55Om54mH6ZuG5L+h5oGv44CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlc2V0c2luZm9sb2FkZWQnLCB7XHJcbiAgICAgICAgICAgIHRpbGVWZXJzaW9uczogdGhpcy50aWxlU2V0cy50aWxlVmVyc2lvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNoYW5nZVRpbGVzVmVyc2lvbigpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBUaWxlZE1hcExheWVyLnByb3RvdHlwZS5sYXN0VGlsZXNWZXJzaW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24g6K+35rGC5LiK5LiA5Liq54mI5pys5YiH54mH77yM5bm26YeN5paw57uY5Yi244CCXHJcbiAgICAgKi9cclxuICAgIGxhc3RUaWxlc1ZlcnNpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRlbXBJbmRleCA9IHRoaXMudGlsZVNldHNJbmRleCAtIDE7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VUaWxlc1ZlcnNpb24oKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gVGlsZWRNYXBMYXllci5wcm90b3R5cGUubmV4dFRpbGVzVmVyc2lvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIOivt+axguS4i+S4gOS4queJiOacrOWIh+eJh++8jOW5tumHjeaWsOe7mOWItuOAglxyXG4gICAgICovXHJcbiAgICBuZXh0VGlsZXNWZXJzaW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50ZW1wSW5kZXggPSB0aGlzLnRpbGVTZXRzSW5kZXggKyAxO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlVGlsZXNWZXJzaW9uKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIFRpbGVkTWFwTGF5ZXIucHJvdG90eXBlLmNoYW5nZVRpbGVzVmVyc2lvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIOWIh+aNouWIsOafkOS4gOeJiOacrOeahOWIh+eJh++8jOW5tumHjee7mOOAgumAmui/hyB0aGlzLnRlbXBJbmRleCDkv53lrZjpnIDopoHliIfmjaLnmoTniYjmnKzntKLlvJVcclxuICAgICAqL1xyXG4gICAgY2hhbmdlVGlsZXNWZXJzaW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgICAvL+WIh+eJh+eJiOacrOmbhuS/oeaBr+aYr+WQpuWtmOWcqFxyXG4gICAgICAgIGlmIChtZS50aWxlU2V0cyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8v54mI5pys5L+h5oGv5Li656m677yM6YeN5paw5p+l6K+i77yM5p+l6K+i5oiQ5Yqf57un57ut6Lez6L2s5Yiw55u45bqU55qE54mI5pysXHJcbiAgICAgICAgICAgIC8vbWUuZ2V0VGlsZVNldHNJbmZvKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lLnRlbXBJbmRleCA9PT0gbWUudGlsZVNldHNJbmRleCB8fCB0aGlzLnRlbXBJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+ajgOa1i2luZGV45piv5ZCm5Y+v55SoXHJcbiAgICAgICAgdmFyIHRpbGVWZXJzaW9ucyA9IG1lLnRpbGVTZXRzLnRpbGVWZXJzaW9ucztcclxuICAgICAgICBpZiAodGlsZVZlcnNpb25zICYmIG1lLnRlbXBJbmRleCA8IHRpbGVWZXJzaW9ucy5sZW5ndGggJiYgbWUudGVtcEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aWxlVmVyc2lvbnNbbWUudGVtcEluZGV4XS5uYW1lO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbWUubWVyZ2VUaWxlVmVyc2lvblBhcmFtKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBtZS50aWxlU2V0c0luZGV4ID0gbWUudGVtcEluZGV4O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgVGlsZWRNYXBMYXllciN0aWxldmVyc2lvbnNjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5YiH54mH55qE54mI5pys5YiH5o2i5ZKM6YeN57uY5oiQ5Yqf5LmL5ZCO6Kem5Y+R44CCXHJcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gdGlsZVZlcnNpb24gIC0g6K+l54mI5pys55qE5YiH54mH44CCXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ3RpbGV2ZXJzaW9uc2NoYW5nZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZVZlcnNpb246IHRpbGVWZXJzaW9uc1ttZS50ZW1wSW5kZXhdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gVGlsZWRNYXBMYXllci5wcm90b3R5cGUudXBkYXRlQ3VycmVudFRpbGVTZXRzSW5kZXhcclxuICAgICAqIEBkZXNjcmlwdGlvbiDmiYvliqjorr7nva7lvZPliY3liIfniYfpm4bntKLlvJXvvIznm67liY3kuLvopoHmj5Dkvpvnu5nmjqfku7bkvb/nlKjjgIJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIOe0ouW8leWAvOOAglxyXG4gICAgICovXHJcbiAgICB1cGRhdGVDdXJyZW50VGlsZVNldHNJbmRleDogZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdGhpcy50ZW1wSW5kZXggPSBpbmRleDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gVGlsZWRNYXBMYXllci5wcm90b3R5cGUubWVyZ2VUaWxlVmVyc2lvblBhcmFtXHJcbiAgICAgKiBAZGVzY3JpcHRpb24g5pu05pS5VVJM6K+35rGC5Y+C5pWw5Lit55qE5YiH54mH54mI5pys5Y+377yM5bm26YeN57uY44CCXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiAtIOWIh+eJh+eJiOacrOWPt+OAglxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IOaYr+WQpuaIkOWKn+OAglxyXG4gICAgICovXHJcbiAgICBtZXJnZVRpbGVWZXJzaW9uUGFyYW06IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XHJcbiAgICAgICAgaWYgKHZlcnNpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UGFyYW1zW1widGlsZXZlcnNpb25cIl0gPSB2ZXJzaW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJhbXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcclxuICAgICAgICAgICAgdGhpcy5fcGFyYW1zQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBfZ2V0TGF5ZXJVcmw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcGFyYW1zQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllclVybCA9IHRoaXMuX2NyZWF0ZUxheWVyVXJsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllclVybCB8fCB0aGlzLl9jcmVhdGVMYXllclVybCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY3JlYXRlTGF5ZXJVcmw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgbGF5ZXJVcmwgPSBDb21tb25VdGlsLnVybFBhdGhBcHBlbmQodGhpcy5fdXJsLCBgdGlsZUltYWdlLiR7dGhpcy5vcHRpb25zLmZvcm1hdH1gKTtcclxuICAgICAgICB0aGlzLnJlcXVlc3RQYXJhbXMgPSB0aGlzLnJlcXVlc3RQYXJhbXMgfHwgdGhpcy5fZ2V0QWxsUmVxdWVzdFBhcmFtcygpO1xyXG4gICAgICAgIGxheWVyVXJsID0gQ29tbW9uVXRpbC51cmxBcHBlbmQobGF5ZXJVcmwsIExVdGlsLmdldFBhcmFtU3RyaW5nKHRoaXMucmVxdWVzdFBhcmFtcykpO1xyXG4gICAgICAgIGxheWVyVXJsID0gU2VjdXJpdHlNYW5hZ2VyLmFwcGVuZENyZWRlbnRpYWwobGF5ZXJVcmwpO1xyXG4gICAgICAgIHRoaXMuX2xheWVyVXJsID0gbGF5ZXJVcmw7XHJcbiAgICAgICAgcmV0dXJuIGxheWVyVXJsO1xyXG4gICAgfSxcclxuXHJcbiAgICBfZ2V0QWxsUmVxdWVzdFBhcmFtczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBtZS5vcHRpb25zIHx8IHt9LFxyXG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcclxuXHJcbiAgICAgICAgdmFyIHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xyXG4gICAgICAgIGlmICghKHRpbGVTaXplIGluc3RhbmNlb2YgTC5Qb2ludCkpIHtcclxuICAgICAgICAgICAgdGlsZVNpemUgPSBMLnBvaW50KHRpbGVTaXplLCB0aWxlU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtc1tcIndpZHRoXCJdID0gdGlsZVNpemUueDtcclxuICAgICAgICBwYXJhbXNbXCJoZWlnaHRcIl0gPSB0aWxlU2l6ZS55O1xyXG5cclxuICAgICAgICBwYXJhbXNbXCJyZWRpcmVjdFwiXSA9IG9wdGlvbnMucmVkaXJlY3QgPT09IHRydWU7XHJcbiAgICAgICAgcGFyYW1zW1widHJhbnNwYXJlbnRcIl0gPSBvcHRpb25zLnRyYW5zcGFyZW50ID09PSB0cnVlO1xyXG4gICAgICAgIHBhcmFtc1tcImNhY2hlRW5hYmxlZFwiXSA9ICEob3B0aW9ucy5jYWNoZUVuYWJsZWQgPT09IGZhbHNlKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucHJqQ29vcmRTeXMpIHtcclxuICAgICAgICAgICAgcGFyYW1zW1wicHJqQ29vcmRTeXNcIl0gPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLnByakNvb3JkU3lzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmxheWVyc0lEKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1tcImxheWVyc0lEXCJdID0gb3B0aW9ucy5sYXllcnNJRC50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2xpcFJlZ2lvbkVuYWJsZWQgJiYgb3B0aW9ucy5jbGlwUmVnaW9uKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY2xpcFJlZ2lvbiA9IFNlcnZlckdlb21ldHJ5LmZyb21HZW9tZXRyeShVdGlsLnRvU3VwZXJNYXBHZW9tZXRyeShvcHRpb25zLmNsaXBSZWdpb24pKTtcclxuICAgICAgICAgICAgcGFyYW1zW1wiY2xpcFJlZ2lvbkVuYWJsZWRcIl0gPSBvcHRpb25zLmNsaXBSZWdpb25FbmFibGVkO1xyXG4gICAgICAgICAgICBwYXJhbXNbXCJjbGlwUmVnaW9uXCJdID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jbGlwUmVnaW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8v5YiH54mH55qE6LW35aeL5Y+C6ICD54K577yM6buY6K6k5Li65Zyw5Zu+6IyD5Zu055qE5bem5LiK6KeS44CCXHJcbiAgICAgICAgdmFyIGNycyA9IG1lLl9jcnM7XHJcbiAgICAgICAgaWYgKGNycy5vcHRpb25zICYmIGNycy5vcHRpb25zLm9yaWdpbikge1xyXG4gICAgICAgICAgICBwYXJhbXNbXCJvcmlnaW5cIl0gPSBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICB4OiBjcnMub3B0aW9ucy5vcmlnaW5bMF0sXHJcbiAgICAgICAgICAgICAgICB5OiBjcnMub3B0aW9ucy5vcmlnaW5bMV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjcnMucHJvamVjdGlvbiAmJiBjcnMucHJvamVjdGlvbi5ib3VuZHMpIHtcclxuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGNycy5wcm9qZWN0aW9uLmJvdW5kcztcclxuICAgICAgICAgICAgdmFyIHRpbGVPcmlnaW4gPSBMLnBvaW50KGJvdW5kcy5taW4ueCwgYm91bmRzLm1heC55KTtcclxuICAgICAgICAgICAgcGFyYW1zW1wib3JpZ2luXCJdID0gSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgeDogdGlsZU9yaWdpbi54LFxyXG4gICAgICAgICAgICAgICAgeTogdGlsZU9yaWdpbi55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMub3ZlcmxhcERpc3BsYXllZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcGFyYW1zW1wib3ZlcmxhcERpc3BsYXllZFwiXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vdmVybGFwRGlzcGxheWVkT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zW1wib3ZlcmxhcERpc3BsYXllZE9wdGlvbnNcIl0gPSBtZS5vdmVybGFwRGlzcGxheWVkT3B0aW9ucy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyYW1zW1wib3ZlcmxhcERpc3BsYXllZFwiXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyYW1zLmNhY2hlRW5hYmxlZCA9PT0gdHJ1ZSAmJiBvcHRpb25zLnRpbGV2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1tcInRpbGV2ZXJzaW9uXCJdID0gb3B0aW9ucy50aWxldmVyc2lvbi50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5yYXN0ZXJmdW5jdGlvbikge1xyXG4gICAgICAgICAgICBwYXJhbXNbXCJyYXN0ZXJmdW5jdGlvblwiXSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMucmFzdGVyZnVuY3Rpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH1cclxufSk7XHJcblxyXG5leHBvcnQgdmFyIHRpbGVkTWFwTGF5ZXIgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IFRpbGVkTWFwTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufTtcclxuIiwiPCEtLVxyXG4gKiBAQXV0aG9yOiB6dWxlemhlXHJcbiAqIEBEYXRlOiAyMDIyLTA4LTIyIDE4OjIwOjQ3XHJcbiAqIEBMYXN0RWRpdG9yczogenVsZXpoZVxyXG4gKiBATGFzdEVkaXRUaW1lOiAyMDIyLTA4LTI0IDExOjQ1OjUwXHJcbiAqIEBQYXRoOiBodHRwczovL2dpdGVlLmNvbS96dWxlemhlL1xyXG4gKiBARGVzY3JpcHRpb246IFxyXG4tLT5cclxuPHRlbXBsYXRlPlxyXG4gIDxkaXYgOmNsYXNzPVwiWyd3Y3gtbWFwLWNvbnRhaW5lcicsIGN1c3RvbUNsYXNzXVwiIDppZD1cImVsXCI+XHJcbiAgICA8dGVtcGxhdGUgdi1pZj1cIm1hcFwiPlxyXG4gICAgICA8c2xvdCA6bWFwPVwibWFwXCI+PC9zbG90PlxyXG4gICAgPC90ZW1wbGF0ZT5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuaW1wb3J0IEwgZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCB7IFRpbGVkTWFwTGF5ZXIgfSBmcm9tICdAc3VwZXJtYXAvaWNsaWVudC1sZWFmbGV0JztcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGNvbXBvbmVudHM6IHt9LFxyXG4gIHByb3BzOiB7XHJcbiAgICBjdXN0b21DbGFzczoge1xyXG4gICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgIGRlZmF1bHQ6ICd3Y3gtY3VzdG9tLW1hcCdcclxuICAgIH0sXHJcbiAgICBlbDoge1xyXG4gICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgIGRlZmF1bHQ6ICdtYXAnXHJcbiAgICB9LFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICB0eXBlOiBPYmplY3QsXHJcbiAgICAgIGRlZmF1bHQ6ICgpID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgY2VudGVyOiBbMzQuNzU5MTk3LCAxMTMuNzc4NTg0XSxcclxuICAgICAgICAgIHpvb206IDEwLFxyXG4gICAgICAgICAgbWluWm9vbTogNCxcclxuICAgICAgICAgIG1heFpvb206IDE2XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1hcDogbnVsbFxyXG4gICAgfTtcclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7fSxcclxuICBjcmVhdGVkKCkge30sXHJcbiAgbW91bnRlZCgpIHtcclxuICAgIHRoaXMuaW5pdE1hcCgpO1xyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgaW5pdE1hcCgpIHtcclxuICAgICAgbGV0IENoaW5hID0gbmV3IFRpbGVkTWFwTGF5ZXIoJ2h0dHBzOi8vaXNlcnZlci5zdXBlcm1hcC5pby9pc2VydmVyL3NlcnZpY2VzL21hcC1jaGluYTQwMC9yZXN0L21hcHMvQ2hpbmEnLCB7IG5vV3JhcDogdHJ1ZSB9KTtcclxuICAgICAgbGV0IENoaW5hRGFyayA9IG5ldyBUaWxlZE1hcExheWVyKCdodHRwczovL2lzZXJ2ZXIuc3VwZXJtYXAuaW8vaXNlcnZlci9zZXJ2aWNlcy9tYXAtY2hpbmE0MDAvcmVzdC9tYXBzL0NoaW5hRGFyaycsIHsgbm9XcmFwOiB0cnVlIH0pO1xyXG4gICAgICBsZXQgYXJjZ2lzID0gTC50aWxlTGF5ZXIoJ2h0dHBzOi8vc2VydmVyLmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvV29ybGRfSW1hZ2VyeS9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fScpO1xyXG4gICAgICB2YXIgbGFiZWxUZXh0Q29sbGlzaW9uID0gbmV3IEwuTGFiZWxUZXh0Q29sbGlzaW9uKHtcclxuICAgICAgICBjb2xsaXNpb25GbGc6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIHdpbmRvdy5tYXAgPSB0aGlzLm1hcCA9IEwubWFwKHRoaXMuZWwsIHtcclxuICAgICAgICAuLi50aGlzLm9wdGlvbnMsXHJcbiAgICAgICAgbGF5ZXJzOiBbQ2hpbmFdLFxyXG4gICAgICAgIHJlbmRlcmVyOiBsYWJlbFRleHRDb2xsaXNpb25cclxuICAgICAgfSk7XHJcbiAgICAgIGxldCBiYXNlTWFwcyA9IHtcclxuICAgICAgICBDaGluYTogQ2hpbmEsXHJcbiAgICAgICAgQ2hpbmFEYXJrOiBDaGluYURhcmssXHJcbiAgICAgICAgYXJjZ2lzOiBhcmNnaXNcclxuICAgICAgfTtcclxuICAgICAgTC5jb250cm9sLmxheWVycyhiYXNlTWFwcykuYWRkVG8odGhpcy5tYXApO1xyXG4gICAgICB0aGlzLiRlbWl0KCdtYXBDb21wbGV0ZScsIHRoaXMubWFwKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbjwvc2NyaXB0PlxyXG48c3R5bGUgc2NvcGVkIGxhbmc9XCJsZXNzXCI+XHJcbi53Y3gtbWFwLWNvbnRhaW5lciB7XHJcbiAgd2lkdGg6IDEwMCU7XHJcbiAgaGVpZ2h0OiAxMDAlO1xyXG59XHJcbjwvc3R5bGU+XHJcbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTMtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50KFxuICBzY3JpcHRFeHBvcnRzLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIgLyogc2VydmVyIG9ubHkgKi8sXG4gIHNoYWRvd01vZGUgLyogdnVlLWNsaSBvbmx5ICovXG4pIHtcbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9XG4gICAgdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbicgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnMgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHtcbiAgICAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IHNoYWRvd01vZGVcbiAgICAgID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluamVjdFN0eWxlcy5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIChvcHRpb25zLmZ1bmN0aW9uYWwgPyB0aGlzLnBhcmVudCA6IHRoaXMpLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3RcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbihoLCBjb250ZXh0KSB7XG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIHZhciBleGlzdGluZyA9IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKSA6IFtob29rXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cbiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWZhZDRiZDhlJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWZhZDRiZDhlJnByb2Qmc2NvcGVkPXRydWUmbGFuZz1sZXNzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCJmYWQ0YmQ4ZVwiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsInZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKXt2YXIgX3ZtPXRoaXMsX2M9X3ZtLl9zZWxmLl9jO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ3Y3gtdGFibGUtY29udGFpbmVyXCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ3Y3gtdGFibGUtZm9sZFwiLG9uOntcImNsaWNrXCI6X3ZtLmhhbmRkbGVGb2xkfX0sW19jKCdpbWcnLHtjbGFzczpfdm0uaXNPcGVuID8gJ29wZW4nIDogJycsYXR0cnM6e1wic3JjXCI6cmVxdWlyZSgnQC9hc3NldHMvaW1hZ2VzL25leHQtYmcucG5nJyksXCJhbHRcIjpcIlwifX0pXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwid2N4LXRhYmxlLWNvbnRlbnRcIixjbGFzczpbX3ZtLmlzT3BlbiA/ICdvcGVuJyA6ICcnXX0sW19jKCdlbC10YWJsZScse2RpcmVjdGl2ZXM6W3tuYW1lOlwibG9hZGluZ1wiLHJhd05hbWU6XCJ2LWxvYWRpbmdcIix2YWx1ZTooX3ZtLmxvYWRpbmcpLGV4cHJlc3Npb246XCJsb2FkaW5nXCJ9XSxzdGF0aWNTdHlsZTp7XCJ3aWR0aFwiOlwiMTAwJVwifSxhdHRyczp7XCJkYXRhXCI6X3ZtLnRhYmxlTGlzdH0sb246e1wicm93LWNsaWNrXCI6X3ZtLnJvd0NsaWNrfX0sW19jKCdlbC10YWJsZS1jb2x1bW4nLHthdHRyczp7XCJ0eXBlXCI6XCLorr7nva7nsbvlnotcIixcInByb3BcIjpcIm5hbWVcIixcImxhYmVsXCI6XCLlkI3np7BcIn19KSxfYygnZWwtdGFibGUtY29sdW1uJyx7YXR0cnM6e1widHlwZVwiOlwi6K6+572u57G75Z6LXCIsXCJwcm9wXCI6XCJwcm92aW5jZVwiLFwibGFiZWxcIjpcIuaJgOWxnuecgeS7vVwifX0pLF9jKCdlbC10YWJsZS1jb2x1bW4nLHthdHRyczp7XCJ0eXBlXCI6XCLorr7nva7nsbvlnotcIixcImxhYmVsXCI6XCLnvJbnoIFcIixcInByb3BcIjpcImNvZGVcIn19KSxfYygnZWwtdGFibGUtY29sdW1uJyx7YXR0cnM6e1widHlwZVwiOlwi6K6+572u57G75Z6LXCIsXCJsYWJlbFwiOlwi57uP5bqmXCIsXCJwcm9wXCI6XCJsYXRcIn19KSxfYygnZWwtdGFibGUtY29sdW1uJyx7YXR0cnM6e1widHlwZVwiOlwi6K6+572u57G75Z6LXCIsXCJsYWJlbFwiOlwi57qs5bqmXCIsXCJwcm9wXCI6XCJsbmdcIn19KSxfYygnZWwtdGFibGUtY29sdW1uJyx7YXR0cnM6e1widHlwZVwiOlwi6K6+572u57G75Z6LXCIsXCJsYWJlbFwiOlwi5rW35ouUXCIsXCJwcm9wXCI6XCJoZWlnaHRcIn19KV0sMSksX2MoJ2VsLXBhZ2luYXRpb24nLHthdHRyczp7XCJwYWdlLXNpemVcIjpfdm0ucGFyYW1zLnNpemUsXCJjdXJyZW50LXBhZ2VcIjpfdm0ucGFyYW1zLnBhZ2VOdW1iZXIsXCJsYXlvdXRcIjpcInByZXYsIHBhZ2VyLCBuZXh0XCIsXCJ0b3RhbFwiOl92bS5wYXJhbXMudG90YWx9LG9uOntcImN1cnJlbnQtY2hhbmdlXCI6X3ZtLmN1cnJlbnRDaGFuZ2V9fSldLDEpXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPCEtLVxuICogQEF1dGhvcjogenVsZXpoZVxuICogQERhdGU6IDIwMjItMDgtMjIgMjM6MDk6MzZcbiAqIEBMYXN0RWRpdG9yczogenVsZXpoZVxuICogQExhc3RFZGl0VGltZTogMjAyMi0wOC0yNCAxMzoyNjoxNlxuICogQFBhdGg6IGh0dHBzOi8vZ2l0ZWUuY29tL3p1bGV6aGUvXG4gKiBARGVzY3JpcHRpb246IFxuLS0+XG48dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJ3Y3gtdGFibGUtY29udGFpbmVyXCI+XG4gICAgPGRpdiBjbGFzcz1cIndjeC10YWJsZS1mb2xkXCIgQGNsaWNrPVwiaGFuZGRsZUZvbGRcIj5cbiAgICAgIDxpbWcgOmNsYXNzPVwiaXNPcGVuID8gJ29wZW4nIDogJydcIiA6c3JjPVwicmVxdWlyZSgnQC9hc3NldHMvaW1hZ2VzL25leHQtYmcucG5nJylcIiBhbHQ9XCJcIiAvPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ3Y3gtdGFibGUtY29udGVudFwiIDpjbGFzcz1cIltpc09wZW4gPyAnb3BlbicgOiAnJ11cIj5cbiAgICAgIDxlbC10YWJsZSA6ZGF0YT1cInRhYmxlTGlzdFwiIHN0eWxlPVwid2lkdGg6IDEwMCVcIiB2LWxvYWRpbmc9XCJsb2FkaW5nXCIgQHJvdy1jbGljaz1cInJvd0NsaWNrXCI+XG4gICAgICAgIDxlbC10YWJsZS1jb2x1bW4gdHlwZT1cIuiuvue9ruexu+Wei1wiIHByb3A9XCJuYW1lXCIgbGFiZWw9XCLlkI3np7BcIj4gPC9lbC10YWJsZS1jb2x1bW4+XG4gICAgICAgIDxlbC10YWJsZS1jb2x1bW4gdHlwZT1cIuiuvue9ruexu+Wei1wiIHByb3A9XCJwcm92aW5jZVwiIGxhYmVsPVwi5omA5bGe55yB5Lu9XCI+IDwvZWwtdGFibGUtY29sdW1uPlxuICAgICAgICA8ZWwtdGFibGUtY29sdW1uIHR5cGU9XCLorr7nva7nsbvlnotcIiBsYWJlbD1cIue8lueggVwiIHByb3A9XCJjb2RlXCI+IDwvZWwtdGFibGUtY29sdW1uPlxuICAgICAgICA8ZWwtdGFibGUtY29sdW1uIHR5cGU9XCLorr7nva7nsbvlnotcIiBsYWJlbD1cIue7j+W6plwiIHByb3A9XCJsYXRcIj4gPC9lbC10YWJsZS1jb2x1bW4+XG4gICAgICAgIDxlbC10YWJsZS1jb2x1bW4gdHlwZT1cIuiuvue9ruexu+Wei1wiIGxhYmVsPVwi57qs5bqmXCIgcHJvcD1cImxuZ1wiPiA8L2VsLXRhYmxlLWNvbHVtbj5cbiAgICAgICAgPGVsLXRhYmxlLWNvbHVtbiB0eXBlPVwi6K6+572u57G75Z6LXCIgbGFiZWw9XCLmtbfmi5RcIiBwcm9wPVwiaGVpZ2h0XCI+IDwvZWwtdGFibGUtY29sdW1uPlxuICAgICAgPC9lbC10YWJsZT5cbiAgICAgIDxlbC1wYWdpbmF0aW9uIDpwYWdlLXNpemU9XCJwYXJhbXMuc2l6ZVwiIDpjdXJyZW50LXBhZ2U9XCJwYXJhbXMucGFnZU51bWJlclwiIGxheW91dD1cInByZXYsIHBhZ2VyLCBuZXh0XCIgOnRvdGFsPVwicGFyYW1zLnRvdGFsXCIgQGN1cnJlbnQtY2hhbmdlPVwiY3VycmVudENoYW5nZVwiPiA8L2VsLXBhZ2luYXRpb24+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgcGFyYW1zOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFnZVNpemU6IDEwLFxuICAgICAgICAgIHBhZ2VOdW1iZXI6IDEsXG4gICAgICAgICAgdG90YWw6IDEwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB0YWJsZUxpc3Q6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2FkaW5nOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50czoge30sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzT3BlbjogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7fSxcbiAgY3JlYXRlZCgpIHt9LFxuICBtb3VudGVkKCkge30sXG4gIG1ldGhvZHM6IHtcbiAgICBjdXJyZW50Q2hhbmdlKHZhbCkge1xuICAgICAgdGhpcy4kZW1pdCgnY3VycmVudENoYW5nZScsIHZhbCk7XG4gICAgfSxcbiAgICBoYW5kZGxlRm9sZCgpIHtcbiAgICAgIHRoaXMuaXNPcGVuID0gIXRoaXMuaXNPcGVuO1xuICAgIH0sXG4gICAgcm93Q2xpY2socm93LCBjb2x1bW4sIGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdyb3dDbGljaycsIHJvdywgY29sdW1uLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuPC9zY3JpcHQ+XG48c3R5bGUgc2NvcGVkIGxhbmc9XCJsZXNzXCI+XG4ud2N4LXRhYmxlLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgei1pbmRleDogOTk5OTtcbiAgd2lkdGg6IDEwMCU7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIGJvdHRvbTogMDtcbiAgLndjeC10YWJsZS1mb2xkIHtcbiAgICB3aWR0aDogNTBweDtcbiAgICBoZWlnaHQ6IDMwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogOHB4IDhweCAwIDA7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2FhYTtcbiAgICBib3JkZXItYm90dG9tOiAwO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBpbWcge1xuICAgICAgdHJhbnNpdGlvbjogYWxsIDAuNXMgZWFzZS1pbi1vdXQ7XG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xuICAgICAgJi5vcGVuIHtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC53Y3gtdGFibGUtY29udGVudCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2FhYTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2UtaW4tb3V0O1xuICAgIGhlaWdodDogMHB4O1xuICAgICYub3BlbiB7XG4gICAgICBoZWlnaHQ6IDMzMHB4O1xuICAgIH1cbiAgfVxufVxuPC9zdHlsZT5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMy0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTMtMCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTJkZTNhMTAxJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTJkZTNhMTAxJnByb2Qmc2NvcGVkPXRydWUmbGFuZz1sZXNzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIyZGUzYTEwMVwiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsInZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKXt2YXIgX3ZtPXRoaXMsX2M9X3ZtLl9zZWxmLl9jO3JldHVybiBfYygnZGl2Jylcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPCEtLVxyXG4gKiBAQXV0aG9yOiB6dWxlemhlXHJcbiAqIEBEYXRlOiAyMDIyLTA4LTIzIDA5OjI1OjExXHJcbiAqIEBMYXN0RWRpdG9yczogenVsZXpoZVxyXG4gKiBATGFzdEVkaXRUaW1lOiAyMDIyLTA4LTIzIDIxOjU2OjMwXHJcbiAqIEBQYXRoOiBodHRwczovL2dpdGVlLmNvbS96dWxlemhlL1xyXG4gKiBARGVzY3JpcHRpb246IFxyXG4tLT5cclxuPHRlbXBsYXRlPlxyXG4gIDxkaXY+PC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmltcG9ydCAnQGdlb21hbi1pby9sZWFmbGV0LWdlb21hbi1mcmVlJztcclxuaW1wb3J0ICdAZ2VvbWFuLWlvL2xlYWZsZXQtZ2VvbWFuLWZyZWUvZGlzdC9sZWFmbGV0LWdlb21hbi5jc3MnO1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ0RyYXdUb29sJyxcclxuICBwcm9wczoge1xyXG4gICAgbWFwOiB7XHJcbiAgICAgIHR5cGU6IE9iamVjdCxcclxuICAgICAgZGVmYXVsdDogKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH0sXHJcbiAgbW91bnRlZCgpIHtcclxuICAgIHRoaXMubWFwLnBtLmFkZENvbnRyb2xzKHtcclxuICAgICAgcG9zaXRpb246ICd0b3BsZWZ0JyxcclxuICAgICAgZHJhd1BvbHlnb246IHRydWUsIC8vIOa3u+WKoOe7mOWItuWkmui+ueW9olxyXG4gICAgICBkcmF3TWFya2VyOiB0cnVlLCAvL+a3u+WKoOaMiemSruS7pee7mOWItuagh+iusFxyXG4gICAgICBkcmF3Q2lyY2xlTWFya2VyOiB0cnVlLCAvL+a3u+WKoOaMiemSruS7pee7mOWItuWchuW9ouagh+iusFxyXG4gICAgICBkcmF3UG9seWxpbmU6IHRydWUsIC8v5re75Yqg5oyJ6ZKu57uY5Yi257q/5p2hXHJcbiAgICAgIGRyYXdSZWN0YW5nbGU6IHRydWUsIC8v5re75Yqg5oyJ6ZKu57uY5Yi255+p5b2iXHJcbiAgICAgIGRyYXdDaXJjbGU6IHRydWUsIC8vICDmt7vliqDmjInpkq7nu5jliLblnIblnIhcclxuICAgICAgZWRpdE1vZGU6IHRydWUsIC8vICDmt7vliqDmjInpkq7nvJbovpHlpJrovrnlvaJcclxuICAgICAgZHJhZ01vZGU6IHRydWUsIC8vICAg5re75Yqg5oyJ6ZKu5ouW5Yqo5aSa6L655b2iXHJcbiAgICAgIGN1dFBvbHlnb246IHRydWUsIC8vIOa3u+WKoOS4gOS4quaMiemSruS7peWIoOmZpOWbvuWxgumHjOmdoueahOmDqOWIhuWGheWuuVxyXG4gICAgICByZW1vdmFsTW9kZTogdHJ1ZSAvLyDmuIXpmaTlm77lsYJcclxuICAgIH0pO1xyXG4gICAgLy8g6K6+572u57uY5Yi25ZCO55qE57q/5p2h6aKc6Imy562JXHJcbiAgICB0aGlzLm1hcC5wbS5zZXRQYXRoT3B0aW9ucyh7XHJcbiAgICAgIGNvbG9yOiAnYmx1ZScsXHJcbiAgICAgIGZpbGxDb2xvcjogJ3BpbmsnLFxyXG4gICAgICBmaWxsT3BhY2l0eTogMC40XHJcbiAgICB9KTtcclxuICAgIHRoaXMubWFwLnBtLnNldExhbmcoJ3poJyk7IC8v6K6+572u6K+t6KiAXHJcbiAgICB0aGlzLm1hcC5vbigncG06ZHJhd3N0YXJ0JywgZSA9PiB7XHJcbiAgICAgIC8v57uY5Yi25byA5aeL5pe25LqL5Lu2XHJcbiAgICAgIGNvbnNvbGUubG9nKGUsICdmaXJzdCcpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLm1hcC5vbigncG06Y3JlYXRlJywgZSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGUsICfnu5jliLblrozmiJDml7bosIPnlKgnKTtcclxuICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoZS5sYXllci5fbGF0bG5ncykpOyAvL+iOt+WPlue7mOWItueahOWdkOaghyAgICAgICAgICAg57uY5Yi257q/5q615pe25LiN6IO95pi+56S656ys5LiA5Liq54K55Z2Q5qCHXHJcbiAgICB9KTtcclxuICB9LFxyXG4gIGNvbXBvbmVudHM6IHt9LFxyXG4gIG1ldGhvZHM6IHt9XHJcbn07XHJcbjwvc2NyaXB0PlxyXG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTMtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEzLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wM2RiYWU3MiZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpe3ZhciBfdm09dGhpcyxfYz1fdm0uX3NlbGYuX2M7cmV0dXJuIF9jKCdlbC1idXR0b24nLHtzdGF0aWNDbGFzczpcImFkZC1idXR0b25cIixhdHRyczp7XCJ0eXBlXCI6XCJwcmltYXJ5XCIsXCJzaXplXCI6XCJtaW5pXCJ9LG9uOntcImNsaWNrXCI6X3ZtLmhhbmRsZUNsaWNrfX0sW192bS5fdihfdm0uX3MoX3ZtLnRleHQpKV0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjwhLS1cbiAqIEBBdXRob3I6IHp1bGV6aGVcbiAqIEBEYXRlOiAyMDIyLTA4LTIzIDIyOjU2OjM2XG4gKiBATGFzdEVkaXRvcnM6IHp1bGV6aGVcbiAqIEBMYXN0RWRpdFRpbWU6IDIwMjItMDgtMjQgMDc6MDI6MDVcbiAqIEBQYXRoOiBodHRwczovL2dpdGVlLmNvbS96dWxlemhlL1xuICogQERlc2NyaXB0aW9uOiBcbi0tPlxuPHRlbXBsYXRlPlxuICA8ZWwtYnV0dG9uIHR5cGU9XCJwcmltYXJ5XCIgc2l6ZT1cIm1pbmlcIiBjbGFzcz1cImFkZC1idXR0b25cIiBAY2xpY2s9XCJoYW5kbGVDbGlja1wiPnt7IHRleHQgfX08L2VsLWJ1dHRvbj5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuaW1wb3J0IEwgZnJvbSAnbGVhZmxldCc7XG5pbXBvcnQgJ2xlYWZsZXQubW90aW9uL2Rpc3QvbGVhZmxldC5tb3Rpb24uanMnO1xubGV0IGZlYXR1cmVHcm91cCA9IG51bGw7XG5sZXQgcm91dGUgPSBudWxsO1xuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7fSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogJ+aYvuekuue6v+WSjOmdoicsXG4gICAgICBoYXM6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHt9LFxuICBjcmVhdGVkKCkge30sXG4gIG1vdW50ZWQoKSB7XG4gICAgZmVhdHVyZUdyb3VwID0gTC5mZWF0dXJlR3JvdXAoKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGhhbmRsZUNsaWNrKCkge1xuICAgICAgaWYgKHRoaXMuaGFzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKDExMSk7XG4gICAgICAgIHRoaXMucmVtb3ZlVmVjdG9yTGF5ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkVmVjdG9yTGF5ZXIoKTtcbiAgICAgICAgY29uc29sZS5sb2coMjIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkVmVjdG9yTGF5ZXIoKSB7XG4gICAgICBmZXRjaCgnLi9kYXRhL3ZlY3Rvci5qc29uJylcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgICBsZXQgcG9seWdvbiA9IEwucG9seWdvbihyZXN1bHQucG9seWdvbiwgeyBjb2xvcjogJ3JlZCcgfSk7XG4gICAgICAgICAgbGV0IHBvbHlsaW5lID0gTC5wb2x5bGluZShyZXN1bHQucG9seWxpbmUsIHsgY29sb3I6ICdyZWQnIH0pO1xuICAgICAgICAgIHJvdXRlID0gcmVzdWx0LnBvbHlsaW5lO1xuICAgICAgICAgIGZlYXR1cmVHcm91cC5hZGRMYXllcihwb2x5Z29uKTtcbiAgICAgICAgICBmZWF0dXJlR3JvdXAuYWRkTGF5ZXIocG9seWxpbmUpO1xuICAgICAgICAgIGZlYXR1cmVHcm91cC5hZGRUbyhtYXApO1xuICAgICAgICAgIG1hcC5maXRCb3VuZHMoZmVhdHVyZUdyb3VwLmdldEJvdW5kcygpKTtcbiAgICAgICAgICB0aGlzLnRleHQgPSAn5riF6Zmk54K55ZKM6Z2iJztcbiAgICAgICAgICB0aGlzLmhhcyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5tb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVtb3ZlVmVjdG9yTGF5ZXIoKSB7XG4gICAgICB0aGlzLnRleHQgPSAn5pi+56S654K55ZKM6Z2iJztcbiAgICAgIGZlYXR1cmVHcm91cCAmJiBmZWF0dXJlR3JvdXAuY2xlYXJMYXllcnMoKTtcbiAgICAgIHRoaXMuaGFzID0gZmFsc2U7XG4gICAgfSxcbiAgICBtb3ZlKCkge1xuICAgICAgbGV0IHNlcUdyb3VwID0gTC5tb3Rpb25cbiAgICAgICAgLnNlcShbXG4gICAgICAgICAgTC5tb3Rpb25cbiAgICAgICAgICAgIC5wb2x5bGluZShcbiAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ29yYW5nZXJlZCdcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVhc2luZzogTC5Nb3Rpb24uRWFzZS5lYXNlSW5PdXRRdWFkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZW1vdmVPbkVuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpY29uOiBMLmRpdkljb24oeyBodG1sOiBcIjxpIGNsYXNzPSdpY29uJyBzdHlsZT0nZm9udFNpemU6MjRweCc+4pyIPC9pPlwiLCBpY29uU2l6ZTogTC5wb2ludCgzNiwgMzYpIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5tb3Rpb25EdXJhdGlvbigxODAwMClcbiAgICAgICAgXSlcbiAgICAgICAgLmFkZFRvKG1hcCk7XG4gICAgICBzZXFHcm91cC5tb3Rpb25TdGFydCgpO1xuICAgIH1cbiAgfVxufTtcbjwvc2NyaXB0PlxuPHN0eWxlIHNjb3BlZCBsYW5nPVwibGVzc1wiPlxuLmFkZC1idXR0b24ge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGxlZnQ6IDEwMHB4O1xuICB0b3A6IDIwcHg7XG4gIHotaW5kZXg6IDk5OTk7XG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEzLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi92ZWN0b3IudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTMtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3ZlY3Rvci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL3ZlY3Rvci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZTUxZGFmMTgmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vdmVjdG9yLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vdmVjdG9yLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi92ZWN0b3IudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZTUxZGFmMTgmcHJvZCZzY29wZWQ9dHJ1ZSZsYW5nPWxlc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcImU1MWRhZjE4XCIsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpe3ZhciBfdm09dGhpcyxfYz1fdm0uX3NlbGYuX2M7cmV0dXJuIF9jKCdlbC1idXR0b24nLHtzdGF0aWNDbGFzczpcImFkZC1idXR0b25cIixhdHRyczp7XCJ0eXBlXCI6XCJwcmltYXJ5XCIsXCJzaXplXCI6XCJtaW5pXCJ9LG9uOntcImNsaWNrXCI6X3ZtLmhhbmRsZUNsaWNrfX0sW192bS5fdihcIuWKoOi9vTEwMDAw54K5XCIpXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiLypcclxuICogQEF1dGhvcjogenVsZXpoZVxyXG4gKiBARGF0ZTogMjAyMi0wOC0yMyAxMDowODoyOVxyXG4gKiBATGFzdEVkaXRvcnM6IHp1bGV6aGVcclxuICogQExhc3RFZGl0VGltZTogMjAyMi0wOC0yNCAxMjo1MjoxM1xyXG4gKiBAUGF0aDogaHR0cHM6Ly9naXRlZS5jb20venVsZXpoZS9cclxuICogQERlc2NyaXB0aW9uOlxyXG4gKi9cclxuaW1wb3J0IEwgZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCAnLi4vbGliL2xlYWZsZXQuY2FudmFzLW1hcmtlcnMuanMnO1xyXG5sZXQgcG9wdXAgPSBudWxsO1xyXG5sZXQgZmVhdHVyZUdyb3VwID0gbnVsbDtcclxuLyoqXHJcbiAqIOa3u+WKoOeCuVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZE1hcmtlcihpdGVtKSB7XHJcbiAgbGV0IG1hcmtlciA9IEwubWFya2VyKFtOdW1iZXIoaXRlbS5sYXQpLCBOdW1iZXIoaXRlbS5sbmcpXSwge1xyXG4gICAgY29kZTogJ21hcmtlci0nICsgaXRlbS5jb2RlLFxyXG4gICAgaWNvbjogTC5pY29uKHtcclxuICAgICAgaWNvblVybDogaXRlbS5pY29uLmljb25VcmwsXHJcbiAgICAgIGljb25TaXplOiBpdGVtLmljb24uaWNvblNpemUsXHJcbiAgICAgIGljb25BbmNob3I6IFswLCAwXSxcclxuICAgICAgcG9wdXBBbmNob3I6IFs1LCAwXSxcclxuICAgICAgY2xhc3NOYW1lOiAnbGVhZmxldC1jdXN0b20taWNvbidcclxuICAgIH0pLFxyXG4gICAgY3VzdG9tRGF0YTogeyAuLi5pdGVtIH1cclxuICB9KTtcclxuICBtYXJrZXJcclxuICAgIC5iaW5kVG9vbHRpcChpdGVtLm5hbWUsIHtcclxuICAgICAgZGlyZWN0aW9uOiAndG9wJyxcclxuICAgICAgb2Zmc2V0OiBMLnBvaW50KDE1LCAwKVxyXG4gICAgfSlcclxuICAgIC5vcGVuVG9vbHRpcCgpO1xyXG4gIG1hcmtlci5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICByZXR1cm4gbWFya2VyO1xyXG59XHJcbi8vIGV4cG9ydCBmdW5jdGlvbiBhZGRNYXJrZXIoaXRlbSkge1xyXG4vLyAgIGxldCBtYXJrZXIgPSBMLm1hcmtlcihbTnVtYmVyKGl0ZW0ubGF0KSwgTnVtYmVyKGl0ZW0ubG5nKV0sIHtcclxuLy8gICAgIGNvZGU6ICdtYXJrZXItJyArIGl0ZW0uY29kZSxcclxuLy8gICAgIGljb246IEwuZGl2SWNvbih7XHJcbi8vICAgICAgIGh0bWw6IGBcclxuLy8gICAgICAgPGRpdiBjbGFzcz1cImN1c3RvbS1kaXYtaWNvbi1jb250YWluZXJcIj5cclxuLy8gICAgICAgICA8aW1nIHNyYz1cIiR7aXRlbS5pY29uLmljb25Vcmx9XCIgYWx0PVwiXCI+XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICBgLFxyXG4vLyAgICAgICBpY29uU2l6ZTogTC5wb2ludCgyNy41LCAyNClcclxuLy8gICAgIH0pLFxyXG4vLyAgICAgY3VzdG9tRGF0YTogeyAuLi5pdGVtIH1cclxuLy8gICB9KTtcclxuLy8gICBtYXJrZXJcclxuLy8gICAgIC5iaW5kVG9vbHRpcChpdGVtLm5hbWUsIHtcclxuLy8gICAgICAgZGlyZWN0aW9uOiAndG9wJyxcclxuLy8gICAgICAgb2Zmc2V0OiBMLnBvaW50KDE1LCAwKVxyXG4vLyAgICAgfSlcclxuLy8gICAgIC5vcGVuVG9vbHRpcCgpO1xyXG4vLyAgIG1hcmtlci5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuLy8gICByZXR1cm4gbWFya2VyO1xyXG4vLyB9XHJcbi8qKlxyXG4gKiDmt7vliqDlpJrngrlcclxuICogQHBhcmFtIHsqfSBsaXN0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkTWFya2VycyhsaXN0LCBvcHRpb25zKSB7XHJcbiAgZmVhdHVyZUdyb3VwID0gTC5mZWF0dXJlR3JvdXAoKTtcclxuICBsaXN0Lm1hcChpdGVtID0+IHtcclxuICAgIGZlYXR1cmVHcm91cC5hZGRMYXllcihhZGRNYXJrZXIoeyAuLi5pdGVtLCAuLi5vcHRpb25zIH0pKTtcclxuICB9KTtcclxuICBmZWF0dXJlR3JvdXAuYWRkVG8obWFwKTtcclxuICBtYXAuZml0Qm91bmRzKGZlYXR1cmVHcm91cC5nZXRCb3VuZHMoKSk7XHJcbiAgcmV0dXJuIGZlYXR1cmVHcm91cDtcclxufVxyXG4vKipcclxuICog5re75Yqg5rW36YeP54K5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkSHVnZU1hcmtlcnMobGlzdCwgb3B0aW9ucykge1xyXG4gIGxldCBjaUxheWVyID0gTC5jYW52YXNJY29uTGF5ZXIoe30pLmFkZFRvKG1hcCk7XHJcbiAgbGlzdC5tYXAoaXRlbSA9PiB7XHJcbiAgICBsZXQgbWFya2VyID0gYWRkTWFya2VyKHsgLi4uaXRlbSwgLi4ub3B0aW9ucyB9KTtcclxuICAgIGNpTGF5ZXIuYWRkTGF5ZXIobWFya2VyKTtcclxuICB9KTtcclxuICBjb25zb2xlLmxvZyhjaUxheWVyKTtcclxufVxyXG4vKipcclxuICog5Yig6Zmk54K5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTWFya2VyKCkge31cclxuLyoqXHJcbiAqIOa4heepuuimgee0oOe7hFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyR3JvdXAoZ3JvdXApIHtcclxuICBncm91cC5jbGVhckxheWVycygpO1xyXG59XHJcbi8qKlxyXG4gKiDmn6Xmib7ngrlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWFya2VyKCkge31cclxuLyoqXHJcbiAqIOabtOaWsOeCuVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU1hcmtlcigpIHt9XHJcbi8qKlxyXG4gKiDnp7vlhaXngrlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvbk1vdXNlb3ZlcihlKSB7XHJcbiAgY29uc29sZS5sb2coJ+m8oOagh+enu+WFpScsIGUpO1xyXG4gIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICBsZXQgY3VzdG9tRGF0YSA9IHRhcmdldC5vcHRpb25zLmN1c3RvbURhdGE7XHJcbiAgZS50YXJnZXRcclxuICAgIC5iaW5kVG9vbHRpcChjdXN0b21EYXRhLm5hbWUsIHtcclxuICAgICAgZGlyZWN0aW9uOiAndG9wJ1xyXG4gICAgfSlcclxuICAgIC5vcGVuVG9vbHRpcCgpO1xyXG59XHJcbi8qKlxyXG4gKiDnp7vlh7rngrlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvbk1vdXNlb3V0KGUpIHtcclxuICBjb25zb2xlLmxvZygn6byg5qCH56e75Ye6JywgZSk7XHJcbiAgZS50YXJnZXQuY2xvc2VUb29sdGlwKCk7XHJcbn1cclxuLyoqXHJcbiAqIOeCueWHu+eCuVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xyXG4gIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICBjb25zb2xlLmxvZygn54K55Ye754K5JywgZSwgdGFyZ2V0KTtcclxuICBsZXQgbGF5ZXJzID0gZmVhdHVyZUdyb3VwLmdldExheWVycygpO1xyXG4gIGxheWVycy5tYXAobGF5ZXIgPT4ge1xyXG4gICAgaWYgKGxheWVyLm9wdGlvbnMuY29kZSA9PT0gdGFyZ2V0Lm9wdGlvbnMuY29kZSkge1xyXG4gICAgICB0YXJnZXQuc2V0SWNvbihcclxuICAgICAgICBMLmljb24oe1xyXG4gICAgICAgICAgaWNvblVybDogcmVxdWlyZSgnQC9hc3NldHMvaW1hZ2VzLzEtMi5wbmcnKSxcclxuICAgICAgICAgIGNsYXNzTmFtZTogJ2xlYWZsZXQtY3VzdG9tLWljb24gYmxpbmtpbmcnXHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxheWVyLnNldEljb24oXHJcbiAgICAgICAgTC5pY29uKHtcclxuICAgICAgICAgIGljb25Vcmw6IHJlcXVpcmUoJ0AvYXNzZXRzL2ltYWdlcy8xLnBuZycpLFxyXG4gICAgICAgICAgY2xhc3NOYW1lOiAnbGVhZmxldC1jdXN0b20taWNvbidcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGNvbnNvbGUubG9nKCfojrflj5ZmZWF0dXJlR3JvdXDkuIrnmoTmiYDmnInlm77lsYI9PT0+JywgbGF5ZXJzKTtcclxuICAvLyBMLkRvbVV0aWwuYWRkQ2xhc3ModGFyZ2V0LCAnYWN0aXZlJyk7XHJcbiAgcG9wdXAgPSBMLnBvcHVwKHtcclxuICAgIG9mZnNldDogTC5wb2ludCgxMCwgMClcclxuICB9KS5zZXRMYXRMbmcoW2UubGF0bG5nLmxhdCwgZS5sYXRsbmcubG5nXSkuc2V0Q29udGVudChgXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJjdXN0b20tcG9wdXAtY29udGFpbmVyXCIgc3R5bGU9XCJ3aWR0aDozMDBweDtoZWlnaHQ6MjQwcHg7XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRpdGxlXCI+5ZCN56ewOjwvc3Bhbj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2YWx1ZVwiPiR7dGFyZ2V0Lm9wdGlvbnMuY3VzdG9tRGF0YS5uYW1lfTwvc3Bhbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGl0bGVcIj7miYDlsZ7nnIHku706PC9zcGFuPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZhbHVlXCI+JHt0YXJnZXQub3B0aW9ucy5jdXN0b21EYXRhLnByb3ZpbmNlfTwvc3Bhbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGl0bGVcIj7nvJbnoIE6PC9zcGFuPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZhbHVlXCI+JHt0YXJnZXQub3B0aW9ucy5jdXN0b21EYXRhLmNvZGV9PC9zcGFuPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0aXRsZVwiPuS9jee9rjo8L3NwYW4+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmFsdWVcIj4ke3RhcmdldC5vcHRpb25zLmN1c3RvbURhdGEubG5nfSwke3RhcmdldC5vcHRpb25zLmN1c3RvbURhdGEubGF0fTwvc3Bhbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGl0bGVcIj7mtbfmi5Q6PC9zcGFuPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZhbHVlXCI+JHt0YXJnZXQub3B0aW9ucy5jdXN0b21EYXRhLmhlaWdodH1tPC9zcGFuPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIGApO1xyXG4gIHBvcHVwLm9wZW5PbihtYXApO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9zZVBvcHVwKCkge1xyXG4gIGNvbnNvbGUubG9nKHBvcHVwKTtcclxuICBwb3B1cCAmJiBwb3B1cC5fY2xvc2UoKTtcclxufVxyXG4vKipcclxuICog6IGa54Sm5Yiw5aSa54K5XHJcbiAqIEBwYXJhbSB7Kn0gbWFya2Vyc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFZpZXdNYXJrZXJzKG1hcmtlcnMpIHtcclxuICBsZXQgbWFya2VyQm91bmRzID0gTC5sYXRMbmdCb3VuZHMoW10pO1xyXG4gIG1hcmtlcnMuZm9yRWFjaChtYXJrZXIgPT4ge1xyXG4gICAgbWFya2VyQm91bmRzLmV4dGVuZChbbWFya2VyLmxhdCwgbWFya2VyLmxuZ10pO1xyXG4gIH0pO1xyXG4gIG1hcC5maXRCb3VuZHMobWFya2VyQm91bmRzKTtcclxufVxyXG4vKipcclxuICog6aOe6KGM5Yiw54K5XHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqIEBwYXJhbSB7Kn0gcG9zaXRpb25cclxuICogQHBhcmFtIHsqfSB6b29tXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmx5VG8ocG9zaXRpb24sIHpvb20gPSAxMykge1xyXG4gIG1hcC5mbHlUbyhwb3NpdGlvbiwgem9vbSk7XHJcbn1cclxuIiwiPCEtLVxyXG4gKiBAQXV0aG9yOiB6dWxlemhlXHJcbiAqIEBEYXRlOiAyMDIyLTA4LTI0IDA4OjAzOjM0XHJcbiAqIEBMYXN0RWRpdG9yczogenVsZXpoZVxyXG4gKiBATGFzdEVkaXRUaW1lOiAyMDIyLTA4LTI0IDEyOjUwOjM3XHJcbiAqIEBQYXRoOiBodHRwczovL2dpdGVlLmNvbS96dWxlemhlL1xyXG4gKiBARGVzY3JpcHRpb246IFxyXG4tLT5cclxuPHRlbXBsYXRlPlxyXG4gIDxlbC1idXR0b24gdHlwZT1cInByaW1hcnlcIiBzaXplPVwibWluaVwiIGNsYXNzPVwiYWRkLWJ1dHRvblwiIEBjbGljaz1cImhhbmRsZUNsaWNrXCI+5Yqg6L29MTAwMDDngrk8L2VsLWJ1dHRvbj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHsgYWRkSHVnZU1hcmtlcnMgfSBmcm9tICdAL3dsZWFmbGV0L2NvcmUvbWFya2VyLmpzJztcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGNvbXBvbmVudHM6IHt9LFxyXG4gIGRhdGEoKSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfSxcclxuICBjb21wdXRlZDoge30sXHJcbiAgY3JlYXRlZCgpIHt9LFxyXG4gIG1vdW50ZWQoKSB7fSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBoYW5kbGVDbGljaygpIHtcclxuICAgICAgbGV0IGxpc3QgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDAwMDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGxhdCA9IDM0Ljc1OTE5NyArIChNYXRoLnJhbmRvbSgpIC0gTWF0aC5yYW5kb20oKSkgKiAzO1xyXG4gICAgICAgIHZhciBsbmcgPSAxMTMuNzc4NTg0ICsgKE1hdGgucmFuZG9tKCkgLSBNYXRoLnJhbmRvbSgpKSAqIDM7XHJcbiAgICAgICAgbGlzdC5wdXNoKHtcclxuICAgICAgICAgIGxhdDogbGF0LFxyXG4gICAgICAgICAgbG5nOiBsbmcsXHJcbiAgICAgICAgICBuYW1lOiAn56ysJyArIGkgKyAn5LiqJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGFkZEh1Z2VNYXJrZXJzKGxpc3QsIHtcclxuICAgICAgICBpY29uOiB7XHJcbiAgICAgICAgICBpY29uVXJsOiByZXF1aXJlKCdAL2Fzc2V0cy9pbWFnZXMvd2Fybi5wbmcnKSxcclxuICAgICAgICAgIGljb25TaXplOiBbMzAsIDMwXVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuPHN0eWxlIHNjb3BlZCBsYW5nPVwibGVzc1wiPlxyXG4uYWRkLWJ1dHRvbiB7XHJcbiAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gIGxlZnQ6IDIwMHB4O1xyXG4gIHRvcDogMjBweDtcclxuICB6LWluZGV4OiA5OTk5O1xyXG59XHJcbjwvc3R5bGU+XHJcbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMy0wIS4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaHVnZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMy0wIS4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaHVnZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL2h1Z2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFlOTBkMTMzJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL2h1Z2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9odWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9odWdlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFlOTBkMTMzJnByb2Qmc2NvcGVkPXRydWUmbGFuZz1sZXNzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIxZTkwZDEzM1wiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsInZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKXt2YXIgX3ZtPXRoaXMsX2M9X3ZtLl9zZWxmLl9jO3JldHVybiBfYygnZWwtYnV0dG9uJyx7c3RhdGljQ2xhc3M6XCJhZGQtYnV0dG9uXCIsYXR0cnM6e1widHlwZVwiOlwicHJpbWFyeVwiLFwic2l6ZVwiOlwibWluaVwifSxvbjp7XCJjbGlja1wiOl92bS5oYW5kbGVDbGlja319LFtfdm0uX3YoXCI1MDAw5qCH562+6YG/6K6pXCIpXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPCEtLVxyXG4gKiBAQXV0aG9yOiB6dWxlemhlXHJcbiAqIEBEYXRlOiAyMDIyLTA4LTI0IDA4OjAzOjM0XHJcbiAqIEBMYXN0RWRpdG9yczogenVsZXpoZVxyXG4gKiBATGFzdEVkaXRUaW1lOiAyMDIyLTA4LTI0IDEzOjA2OjM5XHJcbiAqIEBQYXRoOiBodHRwczovL2dpdGVlLmNvbS96dWxlemhlL1xyXG4gKiBARGVzY3JpcHRpb246IFxyXG4tLT5cclxuPHRlbXBsYXRlPlxyXG4gIDxlbC1idXR0b24gdHlwZT1cInByaW1hcnlcIiBzaXplPVwibWluaVwiIGNsYXNzPVwiYWRkLWJ1dHRvblwiIEBjbGljaz1cImhhbmRsZUNsaWNrXCI+NTAwMOagh+etvumBv+iuqTwvZWwtYnV0dG9uPlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgJ0Avd2xlYWZsZXQvbGliL0wuTGFiZWxUZXh0Q29sbGlzaW9uLmpzJztcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGNvbXBvbmVudHM6IHt9LFxyXG4gIGRhdGEoKSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfSxcclxuICBjb21wdXRlZDoge30sXHJcbiAgY3JlYXRlZCgpIHt9LFxyXG4gIG1vdW50ZWQoKSB7fSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBoYW5kbGVDbGljaygpIHtcclxuICAgICAgdmFyIGxheWVycyA9IEwuZmVhdHVyZUdyb3VwKCkuYWRkVG8obWFwKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MDAwOyBpKyspIHtcclxuICAgICAgICB2YXIgbGF0ID0gMzQuNzU5MTk3ICsgKE1hdGgucmFuZG9tKCkgLSBNYXRoLnJhbmRvbSgpKSAqIDM7XHJcbiAgICAgICAgdmFyIGxuZyA9IDExMy43Nzg1ODQgKyAoTWF0aC5yYW5kb20oKSAtIE1hdGgucmFuZG9tKCkpICogMztcclxuICAgICAgICB2YXIgbGF0bG5nID0gTC5sYXRMbmcobGF0LCBsbmcpO1xyXG4gICAgICAgIHZhciBtYXJrZXIgPSBMLmNpcmNsZU1hcmtlcihsYXRsbmcsIHtcclxuICAgICAgICAgIHJhZGl1czogMCxcclxuICAgICAgICAgIHRleHQ6ICfmiJHmmK/nrKwnICsgaSArICfkuKrmoIfnrb4nLFxyXG4gICAgICAgICAgdGV4dFN0eWxlOiB7XHJcbiAgICAgICAgICAgIHN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgd2lkdGg6IDgwLFxyXG4gICAgICAgICAgICBoaWVnaHQ6IDQwLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsdWUnLFxyXG4gICAgICAgICAgICBmb250OiBcIjE1cHggJ01pY3Jvc29mdCBZYWhlaSdcIixcclxuICAgICAgICAgICAgb2Zmc2V0WDogLTcwLFxyXG4gICAgICAgICAgICBvZmZzZXRZOiAtMTBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsYXllcnMuYWRkTGF5ZXIobWFya2VyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcbjxzdHlsZSBzY29wZWQgbGFuZz1cImxlc3NcIj5cclxuLmFkZC1idXR0b24ge1xyXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICBsZWZ0OiAzMjBweDtcclxuICB0b3A6IDIwcHg7XHJcbiAgei1pbmRleDogOTk5OTtcclxufVxyXG48L3N0eWxlPlxyXG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTMtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2F2b2lkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEzLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9hdm9pZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL2F2b2lkLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01NGM5Mjg4YSZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9hdm9pZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL2F2b2lkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9hdm9pZC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01NGM5Mjg4YSZwcm9kJnNjb3BlZD10cnVlJmxhbmc9bGVzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNTRjOTI4OGFcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCIvKlxuICogQEF1dGhvcjogd2FuZ2NoYW94dVxuICogQERhdGU6IDIwMjEtMDQtMjEgMTk6MTM6MzZcbiAqIEBMYXN0RWRpdG9yczogenVsZXpoZVxuICogQExhc3RFZGl0VGltZTogMjAyMi0wOC0yMyAwMDozMToyNlxuICogQFBhdGg6IGh0dHBzOi8vZ2l0ZWUuY29tL3dhbmdjaGFveHUvXG4gKiBARGVzY3JpcHRpb246XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhKHBhcmFtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZldGNoKCcuL2RhdGEvdGVzdC5qc29uJylcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBkYXRhOiByZXMuc2xpY2UoKHBhcmFtcy5wYWdlTnVtYmVyIC0gMSkgKiBwYXJhbXMucGFnZVNpemUsIHBhcmFtcy5wYWdlTnVtYmVyICogcGFyYW1zLnBhZ2VTaXplKSxcbiAgICAgICAgICB0b3RhbDogcmVzLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgfSk7XG59XG4iLCI8IS0tXHJcbiAqIEBBdXRob3I6IHp1bGV6aGVcclxuICogQERhdGU6IDIwMjItMDgtMjIgMjA6MjQ6NDJcclxuICogQExhc3RFZGl0b3JzOiB6dWxlemhlXHJcbiAqIEBMYXN0RWRpdFRpbWU6IDIwMjItMDgtMjQgMTE6NDc6MjZcclxuICogQFBhdGg6IGh0dHBzOi8vZ2l0ZWUuY29tL3p1bGV6aGUvXHJcbiAqIEBEZXNjcmlwdGlvbjogXHJcbi0tPlxyXG48dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cImhvbWUtY29udGFpbmVyXCI+XHJcbiAgICA8V01hcCBAbWFwQ29tcGxldGU9XCJtYXBDb21wbGV0ZVwiPlxyXG4gICAgICA8V0RyYXdUb29sIDptYXA9XCJtYXBcIj48L1dEcmF3VG9vbD5cclxuICAgIDwvV01hcD5cclxuICAgIDxXVGFibGUgOnRhYmxlTGlzdD1cInRhYmxlTGlzdFwiIDpsb2FkaW5nPVwibG9hZGluZ1wiIDpwYXJhbXM9XCJwYXJhbXNcIiBAY3VycmVudENoYW5nZT1cImN1cnJlbnRDaGFuZ2VcIiBAcm93Q2xpY2s9XCJyb3dDbGlja1wiIC8+XHJcbiAgICA8V1ZlY3RvciA+PC9XVmVjdG9yPlxyXG4gICAgPFdIdWdlPjwvV0h1Z2U+XHJcbiAgICA8V0F2b2lkPjwvV0F2b2lkPlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgV01hcCBmcm9tICdAL3dsZWFmbGV0L3VpL01hcCc7XHJcbmltcG9ydCBXVGFibGUgZnJvbSAnQC9jb21wb25lbnRzL1RhYmxlJztcclxuaW1wb3J0IFdEcmF3VG9vbCBmcm9tICdAL3dsZWFmbGV0L3VpL0RyYXdUb29sJztcclxuaW1wb3J0IFdWZWN0b3IgZnJvbSAnLi92ZWN0b3IudnVlJztcclxuaW1wb3J0IFdIdWdlIGZyb20gJy4vaHVnZS52dWUnO1xyXG5pbXBvcnQgV0F2b2lkIGZyb20gJy4vYXZvaWQudnVlJztcclxuaW1wb3J0IHsgYWRkTWFya2VycywgZmx5VG8sIGNsZWFyR3JvdXAsIGNsb3NlUG9wdXAgfSBmcm9tICdAL3dsZWFmbGV0L2NvcmUvbWFya2VyJztcclxuaW1wb3J0ICogYXMgYXBpIGZyb20gJ0AvYXBpJztcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGNvbXBvbmVudHM6IHsgV01hcCwgV1RhYmxlLCBXRHJhd1Rvb2wsIFdWZWN0b3IsV0h1Z2UsV0F2b2lkIH0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRhYmxlTGlzdDogW10sXHJcbiAgICAgIGxvYWRpbmc6IHRydWUsXHJcbiAgICAgIG1hcDogbnVsbCxcclxuICAgICAgZmVhdHVyZUdyb3VwOiBudWxsLFxyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBwYWdlTnVtYmVyOiAxLFxyXG4gICAgICAgIHBhZ2VTaXplOiA1LFxyXG4gICAgICAgIHRvdGFsOiAxMFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7fSxcclxuICBjcmVhdGVkKCkge30sXHJcbiAgbW91bnRlZCgpIHtcclxuICAgIHRoaXMuZ2V0RGF0YSgpO1xyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgbWFwQ29tcGxldGUobWFwKSB7XHJcbiAgICAgIHRoaXMubWFwID0gbWFwO1xyXG4gICAgICBjb25zb2xlLmxvZygn5Zyw5Zu+5Yqg6L295a6M5oiQJywgbWFwKTtcclxuICAgIH0sXHJcbiAgICBnZXREYXRhKCkge1xyXG4gICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICBhcGlcclxuICAgICAgICAuZ2V0RGF0YSh0aGlzLnBhcmFtcylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgdGhpcy50YWJsZUxpc3QgPSByZXMuZGF0YTtcclxuICAgICAgICAgIHRoaXMucGFyYW1zLnRvdGFsID0gcmVzLnRvdGFsO1xyXG4gICAgICAgICAgdGhpcy5mZWF0dXJlR3JvdXAgJiYgY2xlYXJHcm91cCh0aGlzLmZlYXR1cmVHcm91cCk7XHJcbiAgICAgICAgICB0aGlzLmZlYXR1cmVHcm91cCA9IGFkZE1hcmtlcnModGhpcy50YWJsZUxpc3QsIHtcclxuICAgICAgICAgICAgaWNvbjoge1xyXG4gICAgICAgICAgICAgIGljb25Vcmw6IHJlcXVpcmUoJ0AvYXNzZXRzL2ltYWdlcy8xLnBuZycpLFxyXG4gICAgICAgICAgICAgIGljb25TaXplOiBbMzIsIDQ4XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIH0sIDEwMDApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGN1cnJlbnRDaGFuZ2UodmFsKSB7XHJcbiAgICAgIHRoaXMucGFyYW1zLnBhZ2VOdW1iZXIgPSB2YWw7XHJcbiAgICAgIGNsb3NlUG9wdXAoKTtcclxuICAgICAgdGhpcy5nZXREYXRhKCk7XHJcbiAgICB9LFxyXG4gICAgcm93Q2xpY2socm93LCBjb2x1bW4sIGV2ZW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfngrnlh7vlvZPliY3ooYw9PT0+Jywgcm93LCBjb2x1bW4sIGV2ZW50KTtcclxuICAgICAgZmx5VG8oW051bWJlcihyb3cubGF0KSwgTnVtYmVyKHJvdy5sbmcpXSwgMTMpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcbjxzdHlsZSBzY29wZWQgbGFuZz1cImxlc3NcIj5cclxuLmhvbWUtY29udGFpbmVyIHtcclxuICB3aWR0aDogMTAwJTtcclxuICBoZWlnaHQ6IDEwMCU7XHJcbn1cclxuPC9zdHlsZT5cclxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEzLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMy0wIS4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9pbmRleC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MjNlYzhkZjgmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MjNlYzhkZjgmcHJvZCZzY29wZWQ9dHJ1ZSZsYW5nPWxlc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjIzZWM4ZGY4XCIsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiPCEtLVxuICogQEF1dGhvcjogd2FuZ2NoYW94dVxuICogQERhdGU6IDIwMjEtMDQtMTQgMTc6MjE6MTdcbiAqIEBMYXN0RWRpdG9yczogenVsZXpoZVxuICogQExhc3RFZGl0VGltZTogMjAyMi0wOC0yMiAxODozMToxOFxuICogQFBhdGg6IGh0dHBzOi8vZ2l0ZWUuY29tL3dhbmdjaGFveHUvXG4gKiBARGVzY3JpcHRpb246XG4tLT5cbjx0ZW1wbGF0ZT5cbiAgPGRpdiBpZD1cImFwcFwiPlxuICAgIDxIb21lPjwvSG9tZT5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmltcG9ydCBIb21lIGZyb20gJ0Avdmlld3MnO1xuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7IEhvbWUgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCIgc2NvcGVkPlxuaHRtbCxcbmJvZHksXG4jYXBwIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTMtMCEuLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMy0wIS4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1mOGE4MmU0MCZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1mOGE4MmU0MCZwcm9kJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiZjhhODJlNDBcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCIvKlxuICogQEF1dGhvcjogeW91ciBuYW1lXG4gKiBARGF0ZTogMjAyMC0xMC0yNSAxNDo0NToxNFxuICogQExhc3RFZGl0VGltZTogMjAyMi0wOC0yNCAxMzowOToxOVxuICogQExhc3RFZGl0b3JzOiB6dWxlemhlXG4gKiBARGVzY3JpcHRpb246IEluIFVzZXIgU2V0dGluZ3MgRWRpdFxuICogQEZpbGVQYXRoOiBcXG1vYWZseS1zcGEyXFxzcmNcXHBsdWdpbnNcXGVsZW1lbnQtdWkuanNcbiAqL1xuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IHsgQnV0dG9uLCBNZXNzYWdlLCBMb2FkaW5nLCBUYWJsZSwgVGFibGVDb2x1bW4sIFBhZ2luYXRpb24gfSBmcm9tICdlbGVtZW50LXVpJztcblZ1ZS51c2UoQnV0dG9uKTtcblZ1ZS51c2UoVGFibGUpO1xuVnVlLnVzZShUYWJsZUNvbHVtbik7XG5WdWUudXNlKFBhZ2luYXRpb24pO1xuVnVlLnVzZShMb2FkaW5nLmRpcmVjdGl2ZSk7XG5WdWUucHJvdG90eXBlLiRtZXNzYWdlID0gTWVzc2FnZTtcblZ1ZS5wcm90b3R5cGUuJGxvYWRpbmcgPSB7XG4gIGxvYWRpbmc6IG51bGwsXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5sb2FkaW5nID0gTG9hZGluZy5zZXJ2aWNlKHtcbiAgICAgIC8vIOWjsOaYjuS4gOS4qmxvYWRpbmflr7nosaFcbiAgICAgIGxvY2s6IHRydWUsIC8vIOaYr+WQpumUgeWxj1xuICAgICAgdGV4dDogJ+ato+WcqOWKoOi9vS4uLicsIC8vIOWKoOi9veWKqOeUu+eahOaWh+Wtl1xuICAgICAgc3Bpbm5lcjogJ2VsLWljb24tbG9hZGluZycsIC8vIOW8leWFpeeahGxvYWRpbmflm77moIdcbiAgICAgIGJhY2tncm91bmQ6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLCAvLyDog4zmma/popzoibJcbiAgICAgIHRhcmdldDogJy5zdWItbWFpbicsIC8vIOmcgOimgemBrue9qeeahOWMuuWfn1xuICAgICAgYm9keTogdHJ1ZSxcbiAgICAgIGN1c3RvbUNsYXNzOiAnbWFzaycgLy8g6YGu572p5bGC5paw5aKe57G75ZCNXG4gICAgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyDorr7lrprlrprml7blmajvvIzotoXml7Y1U+WQjuiHquWKqOWFs+mXremBrue9qeWxgu+8jOmBv+WFjeivt+axguWksei0peaXtu+8jOmBrue9qeWxguS4gOebtOWtmOWcqOeahOmXrumimFxuICAgICAgdGhpcy5sb2FkaW5nLmNsb3NlKCk7IC8vIOWFs+mXremBrue9qeWxglxuICAgIH0sIDUwMDApO1xuICB9LFxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmxvYWRpbmcuY2xvc2UoKTtcbiAgfVxufTtcbiIsIi8qXG4gKiBAQXV0aG9yOiB6dWxlemhlXG4gKiBARGF0ZTogMjAyMi0wOC0yMiAxNzo1ODo1N1xuICogQExhc3RFZGl0b3JzOiB6dWxlemhlXG4gKiBATGFzdEVkaXRUaW1lOiAyMDIyLTA4LTI0IDEzOjE3OjU5XG4gKiBAUGF0aDogaHR0cHM6Ly9naXRlZS5jb20venVsZXpoZS9cbiAqIEBEZXNjcmlwdGlvbjpcbiAqL1xuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IEFwcCBmcm9tICcuL0FwcC52dWUnO1xuaW1wb3J0ICdAL2Fzc2V0cy9zdHlsZXMvaW5jbHVkZS5sZXNzJztcbmltcG9ydCAnQC9wbHVnaW5zL2VsZW1lbnQtdWkuanMnO1xuVnVlLmNvbmZpZy5wcm9kdWN0aW9uVGlwID0gZmFsc2U7XG5uZXcgVnVlKHtcbiAgcmVuZGVyOiBoID0+IGgoQXBwKVxufSkuJG1vdW50KCcjYXBwJyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///56d7\n')},"597f":function(module,exports){eval("/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset)\n * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @return {Function}  A new, throttled, function.\n */\nmodule.exports = function ( delay, noTrailing, callback, debounceMode ) {\n\n\t// After wrapper has stopped being called, this timeout ensures that\n\t// `callback` is executed at the proper times in `throttle` and `end`\n\t// debounce modes.\n\tvar timeoutID;\n\n\t// Keep track of the last time `callback` was executed.\n\tvar lastExec = 0;\n\n\t// `noTrailing` defaults to falsy.\n\tif ( typeof noTrailing !== 'boolean' ) {\n\t\tdebounceMode = callback;\n\t\tcallback = noTrailing;\n\t\tnoTrailing = undefined;\n\t}\n\n\t// The `wrapper` function encapsulates all of the throttling / debouncing\n\t// functionality and when executed will limit the rate at which `callback`\n\t// is executed.\n\tfunction wrapper () {\n\n\t\tvar self = this;\n\t\tvar elapsed = Number(new Date()) - lastExec;\n\t\tvar args = arguments;\n\n\t\t// Execute `callback` and update the `lastExec` timestamp.\n\t\tfunction exec () {\n\t\t\tlastExec = Number(new Date());\n\t\t\tcallback.apply(self, args);\n\t\t}\n\n\t\t// If `debounceMode` is true (at begin) this is used to clear the flag\n\t\t// to allow future `callback` executions.\n\t\tfunction clear () {\n\t\t\ttimeoutID = undefined;\n\t\t}\n\n\t\tif ( debounceMode && !timeoutID ) {\n\t\t\t// Since `wrapper` is being called for the first time and\n\t\t\t// `debounceMode` is true (at begin), execute `callback`.\n\t\t\texec();\n\t\t}\n\n\t\t// Clear any existing timeout.\n\t\tif ( timeoutID ) {\n\t\t\tclearTimeout(timeoutID);\n\t\t}\n\n\t\tif ( debounceMode === undefined && elapsed > delay ) {\n\t\t\t// In throttle mode, if `delay` time has been exceeded, execute\n\t\t\t// `callback`.\n\t\t\texec();\n\n\t\t} else if ( noTrailing !== true ) {\n\t\t\t// In trailing throttle mode, since `delay` time has not been\n\t\t\t// exceeded, schedule `callback` to execute `delay` ms after most\n\t\t\t// recent execution.\n\t\t\t//\n\t\t\t// If `debounceMode` is true (at begin), schedule `clear` to execute\n\t\t\t// after `delay` ms.\n\t\t\t//\n\t\t\t// If `debounceMode` is false (at end), schedule `callback` to\n\t\t\t// execute after `delay` ms.\n\t\t\ttimeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n\t\t}\n\n\t}\n\n\t// Return the wrapper function.\n\treturn wrapper;\n\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvdGhyb3R0bGUuanM/NTk3ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiI1OTdmLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkLG5vLXBhcmFtLXJlYXNzaWduLG5vLXNoYWRvdyAqL1xuXG4vKipcbiAqIFRocm90dGxlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IHVzZWZ1bCBmb3IgcmF0ZSBsaW1pdGluZ1xuICogZXhlY3V0aW9uIG9mIGhhbmRsZXJzIG9uIGV2ZW50cyBsaWtlIHJlc2l6ZSBhbmQgc2Nyb2xsLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgZGVsYXkgICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgIFtub1RyYWlsaW5nXSAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgbm9UcmFpbGluZyBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIG9ubHkgZXhlY3V0ZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kcyB3aGlsZSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGVkLWZ1bmN0aW9uIGlzIGJlaW5nIGNhbGxlZC4gSWYgbm9UcmFpbGluZyBpcyBmYWxzZSBvciB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbmUgZmluYWwgdGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbC4gKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KVxuICogQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGBjYWxsYmFja2Agd2hlbiB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxuICogQHBhcmFtICB7Qm9vbGVhbn0gICBbZGVib3VuY2VNb2RlXSBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259ICBBIG5ldywgdGhyb3R0bGVkLCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIGRlbGF5LCBub1RyYWlsaW5nLCBjYWxsYmFjaywgZGVib3VuY2VNb2RlICkge1xuXG5cdC8vIEFmdGVyIHdyYXBwZXIgaGFzIHN0b3BwZWQgYmVpbmcgY2FsbGVkLCB0aGlzIHRpbWVvdXQgZW5zdXJlcyB0aGF0XG5cdC8vIGBjYWxsYmFja2AgaXMgZXhlY3V0ZWQgYXQgdGhlIHByb3BlciB0aW1lcyBpbiBgdGhyb3R0bGVgIGFuZCBgZW5kYFxuXHQvLyBkZWJvdW5jZSBtb2Rlcy5cblx0dmFyIHRpbWVvdXRJRDtcblxuXHQvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHRpbWUgYGNhbGxiYWNrYCB3YXMgZXhlY3V0ZWQuXG5cdHZhciBsYXN0RXhlYyA9IDA7XG5cblx0Ly8gYG5vVHJhaWxpbmdgIGRlZmF1bHRzIHRvIGZhbHN5LlxuXHRpZiAoIHR5cGVvZiBub1RyYWlsaW5nICE9PSAnYm9vbGVhbicgKSB7XG5cdFx0ZGVib3VuY2VNb2RlID0gY2FsbGJhY2s7XG5cdFx0Y2FsbGJhY2sgPSBub1RyYWlsaW5nO1xuXHRcdG5vVHJhaWxpbmcgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBUaGUgYHdyYXBwZXJgIGZ1bmN0aW9uIGVuY2Fwc3VsYXRlcyBhbGwgb2YgdGhlIHRocm90dGxpbmcgLyBkZWJvdW5jaW5nXG5cdC8vIGZ1bmN0aW9uYWxpdHkgYW5kIHdoZW4gZXhlY3V0ZWQgd2lsbCBsaW1pdCB0aGUgcmF0ZSBhdCB3aGljaCBgY2FsbGJhY2tgXG5cdC8vIGlzIGV4ZWN1dGVkLlxuXHRmdW5jdGlvbiB3cmFwcGVyICgpIHtcblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgZWxhcHNlZCA9IE51bWJlcihuZXcgRGF0ZSgpKSAtIGxhc3RFeGVjO1xuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG5cdFx0Ly8gRXhlY3V0ZSBgY2FsbGJhY2tgIGFuZCB1cGRhdGUgdGhlIGBsYXN0RXhlY2AgdGltZXN0YW1wLlxuXHRcdGZ1bmN0aW9uIGV4ZWMgKCkge1xuXHRcdFx0bGFzdEV4ZWMgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjYWxsYmFjay5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHQvLyBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbikgdGhpcyBpcyB1c2VkIHRvIGNsZWFyIHRoZSBmbGFnXG5cdFx0Ly8gdG8gYWxsb3cgZnV0dXJlIGBjYWxsYmFja2AgZXhlY3V0aW9ucy5cblx0XHRmdW5jdGlvbiBjbGVhciAoKSB7XG5cdFx0XHR0aW1lb3V0SUQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBkZWJvdW5jZU1vZGUgJiYgIXRpbWVvdXRJRCApIHtcblx0XHRcdC8vIFNpbmNlIGB3cmFwcGVyYCBpcyBiZWluZyBjYWxsZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZFxuXHRcdFx0Ly8gYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBleGVjdXRlIGBjYWxsYmFja2AuXG5cdFx0XHRleGVjKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVvdXQuXG5cdFx0aWYgKCB0aW1lb3V0SUQgKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dElEKTtcblx0XHR9XG5cblx0XHRpZiAoIGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkICYmIGVsYXBzZWQgPiBkZWxheSApIHtcblx0XHRcdC8vIEluIHRocm90dGxlIG1vZGUsIGlmIGBkZWxheWAgdGltZSBoYXMgYmVlbiBleGNlZWRlZCwgZXhlY3V0ZVxuXHRcdFx0Ly8gYGNhbGxiYWNrYC5cblx0XHRcdGV4ZWMoKTtcblxuXHRcdH0gZWxzZSBpZiAoIG5vVHJhaWxpbmcgIT09IHRydWUgKSB7XG5cdFx0XHQvLyBJbiB0cmFpbGluZyB0aHJvdHRsZSBtb2RlLCBzaW5jZSBgZGVsYXlgIHRpbWUgaGFzIG5vdCBiZWVuXG5cdFx0XHQvLyBleGNlZWRlZCwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGBkZWxheWAgbXMgYWZ0ZXIgbW9zdFxuXHRcdFx0Ly8gcmVjZW50IGV4ZWN1dGlvbi5cblx0XHRcdC8vXG5cdFx0XHQvLyBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZVxuXHRcdFx0Ly8gYWZ0ZXIgYGRlbGF5YCBtcy5cblx0XHRcdC8vXG5cdFx0XHQvLyBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0b1xuXHRcdFx0Ly8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxuXHRcdFx0dGltZW91dElEID0gc2V0VGltZW91dChkZWJvdW5jZU1vZGUgPyBjbGVhciA6IGV4ZWMsIGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkID8gZGVsYXkgLSBlbGFwc2VkIDogZGVsYXkpO1xuXHRcdH1cblxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuXHRyZXR1cm4gd3JhcHBlcjtcblxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///597f\n")},"664f":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_avoid_vue_vue_type_style_index_0_id_54c9288a_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9bf0");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_avoid_vue_vue_type_style_index_0_id_54c9288a_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_avoid_vue_vue_type_style_index_0_id_54c9288a_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYXZvaWQudnVlP2JkMGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBIiwiZmlsZSI6IjY2NGYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tMTEtb25lT2YtMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTExLW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xMS1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTExLW9uZU9mLTEtMyEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtcmVzb3VyY2VzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMTEtb25lT2YtMS00IS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vYXZvaWQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NTRjOTI4OGEmcHJvZCZzY29wZWQ9dHJ1ZSZsYW5nPWxlc3MmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///664f\n')},6664:function(module,exports,__webpack_require__){eval('var _typeof = __webpack_require__("7037")["default"];\n\n!function (t) {\n  var n = {};\n\n  function i(a) {\n    if (n[a]) return n[a].exports;\n    var e = n[a] = {\n      i: a,\n      l: !1,\n      exports: {}\n    };\n    return t[a].call(e.exports, e, e.exports, i), e.l = !0, e.exports;\n  }\n\n  i.m = t, i.c = n, i.d = function (t, n, a) {\n    i.o(t, n) || Object.defineProperty(t, n, {\n      enumerable: !0,\n      get: a\n    });\n  }, i.r = function (t) {\n    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n      value: "Module"\n    }), Object.defineProperty(t, "__esModule", {\n      value: !0\n    });\n  }, i.t = function (t, n) {\n    if (1 & n && (t = i(t)), 8 & n) return t;\n    if (4 & n && "object" == _typeof(t) && t && t.__esModule) return t;\n    var a = Object.create(null);\n    if (i.r(a), Object.defineProperty(a, "default", {\n      enumerable: !0,\n      value: t\n    }), 2 & n && "string" != typeof t) for (var e in t) {\n      i.d(a, e, function (n) {\n        return t[n];\n      }.bind(null, e));\n    }\n    return a;\n  }, i.n = function (t) {\n    var n = t && t.__esModule ? function () {\n      return t["default"];\n    } : function () {\n      return t;\n    };\n    return i.d(n, "a", n), n;\n  }, i.o = function (t, n) {\n    return Object.prototype.hasOwnProperty.call(t, n);\n  }, i.p = "", i(i.s = 0);\n}([function (t, n, i) {\n  var a = i(1),\n      e = i(3);\n  window.L.CanvasIconLayer = e(L), window.rbush = a;\n}, function (t, n, i) {\n  "use strict";\n\n  t.exports = e, t.exports["default"] = e;\n  var a = i(2);\n\n  function e(t, n) {\n    if (!(this instanceof e)) return new e(t, n);\n    this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), n && this._initFormat(n), this.clear();\n  }\n\n  function r(t, n, i) {\n    if (!i) return n.indexOf(t);\n\n    for (var a = 0; a < n.length; a++) {\n      if (i(t, n[a])) return a;\n    }\n\n    return -1;\n  }\n\n  function o(t, n) {\n    s(t, 0, t.children.length, n, t);\n  }\n\n  function s(t, n, i, a, e) {\n    e || (e = _(null)), e.minX = 1 / 0, e.minY = 1 / 0, e.maxX = -1 / 0, e.maxY = -1 / 0;\n\n    for (var r, o = n; o < i; o++) {\n      r = t.children[o], h(e, t.leaf ? a(r) : r);\n    }\n\n    return e;\n  }\n\n  function h(t, n) {\n    return t.minX = Math.min(t.minX, n.minX), t.minY = Math.min(t.minY, n.minY), t.maxX = Math.max(t.maxX, n.maxX), t.maxY = Math.max(t.maxY, n.maxY), t;\n  }\n\n  function l(t, n) {\n    return t.minX - n.minX;\n  }\n\n  function c(t, n) {\n    return t.minY - n.minY;\n  }\n\n  function m(t) {\n    return (t.maxX - t.minX) * (t.maxY - t.minY);\n  }\n\n  function u(t) {\n    return t.maxX - t.minX + (t.maxY - t.minY);\n  }\n\n  function f(t, n) {\n    return t.minX <= n.minX && t.minY <= n.minY && n.maxX <= t.maxX && n.maxY <= t.maxY;\n  }\n\n  function d(t, n) {\n    return n.minX <= t.maxX && n.minY <= t.maxY && n.maxX >= t.minX && n.maxY >= t.minY;\n  }\n\n  function _(t) {\n    return {\n      children: t,\n      height: 1,\n      leaf: !0,\n      minX: 1 / 0,\n      minY: 1 / 0,\n      maxX: -1 / 0,\n      maxY: -1 / 0\n    };\n  }\n\n  function p(t, n, i, e, r) {\n    for (var o, s = [n, i]; s.length;) {\n      (i = s.pop()) - (n = s.pop()) <= e || (o = n + Math.ceil((i - n) / e / 2) * e, a(t, o, n, i, r), s.push(n, o, o, i));\n    }\n  }\n\n  e.prototype = {\n    all: function all() {\n      return this._all(this.data, []);\n    },\n    search: function search(t) {\n      var n = this.data,\n          i = [],\n          a = this.toBBox;\n      if (!d(t, n)) return i;\n\n      for (var e, r, o, s, h = []; n;) {\n        for (e = 0, r = n.children.length; e < r; e++) {\n          o = n.children[e], d(t, s = n.leaf ? a(o) : o) && (n.leaf ? i.push(o) : f(t, s) ? this._all(o, i) : h.push(o));\n        }\n\n        n = h.pop();\n      }\n\n      return i;\n    },\n    collides: function collides(t) {\n      var n = this.data,\n          i = this.toBBox;\n      if (!d(t, n)) return !1;\n\n      for (var a, e, r, o, s = []; n;) {\n        for (a = 0, e = n.children.length; a < e; a++) {\n          if (r = n.children[a], d(t, o = n.leaf ? i(r) : r)) {\n            if (n.leaf || f(t, o)) return !0;\n            s.push(r);\n          }\n        }\n\n        n = s.pop();\n      }\n\n      return !1;\n    },\n    load: function load(t) {\n      if (!t || !t.length) return this;\n\n      if (t.length < this._minEntries) {\n        for (var n = 0, i = t.length; n < i; n++) {\n          this.insert(t[n]);\n        }\n\n        return this;\n      }\n\n      var a = this._build(t.slice(), 0, t.length - 1, 0);\n\n      if (this.data.children.length) {\n        if (this.data.height === a.height) this._splitRoot(this.data, a);else {\n          if (this.data.height < a.height) {\n            var e = this.data;\n            this.data = a, a = e;\n          }\n\n          this._insert(a, this.data.height - a.height - 1, !0);\n        }\n      } else this.data = a;\n      return this;\n    },\n    insert: function insert(t) {\n      return t && this._insert(t, this.data.height - 1), this;\n    },\n    clear: function clear() {\n      return this.data = _([]), this;\n    },\n    remove: function remove(t, n) {\n      if (!t) return this;\n\n      for (var i, a, e, o, s = this.data, h = this.toBBox(t), l = [], c = []; s || l.length;) {\n        if (s || (s = l.pop(), a = l[l.length - 1], i = c.pop(), o = !0), s.leaf && -1 !== (e = r(t, s.children, n))) return s.children.splice(e, 1), l.push(s), this._condense(l), this;\n        o || s.leaf || !f(s, h) ? a ? (i++, s = a.children[i], o = !1) : s = null : (l.push(s), c.push(i), i = 0, a = s, s = s.children[0]);\n      }\n\n      return this;\n    },\n    toBBox: function toBBox(t) {\n      return t;\n    },\n    compareMinX: l,\n    compareMinY: c,\n    toJSON: function toJSON() {\n      return this.data;\n    },\n    fromJSON: function fromJSON(t) {\n      return this.data = t, this;\n    },\n    _all: function _all(t, n) {\n      for (var i = []; t;) {\n        t.leaf ? n.push.apply(n, t.children) : i.push.apply(i, t.children), t = i.pop();\n      }\n\n      return n;\n    },\n    _build: function _build(t, n, i, a) {\n      var e,\n          r = i - n + 1,\n          s = this._maxEntries;\n      if (r <= s) return o(e = _(t.slice(n, i + 1)), this.toBBox), e;\n      a || (a = Math.ceil(Math.log(r) / Math.log(s)), s = Math.ceil(r / Math.pow(s, a - 1))), (e = _([])).leaf = !1, e.height = a;\n      var h,\n          l,\n          c,\n          m,\n          u = Math.ceil(r / s),\n          f = u * Math.ceil(Math.sqrt(s));\n\n      for (p(t, n, i, f, this.compareMinX), h = n; h <= i; h += f) {\n        for (p(t, h, c = Math.min(h + f - 1, i), u, this.compareMinY), l = h; l <= c; l += u) {\n          m = Math.min(l + u - 1, c), e.children.push(this._build(t, l, m, a - 1));\n        }\n      }\n\n      return o(e, this.toBBox), e;\n    },\n    _chooseSubtree: function _chooseSubtree(t, n, i, a) {\n      for (var e, r, o, s, h, l, c, u, f, d; a.push(n), !n.leaf && a.length - 1 !== i;) {\n        for (c = u = 1 / 0, e = 0, r = n.children.length; e < r; e++) {\n          h = m(o = n.children[e]), f = t, d = o, (l = (Math.max(d.maxX, f.maxX) - Math.min(d.minX, f.minX)) * (Math.max(d.maxY, f.maxY) - Math.min(d.minY, f.minY)) - h) < u ? (u = l, c = h < c ? h : c, s = o) : l === u && h < c && (c = h, s = o);\n        }\n\n        n = s || n.children[0];\n      }\n\n      return n;\n    },\n    _insert: function _insert(t, n, i) {\n      var a = this.toBBox,\n          e = i ? t : a(t),\n          r = [],\n          o = this._chooseSubtree(e, this.data, n, r);\n\n      for (o.children.push(t), h(o, e); n >= 0 && r[n].children.length > this._maxEntries;) {\n        this._split(r, n), n--;\n      }\n\n      this._adjustParentBBoxes(e, r, n);\n    },\n    _split: function _split(t, n) {\n      var i = t[n],\n          a = i.children.length,\n          e = this._minEntries;\n\n      this._chooseSplitAxis(i, e, a);\n\n      var r = this._chooseSplitIndex(i, e, a),\n          s = _(i.children.splice(r, i.children.length - r));\n\n      s.height = i.height, s.leaf = i.leaf, o(i, this.toBBox), o(s, this.toBBox), n ? t[n - 1].children.push(s) : this._splitRoot(i, s);\n    },\n    _splitRoot: function _splitRoot(t, n) {\n      this.data = _([t, n]), this.data.height = t.height + 1, this.data.leaf = !1, o(this.data, this.toBBox);\n    },\n    _chooseSplitIndex: function _chooseSplitIndex(t, n, i) {\n      var a, e, r, o, h, l, c, u, f, d, _, p, x, g;\n\n      for (l = c = 1 / 0, a = n; a <= i - n; a++) {\n        e = s(t, 0, a, this.toBBox), r = s(t, a, i, this.toBBox), f = e, d = r, void 0, void 0, void 0, void 0, _ = Math.max(f.minX, d.minX), p = Math.max(f.minY, d.minY), x = Math.min(f.maxX, d.maxX), g = Math.min(f.maxY, d.maxY), o = Math.max(0, x - _) * Math.max(0, g - p), h = m(e) + m(r), o < l ? (l = o, u = a, c = h < c ? h : c) : o === l && h < c && (c = h, u = a);\n      }\n\n      return u;\n    },\n    _chooseSplitAxis: function _chooseSplitAxis(t, n, i) {\n      var a = t.leaf ? this.compareMinX : l,\n          e = t.leaf ? this.compareMinY : c;\n      this._allDistMargin(t, n, i, a) < this._allDistMargin(t, n, i, e) && t.children.sort(a);\n    },\n    _allDistMargin: function _allDistMargin(t, n, i, a) {\n      t.children.sort(a);\n      var e,\n          r,\n          o = this.toBBox,\n          l = s(t, 0, n, o),\n          c = s(t, i - n, i, o),\n          m = u(l) + u(c);\n\n      for (e = n; e < i - n; e++) {\n        r = t.children[e], h(l, t.leaf ? o(r) : r), m += u(l);\n      }\n\n      for (e = i - n - 1; e >= n; e--) {\n        r = t.children[e], h(c, t.leaf ? o(r) : r), m += u(c);\n      }\n\n      return m;\n    },\n    _adjustParentBBoxes: function _adjustParentBBoxes(t, n, i) {\n      for (var a = i; a >= 0; a--) {\n        h(n[a], t);\n      }\n    },\n    _condense: function _condense(t) {\n      for (var n, i = t.length - 1; i >= 0; i--) {\n        0 === t[i].children.length ? i > 0 ? (n = t[i - 1].children).splice(n.indexOf(t[i]), 1) : this.clear() : o(t[i], this.toBBox);\n      }\n    },\n    _initFormat: function _initFormat(t) {\n      var n = ["return a", " - b", ";"];\n      this.compareMinX = new Function("a", "b", n.join(t[0])), this.compareMinY = new Function("a", "b", n.join(t[1])), this.toBBox = new Function("a", "return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};");\n    }\n  };\n}, function (t, n, i) {\n  t.exports = function () {\n    "use strict";\n\n    function t(t, n, i) {\n      var a = t[n];\n      t[n] = t[i], t[i] = a;\n    }\n\n    function n(t, n) {\n      return t < n ? -1 : t > n ? 1 : 0;\n    }\n\n    return function (i, a, e, r, o) {\n      !function n(i, a, e, r, o) {\n        for (; r > e;) {\n          if (r - e > 600) {\n            var s = r - e + 1,\n                h = a - e + 1,\n                l = Math.log(s),\n                c = .5 * Math.exp(2 * l / 3),\n                m = .5 * Math.sqrt(l * c * (s - c) / s) * (h - s / 2 < 0 ? -1 : 1),\n                u = Math.max(e, Math.floor(a - h * c / s + m)),\n                f = Math.min(r, Math.floor(a + (s - h) * c / s + m));\n            n(i, a, u, f, o);\n          }\n\n          var d = i[a],\n              _ = e,\n              p = r;\n\n          for (t(i, e, a), o(i[r], d) > 0 && t(i, e, r); _ < p;) {\n            for (t(i, _, p), _++, p--; o(i[_], d) < 0;) {\n              _++;\n            }\n\n            for (; o(i[p], d) > 0;) {\n              p--;\n            }\n          }\n\n          0 === o(i[e], d) ? t(i, e, p) : t(i, ++p, r), p <= a && (e = p + 1), a <= p && (r = p - 1);\n        }\n      }(i, a, e || 0, r || i.length - 1, o || n);\n    };\n  }();\n}, function (t, n, i) {\n  "use strict";\n\n  t.exports = function (t) {\n    var n = (t.Layer ? t.Layer : t.Class).extend({\n      initialize: function initialize(n) {\n        t.setOptions(this, n), this._onClickListeners = [], this._onHoverListeners = [];\n      },\n      setOptions: function setOptions(n) {\n        return t.setOptions(this, n), this.redraw();\n      },\n      redraw: function redraw() {\n        this._redraw(!0);\n      },\n      addMarkers: function addMarkers(t) {\n        var n = this,\n            i = [],\n            a = [];\n        t.forEach(function (t) {\n          if ("markerPane" == t.options.pane && t.options.icon) {\n            var e = t.getLatLng(),\n                r = n._map.getBounds().contains(e),\n                o = n._addMarker(t, e, r);\n\n            !0 === r && i.push(o[0]), a.push(o[1]);\n          } else console.error("Layer isn\'t a marker");\n        }), n._markers.load(i), n._latlngMarkers.load(a);\n      },\n      addMarker: function addMarker(t) {\n        var n = t.getLatLng(),\n            i = this._map.getBounds().contains(n),\n            a = this._addMarker(t, n, i);\n\n        !0 === i && this._markers.insert(a[0]), this._latlngMarkers.insert(a[1]);\n      },\n      addLayer: function addLayer(t) {\n        "markerPane" == t.options.pane && t.options.icon ? this.addMarker(t) : console.error("Layer isn\'t a marker");\n      },\n      addLayers: function addLayers(t) {\n        this.addMarkers(t);\n      },\n      removeLayer: function removeLayer(t) {\n        this.removeMarker(t, !0);\n      },\n      removeMarker: function removeMarker(t, n) {\n        t.minX && (t = t.data);\n\n        var i = t.getLatLng(),\n            a = this._map.getBounds().contains(i),\n            e = {\n          minX: i.lng,\n          minY: i.lat,\n          maxX: i.lng,\n          maxY: i.lat,\n          data: t\n        };\n\n        this._latlngMarkers.remove(e, function (t, n) {\n          return t.data._leaflet_id === n.data._leaflet_id;\n        }), this._latlngMarkers.total--, this._latlngMarkers.dirty++, !0 === a && !0 === n && this._redraw(!0);\n      },\n      onAdd: function onAdd(t) {\n        this._map = t, this._canvas || this._initCanvas(), this.options.pane ? this.getPane().appendChild(this._canvas) : t._panes.overlayPane.appendChild(this._canvas), t.on("moveend", this._reset, this), t.on("resize", this._reset, this), t.on("click", this._executeListeners, this), t.on("mousemove", this._executeListeners, this), t._zoomAnimated && t.on("zoomanim", this._animateZoom, this);\n      },\n      onRemove: function onRemove(t) {\n        this.options.pane ? this.getPane().removeChild(this._canvas) : t.getPanes().overlayPane.removeChild(this._canvas), t.off("click", this._executeListeners, this), t.off("mousemove", this._executeListeners, this), t.off("moveend", this._reset, this), t.off("resize", this._reset, this), t._zoomAnimated && t.off("zoomanim", this._animateZoom, this);\n      },\n      addTo: function addTo(t) {\n        return t.addLayer(this), this;\n      },\n      clearLayers: function clearLayers() {\n        this._latlngMarkers = null, this._markers = null, this._redraw(!0);\n      },\n      _animateZoom: function _animateZoom(n) {\n        var i = this._map.getZoomScale(n.zoom),\n            a = this._map._latLngBoundsToNewLayerBounds(this._map.getBounds(), n.zoom, n.center).min;\n\n        t.DomUtil.setTransform(this._canvas, a, i);\n      },\n      _addMarker: function _addMarker(n, i, a) {\n        n._map = this._map, this._markers || (this._markers = new rbush()), this._latlngMarkers || (this._latlngMarkers = new rbush(), this._latlngMarkers.dirty = 0, this._latlngMarkers.total = 0), t.Util.stamp(n);\n\n        var e = this._map.latLngToContainerPoint(i),\n            r = n.options.icon.options.iconSize,\n            o = r[0] / 2,\n            s = r[1] / 2,\n            h = [{\n          minX: e.x - o,\n          minY: e.y - s,\n          maxX: e.x + o,\n          maxY: e.y + s,\n          data: n\n        }, {\n          minX: i.lng,\n          minY: i.lat,\n          maxX: i.lng,\n          maxY: i.lat,\n          data: n\n        }];\n\n        return this._latlngMarkers.dirty++, this._latlngMarkers.total++, !0 === a && this._drawMarker(n, e), h;\n      },\n      _drawMarker: function _drawMarker(t, n) {\n        var i = this;\n        this._imageLookup || (this._imageLookup = {}), n || (n = i._map.latLngToContainerPoint(t.getLatLng()));\n        var a = t.options.icon.options.iconUrl;\n        if (t.canvas_img) i._drawImage(t, n), i._drawText(t, n);else if (i._imageLookup[a]) t.canvas_img = i._imageLookup[a][0], !1 === i._imageLookup[a][1] ? i._imageLookup[a][2].push([t, n]) : (i._drawImage(t, n), i._drawText(t, n));else {\n          var e = new Image();\n          e.src = a, t.canvas_img = e, i._imageLookup[a] = [e, !1, [[t, n]]], e.onload = function () {\n            i._imageLookup[a][1] = !0, i._imageLookup[a][2].forEach(function (t) {\n              i._drawImage(t[0], t[1]), i._drawText(t[0], t[1]);\n            });\n          };\n        }\n      },\n      _drawImage: function _drawImage(t, n) {\n        var i = t.options.icon.options;\n\n        this._context.drawImage(t.canvas_img, n.x - i.iconAnchor[0], n.y - i.iconAnchor[1], i.iconSize[0], i.iconSize[1]);\n      },\n      _drawText: function _drawText(t, n) {\n        var i = t.options.icon.options;\n        i.text && (this._context.font = i.textFont, this._context.fillStyle = i.textFillStyle, this._context.fillText(i.text, n.x - i.textAnchor[0], n.y - i.textAnchor[1]));\n      },\n      _reset: function _reset() {\n        var n = this._map.containerPointToLayerPoint([0, 0]);\n\n        t.DomUtil.setPosition(this._canvas, n);\n\n        var i = this._map.getSize();\n\n        this._canvas.width = i.x, this._canvas.height = i.y, this._redraw();\n      },\n      _redraw: function _redraw(t) {\n        var n = this;\n\n        if (t && this._context.clearRect(0, 0, this._canvas.width, this._canvas.height), this._map && this._latlngMarkers) {\n          var i = [];\n          n._latlngMarkers.dirty / n._latlngMarkers.total >= .1 && (n._latlngMarkers.all().forEach(function (t) {\n            i.push(t);\n          }), n._latlngMarkers.clear(), n._latlngMarkers.load(i), n._latlngMarkers.dirty = 0, i = []);\n\n          var a = n._map.getBounds(),\n              e = {\n            minX: a.getWest(),\n            minY: a.getSouth(),\n            maxX: a.getEast(),\n            maxY: a.getNorth()\n          };\n\n          n._latlngMarkers.search(e).forEach(function (t) {\n            var a = n._map.latLngToContainerPoint(t.data.getLatLng()),\n                e = t.data.options.icon.options.iconSize,\n                r = e[0] / 2,\n                o = e[1] / 2,\n                s = {\n              minX: a.x - r,\n              minY: a.y - o,\n              maxX: a.x + r,\n              maxY: a.y + o,\n              data: t.data\n            };\n\n            i.push(s), n._drawMarker(t.data, a);\n          }), this._markers.clear(), this._markers.load(i);\n        }\n      },\n      _initCanvas: function _initCanvas() {\n        this._canvas = t.DomUtil.create("canvas", "leaflet-canvas-icon-layer leaflet-layer");\n\n        var n = this._map.getSize();\n\n        this._canvas.width = n.x, this._canvas.height = n.y, this._context = this._canvas.getContext("2d");\n        var i = this._map.options.zoomAnimation && t.Browser.any3d;\n        t.DomUtil.addClass(this._canvas, "leaflet-zoom-" + (i ? "animated" : "hide"));\n      },\n      addOnClickListener: function addOnClickListener(t) {\n        this._onClickListeners.push(t);\n      },\n      addOnHoverListener: function addOnHoverListener(t) {\n        this._onHoverListeners.push(t);\n      },\n      _executeListeners: function _executeListeners(t) {\n        if (this._markers) {\n          var n = this,\n              i = t.containerPoint.x,\n              a = t.containerPoint.y;\n          n._openToolTip && (n._openToolTip.closeTooltip(), delete n._openToolTip);\n\n          var e = this._markers.search({\n            minX: i,\n            minY: a,\n            maxX: i,\n            maxY: a\n          });\n\n          e && e.length > 0 ? (n._map._container.style.cursor = "pointer", "click" === t.type && (e[0].data.getPopup() && e[0].data.openPopup(), n._onClickListeners.forEach(function (n) {\n            n(t, e);\n          })), "mousemove" === t.type && (e[0].data.getTooltip() && (n._openToolTip = e[0].data, e[0].data.openTooltip()), n._onHoverListeners.forEach(function (n) {\n            n(t, e);\n          }))) : n._map._container.style.cursor = "";\n        }\n      }\n    });\n\n    t.canvasIconLayer = function (t) {\n      return new n(t);\n    };\n  };\n}]);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvd2xlYWZsZXQvbGliL2xlYWZsZXQuY2FudmFzLW1hcmtlcnMuanM/NjY2NCJdLCJuYW1lcyI6WyJ0IiwibiIsImkiLCJhIiwiZXhwb3J0cyIsImUiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsIl9fZXNNb2R1bGUiLCJjcmVhdGUiLCJiaW5kIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIndpbmRvdyIsIkwiLCJDYW52YXNJY29uTGF5ZXIiLCJyYnVzaCIsIl9tYXhFbnRyaWVzIiwiTWF0aCIsIm1heCIsIl9taW5FbnRyaWVzIiwiY2VpbCIsIl9pbml0Rm9ybWF0IiwiY2xlYXIiLCJpbmRleE9mIiwibGVuZ3RoIiwiY2hpbGRyZW4iLCJfIiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsImgiLCJsZWFmIiwibWluIiwidSIsImYiLCJoZWlnaHQiLCJwb3AiLCJwdXNoIiwiYWxsIiwiX2FsbCIsImRhdGEiLCJzZWFyY2giLCJ0b0JCb3giLCJjb2xsaWRlcyIsImxvYWQiLCJpbnNlcnQiLCJfYnVpbGQiLCJzbGljZSIsIl9zcGxpdFJvb3QiLCJfaW5zZXJ0IiwicmVtb3ZlIiwic3BsaWNlIiwiX2NvbmRlbnNlIiwiY29tcGFyZU1pblgiLCJjb21wYXJlTWluWSIsInRvSlNPTiIsImZyb21KU09OIiwiYXBwbHkiLCJsb2ciLCJwb3ciLCJzcXJ0IiwiX2Nob29zZVN1YnRyZWUiLCJfc3BsaXQiLCJfYWRqdXN0UGFyZW50QkJveGVzIiwiX2Nob29zZVNwbGl0QXhpcyIsIl9jaG9vc2VTcGxpdEluZGV4IiwieCIsImciLCJfYWxsRGlzdE1hcmdpbiIsInNvcnQiLCJGdW5jdGlvbiIsImpvaW4iLCJleHAiLCJmbG9vciIsIkxheWVyIiwiQ2xhc3MiLCJleHRlbmQiLCJpbml0aWFsaXplIiwic2V0T3B0aW9ucyIsIl9vbkNsaWNrTGlzdGVuZXJzIiwiX29uSG92ZXJMaXN0ZW5lcnMiLCJyZWRyYXciLCJfcmVkcmF3IiwiYWRkTWFya2VycyIsImZvckVhY2giLCJvcHRpb25zIiwicGFuZSIsImljb24iLCJnZXRMYXRMbmciLCJfbWFwIiwiZ2V0Qm91bmRzIiwiY29udGFpbnMiLCJfYWRkTWFya2VyIiwiY29uc29sZSIsImVycm9yIiwiX21hcmtlcnMiLCJfbGF0bG5nTWFya2VycyIsImFkZE1hcmtlciIsImFkZExheWVyIiwiYWRkTGF5ZXJzIiwicmVtb3ZlTGF5ZXIiLCJyZW1vdmVNYXJrZXIiLCJsbmciLCJsYXQiLCJfbGVhZmxldF9pZCIsInRvdGFsIiwiZGlydHkiLCJvbkFkZCIsIl9jYW52YXMiLCJfaW5pdENhbnZhcyIsImdldFBhbmUiLCJhcHBlbmRDaGlsZCIsIl9wYW5lcyIsIm92ZXJsYXlQYW5lIiwib24iLCJfcmVzZXQiLCJfZXhlY3V0ZUxpc3RlbmVycyIsIl96b29tQW5pbWF0ZWQiLCJfYW5pbWF0ZVpvb20iLCJvblJlbW92ZSIsInJlbW92ZUNoaWxkIiwiZ2V0UGFuZXMiLCJvZmYiLCJhZGRUbyIsImNsZWFyTGF5ZXJzIiwiZ2V0Wm9vbVNjYWxlIiwiem9vbSIsIl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzIiwiY2VudGVyIiwiRG9tVXRpbCIsInNldFRyYW5zZm9ybSIsIlV0aWwiLCJzdGFtcCIsImxhdExuZ1RvQ29udGFpbmVyUG9pbnQiLCJpY29uU2l6ZSIsInkiLCJfZHJhd01hcmtlciIsIl9pbWFnZUxvb2t1cCIsImljb25VcmwiLCJjYW52YXNfaW1nIiwiX2RyYXdJbWFnZSIsIl9kcmF3VGV4dCIsIkltYWdlIiwic3JjIiwib25sb2FkIiwiX2NvbnRleHQiLCJkcmF3SW1hZ2UiLCJpY29uQW5jaG9yIiwidGV4dCIsImZvbnQiLCJ0ZXh0Rm9udCIsImZpbGxTdHlsZSIsInRleHRGaWxsU3R5bGUiLCJmaWxsVGV4dCIsInRleHRBbmNob3IiLCJjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCIsInNldFBvc2l0aW9uIiwiZ2V0U2l6ZSIsIndpZHRoIiwiY2xlYXJSZWN0IiwiZ2V0V2VzdCIsImdldFNvdXRoIiwiZ2V0RWFzdCIsImdldE5vcnRoIiwiZ2V0Q29udGV4dCIsInpvb21BbmltYXRpb24iLCJCcm93c2VyIiwiYW55M2QiLCJhZGRDbGFzcyIsImFkZE9uQ2xpY2tMaXN0ZW5lciIsImFkZE9uSG92ZXJMaXN0ZW5lciIsImNvbnRhaW5lclBvaW50IiwiX29wZW5Ub29sVGlwIiwiY2xvc2VUb29sdGlwIiwiX2NvbnRhaW5lciIsInN0eWxlIiwiY3Vyc29yIiwidHlwZSIsImdldFBvcHVwIiwib3BlblBvcHVwIiwiZ2V0VG9vbHRpcCIsIm9wZW5Ub29sdGlwIiwiY2FudmFzSWNvbkxheWVyIl0sIm1hcHBpbmdzIjoiOztBQUFBLENBQUMsVUFBU0EsQ0FBVCxFQUFXO0VBQUMsSUFBSUMsQ0FBQyxHQUFDLEVBQU47O0VBQVMsU0FBU0MsQ0FBVCxDQUFXQyxDQUFYLEVBQWE7SUFBQyxJQUFHRixDQUFDLENBQUNFLENBQUQsQ0FBSixFQUFRLE9BQU9GLENBQUMsQ0FBQ0UsQ0FBRCxDQUFELENBQUtDLE9BQVo7SUFBb0IsSUFBSUMsQ0FBQyxHQUFDSixDQUFDLENBQUNFLENBQUQsQ0FBRCxHQUFLO01BQUNELENBQUMsRUFBQ0MsQ0FBSDtNQUFLRyxDQUFDLEVBQUMsQ0FBQyxDQUFSO01BQVVGLE9BQU8sRUFBQztJQUFsQixDQUFYO0lBQWlDLE9BQU9KLENBQUMsQ0FBQ0csQ0FBRCxDQUFELENBQUtJLElBQUwsQ0FBVUYsQ0FBQyxDQUFDRCxPQUFaLEVBQW9CQyxDQUFwQixFQUFzQkEsQ0FBQyxDQUFDRCxPQUF4QixFQUFnQ0YsQ0FBaEMsR0FBbUNHLENBQUMsQ0FBQ0MsQ0FBRixHQUFJLENBQUMsQ0FBeEMsRUFBMENELENBQUMsQ0FBQ0QsT0FBbkQ7RUFBMkQ7O0VBQUFGLENBQUMsQ0FBQ00sQ0FBRixHQUFJUixDQUFKLEVBQU1FLENB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LEdBQWV2TCxDQUFDLENBQUMsQ0FBRCxDQUFELENBQUttRCxJQUFwQixFQUF5Qm5ELENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBS21ELElBQUwsQ0FBVTZJLFdBQVYsRUFBbEQsR0FBMkVwTSxDQUFDLENBQUMrRixpQkFBRixDQUFvQkksT0FBcEIsQ0FBNEIsVUFBU25HLENBQVQsRUFBVztZQUFDQSxDQUFDLENBQUNELENBQUQsRUFBR0ssQ0FBSCxDQUFEO1VBQU8sQ0FBL0MsQ0FBbEcsQ0FBekssSUFBOFRKLENBQUMsQ0FBQ3dHLElBQUYsQ0FBT3FGLFVBQVAsQ0FBa0JDLEtBQWxCLENBQXdCQyxNQUF4QixHQUErQixFQUE3VjtRQUFnVztNQUFDO0lBQTVtTCxDQUFqQyxDQUFOOztJQUFzcExoTSxDQUFDLENBQUNzTSxlQUFGLEdBQWtCLFVBQVN0TSxDQUFULEVBQVc7TUFBQyxPQUFPLElBQUlDLENBQUosQ0FBTUQsQ0FBTixDQUFQO0lBQWdCLENBQTlDO0VBQStDLENBQTN0TDtBQUE0dEwsQ0FBeGdZLENBQTk0QixDQUFEIiwiZmlsZSI6IjY2NjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCl7dmFyIG49e307ZnVuY3Rpb24gaShhKXtpZihuW2FdKXJldHVybiBuW2FdLmV4cG9ydHM7dmFyIGU9blthXT17aTphLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIHRbYV0uY2FsbChlLmV4cG9ydHMsZSxlLmV4cG9ydHMsaSksZS5sPSEwLGUuZXhwb3J0c31pLm09dCxpLmM9bixpLmQ9ZnVuY3Rpb24odCxuLGEpe2kubyh0LG4pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGdldDphfSl9LGkucj1mdW5jdGlvbih0KXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxpLnQ9ZnVuY3Rpb24odCxuKXtpZigxJm4mJih0PWkodCkpLDgmbilyZXR1cm4gdDtpZig0Jm4mJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGE9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihpLnIoYSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImbiYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpZm9yKHZhciBlIGluIHQpaS5kKGEsZSxmdW5jdGlvbihuKXtyZXR1cm4gdFtuXX0uYmluZChudWxsLGUpKTtyZXR1cm4gYX0saS5uPWZ1bmN0aW9uKHQpe3ZhciBuPXQmJnQuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiB0LmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIHR9O3JldHVybiBpLmQobixcImFcIixuKSxufSxpLm89ZnVuY3Rpb24odCxuKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbil9LGkucD1cIlwiLGkoaS5zPTApfShbZnVuY3Rpb24odCxuLGkpe3ZhciBhPWkoMSksZT1pKDMpO3dpbmRvdy5MLkNhbnZhc0ljb25MYXllcj1lKEwpLHdpbmRvdy5yYnVzaD1hfSxmdW5jdGlvbih0LG4saSl7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWUsdC5leHBvcnRzLmRlZmF1bHQ9ZTt2YXIgYT1pKDIpO2Z1bmN0aW9uIGUodCxuKXtpZighKHRoaXMgaW5zdGFuY2VvZiBlKSlyZXR1cm4gbmV3IGUodCxuKTt0aGlzLl9tYXhFbnRyaWVzPU1hdGgubWF4KDQsdHx8OSksdGhpcy5fbWluRW50cmllcz1NYXRoLm1heCgyLE1hdGguY2VpbCguNCp0aGlzLl9tYXhFbnRyaWVzKSksbiYmdGhpcy5faW5pdEZvcm1hdChuKSx0aGlzLmNsZWFyKCl9ZnVuY3Rpb24gcih0LG4saSl7aWYoIWkpcmV0dXJuIG4uaW5kZXhPZih0KTtmb3IodmFyIGE9MDthPG4ubGVuZ3RoO2ErKylpZihpKHQsblthXSkpcmV0dXJuIGE7cmV0dXJuLTF9ZnVuY3Rpb24gbyh0LG4pe3ModCwwLHQuY2hpbGRyZW4ubGVuZ3RoLG4sdCl9ZnVuY3Rpb24gcyh0LG4saSxhLGUpe2V8fChlPV8obnVsbCkpLGUubWluWD0xLzAsZS5taW5ZPTEvMCxlLm1heFg9LTEvMCxlLm1heFk9LTEvMDtmb3IodmFyIHIsbz1uO288aTtvKyspcj10LmNoaWxkcmVuW29dLGgoZSx0LmxlYWY/YShyKTpyKTtyZXR1cm4gZX1mdW5jdGlvbiBoKHQsbil7cmV0dXJuIHQubWluWD1NYXRoLm1pbih0Lm1pblgsbi5taW5YKSx0Lm1pblk9TWF0aC5taW4odC5taW5ZLG4ubWluWSksdC5tYXhYPU1hdGgubWF4KHQubWF4WCxuLm1heFgpLHQubWF4WT1NYXRoLm1heCh0Lm1heFksbi5tYXhZKSx0fWZ1bmN0aW9uIGwodCxuKXtyZXR1cm4gdC5taW5YLW4ubWluWH1mdW5jdGlvbiBjKHQsbil7cmV0dXJuIHQubWluWS1uLm1pbll9ZnVuY3Rpb24gbSh0KXtyZXR1cm4odC5tYXhYLXQubWluWCkqKHQubWF4WS10Lm1pblkpfWZ1bmN0aW9uIHUodCl7cmV0dXJuIHQubWF4WC10Lm1pblgrKHQubWF4WS10Lm1pblkpfWZ1bmN0aW9uIGYodCxuKXtyZXR1cm4gdC5taW5YPD1uLm1pblgmJnQubWluWTw9bi5taW5ZJiZuLm1heFg8PXQubWF4WCYmbi5tYXhZPD10Lm1heFl9ZnVuY3Rpb24gZCh0LG4pe3JldHVybiBuLm1pblg8PXQubWF4WCYmbi5taW5ZPD10Lm1heFkmJm4ubWF4WD49dC5taW5YJiZuLm1heFk+PXQubWluWX1mdW5jdGlvbiBfKHQpe3JldHVybntjaGlsZHJlbjp0LGhlaWdodDoxLGxlYWY6ITAsbWluWDoxLzAsbWluWToxLzAsbWF4WDotMS8wLG1heFk6LTEvMH19ZnVuY3Rpb24gcCh0LG4saSxlLHIpe2Zvcih2YXIgbyxzPVtuLGldO3MubGVuZ3RoOykoaT1zLnBvcCgpKS0obj1zLnBvcCgpKTw9ZXx8KG89bitNYXRoLmNlaWwoKGktbikvZS8yKSplLGEodCxvLG4saSxyKSxzLnB1c2gobixvLG8saSkpfWUucHJvdG90eXBlPXthbGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSxbXSl9LHNlYXJjaDpmdW5jdGlvbih0KXt2YXIgbj10aGlzLmRhdGEsaT1bXSxhPXRoaXMudG9CQm94O2lmKCFkKHQsbikpcmV0dXJuIGk7Zm9yKHZhciBlLHIsbyxzLGg9W107bjspe2ZvcihlPTAscj1uLmNoaWxkcmVuLmxlbmd0aDtlPHI7ZSsrKW89bi5jaGlsZHJlbltlXSxkKHQscz1uLmxlYWY/YShvKTpvKSYmKG4ubGVhZj9pLnB1c2gobyk6Zih0LHMpP3RoaXMuX2FsbChvLGkpOmgucHVzaChvKSk7bj1oLnBvcCgpfXJldHVybiBpfSxjb2xsaWRlczpmdW5jdGlvbih0KXt2YXIgbj10aGlzLmRhdGEsaT10aGlzLnRvQkJveDtpZighZCh0LG4pKXJldHVybiExO2Zvcih2YXIgYSxlLHIsbyxzPVtdO247KXtmb3IoYT0wLGU9bi5jaGlsZHJlbi5sZW5ndGg7YTxlO2ErKylpZihyPW4uY2hpbGRyZW5bYV0sZCh0LG89bi5sZWFmP2kocik6cikpe2lmKG4ubGVhZnx8Zih0LG8pKXJldHVybiEwO3MucHVzaChyKX1uPXMucG9wKCl9cmV0dXJuITF9LGxvYWQ6ZnVuY3Rpb24odCl7aWYoIXR8fCF0Lmxlbmd0aClyZXR1cm4gdGhpcztpZih0Lmxlbmd0aDx0aGlzLl9taW5FbnRyaWVzKXtmb3IodmFyIG49MCxpPXQubGVuZ3RoO248aTtuKyspdGhpcy5pbnNlcnQodFtuXSk7cmV0dXJuIHRoaXN9dmFyIGE9dGhpcy5fYnVpbGQodC5zbGljZSgpLDAsdC5sZW5ndGgtMSwwKTtpZih0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKWlmKHRoaXMuZGF0YS5oZWlnaHQ9PT1hLmhlaWdodCl0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLGEpO2Vsc2V7aWYodGhpcy5kYXRhLmhlaWdodDxhLmhlaWdodCl7dmFyIGU9dGhpcy5kYXRhO3RoaXMuZGF0YT1hLGE9ZX10aGlzLl9pbnNlcnQoYSx0aGlzLmRhdGEuaGVpZ2h0LWEuaGVpZ2h0LTEsITApfWVsc2UgdGhpcy5kYXRhPWE7cmV0dXJuIHRoaXN9LGluc2VydDpmdW5jdGlvbih0KXtyZXR1cm4gdCYmdGhpcy5faW5zZXJ0KHQsdGhpcy5kYXRhLmhlaWdodC0xKSx0aGlzfSxjbGVhcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGE9XyhbXSksdGhpc30scmVtb3ZlOmZ1bmN0aW9uKHQsbil7aWYoIXQpcmV0dXJuIHRoaXM7Zm9yKHZhciBpLGEsZSxvLHM9dGhpcy5kYXRhLGg9dGhpcy50b0JCb3godCksbD1bXSxjPVtdO3N8fGwubGVuZ3RoOyl7aWYoc3x8KHM9bC5wb3AoKSxhPWxbbC5sZW5ndGgtMV0saT1jLnBvcCgpLG89ITApLHMubGVhZiYmLTEhPT0oZT1yKHQscy5jaGlsZHJlbixuKSkpcmV0dXJuIHMuY2hpbGRyZW4uc3BsaWNlKGUsMSksbC5wdXNoKHMpLHRoaXMuX2NvbmRlbnNlKGwpLHRoaXM7b3x8cy5sZWFmfHwhZihzLGgpP2E/KGkrKyxzPWEuY2hpbGRyZW5baV0sbz0hMSk6cz1udWxsOihsLnB1c2gocyksYy5wdXNoKGkpLGk9MCxhPXMscz1zLmNoaWxkcmVuWzBdKX1yZXR1cm4gdGhpc30sdG9CQm94OmZ1bmN0aW9uKHQpe3JldHVybiB0fSxjb21wYXJlTWluWDpsLGNvbXBhcmVNaW5ZOmMsdG9KU09OOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sZnJvbUpTT046ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YT10LHRoaXN9LF9hbGw6ZnVuY3Rpb24odCxuKXtmb3IodmFyIGk9W107dDspdC5sZWFmP24ucHVzaC5hcHBseShuLHQuY2hpbGRyZW4pOmkucHVzaC5hcHBseShpLHQuY2hpbGRyZW4pLHQ9aS5wb3AoKTtyZXR1cm4gbn0sX2J1aWxkOmZ1bmN0aW9uKHQsbixpLGEpe3ZhciBlLHI9aS1uKzEscz10aGlzLl9tYXhFbnRyaWVzO2lmKHI8PXMpcmV0dXJuIG8oZT1fKHQuc2xpY2UobixpKzEpKSx0aGlzLnRvQkJveCksZTthfHwoYT1NYXRoLmNlaWwoTWF0aC5sb2cocikvTWF0aC5sb2cocykpLHM9TWF0aC5jZWlsKHIvTWF0aC5wb3cocyxhLTEpKSksKGU9XyhbXSkpLmxlYWY9ITEsZS5oZWlnaHQ9YTt2YXIgaCxsLGMsbSx1PU1hdGguY2VpbChyL3MpLGY9dSpNYXRoLmNlaWwoTWF0aC5zcXJ0KHMpKTtmb3IocCh0LG4saSxmLHRoaXMuY29tcGFyZU1pblgpLGg9bjtoPD1pO2grPWYpZm9yKHAodCxoLGM9TWF0aC5taW4oaCtmLTEsaSksdSx0aGlzLmNvbXBhcmVNaW5ZKSxsPWg7bDw9YztsKz11KW09TWF0aC5taW4obCt1LTEsYyksZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKHQsbCxtLGEtMSkpO3JldHVybiBvKGUsdGhpcy50b0JCb3gpLGV9LF9jaG9vc2VTdWJ0cmVlOmZ1bmN0aW9uKHQsbixpLGEpe2Zvcih2YXIgZSxyLG8scyxoLGwsYyx1LGYsZDthLnB1c2gobiksIW4ubGVhZiYmYS5sZW5ndGgtMSE9PWk7KXtmb3IoYz11PTEvMCxlPTAscj1uLmNoaWxkcmVuLmxlbmd0aDtlPHI7ZSsrKWg9bShvPW4uY2hpbGRyZW5bZV0pLGY9dCxkPW8sKGw9KE1hdGgubWF4KGQubWF4WCxmLm1heFgpLU1hdGgubWluKGQubWluWCxmLm1pblgpKSooTWF0aC5tYXgoZC5tYXhZLGYubWF4WSktTWF0aC5taW4oZC5taW5ZLGYubWluWSkpLWgpPHU/KHU9bCxjPWg8Yz9oOmMscz1vKTpsPT09dSYmaDxjJiYoYz1oLHM9byk7bj1zfHxuLmNoaWxkcmVuWzBdfXJldHVybiBufSxfaW5zZXJ0OmZ1bmN0aW9uKHQsbixpKXt2YXIgYT10aGlzLnRvQkJveCxlPWk/dDphKHQpLHI9W10sbz10aGlzLl9jaG9vc2VTdWJ0cmVlKGUsdGhpcy5kYXRhLG4scik7Zm9yKG8uY2hpbGRyZW4ucHVzaCh0KSxoKG8sZSk7bj49MCYmcltuXS5jaGlsZHJlbi5sZW5ndGg+dGhpcy5fbWF4RW50cmllczspdGhpcy5fc3BsaXQocixuKSxuLS07dGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKGUscixuKX0sX3NwbGl0OmZ1bmN0aW9uKHQsbil7dmFyIGk9dFtuXSxhPWkuY2hpbGRyZW4ubGVuZ3RoLGU9dGhpcy5fbWluRW50cmllczt0aGlzLl9jaG9vc2VTcGxpdEF4aXMoaSxlLGEpO3ZhciByPXRoaXMuX2Nob29zZVNwbGl0SW5kZXgoaSxlLGEpLHM9XyhpLmNoaWxkcmVuLnNwbGljZShyLGkuY2hpbGRyZW4ubGVuZ3RoLXIpKTtzLmhlaWdodD1pLmhlaWdodCxzLmxlYWY9aS5sZWFmLG8oaSx0aGlzLnRvQkJveCksbyhzLHRoaXMudG9CQm94KSxuP3Rbbi0xXS5jaGlsZHJlbi5wdXNoKHMpOnRoaXMuX3NwbGl0Um9vdChpLHMpfSxfc3BsaXRSb290OmZ1bmN0aW9uKHQsbil7dGhpcy5kYXRhPV8oW3Qsbl0pLHRoaXMuZGF0YS5oZWlnaHQ9dC5oZWlnaHQrMSx0aGlzLmRhdGEubGVhZj0hMSxvKHRoaXMuZGF0YSx0aGlzLnRvQkJveCl9LF9jaG9vc2VTcGxpdEluZGV4OmZ1bmN0aW9uKHQsbixpKXt2YXIgYSxlLHIsbyxoLGwsYyx1LGYsZCxfLHAseCxnO2ZvcihsPWM9MS8wLGE9bjthPD1pLW47YSsrKWU9cyh0LDAsYSx0aGlzLnRvQkJveCkscj1zKHQsYSxpLHRoaXMudG9CQm94KSxmPWUsZD1yLHZvaWQgMCx2b2lkIDAsdm9pZCAwLHZvaWQgMCxfPU1hdGgubWF4KGYubWluWCxkLm1pblgpLHA9TWF0aC5tYXgoZi5taW5ZLGQubWluWSkseD1NYXRoLm1pbihmLm1heFgsZC5tYXhYKSxnPU1hdGgubWluKGYubWF4WSxkLm1heFkpLG89TWF0aC5tYXgoMCx4LV8pKk1hdGgubWF4KDAsZy1wKSxoPW0oZSkrbShyKSxvPGw/KGw9byx1PWEsYz1oPGM/aDpjKTpvPT09bCYmaDxjJiYoYz1oLHU9YSk7cmV0dXJuIHV9LF9jaG9vc2VTcGxpdEF4aXM6ZnVuY3Rpb24odCxuLGkpe3ZhciBhPXQubGVhZj90aGlzLmNvbXBhcmVNaW5YOmwsZT10LmxlYWY/dGhpcy5jb21wYXJlTWluWTpjO3RoaXMuX2FsbERpc3RNYXJnaW4odCxuLGksYSk8dGhpcy5fYWxsRGlzdE1hcmdpbih0LG4saSxlKSYmdC5jaGlsZHJlbi5zb3J0KGEpfSxfYWxsRGlzdE1hcmdpbjpmdW5jdGlvbih0LG4saSxhKXt0LmNoaWxkcmVuLnNvcnQoYSk7dmFyIGUscixvPXRoaXMudG9CQm94LGw9cyh0LDAsbixvKSxjPXModCxpLW4saSxvKSxtPXUobCkrdShjKTtmb3IoZT1uO2U8aS1uO2UrKylyPXQuY2hpbGRyZW5bZV0saChsLHQubGVhZj9vKHIpOnIpLG0rPXUobCk7Zm9yKGU9aS1uLTE7ZT49bjtlLS0pcj10LmNoaWxkcmVuW2VdLGgoYyx0LmxlYWY/byhyKTpyKSxtKz11KGMpO3JldHVybiBtfSxfYWRqdXN0UGFyZW50QkJveGVzOmZ1bmN0aW9uKHQsbixpKXtmb3IodmFyIGE9aTthPj0wO2EtLSloKG5bYV0sdCl9LF9jb25kZW5zZTpmdW5jdGlvbih0KXtmb3IodmFyIG4saT10Lmxlbmd0aC0xO2k+PTA7aS0tKTA9PT10W2ldLmNoaWxkcmVuLmxlbmd0aD9pPjA/KG49dFtpLTFdLmNoaWxkcmVuKS5zcGxpY2Uobi5pbmRleE9mKHRbaV0pLDEpOnRoaXMuY2xlYXIoKTpvKHRbaV0sdGhpcy50b0JCb3gpfSxfaW5pdEZvcm1hdDpmdW5jdGlvbih0KXt2YXIgbj1bXCJyZXR1cm4gYVwiLFwiIC0gYlwiLFwiO1wiXTt0aGlzLmNvbXBhcmVNaW5YPW5ldyBGdW5jdGlvbihcImFcIixcImJcIixuLmpvaW4odFswXSkpLHRoaXMuY29tcGFyZU1pblk9bmV3IEZ1bmN0aW9uKFwiYVwiLFwiYlwiLG4uam9pbih0WzFdKSksdGhpcy50b0JCb3g9bmV3IEZ1bmN0aW9uKFwiYVwiLFwicmV0dXJuIHttaW5YOiBhXCIrdFswXStcIiwgbWluWTogYVwiK3RbMV0rXCIsIG1heFg6IGFcIit0WzJdK1wiLCBtYXhZOiBhXCIrdFszXStcIn07XCIpfX19LGZ1bmN0aW9uKHQsbixpKXt0LmV4cG9ydHM9ZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQsbixpKXt2YXIgYT10W25dO3Rbbl09dFtpXSx0W2ldPWF9ZnVuY3Rpb24gbih0LG4pe3JldHVybiB0PG4/LTE6dD5uPzE6MH1yZXR1cm4gZnVuY3Rpb24oaSxhLGUscixvKXshZnVuY3Rpb24gbihpLGEsZSxyLG8pe2Zvcig7cj5lOyl7aWYoci1lPjYwMCl7dmFyIHM9ci1lKzEsaD1hLWUrMSxsPU1hdGgubG9nKHMpLGM9LjUqTWF0aC5leHAoMipsLzMpLG09LjUqTWF0aC5zcXJ0KGwqYyoocy1jKS9zKSooaC1zLzI8MD8tMToxKSx1PU1hdGgubWF4KGUsTWF0aC5mbG9vcihhLWgqYy9zK20pKSxmPU1hdGgubWluKHIsTWF0aC5mbG9vcihhKyhzLWgpKmMvcyttKSk7bihpLGEsdSxmLG8pfXZhciBkPWlbYV0sXz1lLHA9cjtmb3IodChpLGUsYSksbyhpW3JdLGQpPjAmJnQoaSxlLHIpO188cDspe2Zvcih0KGksXyxwKSxfKysscC0tO28oaVtfXSxkKTwwOylfKys7Zm9yKDtvKGlbcF0sZCk+MDspcC0tfTA9PT1vKGlbZV0sZCk/dChpLGUscCk6dChpLCsrcCxyKSxwPD1hJiYoZT1wKzEpLGE8PXAmJihyPXAtMSl9fShpLGEsZXx8MCxyfHxpLmxlbmd0aC0xLG98fG4pfX0oKX0sZnVuY3Rpb24odCxuLGkpe1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgbj0odC5MYXllcj90LkxheWVyOnQuQ2xhc3MpLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbihuKXt0LnNldE9wdGlvbnModGhpcyxuKSx0aGlzLl9vbkNsaWNrTGlzdGVuZXJzPVtdLHRoaXMuX29uSG92ZXJMaXN0ZW5lcnM9W119LHNldE9wdGlvbnM6ZnVuY3Rpb24obil7cmV0dXJuIHQuc2V0T3B0aW9ucyh0aGlzLG4pLHRoaXMucmVkcmF3KCl9LHJlZHJhdzpmdW5jdGlvbigpe3RoaXMuX3JlZHJhdyghMCl9LGFkZE1hcmtlcnM6ZnVuY3Rpb24odCl7dmFyIG49dGhpcyxpPVtdLGE9W107dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKFwibWFya2VyUGFuZVwiPT10Lm9wdGlvbnMucGFuZSYmdC5vcHRpb25zLmljb24pe3ZhciBlPXQuZ2V0TGF0TG5nKCkscj1uLl9tYXAuZ2V0Qm91bmRzKCkuY29udGFpbnMoZSksbz1uLl9hZGRNYXJrZXIodCxlLHIpOyEwPT09ciYmaS5wdXNoKG9bMF0pLGEucHVzaChvWzFdKX1lbHNlIGNvbnNvbGUuZXJyb3IoXCJMYXllciBpc24ndCBhIG1hcmtlclwiKX0pLG4uX21hcmtlcnMubG9hZChpKSxuLl9sYXRsbmdNYXJrZXJzLmxvYWQoYSl9LGFkZE1hcmtlcjpmdW5jdGlvbih0KXt2YXIgbj10LmdldExhdExuZygpLGk9dGhpcy5fbWFwLmdldEJvdW5kcygpLmNvbnRhaW5zKG4pLGE9dGhpcy5fYWRkTWFya2VyKHQsbixpKTshMD09PWkmJnRoaXMuX21hcmtlcnMuaW5zZXJ0KGFbMF0pLHRoaXMuX2xhdGxuZ01hcmtlcnMuaW5zZXJ0KGFbMV0pfSxhZGRMYXllcjpmdW5jdGlvbih0KXtcIm1hcmtlclBhbmVcIj09dC5vcHRpb25zLnBhbmUmJnQub3B0aW9ucy5pY29uP3RoaXMuYWRkTWFya2VyKHQpOmNvbnNvbGUuZXJyb3IoXCJMYXllciBpc24ndCBhIG1hcmtlclwiKX0sYWRkTGF5ZXJzOmZ1bmN0aW9uKHQpe3RoaXMuYWRkTWFya2Vycyh0KX0scmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCl7dGhpcy5yZW1vdmVNYXJrZXIodCwhMCl9LHJlbW92ZU1hcmtlcjpmdW5jdGlvbih0LG4pe3QubWluWCYmKHQ9dC5kYXRhKTt2YXIgaT10LmdldExhdExuZygpLGE9dGhpcy5fbWFwLmdldEJvdW5kcygpLmNvbnRhaW5zKGkpLGU9e21pblg6aS5sbmcsbWluWTppLmxhdCxtYXhYOmkubG5nLG1heFk6aS5sYXQsZGF0YTp0fTt0aGlzLl9sYXRsbmdNYXJrZXJzLnJlbW92ZShlLGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQuZGF0YS5fbGVhZmxldF9pZD09PW4uZGF0YS5fbGVhZmxldF9pZH0pLHRoaXMuX2xhdGxuZ01hcmtlcnMudG90YWwtLSx0aGlzLl9sYXRsbmdNYXJrZXJzLmRpcnR5KyssITA9PT1hJiYhMD09PW4mJnRoaXMuX3JlZHJhdyghMCl9LG9uQWRkOmZ1bmN0aW9uKHQpe3RoaXMuX21hcD10LHRoaXMuX2NhbnZhc3x8dGhpcy5faW5pdENhbnZhcygpLHRoaXMub3B0aW9ucy5wYW5lP3RoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk6dC5fcGFuZXMub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKSx0Lm9uKFwibW92ZWVuZFwiLHRoaXMuX3Jlc2V0LHRoaXMpLHQub24oXCJyZXNpemVcIix0aGlzLl9yZXNldCx0aGlzKSx0Lm9uKFwiY2xpY2tcIix0aGlzLl9leGVjdXRlTGlzdGVuZXJzLHRoaXMpLHQub24oXCJtb3VzZW1vdmVcIix0aGlzLl9leGVjdXRlTGlzdGVuZXJzLHRoaXMpLHQuX3pvb21BbmltYXRlZCYmdC5vbihcInpvb21hbmltXCIsdGhpcy5fYW5pbWF0ZVpvb20sdGhpcyl9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMub3B0aW9ucy5wYW5lP3RoaXMuZ2V0UGFuZSgpLnJlbW92ZUNoaWxkKHRoaXMuX2NhbnZhcyk6dC5nZXRQYW5lcygpLm92ZXJsYXlQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2NhbnZhcyksdC5vZmYoXCJjbGlja1wiLHRoaXMuX2V4ZWN1dGVMaXN0ZW5lcnMsdGhpcyksdC5vZmYoXCJtb3VzZW1vdmVcIix0aGlzLl9leGVjdXRlTGlzdGVuZXJzLHRoaXMpLHQub2ZmKFwibW92ZWVuZFwiLHRoaXMuX3Jlc2V0LHRoaXMpLHQub2ZmKFwicmVzaXplXCIsdGhpcy5fcmVzZXQsdGhpcyksdC5fem9vbUFuaW1hdGVkJiZ0Lm9mZihcInpvb21hbmltXCIsdGhpcy5fYW5pbWF0ZVpvb20sdGhpcyl9LGFkZFRvOmZ1bmN0aW9uKHQpe3JldHVybiB0LmFkZExheWVyKHRoaXMpLHRoaXN9LGNsZWFyTGF5ZXJzOmZ1bmN0aW9uKCl7dGhpcy5fbGF0bG5nTWFya2Vycz1udWxsLHRoaXMuX21hcmtlcnM9bnVsbCx0aGlzLl9yZWRyYXcoITApfSxfYW5pbWF0ZVpvb206ZnVuY3Rpb24obil7dmFyIGk9dGhpcy5fbWFwLmdldFpvb21TY2FsZShuLnpvb20pLGE9dGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX21hcC5nZXRCb3VuZHMoKSxuLnpvb20sbi5jZW50ZXIpLm1pbjt0LkRvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NhbnZhcyxhLGkpfSxfYWRkTWFya2VyOmZ1bmN0aW9uKG4saSxhKXtuLl9tYXA9dGhpcy5fbWFwLHRoaXMuX21hcmtlcnN8fCh0aGlzLl9tYXJrZXJzPW5ldyByYnVzaCksdGhpcy5fbGF0bG5nTWFya2Vyc3x8KHRoaXMuX2xhdGxuZ01hcmtlcnM9bmV3IHJidXNoLHRoaXMuX2xhdGxuZ01hcmtlcnMuZGlydHk9MCx0aGlzLl9sYXRsbmdNYXJrZXJzLnRvdGFsPTApLHQuVXRpbC5zdGFtcChuKTt2YXIgZT10aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChpKSxyPW4ub3B0aW9ucy5pY29uLm9wdGlvbnMuaWNvblNpemUsbz1yWzBdLzIscz1yWzFdLzIsaD1be21pblg6ZS54LW8sbWluWTplLnktcyxtYXhYOmUueCtvLG1heFk6ZS55K3MsZGF0YTpufSx7bWluWDppLmxuZyxtaW5ZOmkubGF0LG1heFg6aS5sbmcsbWF4WTppLmxhdCxkYXRhOm59XTtyZXR1cm4gdGhpcy5fbGF0bG5nTWFya2Vycy5kaXJ0eSsrLHRoaXMuX2xhdGxuZ01hcmtlcnMudG90YWwrKywhMD09PWEmJnRoaXMuX2RyYXdNYXJrZXIobixlKSxofSxfZHJhd01hcmtlcjpmdW5jdGlvbih0LG4pe3ZhciBpPXRoaXM7dGhpcy5faW1hZ2VMb29rdXB8fCh0aGlzLl9pbWFnZUxvb2t1cD17fSksbnx8KG49aS5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodC5nZXRMYXRMbmcoKSkpO3ZhciBhPXQub3B0aW9ucy5pY29uLm9wdGlvbnMuaWNvblVybDtpZih0LmNhbnZhc19pbWcpaS5fZHJhd0ltYWdlKHQsbiksaS5fZHJhd1RleHQodCxuKTtlbHNlIGlmKGkuX2ltYWdlTG9va3VwW2FdKXQuY2FudmFzX2ltZz1pLl9pbWFnZUxvb2t1cFthXVswXSwhMT09PWkuX2ltYWdlTG9va3VwW2FdWzFdP2kuX2ltYWdlTG9va3VwW2FdWzJdLnB1c2goW3Qsbl0pOihpLl9kcmF3SW1hZ2UodCxuKSxpLl9kcmF3VGV4dCh0LG4pKTtlbHNle3ZhciBlPW5ldyBJbWFnZTtlLnNyYz1hLHQuY2FudmFzX2ltZz1lLGkuX2ltYWdlTG9va3VwW2FdPVtlLCExLFtbdCxuXV1dLGUub25sb2FkPWZ1bmN0aW9uKCl7aS5faW1hZ2VMb29rdXBbYV1bMV09ITAsaS5faW1hZ2VMb29rdXBbYV1bMl0uZm9yRWFjaChmdW5jdGlvbih0KXtpLl9kcmF3SW1hZ2UodFswXSx0WzFdKSxpLl9kcmF3VGV4dCh0WzBdLHRbMV0pfSl9fX0sX2RyYXdJbWFnZTpmdW5jdGlvbih0LG4pe3ZhciBpPXQub3B0aW9ucy5pY29uLm9wdGlvbnM7dGhpcy5fY29udGV4dC5kcmF3SW1hZ2UodC5jYW52YXNfaW1nLG4ueC1pLmljb25BbmNob3JbMF0sbi55LWkuaWNvbkFuY2hvclsxXSxpLmljb25TaXplWzBdLGkuaWNvblNpemVbMV0pfSxfZHJhd1RleHQ6ZnVuY3Rpb24odCxuKXt2YXIgaT10Lm9wdGlvbnMuaWNvbi5vcHRpb25zO2kudGV4dCYmKHRoaXMuX2NvbnRleHQuZm9udD1pLnRleHRGb250LHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlPWkudGV4dEZpbGxTdHlsZSx0aGlzLl9jb250ZXh0LmZpbGxUZXh0KGkudGV4dCxuLngtaS50ZXh0QW5jaG9yWzBdLG4ueS1pLnRleHRBbmNob3JbMV0pKX0sX3Jlc2V0OmZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KFswLDBdKTt0LkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY2FudmFzLG4pO3ZhciBpPXRoaXMuX21hcC5nZXRTaXplKCk7dGhpcy5fY2FudmFzLndpZHRoPWkueCx0aGlzLl9jYW52YXMuaGVpZ2h0PWkueSx0aGlzLl9yZWRyYXcoKX0sX3JlZHJhdzpmdW5jdGlvbih0KXt2YXIgbj10aGlzO2lmKHQmJnRoaXMuX2NvbnRleHQuY2xlYXJSZWN0KDAsMCx0aGlzLl9jYW52YXMud2lkdGgsdGhpcy5fY2FudmFzLmhlaWdodCksdGhpcy5fbWFwJiZ0aGlzLl9sYXRsbmdNYXJrZXJzKXt2YXIgaT1bXTtuLl9sYXRsbmdNYXJrZXJzLmRpcnR5L24uX2xhdGxuZ01hcmtlcnMudG90YWw+PS4xJiYobi5fbGF0bG5nTWFya2Vycy5hbGwoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2kucHVzaCh0KX0pLG4uX2xhdGxuZ01hcmtlcnMuY2xlYXIoKSxuLl9sYXRsbmdNYXJrZXJzLmxvYWQoaSksbi5fbGF0bG5nTWFya2Vycy5kaXJ0eT0wLGk9W10pO3ZhciBhPW4uX21hcC5nZXRCb3VuZHMoKSxlPXttaW5YOmEuZ2V0V2VzdCgpLG1pblk6YS5nZXRTb3V0aCgpLG1heFg6YS5nZXRFYXN0KCksbWF4WTphLmdldE5vcnRoKCl9O24uX2xhdGxuZ01hcmtlcnMuc2VhcmNoKGUpLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGE9bi5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodC5kYXRhLmdldExhdExuZygpKSxlPXQuZGF0YS5vcHRpb25zLmljb24ub3B0aW9ucy5pY29uU2l6ZSxyPWVbMF0vMixvPWVbMV0vMixzPXttaW5YOmEueC1yLG1pblk6YS55LW8sbWF4WDphLngrcixtYXhZOmEueStvLGRhdGE6dC5kYXRhfTtpLnB1c2gocyksbi5fZHJhd01hcmtlcih0LmRhdGEsYSl9KSx0aGlzLl9tYXJrZXJzLmNsZWFyKCksdGhpcy5fbWFya2Vycy5sb2FkKGkpfX0sX2luaXRDYW52YXM6ZnVuY3Rpb24oKXt0aGlzLl9jYW52YXM9dC5Eb21VdGlsLmNyZWF0ZShcImNhbnZhc1wiLFwibGVhZmxldC1jYW52YXMtaWNvbi1sYXllciBsZWFmbGV0LWxheWVyXCIpO3ZhciBuPXRoaXMuX21hcC5nZXRTaXplKCk7dGhpcy5fY2FudmFzLndpZHRoPW4ueCx0aGlzLl9jYW52YXMuaGVpZ2h0PW4ueSx0aGlzLl9jb250ZXh0PXRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7dmFyIGk9dGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbiYmdC5Ccm93c2VyLmFueTNkO3QuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jYW52YXMsXCJsZWFmbGV0LXpvb20tXCIrKGk/XCJhbmltYXRlZFwiOlwiaGlkZVwiKSl9LGFkZE9uQ2xpY2tMaXN0ZW5lcjpmdW5jdGlvbih0KXt0aGlzLl9vbkNsaWNrTGlzdGVuZXJzLnB1c2godCl9LGFkZE9uSG92ZXJMaXN0ZW5lcjpmdW5jdGlvbih0KXt0aGlzLl9vbkhvdmVyTGlzdGVuZXJzLnB1c2godCl9LF9leGVjdXRlTGlzdGVuZXJzOmZ1bmN0aW9uKHQpe2lmKHRoaXMuX21hcmtlcnMpe3ZhciBuPXRoaXMsaT10LmNvbnRhaW5lclBvaW50LngsYT10LmNvbnRhaW5lclBvaW50Lnk7bi5fb3BlblRvb2xUaXAmJihuLl9vcGVuVG9vbFRpcC5jbG9zZVRvb2x0aXAoKSxkZWxldGUgbi5fb3BlblRvb2xUaXApO3ZhciBlPXRoaXMuX21hcmtlcnMuc2VhcmNoKHttaW5YOmksbWluWTphLG1heFg6aSxtYXhZOmF9KTtlJiZlLmxlbmd0aD4wPyhuLl9tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3I9XCJwb2ludGVyXCIsXCJjbGlja1wiPT09dC50eXBlJiYoZVswXS5kYXRhLmdldFBvcHVwKCkmJmVbMF0uZGF0YS5vcGVuUG9wdXAoKSxuLl9vbkNsaWNrTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obil7bih0LGUpfSkpLFwibW91c2Vtb3ZlXCI9PT10LnR5cGUmJihlWzBdLmRhdGEuZ2V0VG9vbHRpcCgpJiYobi5fb3BlblRvb2xUaXA9ZVswXS5kYXRhLGVbMF0uZGF0YS5vcGVuVG9vbHRpcCgpKSxuLl9vbkhvdmVyTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obil7bih0LGUpfSkpKTpuLl9tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3I9XCJcIn19fSk7dC5jYW52YXNJY29uTGF5ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpfX19XSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6664\n')},"69a4":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9jN2U0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjY5YTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///69a4\n")},"6dd8":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"c8ba\")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVzaXplLW9ic2VydmVyLXBvbHlmaWxsL2Rpc3QvUmVzaXplT2JzZXJ2ZXIuZXMuanM/NmRkOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCLG1CQUFtQixFQUFFO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsRUFBRTtBQUNyQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FB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LFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVjLG9FQUFLLEVBQUMiLCJmaWxlIjoiNmRkOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIFJlc2l6ZU9ic2VydmVyXHJcbiAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLCB2YWxpZC1qc2RvYyAqL1xyXG52YXIgTWFwU2hpbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZGV4IGluIHByb3ZpZGVkIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XHJcbiAgICAgICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fX2VudHJpZXNfX1tpbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVsxXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX19baW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoZW50cmllcywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHsgY3R4ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fX2VudHJpZXNfXzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlbnRyeVsxXSwgZW50cnlbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2xhc3NfMTtcclxuICAgIH0oKSk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBEZXRlY3RzIHdoZXRoZXIgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIGFyZSBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC5cclxuICovXHJcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG5cbi8vIFJldHVybnMgZ2xvYmFsIG9iamVjdCBvZiBhIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbnZhciBnbG9iYWwkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG59KSgpO1xuXG4vKipcclxuICogQSBzaGltIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIGZhbGxzIGJhY2sgdG8gdGhlIHNldFRpbWVvdXQgaWZcclxuICogZmlyc3Qgb25lIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlcXVlc3RzJyBpZGVudGlmaWVyLlxyXG4gKi9cclxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byB1c2UgYSBib3VuZGVkIGZ1bmN0aW9uIGJlY2F1c2UgSUUgc29tZXRpbWVzIHRocm93c1xyXG4gICAgICAgIC8vIGFuIFwiSW52YWxpZCBjYWxsaW5nIG9iamVjdFwiIGVycm9yIGlmIHJBRiBpcyBpbnZva2VkIHdpdGhvdXQgdGhlIGdsb2JhbFxyXG4gICAgICAgIC8vIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soRGF0ZS5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcbn0pKCk7XG5cbi8vIERlZmluZXMgbWluaW11bSB0aW1lb3V0IGJlZm9yZSBhZGRpbmcgYSB0cmFpbGluZyBjYWxsLlxyXG52YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGVuc3VyZXMgdGhhdCBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlXHJcbiAqIGludm9rZWQgb25seSBvbmNlIGR1cmluZyB0aGUgc3BlY2lmaWVkIGRlbGF5IHBlcmlvZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBkZWxheSBwZXJpb2QuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGFmdGVyIHdoaWNoIHRvIGludm9rZSBjYWxsYmFjay5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gdGhyb3R0bGUgKGNhbGxiYWNrLCBkZWxheSkge1xyXG4gICAgdmFyIGxlYWRpbmdDYWxsID0gZmFsc2UsIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLCBsYXN0Q2FsbFRpbWUgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSBvcmlnaW5hbCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc2NoZWR1bGVzIG5ldyBpbnZvY2F0aW9uIGlmXHJcbiAgICAgKiB0aGUgXCJwcm94eVwiIHdhcyBjYWxsZWQgZHVyaW5nIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmcoKSB7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgcHJveHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS4gSXQgd2lsbCBmdXJ0aGVyIHBvc3Rwb25lXHJcbiAgICAgKiBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBkZWxlZ2F0aW5nIGl0IHRvIHRoZVxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEocmVzb2x2ZVBlbmRpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHByb3h5KCkge1xyXG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAvLyBSZWplY3QgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGNhbGxzLlxyXG4gICAgICAgICAgICBpZiAodGltZVN0YW1wIC0gbGFzdENhbGxUaW1lIDwgdHJhaWxpbmdUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgbmV3IGNhbGwgdG8gYmUgaW4gaW52b2tlZCB3aGVuIHRoZSBwZW5kaW5nIG9uZSBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxyXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBzbyB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHdlIG1pZ2h0IG1pc3Mgb25lIGlmIGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBoYXBwZW5zIGFtaWRzIHRoZSBwZW5kaW5nIGludm9jYXRpb24uXHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lU3RhbXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cblxuLy8gTWluaW11bSBkZWxheSBiZWZvcmUgaW52b2tpbmcgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXHJcbnZhciBSRUZSRVNIX0RFTEFZID0gMjA7XHJcbi8vIEEgbGlzdCBvZiBzdWJzdHJpbmdzIG9mIENTUyBwcm9wZXJ0aWVzIHVzZWQgdG8gZmluZCB0cmFuc2l0aW9uIGV2ZW50cyB0aGF0XHJcbi8vIG1pZ2h0IGFmZmVjdCBkaW1lbnNpb25zIG9mIG9ic2VydmVkIGVsZW1lbnRzLlxyXG52YXIgdHJhbnNpdGlvbktleXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnc2l6ZScsICd3ZWlnaHQnXTtcclxuLy8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXHJcbnZhciBtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xyXG4vKipcclxuICogU2luZ2xldG9uIGNvbnRyb2xsZXIgY2xhc3Mgd2hpY2ggaGFuZGxlcyB1cGRhdGVzIG9mIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBET00gbGlzdGVuZXJzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlbGxzIHRoYXQgY29udHJvbGxlciBoYXMgc3Vic2NyaWJlZCBmb3IgTXV0YXRpb24gRXZlbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZlclNQST59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNfID0gW107XHJcbiAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoID0gdGhyb3R0bGUodGhpcy5yZWZyZXNoLmJpbmQodGhpcyksIFJFRlJFU0hfREVMQVkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9ic2VydmVyIHRvIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIGlmICghfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKG9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgaWYgdGhleSBoYXZlbid0IGJlZW4gYWRkZWQgeWV0LlxyXG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSByZW1vdmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfO1xyXG4gICAgICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICAvLyBSZW1vdmUgb2JzZXJ2ZXIgaWYgaXQncyBwcmVzZW50IGluIHJlZ2lzdHJ5LlxyXG4gICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMgaWYgY29udHJvbGxlciBoYXMgbm8gY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLiBJdCB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpbnNvZmFyXHJcbiAgICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hhbmdlc0RldGVjdGVkID0gdGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7XHJcbiAgICAgICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XHJcbiAgICAgICAgLy8gYmUgZnV0dXJlIG9uZXMgY2F1c2VkIGJ5IENTUyB0cmFuc2l0aW9ucy5cclxuICAgICAgICBpZiAoY2hhbmdlc0RldGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgZXZlcnkgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdCBhbmQgbm90aWZpZXMgdGhlbSBvZiBxdWV1ZWRcclxuICAgICAqIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlciBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlT2JzZXJ2ZXJzXyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDb2xsZWN0IG9ic2VydmVycyB0aGF0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB2YXIgYWN0aXZlT2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfLmZpbHRlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmdhdGhlckFjdGl2ZSgpLCBvYnNlcnZlci5oYXNBY3RpdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEZWxpdmVyIG5vdGlmaWNhdGlvbnMgaW4gYSBzZXBhcmF0ZSBjeWNsZSBpbiBvcmRlciB0byBhdm9pZCBhbnlcclxuICAgICAgICAvLyBjb2xsaXNpb25zIGJldHdlZW4gb2JzZXJ2ZXJzLCBlLmcuIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mXHJcbiAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcclxuICAgICAgICAvLyBvZiB0aGVtIGNoYW5nZXMgY29udGVudCBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCB0YXJnZXQuIFNvbWV0aW1lc1xyXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBub3RpZmljYXRpb25zIGJlaW5nIGJsb2NrZWQgZm9yIHRoZSByZXN0IG9mIG9ic2VydmVycy5cclxuICAgICAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpOyB9KTtcclxuICAgICAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBhZGRlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxyXG4gICAgICAgIC8vIGRlbGF5ZWQgdHJhbnNpdGlvbnMuIFRoaXMgd2F5IGl0J3MgcG9zc2libGUgdG8gY2FwdHVyZSBhdCBsZWFzdCB0aGVcclxuICAgICAgICAvLyBmaW5hbCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8ub2JzZXJ2ZShkb2N1bWVudCwge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uc09ic2VydmVyXykge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIHRyYW5zaXRpb24gbWF5IGFmZmVjdCBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfnByb3BlcnR5TmFtZS5pbmRleE9mKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV87XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyByZWZlcmVuY2UgdG8gdGhlIGNvbnRyb2xsZXIncyBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuaW5zdGFuY2VfID0gbnVsbDtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgZm9yIHdoaWNoIHRvIGRlZmluZSBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG52YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gKGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgZ2xvYmFsIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKi9cclxudmFyIGdldFdpbmRvd09mID0gKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIE5vZGUsIHdoaWNoIG1lYW5zIHRoYXQgaXRcclxuICAgIC8vIGhhcyB0aGUgXCJvd25lckRvY3VtZW50XCIgcHJvcGVydHkgZnJvbSB3aGljaCB3ZSBjYW4gcmV0cmlldmUgYVxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxyXG4gICAgdmFyIG93bmVyR2xvYmFsID0gdGFyZ2V0ICYmIHRhcmdldC5vd25lckRvY3VtZW50ICYmIHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgLy8gUmV0dXJuIHRoZSBsb2NhbCBnbG9iYWwgb2JqZWN0IGlmIGl0J3Mgbm90IHBvc3NpYmxlIGV4dHJhY3Qgb25lIGZyb21cclxuICAgIC8vIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICByZXR1cm4gb3duZXJHbG9iYWwgfHwgZ2xvYmFsJDE7XHJcbn0pO1xuXG4vLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cclxudmFyIGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4vKipcclxuICogQ29udmVydHMgcHJvdmlkZWQgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XHJcbiAgICAgICAgcmV0dXJuIHNpemUgKyB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH0sIDApO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBwYWRkaW5ncyBzaXplcyBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHJldHVybnMge09iamVjdH0gUGFkZGluZ3MgYm94LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGFkZGluZ3Moc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuICAgIHZhciBwYWRkaW5ncyA9IHt9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBwb3NpdGlvbnNfMSA9IHBvc2l0aW9uczsgX2kgPCBwb3NpdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnNfMVtfaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XHJcbiAgICAgICAgcGFkZGluZ3NbcG9zaXRpb25dID0gdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFkZGluZ3M7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzXHJcbiAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIEhUTUxFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgLy8gQ2xpZW50IHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgY2FuJ3QgYmVcclxuICAgIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxyXG4gICAgdmFyIGNsaWVudFdpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xyXG4gICAgLy8gQnkgdGhpcyBjb25kaXRpb24gd2UgY2FuIGNhdGNoIGFsbCBub24tcmVwbGFjZWQgaW5saW5lLCBoaWRkZW4gYW5kXHJcbiAgICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXHJcbiAgICAvLyB0aGFuIDAuNSB3aWxsIGJlIGRpc2NhcmRlZCBhcyB3ZWxsLlxyXG4gICAgLy9cclxuICAgIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxyXG4gICAgLy8gdGhvc2UgY2FzZXMgYW5kIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYSBwcmVjaXNlIGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgLy8gZWZmZWN0aXZlIHRlc3QgZm9yIGhpZGRlbiBlbGVtZW50cy4gRS5nLiBldmVuIGpRdWVyeSdzICc6dmlzaWJsZScgZmlsdGVyXHJcbiAgICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXHJcbiAgICBpZiAoIWNsaWVudFdpZHRoICYmICFjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgdmFyIHN0eWxlcyA9IGdldFdpbmRvd09mKHRhcmdldCkuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzKTtcclxuICAgIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcclxuICAgIHZhciB2ZXJ0UGFkID0gcGFkZGluZ3MudG9wICsgcGFkZGluZ3MuYm90dG9tO1xyXG4gICAgLy8gQ29tcHV0ZWQgc3R5bGVzIG9mIHdpZHRoICYgaGVpZ2h0IGFyZSBiZWluZyB1c2VkIGJlY2F1c2UgdGhleSBhcmUgdGhlXHJcbiAgICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXHJcbiAgICAvLyBiZSBwb3NzaWJsZSB0byB1dGlsaXplIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaWYgb25seSBpdCdzIGRhdGEgd2Fzbid0XHJcbiAgICAvLyBhZmZlY3RlZCBieSBDU1MgdHJhbnNmb3JtYXRpb25zIGxldCBhbG9uZSBwYWRkaW5ncywgYm9yZGVycyBhbmQgc2Nyb2xsIGJhcnMuXHJcbiAgICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzLmhlaWdodCk7XHJcbiAgICAvLyBXaWR0aCAmIGhlaWdodCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHdoZW4gdGhlICdib3JkZXItYm94JyBib3hcclxuICAgIC8vIG1vZGVsIGlzIGFwcGxpZWQgKGV4Y2VwdCBmb3IgSUUpLlxyXG4gICAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xyXG4gICAgICAgIC8vIEZvbGxvd2luZyBjb25kaXRpb25zIGFyZSByZXF1aXJlZCB0byBoYW5kbGUgSW50ZXJuZXQgRXhwbG9yZXIgd2hpY2hcclxuICAgICAgICAvLyBkb2Vzbid0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgdG8gY29tcHV0ZWQgQ1NTIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXZSBjYW4gc2F5IHRoYXQgaWYgQ1NTIGRpbWVuc2lvbnMgKyBwYWRkaW5ncyBhcmUgZXF1YWwgdG8gdGhlIFwiY2xpZW50XCJcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoZW4gaXQncyBlaXRoZXIgSUUsIGFuZCB0aHVzIHdlIGRvbid0IG5lZWQgdG8gc3VidHJhY3RcclxuICAgICAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpICE9PSBjbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICdsZWZ0JywgJ3JpZ2h0JykgKyBob3JpelBhZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgIT09IGNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAndG9wJywgJ2JvdHRvbScpICsgdmVydFBhZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGb2xsb3dpbmcgc3RlcHMgY2FuJ3QgYmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQncyByb290IGVsZW1lbnQgYXMgaXRzXHJcbiAgICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXHJcbiAgICAvLyBCZXNpZGVzLCBpdCdzIGFzIHdlbGwgbm90IG5lY2Vzc2FyeSBhcyB0aGUgPGh0bWw+IGl0c2VsZiBuZWl0aGVyIGhhc1xyXG4gICAgLy8gcmVuZGVyZWQgc2Nyb2xsIGJhcnMgbm9yIGl0IGNhbiBiZSBjbGlwcGVkLlxyXG4gICAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgLy8gSW4gc29tZSBicm93c2VycyAob25seSBpbiBGaXJlZm94LCBhY3R1YWxseSkgQ1NTIHdpZHRoICYgaGVpZ2h0XHJcbiAgICAgICAgLy8gaW5jbHVkZSBzY3JvbGwgYmFycyBzaXplIHdoaWNoIGNhbiBiZSByZW1vdmVkIGF0IHRoaXMgc3RlcCBhcyBzY3JvbGxcclxuICAgICAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcclxuICAgICAgICAvLyBhbmQgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLCB0aG91Z2ggdGhhdCBpcyBub3QgYWx3YXlzIHRydWUgaW4gQ2hyb21lLlxyXG4gICAgICAgIHZhciB2ZXJ0U2Nyb2xsYmFyID0gTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAtIGNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgLy8gQ2hyb21lIGhhcyBhIHJhdGhlciB3ZWlyZCByb3VuZGluZyBvZiBcImNsaWVudFwiIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gRS5nLiBmb3IgYW4gZWxlbWVudCB3aXRoIGNvbnRlbnQgd2lkdGggb2YgMzE0LjJweCBpdCBzb21ldGltZXMgZ2l2ZXNcclxuICAgICAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcclxuICAgICAgICAvLyAzMTRweC4gQW5kIGl0IGRvZXNuJ3QgaGFwcGVuIGFsbCB0aGUgdGltZS4gU28ganVzdCBpZ25vcmUgdGhpcyBkZWx0YVxyXG4gICAgICAgIC8vIGFzIGEgbm9uLXJlbGV2YW50LlxyXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSB2ZXJ0U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBob3JpelNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG52YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gU29tZSBicm93c2VycywgbmFtZWx5IElFIGFuZCBFZGdlLCBkb24ndCBoYXZlIHRoZSBTVkdHcmFwaGljc0VsZW1lbnRcclxuICAgIC8vIGludGVyZmFjZS5cclxuICAgIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0dyYXBoaWNzRWxlbWVudDsgfTtcclxuICAgIH1cclxuICAgIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgLy8gU1ZHRWxlbWVudCBhbmQgdGhhdCBpdCBoYXMgdGhlIFwiZ2V0QkJveFwiIG1ldGhvZC5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmXHJcbiAgICAgICAgdHlwZW9mIHRhcmdldC5nZXRCQm94ID09PSAnZnVuY3Rpb24nKTsgfTtcclxufSkoKTtcclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYSBkb2N1bWVudCBlbGVtZW50ICg8aHRtbD4pLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcclxuICAgIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGFuIGFwcHJvcHJpYXRlIGNvbnRlbnQgcmVjdGFuZ2xlIGZvciBwcm92aWRlZCBodG1sIG9yIHN2ZyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICBpZiAoIWlzQnJvd3Nlcikge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyByZWN0YW5nbGUgd2l0aCBhbiBpbnRlcmZhY2Ugb2YgdGhlIERPTVJlY3RSZWFkT25seS5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RvbXJlY3RyZWFkb25seVxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIE9iamVjdCB3aXRoIHJlY3RhbmdsZSdzIHgveSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucy5cclxuICogQHJldHVybnMge0RPTVJlY3RSZWFkT25seX1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRPbmx5UmVjdChfYSkge1xyXG4gICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgLy8gSWYgRE9NUmVjdFJlYWRPbmx5IGlzIGF2YWlsYWJsZSB1c2UgaXQgYXMgYSBwcm90b3R5cGUgZm9yIHRoZSByZWN0YW5nbGUuXHJcbiAgICB2YXIgQ29uc3RyID0gdHlwZW9mIERPTVJlY3RSZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcgPyBET01SZWN0UmVhZE9ubHkgOiBPYmplY3Q7XHJcbiAgICB2YXIgcmVjdCA9IE9iamVjdC5jcmVhdGUoQ29uc3RyLnByb3RvdHlwZSk7XHJcbiAgICAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG4gICAgZGVmaW5lQ29uZmlndXJhYmxlKHJlY3QsIHtcclxuICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIHRvcDogeSxcclxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxyXG4gICAgICAgIGJvdHRvbTogaGVpZ2h0ICsgeSxcclxuICAgICAgICBsZWZ0OiB4XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZWN0O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIERPTVJlY3RJbml0IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucyBhbmQgdGhlIHgveSBjb29yZGluYXRlcy5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBSZWN0YW5nbGUncyB3aWR0aC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFJlY3RhbmdsZSdzIGhlaWdodC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVjdEluaXQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG59XG5cbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAqIHByb3ZpZGVkIERPTSBlbGVtZW50IGFuZCBmb3Iga2VlcGluZyB0cmFjayBvZiBpdCdzIGNoYW5nZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCB3aWR0aCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgaGVpZ2h0IG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0RPTVJlY3RJbml0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgY29udGVudCByZWN0YW5nbGUgYW5kIHRlbGxzIHdoZXRoZXIgaXQncyB3aWR0aCBvciBoZWlnaHQgcHJvcGVydGllc1xyXG4gICAgICogaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGJyb2FkY2FzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gZ2V0Q29udGVudFJlY3QodGhpcy50YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gcmVjdDtcclxuICAgICAgICByZXR1cm4gKHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHxcclxuICAgICAgICAgICAgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgJ2Jyb2FkY2FzdFdpZHRoJyBhbmQgJ2Jyb2FkY2FzdEhlaWdodCcgcHJvcGVydGllcyB3aXRoIGEgZGF0YVxyXG4gICAgICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH0gTGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnRSZWN0XztcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuICAgICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gRGF0YSBvZiB0aGUgZWxlbWVudCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcclxuICAgICAgICB2YXIgY29udGVudFJlY3QgPSBjcmVhdGVSZWFkT25seVJlY3QocmVjdEluaXQpO1xyXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlXHJcbiAgICAgICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBQcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBiZWluZyB1c2VkIGFzIHRoZXknZCByZXF1aXJlIHRvIGRlZmluZSBhXHJcbiAgICAgICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XHJcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGlzIHR5cGUgb2YgY29sbGVjdGlvbnMuXHJcbiAgICAgICAgZGVmaW5lQ29uZmlndXJhYmxlKHRoaXMsIHsgdGFyZ2V0OiB0YXJnZXQsIGNvbnRlbnRSZWN0OiBjb250ZW50UmVjdCB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZFxyXG4gICAgICogICAgICB3aGVuIG9uZSBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlcyBpdCdzIGNvbnRlbnQgZGltZW5zaW9ucy5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAgICogICAgICBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHVwZGF0ZXMgb2Ygb2JzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyfSBjYWxsYmFja0N0eCAtIFJlZmVyZW5jZSB0byB0aGUgcHVibGljXHJcbiAgICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgY2FsbGJhY2tDdHgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIHJlc2l6ZSBvYnNlcnZhdGlvbnMgdGhhdCBoYXZlIGRldGVjdGVkIGNoYW5nZXMgaW4gZGltZW5zaW9uc1xyXG4gICAgICAgICAqIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RyeSBvZiB0aGUgUmVzaXplT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge01hcDxFbGVtZW50LCBSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfID0gY29udHJvbGxlcjtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5hZGRPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAvLyBGb3JjZSB0aGUgdXBkYXRlIG9mIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIG5vdCBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0cyBvYnNlcnZhdGlvbiBpbnN0YW5jZXMgdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBvZiB3aGljaCBoYXMgY2hhbmdlZFxyXG4gICAgICogaXQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ucHVzaChvYnNlcnZhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgaW5pdGlhbCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgbGlzdCBvZiBSZXNpemVPYnNlcnZlckVudHJ5XHJcbiAgICAgKiBpbnN0YW5jZXMgY29sbGVjdGVkIGZyb20gYWN0aXZlIHJlc2l6ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBvYnNlcnZlciBkb2Vzbid0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYWxsYmFja0N0eF87XHJcbiAgICAgICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cclxuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5tYXAoZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvYnNlcnZhdGlvbi50YXJnZXQsIG9ic2VydmF0aW9uLmJyb2FkY2FzdFJlY3QoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18uY2FsbChjdHgsIGVudHJpZXMsIGN0eCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjb2xsZWN0aW9uIG9mIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciBvYnNlcnZlciBoYXMgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmhhc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU1BJO1xyXG59KCkpO1xuXG4vLyBSZWdpc3RyeSBvZiBpbnRlcm5hbCBvYnNlcnZlcnMuIElmIFdlYWtNYXAgaXMgbm90IGF2YWlsYWJsZSB1c2UgY3VycmVudCBzaGltXHJcbi8vIGZvciB0aGUgTWFwIGNvbGxlY3Rpb24gYXMgaXQgaGFzIGFsbCByZXF1aXJlZCBtZXRob2RzIGFuZCBiZWNhdXNlIFdlYWtNYXBcclxuLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXHJcbnZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcclxuLyoqXHJcbiAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuICogZXhwb3Npbmcgb25seSB0aG9zZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmluZWQgaW4gdGhlIHNwZWMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzaXplT2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xyXG4gICAgICAgIG9ic2VydmVycy5zZXQodGhpcywgb2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KCkpO1xyXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMgb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbltcclxuICAgICdvYnNlcnZlJyxcclxuICAgICd1bm9ic2VydmUnLFxyXG4gICAgJ2Rpc2Nvbm5lY3QnXHJcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZF0uYXBwbHkoX2EsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59KTtcblxudmFyIGluZGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIEV4cG9ydCBleGlzdGluZyBpbXBsZW1lbnRhdGlvbiBpZiBhdmFpbGFibGUuXHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6dd8\n")},7037:function(module,exports){eval('function _typeof(obj) {\n  "@babel/helpers - typeof";\n\n  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);\n}\n\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/NzAzNyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwibW9kdWxlIiwiZXhwb3J0cyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfX2VzTW9kdWxlIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxPQUFULENBQWlCQyxHQUFqQixFQUFzQjtFQUNwQjs7RUFFQSxPQUFPLENBQUNDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkgsT0FBTyxHQUFHLGNBQWMsT0FBT0ksTUFBckIsSUFBK0IsWUFBWSxPQUFPQSxNQUFNLENBQUNDLFFBQXpELEdBQW9FLFVBQVVKLEdBQVYsRUFBZTtJQUNwSCxPQUFPLE9BQU9BLEdBQWQ7RUFDRCxDQUZrQyxHQUUvQixVQUFVQSxHQUFWLEVBQWU7SUFDakIsT0FBT0EsR0FBRyxJQUFJLGNBQWMsT0FBT0csTUFBNUIsSUFBc0NILEdBQUcsQ0FBQ0ssV0FBSixLQUFvQkYsTUFBMUQsSUFBb0VILEdBQUcsS0FBS0csTUFBTSxDQUFDRyxTQUFuRixHQUErRixRQUEvRixHQUEwRyxPQUFPTixHQUF4SDtFQUNELENBSk8sRUFJTEMsTUFBTSxDQUFDQyxPQUFQLENBQWVLLFVBQWYsR0FBNEIsSUFKdkIsRUFJNkJOLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlLFNBQWYsSUFBNEJELE1BQU0sQ0FBQ0MsT0FKakUsR0FJMkVILE9BQU8sQ0FBQ0MsR0FBRCxDQUp6RjtBQUtEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJILE9BQWpCLEVBQTBCRSxNQUFNLENBQUNDLE9BQVAsQ0FBZUssVUFBZixHQUE0QixJQUF0RCxFQUE0RE4sTUFBTSxDQUFDQyxPQUFQLENBQWUsU0FBZixJQUE0QkQsTUFBTSxDQUFDQyxPQUEvRiIsImZpbGUiOiI3MDM3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cyksIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7037\n')},"71b9":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_vector_vue_vue_type_style_index_0_id_e51daf18_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("dacc");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_vector_vue_vue_type_style_index_0_id_e51daf18_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_vector_vue_vue_type_style_index_0_id_e51daf18_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvdmVjdG9yLnZ1ZT8wYzUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQSIsImZpbGUiOiI3MWI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9yZWYtLTExLW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMS1vbmVPZi0xLTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMTEtb25lT2YtMS0yIS4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMS1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXJlc291cmNlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTExLW9uZU9mLTEtNCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3ZlY3Rvci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1lNTFkYWYxOCZwcm9kJnNjb3BlZD10cnVlJmxhbmc9bGVzcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///71b9\n')},"7b3e":function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isEventSupported\n */\n\n\n\nvar ExecutionEnvironment = __webpack_require__(\"a3de\");\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature =\n    document.implementation &&\n    document.implementation.hasFeature &&\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM ||\n      capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nmodule.exports = isEventSupported;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLXdoZWVsL3NyYy9pc0V2ZW50U3VwcG9ydGVkLmpzPzdiM2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsMkJBQTJCLG1CQUFPLENBQUMsTUFBd0I7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjdiM2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNFdmVudFN1cHBvcnRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9XG4gICAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiZcbiAgICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gICAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAgIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gICAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fFxuICAgICAgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7b3e\n")},8330:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_huge_vue_vue_type_style_index_0_id_1e90d133_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("c3c6");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_huge_vue_vue_type_style_index_0_id_1e90d133_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_huge_vue_vue_type_style_index_0_id_1e90d133_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaHVnZS52dWU/Y2JmMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUEiLCJmaWxlIjoiODMzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS0xMS1vbmVPZi0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTEtb25lT2YtMS0xIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTExLW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTEtb25lT2YtMS0zIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1yZXNvdXJjZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xMS1vbmVPZi0xLTQhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9odWdlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFlOTBkMTMzJnByb2Qmc2NvcGVkPXRydWUmbGFuZz1sZXNzJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8330\n')},"845a":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(process) {(()=>{var t={9705:(t,e,i)=>{"use strict";var n=i(1540);function r(t){var e=[Infinity,Infinity,-Infinity,-Infinity];return n.coordEach(t,(function(t){e[0]>t[0]&&(e[0]=t[0]),e[1]>t[1]&&(e[1]=t[1]),e[2]<t[0]&&(e[2]=t[0]),e[3]<t[1]&&(e[3]=t[1])})),e}r["default"]=r,e.Z=r},4102:(t,e)=>{"use strict";function i(t,e,i){void 0===i&&(i={});var n={type:"Feature"};return(0===i.id||i.id)&&(n.id=i.id),i.bbox&&(n.bbox=i.bbox),n.properties=e||{},n.geometry=t,n}function n(t,e,n){if(void 0===n&&(n={}),!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!d(t[0])||!d(t[1]))throw new Error("coordinates must contain numbers");return i({type:"Point",coordinates:t},e,n)}function r(t,e,n){void 0===n&&(n={});for(var r=0,a=t;r<a.length;r++){var o=a[r];if(o.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(var s=0;s<o[o.length-1].length;s++)if(o[o.length-1][s]!==o[0][s])throw new Error("First and last Position are not equivalent.")}return i({type:"Polygon",coordinates:t},e,n)}function a(t,e,n){if(void 0===n&&(n={}),t.length<2)throw new Error("coordinates must be an array of two or more positions");return i({type:"LineString",coordinates:t},e,n)}function o(t,e){void 0===e&&(e={});var i={type:"FeatureCollection"};return e.id&&(i.id=e.id),e.bbox&&(i.bbox=e.bbox),i.features=t,i}function s(t,e,n){return void 0===n&&(n={}),i({type:"MultiLineString",coordinates:t},e,n)}function l(t,e,n){return void 0===n&&(n={}),i({type:"MultiPoint",coordinates:t},e,n)}function h(t,e,n){return void 0===n&&(n={}),i({type:"MultiPolygon",coordinates:t},e,n)}function u(t,i){void 0===i&&(i="kilometers");var n=e.factors[i];if(!n)throw new Error(i+" units is invalid");return t*n}function c(t,i){void 0===i&&(i="kilometers");var n=e.factors[i];if(!n)throw new Error(i+" units is invalid");return t/n}function p(t){return 180*(t%(2*Math.PI))/Math.PI}function d(t){return!isNaN(t)&&null!==t&&!Array.isArray(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.earthRadius=6371008.8,e.factors={centimeters:100*e.earthRadius,centimetres:100*e.earthRadius,degrees:e.earthRadius/111325,feet:3.28084*e.earthRadius,inches:39.37*e.earthRadius,kilometers:e.earthRadius/1e3,kilometres:e.earthRadius/1e3,meters:e.earthRadius,metres:e.earthRadius,miles:e.earthRadius/1609.344,millimeters:1e3*e.earthRadius,millimetres:1e3*e.earthRadius,nauticalmiles:e.earthRadius/1852,radians:1,yards:1.0936*e.earthRadius},e.unitsFactors={centimeters:100,centimetres:100,degrees:1/111325,feet:3.28084,inches:39.37,kilometers:.001,kilometres:.001,meters:1,metres:1,miles:1/1609.344,millimeters:1e3,millimetres:1e3,nauticalmiles:1/1852,radians:1/e.earthRadius,yards:1.0936133},e.areaFactors={acres:247105e-9,centimeters:1e4,centimetres:1e4,feet:10.763910417,hectares:1e-4,inches:1550.003100006,kilometers:1e-6,kilometres:1e-6,meters:1,metres:1,miles:386e-9,millimeters:1e6,millimetres:1e6,yards:1.195990046},e.feature=i,e.geometry=function(t,e,i){switch(void 0===i&&(i={}),t){case"Point":return n(e).geometry;case"LineString":return a(e).geometry;case"Polygon":return r(e).geometry;case"MultiPoint":return l(e).geometry;case"MultiLineString":return s(e).geometry;case"MultiPolygon":return h(e).geometry;default:throw new Error(t+" is invalid")}},e.point=n,e.points=function(t,e,i){return void 0===i&&(i={}),o(t.map((function(t){return n(t,e)})),i)},e.polygon=r,e.polygons=function(t,e,i){return void 0===i&&(i={}),o(t.map((function(t){return r(t,e)})),i)},e.lineString=a,e.lineStrings=function(t,e,i){return void 0===i&&(i={}),o(t.map((function(t){return a(t,e)})),i)},e.featureCollection=o,e.multiLineString=s,e.multiPoint=l,e.multiPolygon=h,e.geometryCollection=function(t,e,n){return void 0===n&&(n={}),i({type:"GeometryCollection",geometries:t},e,n)},e.round=function(t,e){if(void 0===e&&(e=0),e&&!(e>=0))throw new Error("precision must be a positive number");var i=Math.pow(10,e||0);return Math.round(t*i)/i},e.radiansToLength=u,e.lengthToRadians=c,e.lengthToDegrees=function(t,e){return p(c(t,e))},e.bearingToAzimuth=function(t){var e=t%360;return e<0&&(e+=360),e},e.radiansToDegrees=p,e.degreesToRadians=function(t){return t%360*Math.PI/180},e.convertLength=function(t,e,i){if(void 0===e&&(e="kilometers"),void 0===i&&(i="kilometers"),!(t>=0))throw new Error("length must be a positive number");return u(c(t,e),i)},e.convertArea=function(t,i,n){if(void 0===i&&(i="meters"),void 0===n&&(n="kilometers"),!(t>=0))throw new Error("area must be a positive number");var r=e.areaFactors[i];if(!r)throw new Error("invalid original units");var a=e.areaFactors[n];if(!a)throw new Error("invalid final units");return t/r*a},e.isNumber=d,e.isObject=function(t){return!!t&&t.constructor===Object},e.validateBBox=function(t){if(!t)throw new Error("bbox is required");if(!Array.isArray(t))throw new Error("bbox must be an Array");if(4!==t.length&&6!==t.length)throw new Error("bbox must be an Array of 4 or 6 numbers");t.forEach((function(t){if(!d(t))throw new Error("bbox must only contain numbers")}))},e.validateId=function(t){if(!t)throw new Error("id is required");if(-1===["string","number"].indexOf(typeof t))throw new Error("id must be a number or a string")}},1540:(t,e,i)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(4102);function r(t,e,i){if(null!==t)for(var n,a,o,s,l,h,u,c,p=0,d=0,f=t.type,g="FeatureCollection"===f,_="Feature"===f,m=g?t.features.length:1,y=0;y<m;y++){l=(c=!!(u=g?t.features[y].geometry:_?t.geometry:t)&&"GeometryCollection"===u.type)?u.geometries.length:1;for(var v=0;v<l;v++){var L=0,b=0;if(null!==(s=c?u.geometries[v]:u)){h=s.coordinates;var k=s.type;switch(p=!i||"Polygon"!==k&&"MultiPolygon"!==k?0:1,k){case null:break;case"Point":if(!1===e(h,d,y,L,b))return!1;d++,L++;break;case"LineString":case"MultiPoint":for(n=0;n<h.length;n++){if(!1===e(h[n],d,y,L,b))return!1;d++,"MultiPoint"===k&&L++}"LineString"===k&&L++;break;case"Polygon":case"MultiLineString":for(n=0;n<h.length;n++){for(a=0;a<h[n].length-p;a++){if(!1===e(h[n][a],d,y,L,b))return!1;d++}"MultiLineString"===k&&L++,"Polygon"===k&&b++}"Polygon"===k&&L++;break;case"MultiPolygon":for(n=0;n<h.length;n++){for(b=0,a=0;a<h[n].length;a++){for(o=0;o<h[n][a].length-p;o++){if(!1===e(h[n][a][o],d,y,L,b))return!1;d++}b++}L++}break;case"GeometryCollection":for(n=0;n<s.geometries.length;n++)if(!1===r(s.geometries[n],e,i))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function a(t,e){var i;switch(t.type){case"FeatureCollection":for(i=0;i<t.features.length&&!1!==e(t.features[i].properties,i);i++);break;case"Feature":e(t.properties,0)}}function o(t,e){if("Feature"===t.type)e(t,0);else if("FeatureCollection"===t.type)for(var i=0;i<t.features.length&&!1!==e(t.features[i],i);i++);}function s(t,e){var i,n,r,a,o,s,l,h,u,c,p=0,d="FeatureCollection"===t.type,f="Feature"===t.type,g=d?t.features.length:1;for(i=0;i<g;i++){for(s=d?t.features[i].geometry:f?t.geometry:t,h=d?t.features[i].properties:f?t.properties:{},u=d?t.features[i].bbox:f?t.bbox:undefined,c=d?t.features[i].id:f?t.id:undefined,o=(l=!!s&&"GeometryCollection"===s.type)?s.geometries.length:1,r=0;r<o;r++)if(null!==(a=l?s.geometries[r]:s))switch(a.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===e(a,p,h,u,c))return!1;break;case"GeometryCollection":for(n=0;n<a.geometries.length;n++)if(!1===e(a.geometries[n],p,h,u,c))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===e(null,p,h,u,c))return!1;p++}}function l(t,e){s(t,(function(t,i,r,a,o){var s,l=null===t?null:t.type;switch(l){case null:case"Point":case"LineString":case"Polygon":return!1!==e(n.feature(t,r,{bbox:a,id:o}),i,0)&&void 0}switch(l){case"MultiPoint":s="Point";break;case"MultiLineString":s="LineString";break;case"MultiPolygon":s="Polygon"}for(var h=0;h<t.coordinates.length;h++){var u={type:s,coordinates:t.coordinates[h]};if(!1===e(n.feature(u,r),i,h))return!1}}))}function h(t,e){l(t,(function(t,i,a){var o=0;if(t.geometry){var s=t.geometry.type;if("Point"!==s&&"MultiPoint"!==s){var l,h=0,u=0,c=0;return!1!==r(t,(function(r,s,p,d,f){if(l===undefined||i>h||d>u||f>c)return l=r,h=i,u=d,c=f,void(o=0);var g=n.lineString([l,r],t.properties);if(!1===e(g,i,a,f,o))return!1;o++,l=r}))&&void 0}}}))}function u(t,e){if(!t)throw new Error("geojson is required");l(t,(function(t,i,r){if(null!==t.geometry){var a=t.geometry.type,o=t.geometry.coordinates;switch(a){case"LineString":if(!1===e(t,i,r,0,0))return!1;break;case"Polygon":for(var s=0;s<o.length;s++)if(!1===e(n.lineString(o[s],t.properties),i,r,s))return!1}}}))}e.coordAll=function(t){var e=[];return r(t,(function(t){e.push(t)})),e},e.coordEach=r,e.coordReduce=function(t,e,i,n){var a=i;return r(t,(function(t,n,r,o,s){a=0===n&&i===undefined?t:e(a,t,n,r,o,s)}),n),a},e.featureEach=o,e.featureReduce=function(t,e,i){var n=i;return o(t,(function(t,r){n=0===r&&i===undefined?t:e(n,t,r)})),n},e.findPoint=function(t,e){if(e=e||{},!n.isObject(e))throw new Error("options is invalid");var i,r=e.featureIndex||0,a=e.multiFeatureIndex||0,o=e.geometryIndex||0,s=e.coordIndex||0,l=e.properties;switch(t.type){case"FeatureCollection":r<0&&(r=t.features.length+r),l=l||t.features[r].properties,i=t.features[r].geometry;break;case"Feature":l=l||t.properties,i=t.geometry;break;case"Point":case"MultiPoint":return null;case"LineString":case"Polygon":case"MultiLineString":case"MultiPolygon":i=t;break;default:throw new Error("geojson is invalid")}if(null===i)return null;var h=i.coordinates;switch(i.type){case"Point":return n.point(h,l,e);case"MultiPoint":return a<0&&(a=h.length+a),n.point(h[a],l,e);case"LineString":return s<0&&(s=h.length+s),n.point(h[s],l,e);case"Polygon":return o<0&&(o=h.length+o),s<0&&(s=h[o].length+s),n.point(h[o][s],l,e);case"MultiLineString":return a<0&&(a=h.length+a),s<0&&(s=h[a].length+s),n.point(h[a][s],l,e);case"MultiPolygon":return a<0&&(a=h.length+a),o<0&&(o=h[a].length+o),s<0&&(s=h[a][o].length-s),n.point(h[a][o][s],l,e)}throw new Error("geojson is invalid")},e.findSegment=function(t,e){if(e=e||{},!n.isObject(e))throw new Error("options is invalid");var i,r=e.featureIndex||0,a=e.multiFeatureIndex||0,o=e.geometryIndex||0,s=e.segmentIndex||0,l=e.properties;switch(t.type){case"FeatureCollection":r<0&&(r=t.features.length+r),l=l||t.features[r].properties,i=t.features[r].geometry;break;case"Feature":l=l||t.properties,i=t.geometry;break;case"Point":case"MultiPoint":return null;case"LineString":case"Polygon":case"MultiLineString":case"MultiPolygon":i=t;break;default:throw new Error("geojson is invalid")}if(null===i)return null;var h=i.coordinates;switch(i.type){case"Point":case"MultiPoint":return null;case"LineString":return s<0&&(s=h.length+s-1),n.lineString([h[s],h[s+1]],l,e);case"Polygon":return o<0&&(o=h.length+o),s<0&&(s=h[o].length+s-1),n.lineString([h[o][s],h[o][s+1]],l,e);case"MultiLineString":return a<0&&(a=h.length+a),s<0&&(s=h[a].length+s-1),n.lineString([h[a][s],h[a][s+1]],l,e);case"MultiPolygon":return a<0&&(a=h.length+a),o<0&&(o=h[a].length+o),s<0&&(s=h[a][o].length-s-1),n.lineString([h[a][o][s],h[a][o][s+1]],l,e)}throw new Error("geojson is invalid")},e.flattenEach=l,e.flattenReduce=function(t,e,i){var n=i;return l(t,(function(t,r,a){n=0===r&&0===a&&i===undefined?t:e(n,t,r,a)})),n},e.geomEach=s,e.geomReduce=function(t,e,i){var n=i;return s(t,(function(t,r,a,o,s){n=0===r&&i===undefined?t:e(n,t,r,a,o,s)})),n},e.lineEach=u,e.lineReduce=function(t,e,i){var n=i;return u(t,(function(t,r,a,o){n=0===r&&i===undefined?t:e(n,t,r,a,o)})),n},e.propEach=a,e.propReduce=function(t,e,i){var n=i;return a(t,(function(t,r){n=0===r&&i===undefined?t:e(n,t,r)})),n},e.segmentEach=h,e.segmentReduce=function(t,e,i){var n=i,r=!1;return h(t,(function(t,a,o,s,l){n=!1===r&&i===undefined?t:e(n,t,a,o,s,l),r=!0})),n}},414:(t,e,i)=>{"use strict";i(7107);var n=i(2492),r=i.n(n);const a=JSON.parse(\'{"tooltips":{"placeMarker":"Click to place marker","firstVertex":"Click to place first vertex","continueLine":"Click to continue drawing","finishLine":"Click any existing marker to finish","finishPoly":"Click first marker to finish","finishRect":"Click to finish","startCircle":"Click to place circle center","finishCircle":"Click to finish circle","placeCircleMarker":"Click to place circle marker","placeText":"Click to place text"},"actions":{"finish":"Finish","cancel":"Cancel","removeLastVertex":"Remove Last Vertex"},"buttonTitles":{"drawMarkerButton":"Draw Marker","drawPolyButton":"Draw Polygons","drawLineButton":"Draw Polyline","drawCircleButton":"Draw Circle","drawRectButton":"Draw Rectangle","editButton":"Edit Layers","dragButton":"Drag Layers","cutButton":"Cut Layers","deleteButton":"Remove Layers","drawCircleMarkerButton":"Draw Circle Marker","snappingButton":"Snap dragged marker to other layers and vertices","pinningButton":"Pin shared vertices together","rotateButton":"Rotate Layers","drawTextButton":"Draw Text"}}\'),o=JSON.parse(\'{"tooltips":{"placeMarker":"Platziere den Marker mit Klick","firstVertex":"Platziere den ersten Marker mit Klick","continueLine":"Klicke, um weiter zu zeichnen","finishLine":"Beende mit Klick auf existierenden Marker","finishPoly":"Beende mit Klick auf ersten Marker","finishRect":"Beende mit Klick","startCircle":"Platziere das Kreiszentrum mit Klick","finishCircle":"Beende den Kreis mit Klick","placeCircleMarker":"Platziere den Kreismarker mit Klick","placeText":"Platziere den Text mit Klick"},"actions":{"finish":"Beenden","cancel":"Abbrechen","removeLastVertex":"Letzten Vertex löschen"},"buttonTitles":{"drawMarkerButton":"Marker zeichnen","drawPolyButton":"Polygon zeichnen","drawLineButton":"Polyline zeichnen","drawCircleButton":"Kreis zeichnen","drawRectButton":"Rechteck zeichnen","editButton":"Layer editieren","dragButton":"Layer bewegen","cutButton":"Layer schneiden","deleteButton":"Layer löschen","drawCircleMarkerButton":"Kreismarker zeichnen","snappingButton":"Bewegter Layer an andere Layer oder Vertexe einhacken","pinningButton":"Vertexe an der gleichen Position verknüpfen","rotateButton":"Layer drehen","drawTextButton":"Text zeichnen"}}\'),s=JSON.parse(\'{"tooltips":{"placeMarker":"Clicca per posizionare un Marker","firstVertex":"Clicca per posizionare il primo vertice","continueLine":"Clicca per continuare a disegnare","finishLine":"Clicca qualsiasi marker esistente per terminare","finishPoly":"Clicca il primo marker per terminare","finishRect":"Clicca per terminare","startCircle":"Clicca per posizionare il punto centrale del cerchio","finishCircle":"Clicca per terminare il cerchio","placeCircleMarker":"Clicca per posizionare un Marker del cherchio"},"actions":{"finish":"Termina","cancel":"Annulla","removeLastVertex":"Rimuovi l\\\'ultimo vertice"},"buttonTitles":{"drawMarkerButton":"Disegna Marker","drawPolyButton":"Disegna Poligoni","drawLineButton":"Disegna Polilinea","drawCircleButton":"Disegna Cerchio","drawRectButton":"Disegna Rettangolo","editButton":"Modifica Livelli","dragButton":"Sposta Livelli","cutButton":"Ritaglia Livelli","deleteButton":"Elimina Livelli","drawCircleMarkerButton":"Disegna Marker del Cerchio","snappingButton":"Snap ha trascinato il pennarello su altri strati e vertici","pinningButton":"Pin condiviso vertici insieme"}}\'),l=JSON.parse(\'{"tooltips":{"placeMarker":"Klik untuk menempatkan marker","firstVertex":"Klik untuk menempatkan vertex pertama","continueLine":"Klik untuk meneruskan digitasi","finishLine":"Klik pada sembarang marker yang ada untuk mengakhiri","finishPoly":"Klik marker pertama untuk mengakhiri","finishRect":"Klik untuk mengakhiri","startCircle":"Klik untuk menempatkan titik pusat lingkaran","finishCircle":"Klik untuk mengakhiri lingkaran","placeCircleMarker":"Klik untuk menempatkan penanda lingkarann"},"actions":{"finish":"Selesai","cancel":"Batal","removeLastVertex":"Hilangkan Vertex Terakhir"},"buttonTitles":{"drawMarkerButton":"Digitasi Marker","drawPolyButton":"Digitasi Polygon","drawLineButton":"Digitasi Polyline","drawCircleButton":"Digitasi Lingkaran","drawRectButton":"Digitasi Segi Empat","editButton":"Edit Layer","dragButton":"Geser Layer","cutButton":"Potong Layer","deleteButton":"Hilangkan Layer","drawCircleMarkerButton":"Digitasi Penanda Lingkaran","snappingButton":"Jepretkan penanda yang ditarik ke lapisan dan simpul lain","pinningButton":"Sematkan simpul bersama bersama"}}\'),h=JSON.parse(\'{"tooltips":{"placeMarker":"Adaugă un punct","firstVertex":"Apasă aici pentru a adăuga primul Vertex","continueLine":"Apasă aici pentru a continua desenul","finishLine":"Apasă pe orice obiect pentru a finisa desenul","finishPoly":"Apasă pe primul obiect pentru a finisa","finishRect":"Apasă pentru a finisa","startCircle":"Apasă pentru a desena un cerc","finishCircle":"Apasă pentru a finisa un cerc","placeCircleMarker":"Adaugă un punct"},"actions":{"finish":"Termină","cancel":"Anulează","removeLastVertex":"Șterge ultimul Vertex"},"buttonTitles":{"drawMarkerButton":"Adaugă o bulină","drawPolyButton":"Desenează un poligon","drawLineButton":"Desenează o linie","drawCircleButton":"Desenează un cerc","drawRectButton":"Desenează un dreptunghi","editButton":"Editează straturile","dragButton":"Mută straturile","cutButton":"Taie straturile","deleteButton":"Șterge straturile","drawCircleMarkerButton":"Desenează marcatorul cercului","snappingButton":"Fixați marcatorul glisat pe alte straturi și vârfuri","pinningButton":"Fixați vârfurile partajate împreună"}}\'),u=JSON.parse(\'{"tooltips":{"placeMarker":"Нажмите, чтобы нанести маркер","firstVertex":"Нажмите, чтобы нанести первый объект","continueLine":"Нажмите, чтобы продолжить рисование","finishLine":"Нажмите любой существующий маркер для завершения","finishPoly":"Выберите первую точку, чтобы закончить","finishRect":"Нажмите, чтобы закончить","startCircle":"Нажмите, чтобы добавить центр круга","finishCircle":"Нажмите, чтобы задать радиус","placeCircleMarker":"Нажмите, чтобы нанести круговой маркер"},"actions":{"finish":"Завершить","cancel":"Отменить","removeLastVertex":"Отменить последнее действие"},"buttonTitles":{"drawMarkerButton":"Добавить маркер","drawPolyButton":"Рисовать полигон","drawLineButton":"Рисовать кривую","drawCircleButton":"Рисовать круг","drawRectButton":"Рисовать прямоугольник","editButton":"Редактировать слой","dragButton":"Перенести слой","cutButton":"Вырезать слой","deleteButton":"Удалить слой","drawCircleMarkerButton":"Добавить круговой маркер","snappingButton":"Привязать перетаскиваемый маркер к другим слоям и вершинам","pinningButton":"Связать общие точки вместе"}}\'),c=JSON.parse(\'{"tooltips":{"placeMarker":"Presiona para colocar un marcador","firstVertex":"Presiona para colocar el primer vértice","continueLine":"Presiona para continuar dibujando","finishLine":"Presiona cualquier marcador existente para finalizar","finishPoly":"Presiona el primer marcador para finalizar","finishRect":"Presiona para finalizar","startCircle":"Presiona para colocar el centro del circulo","finishCircle":"Presiona para finalizar el circulo","placeCircleMarker":"Presiona para colocar un marcador de circulo"},"actions":{"finish":"Finalizar","cancel":"Cancelar","removeLastVertex":"Remover ultimo vértice"},"buttonTitles":{"drawMarkerButton":"Dibujar Marcador","drawPolyButton":"Dibujar Polígono","drawLineButton":"Dibujar Línea","drawCircleButton":"Dibujar Circulo","drawRectButton":"Dibujar Rectángulo","editButton":"Editar Capas","dragButton":"Arrastrar Capas","cutButton":"Cortar Capas","deleteButton":"Remover Capas","drawCircleMarkerButton":"Dibujar Marcador de Circulo","snappingButton":"El marcador de Snap arrastrado a otras capas y vértices","pinningButton":"Fijar juntos los vértices compartidos"}}\'),p=JSON.parse(\'{"tooltips":{"placeMarker":"Klik om een marker te plaatsen","firstVertex":"Klik om het eerste punt te plaatsen","continueLine":"Klik om te blijven tekenen","finishLine":"Klik op een bestaand punt om te beëindigen","finishPoly":"Klik op het eerst punt om te beëindigen","finishRect":"Klik om te beëindigen","startCircle":"Klik om het middelpunt te plaatsen","finishCircle":"Klik om de cirkel te beëindigen","placeCircleMarker":"Klik om een marker te plaatsen"},"actions":{"finish":"Bewaar","cancel":"Annuleer","removeLastVertex":"Verwijder laatste punt"},"buttonTitles":{"drawMarkerButton":"Plaats Marker","drawPolyButton":"Teken een vlak","drawLineButton":"Teken een lijn","drawCircleButton":"Teken een cirkel","drawRectButton":"Teken een vierkant","editButton":"Bewerk","dragButton":"Verplaats","cutButton":"Knip","deleteButton":"Verwijder","drawCircleMarkerButton":"Plaats Marker","snappingButton":"Snap gesleepte marker naar andere lagen en hoekpunten","pinningButton":"Speld gedeelde hoekpunten samen"}}\'),d=JSON.parse(\'{"tooltips":{"placeMarker":"Cliquez pour placer un marqueur","firstVertex":"Cliquez pour placer le premier sommet","continueLine":"Cliquez pour continuer à dessiner","finishLine":"Cliquez sur n\\\'importe quel marqueur pour terminer","finishPoly":"Cliquez sur le premier marqueur pour terminer","finishRect":"Cliquez pour terminer","startCircle":"Cliquez pour placer le centre du cercle","finishCircle":"Cliquez pour finir le cercle","placeCircleMarker":"Cliquez pour placer le marqueur circulaire"},"actions":{"finish":"Terminer","cancel":"Annuler","removeLastVertex":"Retirer le dernier sommet"},"buttonTitles":{"drawMarkerButton":"Placer des marqueurs","drawPolyButton":"Dessiner des polygones","drawLineButton":"Dessiner des polylignes","drawCircleButton":"Dessiner un cercle","drawRectButton":"Dessiner un rectangle","editButton":"Éditer des calques","dragButton":"Déplacer des calques","cutButton":"Couper des calques","deleteButton":"Supprimer des calques","drawCircleMarkerButton":"Dessiner un marqueur circulaire","snappingButton":"Glisser le marqueur vers d\\\'autres couches et sommets","pinningButton":"Épingler ensemble les sommets partagés","rotateButton":"Tourner des calques"}}\'),f=JSON.parse(\'{"tooltips":{"placeMarker":"单击放置标记","firstVertex":"单击放置首个顶点","continueLine":"单击继续绘制","finishLine":"单击任何存在的标记以完成","finishPoly":"单击第一个标记以完成","finishRect":"单击完成","startCircle":"单击放置圆心","finishCircle":"单击完成圆形","placeCircleMarker":"点击放置圆形标记"},"actions":{"finish":"完成","cancel":"取消","removeLastVertex":"移除最后的顶点"},"buttonTitles":{"drawMarkerButton":"绘制标记","drawPolyButton":"绘制多边形","drawLineButton":"绘制线段","drawCircleButton":"绘制圆形","drawRectButton":"绘制长方形","editButton":"编辑图层","dragButton":"拖拽图层","cutButton":"剪切图层","deleteButton":"删除图层","drawCircleMarkerButton":"画圆圈标记","snappingButton":"将拖动的标记捕捉到其他图层和顶点","pinningButton":"将共享顶点固定在一起"}}\'),g=JSON.parse(\'{"tooltips":{"placeMarker":"單擊放置標記","firstVertex":"單擊放置第一個頂點","continueLine":"單擊繼續繪製","finishLine":"單擊任何存在的標記以完成","finishPoly":"單擊第一個標記以完成","finishRect":"單擊完成","startCircle":"單擊放置圓心","finishCircle":"單擊完成圓形","placeCircleMarker":"點擊放置圓形標記"},"actions":{"finish":"完成","cancel":"取消","removeLastVertex":"移除最後一個頂點"},"buttonTitles":{"drawMarkerButton":"放置標記","drawPolyButton":"繪製多邊形","drawLineButton":"繪製線段","drawCircleButton":"繪製圓形","drawRectButton":"繪製方形","editButton":"編輯圖形","dragButton":"移動圖形","cutButton":"裁切圖形","deleteButton":"刪除圖形","drawCircleMarkerButton":"畫圓圈標記","snappingButton":"將拖動的標記對齊到其他圖層和頂點","pinningButton":"將共享頂點固定在一起"}}\'),_={en:a,de:o,it:s,id:l,ro:h,ru:u,es:c,nl:p,fr:d,pt_br:JSON.parse(\'{"tooltips":{"placeMarker":"Clique para posicionar o marcador","firstVertex":"Clique para posicionar o primeiro vértice","continueLine":"Clique para continuar desenhando","finishLine":"Clique em qualquer marcador existente para finalizar","finishPoly":"Clique no primeiro ponto para fechar o polígono","finishRect":"Clique para finalizar","startCircle":"Clique para posicionar o centro do círculo","finishCircle":"Clique para fechar o círculo","placeCircleMarker":"Clique para posicionar o marcador circular"},"actions":{"finish":"Finalizar","cancel":"Cancelar","removeLastVertex":"Remover último vértice"},"buttonTitles":{"drawMarkerButton":"Desenhar um marcador","drawPolyButton":"Desenhar um polígono","drawLineButton":"Desenhar uma polilinha","drawCircleButton":"Desenhar um círculo","drawRectButton":"Desenhar um retângulo","editButton":"Editar camada(s)","dragButton":"Mover camada(s)","cutButton":"Recortar camada(s)","deleteButton":"Remover camada(s)","drawCircleMarkerButton":"Marcador de círculos de desenho","snappingButton":"Marcador arrastado para outras camadas e vértices","pinningButton":"Vértices compartilhados de pinos juntos"}}\'),zh:f,zh_tw:g,pl:JSON.parse(\'{"tooltips":{"placeMarker":"Kliknij, aby ustawić znacznik","firstVertex":"Kliknij, aby ustawić pierwszy punkt","continueLine":"Kliknij, aby kontynuować rysowanie","finishLine":"Kliknij dowolny punkt, aby zakończyć","finishPoly":"Kliknij pierwszy punkt, aby zakończyć","finishRect":"Kliknij, aby zakończyć","startCircle":"Kliknij, aby ustawić środek koła","finishCircle":"Kliknij, aby zakończyć rysowanie koła","placeCircleMarker":"Kliknij, aby ustawić okrągły znacznik"},"actions":{"finish":"Zakończ","cancel":"Anuluj","removeLastVertex":"Usuń ostatni punkt"},"buttonTitles":{"drawMarkerButton":"Narysuj znacznik","drawPolyButton":"Narysuj wielokąt","drawLineButton":"Narysuj ścieżkę","drawCircleButton":"Narysuj koło","drawRectButton":"Narysuj prostokąt","editButton":"Edytuj","dragButton":"Przesuń","cutButton":"Wytnij","deleteButton":"Usuń","drawCircleMarkerButton":"Narysuj okrągły znacznik","snappingButton":"Snap przeciągnięty marker na inne warstwy i wierzchołki","pinningButton":"Sworzeń wspólne wierzchołki razem"}}\'),sv:JSON.parse(\'{"tooltips":{"placeMarker":"Klicka för att placera markör","firstVertex":"Klicka för att placera första hörnet","continueLine":"Klicka för att fortsätta rita","finishLine":"Klicka på en existerande punkt för att slutföra","finishPoly":"Klicka på den första punkten för att slutföra","finishRect":"Klicka för att slutföra","startCircle":"Klicka för att placera cirkelns centrum","finishCircle":"Klicka för att slutföra cirkeln","placeCircleMarker":"Klicka för att placera cirkelmarkör"},"actions":{"finish":"Slutför","cancel":"Avbryt","removeLastVertex":"Ta bort sista hörnet"},"buttonTitles":{"drawMarkerButton":"Rita Markör","drawPolyButton":"Rita Polygoner","drawLineButton":"Rita Linje","drawCircleButton":"Rita Cirkel","drawRectButton":"Rita Rektangel","editButton":"Redigera Lager","dragButton":"Dra Lager","cutButton":"Klipp i Lager","deleteButton":"Ta bort Lager","drawCircleMarkerButton":"Rita Cirkelmarkör","snappingButton":"Snäpp dra markören till andra lager och hörn","pinningButton":"Fäst delade hörn tillsammans"}}\'),el:JSON.parse(\'{"tooltips":{"placeMarker":"Κάντε κλικ για να τοποθετήσετε Δείκτη","firstVertex":"Κάντε κλικ για να τοποθετήσετε το πρώτο σημείο","continueLine":"Κάντε κλικ για να συνεχίσετε να σχεδιάζετε","finishLine":"Κάντε κλικ σε οποιονδήποτε υπάρχον σημείο για να ολοκληρωθεί","finishPoly":"Κάντε κλικ στο πρώτο σημείο για να τελειώσετε","finishRect":"Κάντε κλικ για να τελειώσετε","startCircle":"Κάντε κλικ για να τοποθετήσετε κέντρο Κύκλου","finishCircle":"Κάντε κλικ για να ολοκληρώσετε τον Κύκλο","placeCircleMarker":"Κάντε κλικ για να τοποθετήσετε Κυκλικό Δείκτη"},"actions":{"finish":"Τέλος","cancel":"Ακύρωση","removeLastVertex":"Κατάργηση τελευταίου σημείου"},"buttonTitles":{"drawMarkerButton":"Σχεδίαση Δείκτη","drawPolyButton":"Σχεδίαση Πολυγώνου","drawLineButton":"Σχεδίαση Γραμμής","drawCircleButton":"Σχεδίαση Κύκλου","drawRectButton":"Σχεδίαση Ορθογωνίου","editButton":"Επεξεργασία Επιπέδων","dragButton":"Μεταφορά Επιπέδων","cutButton":"Αποκοπή Επιπέδων","deleteButton":"Κατάργηση Επιπέδων","drawCircleMarkerButton":"Σχεδίαση Κυκλικού Δείκτη","snappingButton":"Προσκόλληση του Δείκτη μεταφοράς σε άλλα Επίπεδα και Κορυφές","pinningButton":"Περικοπή κοινών κορυφών μαζί"}}\'),hu:JSON.parse(\'{"tooltips":{"placeMarker":"Kattintson a jelölő elhelyezéséhez","firstVertex":"Kattintson az első pont elhelyezéséhez","continueLine":"Kattintson a következő pont elhelyezéséhez","finishLine":"A befejezéshez kattintson egy meglévő pontra","finishPoly":"A befejezéshez kattintson az első pontra","finishRect":"Kattintson a befejezéshez","startCircle":"Kattintson a kör középpontjának elhelyezéséhez","finishCircle":"Kattintson a kör befejezéséhez","placeCircleMarker":"Kattintson a körjelölő elhelyezéséhez"},"actions":{"finish":"Befejezés","cancel":"Mégse","removeLastVertex":"Utolsó pont eltávolítása"},"buttonTitles":{"drawMarkerButton":"Jelölő rajzolása","drawPolyButton":"Poligon rajzolása","drawLineButton":"Vonal rajzolása","drawCircleButton":"Kör rajzolása","drawRectButton":"Négyzet rajzolása","editButton":"Elemek szerkesztése","dragButton":"Elemek mozgatása","cutButton":"Elemek vágása","deleteButton":"Elemek törlése","drawCircleMarkerButton":"Kör jelölő rajzolása","snappingButton":"Kapcsolja a jelöltőt másik elemhez vagy ponthoz","pinningButton":"Közös pontok összekötése"}}\'),da:JSON.parse(\'{"tooltips":{"placeMarker":"Tryk for at placere en markør","firstVertex":"Tryk for at placere det første punkt","continueLine":"Tryk for at fortsætte linjen","finishLine":"Tryk på et eksisterende punkt for at afslutte","finishPoly":"Tryk på det første punkt for at afslutte","finishRect":"Tryk for at afslutte","startCircle":"Tryk for at placere cirklens center","finishCircle":"Tryk for at afslutte cirklen","placeCircleMarker":"Tryk for at placere en cirkelmarkør"},"actions":{"finish":"Afslut","cancel":"Afbryd","removeLastVertex":"Fjern sidste punkt"},"buttonTitles":{"drawMarkerButton":"Placer markør","drawPolyButton":"Tegn polygon","drawLineButton":"Tegn linje","drawCircleButton":"Tegn cirkel","drawRectButton":"Tegn firkant","editButton":"Rediger","dragButton":"Træk","cutButton":"Klip","deleteButton":"Fjern","drawCircleMarkerButton":"Tegn cirkelmarkør","snappingButton":"Fastgør trukket markør til andre elementer","pinningButton":"Sammenlæg delte elementer"}}\'),no:JSON.parse(\'{"tooltips":{"placeMarker":"Klikk for å plassere punkt","firstVertex":"Klikk for å plassere første punkt","continueLine":"Klikk for å tegne videre","finishLine":"Klikk på et eksisterende punkt for å fullføre","finishPoly":"Klikk første punkt for å fullføre","finishRect":"Klikk for å fullføre","startCircle":"Klikk for å sette sirkel midtpunkt","finishCircle":"Klikk for å fullføre sirkel","placeCircleMarker":"Klikk for å plassere sirkel"},"actions":{"finish":"Fullfør","cancel":"Kanseller","removeLastVertex":"Fjern forrige punkt"},"buttonTitles":{"drawMarkerButton":"Tegn Punkt","drawPolyButton":"Tegn Flate","drawLineButton":"Tegn Linje","drawCircleButton":"Tegn Sirkel","drawRectButton":"Tegn rektangel","editButton":"Rediger Objekter","dragButton":"Dra Objekter","cutButton":"Kutt Objekter","deleteButton":"Fjern Objekter","drawCircleMarkerButton":"Tegn sirkel-punkt","snappingButton":"Fest dratt punkt til andre objekter og punkt","pinningButton":"Pin delte punkt sammen"}}\'),fa:JSON.parse(\'{"tooltips":{"placeMarker":"کلیک برای جانمایی نشان","firstVertex":"کلیک برای رسم اولین رأس","continueLine":"کلیک برای ادامه رسم","finishLine":"کلیک روی هر نشان موجود برای پایان","finishPoly":"کلیک روی اولین نشان برای پایان","finishRect":"کلیک برای پایان","startCircle":"کلیک برای رسم مرکز دایره","finishCircle":"کلیک برای پایان رسم دایره","placeCircleMarker":"کلیک برای رسم نشان دایره"},"actions":{"finish":"پایان","cancel":"لفو","removeLastVertex":"حذف آخرین رأس"},"buttonTitles":{"drawMarkerButton":"درج نشان","drawPolyButton":"رسم چندضلعی","drawLineButton":"رسم خط","drawCircleButton":"رسم دایره","drawRectButton":"رسم چهارضلعی","editButton":"ویرایش لایه‌ها","dragButton":"جابجایی لایه‌ها","cutButton":"برش لایه‌ها","deleteButton":"حذف لایه‌ها","drawCircleMarkerButton":"رسم نشان دایره","snappingButton":"نشانگر را به لایه‌ها و رئوس دیگر بکشید","pinningButton":"رئوس مشترک را با هم پین کنید","rotateButton":"چرخش لایه"}}\'),ua:JSON.parse(\'{"tooltips":{"placeMarker":"Натисніть, щоб нанести маркер","firstVertex":"Натисніть, щоб нанести першу вершину","continueLine":"Натисніть, щоб продовжити малювати","finishLine":"Натисніть будь-який існуючий маркер для завершення","finishPoly":"Виберіть перший маркер, щоб завершити","finishRect":"Натисніть, щоб завершити","startCircle":"Натисніть, щоб додати центр кола","finishCircle":"Натисніть, щоб завершити коло","placeCircleMarker":"Натисніть, щоб нанести круговий маркер"},"actions":{"finish":"Завершити","cancel":"Відмінити","removeLastVertex":"Видалити попередню вершину"},"buttonTitles":{"drawMarkerButton":"Малювати маркер","drawPolyButton":"Малювати полігон","drawLineButton":"Малювати криву","drawCircleButton":"Малювати коло","drawRectButton":"Малювати прямокутник","editButton":"Редагувати шари","dragButton":"Перенести шари","cutButton":"Вирізати шари","deleteButton":"Видалити шари","drawCircleMarkerButton":"Малювати круговий маркер","snappingButton":"Прив’язати перетягнутий маркер до інших шарів та вершин","pinningButton":"Зв\\\'язати спільні вершини разом"}}\'),tr:JSON.parse(\'{"tooltips":{"placeMarker":"İşaretçi yerleştirmek için tıklayın","firstVertex":"İlk tepe noktasını yerleştirmek için tıklayın","continueLine":"Çizime devam etmek için tıklayın","finishLine":"Bitirmek için mevcut herhangi bir işaretçiyi tıklayın","finishPoly":"Bitirmek için ilk işaretçiyi tıklayın","finishRect":"Bitirmek için tıklayın","startCircle":"Daire merkezine yerleştirmek için tıklayın","finishCircle":"Daireyi bitirmek için tıklayın","placeCircleMarker":"Daire işaretçisi yerleştirmek için tıklayın"},"actions":{"finish":"Bitir","cancel":"İptal","removeLastVertex":"Son köşeyi kaldır"},"buttonTitles":{"drawMarkerButton":"Çizim İşaretçisi","drawPolyButton":"Çokgenler çiz","drawLineButton":"Çoklu çizgi çiz","drawCircleButton":"Çember çiz","drawRectButton":"Dikdörtgen çiz","editButton":"Katmanları düzenle","dragButton":"Katmanları sürükle","cutButton":"Katmanları kes","deleteButton":"Katmanları kaldır","drawCircleMarkerButton":"Daire işaretçisi çiz","snappingButton":"Sürüklenen işaretçiyi diğer katmanlara ve köşelere yapıştır","pinningButton":"Paylaşılan köşeleri birbirine sabitle"}}\'),cz:JSON.parse(\'{"tooltips":{"placeMarker":"Kliknutím vytvoříte značku","firstVertex":"Kliknutím vytvoříte první objekt","continueLine":"Kliknutím pokračujte v kreslení","finishLine":"Kliknutí na libovolnou existující značku pro dokončení","finishPoly":"Vyberte první bod pro dokončení","finishRect":"Klikněte pro dokončení","startCircle":"Kliknutím přidejte střed kruhu","finishCircle":"Нажмите, чтобы задать радиус","placeCircleMarker":"Kliknutím nastavte poloměr"},"actions":{"finish":"Dokončit","cancel":"Zrušit","removeLastVertex":"Zrušit poslední akci"},"buttonTitles":{"drawMarkerButton":"Přidat značku","drawPolyButton":"Nakreslit polygon","drawLineButton":"Nakreslit křivku","drawCircleButton":"Nakreslit kruh","drawRectButton":"Nakreslit obdélník","editButton":"Upravit vrstvu","dragButton":"Přeneste vrstvu","cutButton":"Vyjmout vrstvu","deleteButton":"Smazat vrstvu","drawCircleMarkerButton":"Přidat kruhovou značku","snappingButton":"Navázat tažnou značku k dalším vrstvám a vrcholům","pinningButton":"Spojit společné body dohromady"}}\')};function m(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function y(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?m(Object(i),!0).forEach((function(e){v(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):m(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function v(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}const b={_globalEditModeEnabled:!1,enableGlobalEditMode:function(t){this._globalEditModeEnabled=!0,this.Toolbar.toggleButton("editMode",this.globalEditModeEnabled()),L.PM.Utils.findLayers(this.map).forEach((function(e){e.pm.enable(t)})),this.throttledReInitEdit||(this.throttledReInitEdit=L.Util.throttle(this.handleLayerAdditionInGlobalEditMode,100,this)),this._addedLayers={},this.map.on("layeradd",this._layerAdded,this),this.map.on("layeradd",this.throttledReInitEdit,this),this._fireGlobalEditModeToggled(!0)},disableGlobalEditMode:function(){this._globalEditModeEnabled=!1,L.PM.Utils.findLayers(this.map).forEach((function(t){t.pm.disable()})),this.map.off("layeradd",this.throttledReInitEdit,this),this.Toolbar.toggleButton("editMode",this.globalEditModeEnabled()),this._fireGlobalEditModeToggled(!1)},globalEditEnabled:function(){return this.globalEditModeEnabled()},globalEditModeEnabled:function(){return this._globalEditModeEnabled},toggleGlobalEditMode:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.globalOptions;this.globalEditModeEnabled()?this.disableGlobalEditMode():this.enableGlobalEditMode(t)},handleLayerAdditionInGlobalEditMode:function(){var t=this._addedLayers;for(var e in this._addedLayers={},t){var i=t[e];this._isRelevantForEdit(i)&&this.globalEditModeEnabled()&&i.pm.enable(y({},this.globalOptions))}},_layerAdded:function(t){var e=t.layer;this._addedLayers[L.stamp(e)]=e},_isRelevantForEdit:function(t){return t.pm&&!(t instanceof L.LayerGroup)&&(!L.PM.optIn&&!t.options.pmIgnore||L.PM.optIn&&!1===t.options.pmIgnore)&&!t._pmTempLayer&&t.pm.options.allowEditing}};const k={_globalDragModeEnabled:!1,enableGlobalDragMode:function(){var t=L.PM.Utils.findLayers(this.map);this._globalDragModeEnabled=!0,this._addedLayersDrag={},t.forEach((function(t){t.pm.enableLayerDrag()})),this.throttledReInitDrag||(this.throttledReInitDrag=L.Util.throttle(this.reinitGlobalDragMode,100,this)),this.map.on("layeradd",this.throttledReInitDrag,this),this.map.on("layeradd",this._layerAddedDrag,this),this.Toolbar.toggleButton("dragMode",this.globalDragModeEnabled()),this._fireGlobalDragModeToggled(!0)},disableGlobalDragMode:function(){var t=L.PM.Utils.findLayers(this.map);this._globalDragModeEnabled=!1,t.forEach((function(t){t.pm.disableLayerDrag()})),this.map.off("layeradd",this.throttledReInitDrag,this),this.Toolbar.toggleButton("dragMode",this.globalDragModeEnabled()),this._fireGlobalDragModeToggled(!1)},globalDragModeEnabled:function(){return!!this._globalDragModeEnabled},toggleGlobalDragMode:function(){this.globalDragModeEnabled()?this.disableGlobalDragMode():this.enableGlobalDragMode()},reinitGlobalDragMode:function(){var t=this._addedLayersDrag;for(var e in this._addedLayersDrag={},t){var i=t[e];this._isRelevantForDrag(i)&&this.globalDragModeEnabled()&&i.pm.enableLayerDrag()}},_layerAddedDrag:function(t){var e=t.layer;this._addedLayersDrag[L.stamp(e)]=e},_isRelevantForDrag:function(t){return t.pm&&!(t instanceof L.LayerGroup)&&(!L.PM.optIn&&!t.options.pmIgnore||L.PM.optIn&&!1===t.options.pmIgnore)&&!t._pmTempLayer&&t.pm.options.draggable}};const M={_globalRemovalModeEnabled:!1,enableGlobalRemovalMode:function(){var t=this;this._globalRemovalModeEnabled=!0,this.map.eachLayer((function(e){t._isRelevantForRemoval(e)&&(e.pm.disable(),e.on("click",t.removeLayer,t))})),this.throttledReInitRemoval||(this.throttledReInitRemoval=L.Util.throttle(this.reinitGlobalRemovalMode,100,this)),this.map.on("layeradd",this.throttledReInitRemoval,this),this.Toolbar.toggleButton("removalMode",this.globalRemovalModeEnabled()),this._fireGlobalRemovalModeToggled(!0)},disableGlobalRemovalMode:function(){var t=this;this._globalRemovalModeEnabled=!1,this.map.eachLayer((function(e){e.off("click",t.removeLayer,t)})),this.map.off("layeradd",this.throttledReInitRemoval,this),this.Toolbar.toggleButton("removalMode",this.globalRemovalModeEnabled()),this._fireGlobalRemovalModeToggled(!1)},globalRemovalEnabled:function(){return this.globalRemovalModeEnabled()},globalRemovalModeEnabled:function(){return!!this._globalRemovalModeEnabled},toggleGlobalRemovalMode:function(){this.globalRemovalModeEnabled()?this.disableGlobalRemovalMode():this.enableGlobalRemovalMode()},reinitGlobalRemovalMode:function(t){var e=t.layer;this._isRelevantForRemoval(e)&&this.globalRemovalModeEnabled()&&(this.disableGlobalRemovalMode(),this.enableGlobalRemovalMode())},removeLayer:function(t){var e=t.target;this._isRelevantForRemoval(e)&&!e.pm.dragging()&&(e.removeFrom(this.map.pm._getContainingLayer()),e.remove(),e instanceof L.LayerGroup?(this._fireRemoveLayerGroup(e),this._fireRemoveLayerGroup(this.map,e)):(e.pm._fireRemove(e),e.pm._fireRemove(this.map,e)))},_isRelevantForRemoval:function(t){return t.pm&&!(t instanceof L.LayerGroup)&&(!L.PM.optIn&&!t.options.pmIgnore||L.PM.optIn&&!1===t.options.pmIgnore)&&!t._pmTempLayer&&t.pm.options.allowRemoval}};const x={_globalRotateModeEnabled:!1,enableGlobalRotateMode:function(){var t=this;this._globalRotateModeEnabled=!0,L.PM.Utils.findLayers(this.map).filter((function(t){return t instanceof L.Polyline})).forEach((function(e){t._isRelevantForRotate(e)&&e.pm.enableRotate()})),this.throttledReInitRotate||(this.throttledReInitRotate=L.Util.throttle(this._reinitGlobalRotateMode,100,this)),this.map.on("layeradd",this.throttledReInitRotate,this),this.Toolbar.toggleButton("rotateMode",this.globalRotateModeEnabled()),this._fireGlobalRotateModeToggled()},disableGlobalRotateMode:function(){this._globalRotateModeEnabled=!1,L.PM.Utils.findLayers(this.map).filter((function(t){return t instanceof L.Polyline})).forEach((function(t){t.pm.disableRotate()})),this.map.off("layeradd",this.throttledReInitRotate,this),this.Toolbar.toggleButton("rotateMode",this.globalRotateModeEnabled()),this._fireGlobalRotateModeToggled()},globalRotateModeEnabled:function(){return!!this._globalRotateModeEnabled},toggleGlobalRotateMode:function(){this.globalRotateModeEnabled()?this.disableGlobalRotateMode():this.enableGlobalRotateMode()},_reinitGlobalRotateMode:function(t){var e=t.layer;this._isRelevantForRotate(e)&&this.globalRotateModeEnabled()&&(this.disableGlobalRotateMode(),this.enableGlobalRotateMode())},_isRelevantForRotate:function(t){return t.pm&&!(t instanceof L.LayerGroup)&&(!L.PM.optIn&&!t.options.pmIgnore||L.PM.optIn&&!1===t.options.pmIgnore)&&!t._pmTempLayer&&t.pm.options.allowRotation}};function w(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function C(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?w(Object(i),!0).forEach((function(e){P(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):w(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function P(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}var E={_fireDrawStart:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Draw",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._map,"pm:drawstart",{shape:this._shape,workingLayer:this._layer},t,e)},_fireDrawEnd:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Draw",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._map,"pm:drawend",{shape:this._shape},t,e)},_fireCreate:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Draw",i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.__fire(this._map,"pm:create",{shape:this._shape,marker:t,layer:t},e,i)},_fireCenterPlaced:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Draw",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},i="Draw"===t?this._layer:undefined,n="Draw"!==t?this._layer:undefined;this.__fire(this._layer,"pm:centerplaced",{shape:this._shape,workingLayer:i,layer:n,latlng:this._layer.getLatLng()},t,e)},_fireCut:function(t,e,i){var n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:"Draw",r=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};this.__fire(t,"pm:cut",{shape:this._shape,layer:e,originalLayer:i},n,r)},_fireEdit:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this._layer,e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Edit",i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.__fire(t,"pm:edit",{layer:this._layer,shape:this.getShape()},e,i)},_fireEnable:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Edit",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._layer,"pm:enable",{layer:this._layer,shape:this.getShape()},t,e)},_fireDisable:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Edit",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._layer,"pm:disable",{layer:this._layer,shape:this.getShape()},t,e)},_fireUpdate:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Edit",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._layer,"pm:update",{layer:this._layer,shape:this.getShape()},t,e)},_fireMarkerDragStart:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined,i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Edit",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(this._layer,"pm:markerdragstart",{layer:this._layer,markerEvent:t,shape:this.getShape(),indexPath:e},i,n)},_fireMarkerDrag:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined,i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Edit",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(this._layer,"pm:markerdrag",{layer:this._layer,markerEvent:t,shape:this.getShape(),indexPath:e},i,n)},_fireMarkerDragEnd:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined,i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined,n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:"Edit",r=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};this.__fire(this._layer,"pm:markerdragend",{layer:this._layer,markerEvent:t,shape:this.getShape(),indexPath:e,intersectionReset:i},n,r)},_fireDragStart:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Edit",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._layer,"pm:dragstart",{layer:this._layer,shape:this.getShape()},t,e)},_fireDrag:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Edit",i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.__fire(this._layer,"pm:drag",C(C({},t),{},{shape:this.getShape()}),e,i)},_fireDragEnd:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Edit",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._layer,"pm:dragend",{layer:this._layer,shape:this.getShape()},t,e)},_fireDragEnable:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Edit",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._layer,"pm:dragenable",{layer:this._layer,shape:this.getShape()},t,e)},_fireDragDisable:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Edit",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._layer,"pm:dragdisable",{layer:this._layer,shape:this.getShape()},t,e)},_fireRemove:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:t,i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Edit",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(t,"pm:remove",{layer:e,shape:this.getShape()},i,n)},_fireVertexAdded:function(t,e,i){var n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:"Edit",r=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};this.__fire(this._layer,"pm:vertexadded",{layer:this._layer,workingLayer:this._layer,marker:t,indexPath:e,latlng:i,shape:this.getShape()},n,r)},_fireVertexRemoved:function(t,e){var i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Edit",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(this._layer,"pm:vertexremoved",{layer:this._layer,marker:t,indexPath:e,shape:this.getShape()},i,n)},_fireVertexClick:function(t,e){var i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Edit",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(this._layer,"pm:vertexclick",{layer:this._layer,markerEvent:t,indexPath:e,shape:this.getShape()},i,n)},_fireIntersect:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Edit",i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.__fire(this._layer,"pm:intersect",{layer:this._layer,intersection:t,shape:this.getShape()},e,i)},_fireLayerReset:function(t,e){var i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Edit",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(this._layer,"pm:layerreset",{layer:this._layer,markerEvent:t,indexPath:e,shape:this.getShape()},i,n)},_fireChange:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Edit",i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.__fire(this._layer,"pm:change",{layer:this._layer,latlngs:t,shape:this.getShape()},e,i)},_fireTextChange:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Edit",i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.__fire(this._layer,"pm:textchange",{layer:this._layer,text:t,shape:this.getShape()},e,i)},_fireSnapDrag:function(t,e){var i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Snapping",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(t,"pm:snapdrag",e,i,n)},_fireSnap:function(t,e){var i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Snapping",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(t,"pm:snap",e,i,n)},_fireUnsnap:function(t,e){var i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Snapping",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(t,"pm:unsnap",e,i,n)},_fireRotationEnable:function(t,e){var i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Rotation",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(t,"pm:rotateenable",{layer:this._layer,helpLayer:this._rotatePoly,shape:this.getShape()},i,n)},_fireRotationDisable:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Rotation",i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.__fire(t,"pm:rotatedisable",{layer:this._layer,shape:this.getShape()},e,i)},_fireRotationStart:function(t,e){var i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Rotation",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(t,"pm:rotatestart",{layer:this._rotationLayer,helpLayer:this._layer,startAngle:this._startAngle,originLatLngs:e},i,n)},_fireRotation:function(t,e,i){var n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:this._rotationLayer,r=arguments.length>4&&arguments[4]!==undefined?arguments[4]:"Rotation",a=arguments.length>5&&arguments[5]!==undefined?arguments[5]:{};this.__fire(t,"pm:rotate",{layer:n,helpLayer:this._layer,startAngle:this._startAngle,angle:n.pm.getAngle(),angleDiff:e,oldLatLngs:i,newLatLngs:n.getLatLngs()},r,a)},_fireRotationEnd:function(t,e,i){var n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:"Rotation",r=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};this.__fire(t,"pm:rotateend",{layer:this._rotationLayer,helpLayer:this._layer,startAngle:e,angle:this._rotationLayer.pm.getAngle(),originLatLngs:i,newLatLngs:this._rotationLayer.getLatLngs()},n,r)},_fireActionClick:function(t,e,i){var n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:"Toolbar",r=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};this.__fire(this._map,"pm:actionclick",{text:t.text,action:t,btnName:e,button:i},n,r)},_fireButtonClick:function(t,e){var i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Toolbar",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(this._map,"pm:buttonclick",{btnName:t,button:e},i,n)},_fireLangChange:function(t,e,i,n){var r=arguments.length>4&&arguments[4]!==undefined?arguments[4]:"Global",a=arguments.length>5&&arguments[5]!==undefined?arguments[5]:{};this.__fire(this.map,"pm:langchange",{oldLang:t,activeLang:e,fallback:i,translations:n},r,a)},_fireGlobalDragModeToggled:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Global",i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.__fire(this.map,"pm:globaldragmodetoggled",{enabled:t,map:this.map},e,i)},_fireGlobalEditModeToggled:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Global",i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.__fire(this.map,"pm:globaleditmodetoggled",{enabled:t,map:this.map},e,i)},_fireGlobalRemovalModeToggled:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Global",i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.__fire(this.map,"pm:globalremovalmodetoggled",{enabled:t,map:this.map},e,i)},_fireGlobalCutModeToggled:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Global",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._map,"pm:globalcutmodetoggled",{enabled:!!this._enabled,map:this._map},t,e)},_fireGlobalDrawModeToggled:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Global",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this._map,"pm:globaldrawmodetoggled",{enabled:this._enabled,shape:this._shape,map:this._map},t,e)},_fireGlobalRotateModeToggled:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Global",e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.__fire(this.map,"pm:globalrotatemodetoggled",{enabled:this.globalRotateModeEnabled(),map:this.map},t,e)},_fireRemoveLayerGroup:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:t,i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Edit",n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};this.__fire(t,"pm:remove",{layer:e,shape:undefined},i,n)},_fireKeyeventEvent:function(t,e,i){var n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:"Global",r=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};this.__fire(this.map,"pm:keyevent",{event:t,eventType:e,focusOn:i},n,r)},__fire:function(t,e,i,n){var a=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};i=r()(i,a,{source:n}),L.PM.Utils._fireEvent(t,e,i)}};const S=E;const O={_lastEvents:{keydown:undefined,keyup:undefined,current:undefined},_initKeyListener:function(t){this.map=t,L.DomEvent.on(document,"keydown keyup",this._onKeyListener,this),L.DomEvent.on(window,"blur",this._onBlur,this)},_onKeyListener:function(t){var e="document";this.map.getContainer().contains(t.target)&&(e="map");var i={event:t,eventType:t.type,focusOn:e};this._lastEvents[t.type]=i,this._lastEvents.current=i,this.map.pm._fireKeyeventEvent(t,t.type,e)},_onBlur:function(t){t.altKey=!1;var e={event:t,eventType:t.type,focusOn:"document"};this._lastEvents[t.type]=e,this._lastEvents.current=e},getLastKeyEvent:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"current";return this._lastEvents[t]},isShiftKeyPressed:function(){var t;return null===(t=this._lastEvents.current)||void 0===t?void 0:t.event.shiftKey},isAltKeyPressed:function(){var t;return null===(t=this._lastEvents.current)||void 0===t?void 0:t.event.altKey},isCtrlKeyPressed:function(){var t;return null===(t=this._lastEvents.current)||void 0===t?void 0:t.event.ctrlKey},isMetaKeyPressed:function(){var t;return null===(t=this._lastEvents.current)||void 0===t?void 0:t.event.metaKey},getPressedKey:function(){var t;return null===(t=this._lastEvents.current)||void 0===t?void 0:t.event.key}};var D=i(7361),R=i.n(D),B=i(8721),T=i.n(B);function I(t){var e=L.PM.activeLang;return T()(_,e)||(e="en"),R()(_[e],t)}function j(t){return!function e(t){return t.filter((function(t){return![null,"",undefined].includes(t)})).reduce((function(t,i){return t.concat(Array.isArray(i)?e(i):i)}),[])}(t).length}function A(t){return t.reduce((function(t,e){return 0!==e.length&&t.push(Array.isArray(e)?A(e):e),t}),[])}function G(t,e,i){for(var n,r,a,o=6378137,s=6356752.3142,l=1/298.257223563,h=t.lng,u=t.lat,c=i,p=Math.PI,d=e*p/180,f=Math.sin(d),g=Math.cos(d),_=(1-l)*Math.tan(u*p/180),m=1/Math.sqrt(1+_*_),y=_*m,v=Math.atan2(_,g),b=m*f,k=1-b*b,M=k*(o*o-s*s)/(s*s),x=1+M/16384*(4096+M*(M*(320-175*M)-768)),w=M/1024*(256+M*(M*(74-47*M)-128)),C=c/(s*x),P=2*Math.PI;Math.abs(C-P)>1e-12;){n=Math.cos(2*v+C),P=C,C=c/(s*x)+w*(r=Math.sin(C))*(n+w/4*((a=Math.cos(C))*(2*n*n-1)-w/6*n*(4*r*r-3)*(4*n*n-3)))}var E=y*r-m*a*g,S=Math.atan2(y*a+m*r*g,(1-l)*Math.sqrt(b*b+E*E)),O=l/16*k*(4+l*(4-3*k)),D=h+180*(Math.atan2(r*f,m*a-y*r*g)-(1-O)*l*b*(C+O*r*(n+O*a*(2*n*n-1))))/p,R=180*S/p;return L.latLng(D,R)}function N(t,e,i,n){for(var r,a,o=!(arguments.length>4&&arguments[4]!==undefined)||arguments[4],s=[],l=0;l<i;l+=1){if(o)r=G(t,360*l/i+n,e),a=L.latLng(r.lng,r.lat);else{var h=t.lat+Math.cos(2*l*Math.PI/i)*e,u=t.lng+Math.sin(2*l*Math.PI/i)*e;a=L.latLng(h,u)}s.push(a)}return s}function z(t,e,i,n){var r=function(t,e,i){var n=t.latLngToContainerPoint(e),r=t.latLngToContainerPoint(i),a=180*Math.atan2(r.y-n.y,r.x-n.x)/Math.PI+90;return a+(a<0?360:0)}(t,e,i);return function(t,e,i){e=(e+360)%360;var n=Math.PI/180,r=180/Math.PI,a=6378137,o=t.lng*n,s=t.lat*n,l=e*n,h=Math.sin(s),u=Math.cos(s),c=Math.cos(i/a),p=Math.sin(i/a),d=Math.asin(h*c+u*p*Math.cos(l)),f=o+Math.atan2(Math.sin(l)*p*u,c-h*Math.sin(d));return f=(f*=r)>180?f-360:f<-180?f+360:f,L.latLng([d*r,f])}(e,r,n)}function U(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:t.getLatLngs();return t instanceof L.Polygon?L.polygon(e).getLatLngs():L.polyline(e).getLatLngs()}function F(t,e){var i,n;if(null!==(i=e.options.crs)&&void 0!==i&&null!==(n=i.projection)&&void 0!==n&&n.MAX_LATITUDE){var r,a,o=null===(r=e.options.crs)||void 0===r||null===(a=r.projection)||void 0===a?void 0:a.MAX_LATITUDE;t.lat=Math.max(Math.min(o,t.lat),-o)}return t}function V(t){return t.options.renderer||t._map&&(t._map._getPaneRenderer(t.options.pane)||t._map.options.renderer||t._map._renderer)||t._renderer}const K=L.Class.extend({includes:[b,k,M,x,S],initialize:function(t){this.map=t,this.Draw=new L.PM.Draw(t),this.Toolbar=new L.PM.Toolbar(t),this.Keyboard=O,this.globalOptions={snappable:!0,layerGroup:undefined,snappingOrder:["Marker","CircleMarker","Circle","Line","Polygon","Rectangle"],panes:{vertexPane:"markerPane",layerPane:"overlayPane",markerPane:"markerPane"},draggable:!0},this.Keyboard._initKeyListener(t)},setLang:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"en",e=arguments.length>1?arguments[1]:undefined,i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"en",n=L.PM.activeLang;e&&(_[t]=r()(_[i],e)),L.PM.activeLang=t,this.map.pm.Toolbar.reinit(),this._fireLangChange(n,t,i,_[t])},addControls:function(t){this.Toolbar.addControls(t)},removeControls:function(){this.Toolbar.removeControls()},toggleControls:function(){this.Toolbar.toggleControls()},controlsVisible:function(){return this.Toolbar.isVisible},enableDraw:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Polygon",e=arguments.length>1?arguments[1]:undefined;"Poly"===t&&(t="Polygon"),this.Draw.enable(t,e)},disableDraw:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Polygon";"Poly"===t&&(t="Polygon"),this.Draw.disable(t)},setPathOptions:function(t){var e=this,i=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},n=i.ignoreShapes||[],r=i.merge||!1;this.map.pm.Draw.shapes.forEach((function(i){-1===n.indexOf(i)&&e.map.pm.Draw[i].setPathOptions(t,r)}))},getGlobalOptions:function(){return this.globalOptions},setGlobalOptions:function(t){var e=this,i=r()(this.globalOptions,t),n=!1;this.map.pm.Draw.CircleMarker.enabled()&&this.map.pm.Draw.CircleMarker.options.editable!==i.editable&&(this.map.pm.Draw.CircleMarker.disable(),n=!0),this.map.pm.Draw.shapes.forEach((function(t){e.map.pm.Draw[t].setOptions(i)})),n&&this.map.pm.Draw.CircleMarker.enable(),L.PM.Utils.findLayers(this.map).forEach((function(t){t.pm.setOptions(i)})),this.applyGlobalOptions(),this.globalOptions=i},applyGlobalOptions:function(){L.PM.Utils.findLayers(this.map).forEach((function(t){t.pm.enabled()&&t.pm.applyOptions()}))},globalDrawModeEnabled:function(){return!!this.Draw.getActiveShape()},globalCutModeEnabled:function(){return!!this.Draw.Cut.enabled()},enableGlobalCutMode:function(t){return this.Draw.Cut.enable(t)},toggleGlobalCutMode:function(t){return this.Draw.Cut.toggle(t)},disableGlobalCutMode:function(){return this.Draw.Cut.disable()},getGeomanLayers:function(){var t=arguments.length>0&&arguments[0]!==undefined&&arguments[0],e=L.PM.Utils.findLayers(this.map);if(!t)return e;var i=L.featureGroup();return i._pmTempLayer=!0,e.forEach((function(t){i.addLayer(t)})),i},getGeomanDrawLayers:function(){var t=arguments.length>0&&arguments[0]!==undefined&&arguments[0],e=L.PM.Utils.findLayers(this.map).filter((function(t){return!0===t._drawnByGeoman}));if(!t)return e;var i=L.featureGroup();return i._pmTempLayer=!0,e.forEach((function(t){i.addLayer(t)})),i},_getContainingLayer:function(){return this.globalOptions.layerGroup&&this.globalOptions.layerGroup instanceof L.LayerGroup?this.globalOptions.layerGroup:this.map},_isCRSSimple:function(){return this.map.options.crs===L.CRS.Simple},_touchEventCounter:0,_addTouchEvents:function(t){0===this._touchEventCounter&&(L.DomEvent.on(t,"touchmove",this._canvasTouchMove,this),L.DomEvent.on(t,"touchstart touchend touchcancel",this._canvasTouchClick,this)),this._touchEventCounter+=1},_removeTouchEvents:function(t){1===this._touchEventCounter&&(L.DomEvent.off(t,"touchmove",this._canvasTouchMove,this),L.DomEvent.off(t,"touchstart touchend touchcancel",this._canvasTouchClick,this)),this._touchEventCounter=this._touchEventCounter<=1?0:this._touchEventCounter-1},_canvasTouchMove:function(t){V(this.map)._onMouseMove(this._createMouseEvent("mousemove",t))},_canvasTouchClick:function(t){var e="";"touchstart"===t.type||"pointerdown"===t.type?e="mousedown":"touchend"===t.type||"pointerup"===t.type?e="mouseup":"touchcancel"!==t.type&&"pointercancel"!==t.type||(e="mouseup"),e&&V(this.map)._onClick(this._createMouseEvent(e,t))},_createMouseEvent:function(t,e){var i,n=e.touches[0]||e.changedTouches[0];try{i=new MouseEvent(t,{bubbles:e.bubbles,cancelable:e.cancelable,view:e.view,detail:n.detail,screenX:n.screenX,screenY:n.screenY,clientX:n.clientX,clientY:n.clientY,ctrlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey,metaKey:e.metaKey,button:e.button,relatedTarget:e.relatedTarget})}catch(r){(i=document.createEvent("MouseEvents")).initMouseEvent(t,e.bubbles,e.cancelable,e.view,n.detail,n.screenX,n.screenY,n.clientX,n.clientY,e.ctrlKey,e.altKey,e.shiftKey,e.metaKey,e.button,e.relatedTarget)}return i}});function H(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function q(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?H(Object(i),!0).forEach((function(e){J(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):H(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function J(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}const Y=L.Control.extend({includes:[S],options:{position:"topleft"},initialize:function(t){this._button=q(q({},this.options),t)},onAdd:function(t){return this._map=t,this._map.pm.Toolbar.options.oneBlock?this._container=this._map.pm.Toolbar._createContainer(this.options.position):"edit"===this._button.tool?this._container=this._map.pm.Toolbar.editContainer:"options"===this._button.tool?this._container=this._map.pm.Toolbar.optionsContainer:"custom"===this._button.tool?this._container=this._map.pm.Toolbar.customContainer:this._container=this._map.pm.Toolbar.drawContainer,this.buttonsDomNode=this._makeButton(this._button),this._container.appendChild(this.buttonsDomNode),this._container},onRemove:function(){return this.buttonsDomNode.remove(),this._container},getText:function(){return this._button.text},getIconUrl:function(){return this._button.iconUrl},destroy:function(){this._button={},this._update()},toggle:function(t){return this._button.toggleStatus="boolean"==typeof t?t:!this._button.toggleStatus,this._applyStyleClasses(),this._button.toggleStatus},toggled:function(){return this._button.toggleStatus},onCreate:function(){this.toggle(!1)},disable:function(){this.toggle(!1),this._button.disabled=!0,this._updateDisabled()},enable:function(){this._button.disabled=!1,this._updateDisabled()},_triggerClick:function(t){t&&t.preventDefault(),this._button.disabled||(this._button.onClick(t,{button:this,event:t}),this._clicked(t),this._button.afterClick(t,{button:this,event:t}))},_makeButton:function(t){var e=this,i=this.options.position.indexOf("right")>-1?"pos-right":"",n=L.DomUtil.create("div","button-container  ".concat(i),this._container);t.title&&n.setAttribute("title",t.title);var r=L.DomUtil.create("a","leaflet-buttons-control-button",n);r.setAttribute("role","button"),r.setAttribute("tabindex","0"),r.href="#";var a=L.DomUtil.create("div","leaflet-pm-actions-container ".concat(i),n),o=t.actions,s={cancel:{text:I("actions.cancel"),onClick:function(){this._triggerClick()}},finishMode:{text:I("actions.finish"),onClick:function(){this._triggerClick()}},removeLastVertex:{text:I("actions.removeLastVertex"),onClick:function(){this._map.pm.Draw[t.jsClass]._removeLastVertex()}},finish:{text:I("actions.finish"),onClick:function(e){this._map.pm.Draw[t.jsClass]._finishShape(e)}}};o.forEach((function(n){var r,o="string"==typeof n?n:n.name;if(s[o])r=s[o];else{if(!n.text)return;r=n}var l=L.DomUtil.create("a","leaflet-pm-action ".concat(i," action-").concat(o),a);if(l.setAttribute("role","button"),l.setAttribute("tabindex","0"),l.href="#",l.innerHTML=r.text,L.DomEvent.disableClickPropagation(l),L.DomEvent.on(l,"click",L.DomEvent.stop),!t.disabled&&r.onClick){L.DomEvent.addListener(l,"click",(function(i){i.preventDefault();var n="",a=e._map.pm.Toolbar.buttons;for(var o in a)if(a[o]._button===t){n=o;break}e._fireActionClick(r,n,t)}),e),L.DomEvent.addListener(l,"click",r.onClick,e)}})),t.toggleStatus&&L.DomUtil.addClass(n,"active");var l=L.DomUtil.create("div","control-icon",r);return t.iconUrl&&l.setAttribute("src",t.iconUrl),t.className&&L.DomUtil.addClass(l,t.className),L.DomEvent.disableClickPropagation(r),L.DomEvent.on(r,"click",L.DomEvent.stop),t.disabled||(L.DomEvent.addListener(r,"click",this._onBtnClick,this),L.DomEvent.addListener(r,"click",this._triggerClick,this)),t.disabled&&(L.DomUtil.addClass(r,"pm-disabled"),r.setAttribute("aria-disabled","true")),n},_applyStyleClasses:function(){this._container&&(this._button.toggleStatus&&!1!==this._button.cssToggle?(L.DomUtil.addClass(this.buttonsDomNode,"active"),L.DomUtil.addClass(this._container,"activeChild")):(L.DomUtil.removeClass(this.buttonsDomNode,"active"),L.DomUtil.removeClass(this._container,"activeChild")))},_onBtnClick:function(){this._button.disableOtherButtons&&this._map.pm.Toolbar.triggerClickOnToggledButtons(this);var t="",e=this._map.pm.Toolbar.buttons;for(var i in e)if(e[i]._button===this._button){t=i;break}this._fireButtonClick(t,this._button)},_clicked:function(){this._button.doToggle&&this.toggle()},_updateDisabled:function(){if(this._container){var t="pm-disabled",e=this.buttonsDomNode.children[0];this._button.disabled?(L.DomUtil.addClass(e,t),e.setAttribute("aria-disabled","true"),L.DomEvent.off(e,"click",this._triggerClick,this),L.DomEvent.off(e,"click",this._onBtnClick,this)):(L.DomUtil.removeClass(e,t),e.setAttribute("aria-disabled","false"),L.DomEvent.on(e,"click",this._triggerClick,this),L.DomEvent.on(e,"click",this._onBtnClick,this))}}});function X(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function Z(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?X(Object(i),!0).forEach((function(e){$(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):X(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function $(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function W(t){return W="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},W(t)}L.Control.PMButton=Y;const Q=L.Class.extend({options:{drawMarker:!0,drawRectangle:!0,drawPolyline:!0,drawPolygon:!0,drawCircle:!0,drawCircleMarker:!0,drawText:!0,editMode:!0,dragMode:!0,cutPolygon:!0,removalMode:!0,rotateMode:!0,snappingOption:!0,drawControls:!0,editControls:!0,optionsControls:!0,customControls:!0,oneBlock:!1,position:"topleft",positions:{draw:"",edit:"",options:"",custom:""}},customButtons:[],initialize:function(t){this.init(t)},reinit:function(){var t=this.isVisible;this.removeControls(),this._defineButtons(),t&&this.addControls()},init:function(t){this.map=t,this.buttons={},this.isVisible=!1,this.drawContainer=L.DomUtil.create("div","leaflet-pm-toolbar leaflet-pm-draw leaflet-bar leaflet-control"),this.editContainer=L.DomUtil.create("div","leaflet-pm-toolbar leaflet-pm-edit leaflet-bar leaflet-control"),this.optionsContainer=L.DomUtil.create("div","leaflet-pm-toolbar leaflet-pm-options leaflet-bar leaflet-control"),this.customContainer=L.DomUtil.create("div","leaflet-pm-toolbar leaflet-pm-custom leaflet-bar leaflet-control"),this._defineButtons()},_createContainer:function(t){var e="".concat(t,"Container");return this[e]||(this[e]=L.DomUtil.create("div","leaflet-pm-toolbar leaflet-pm-".concat(t," leaflet-bar leaflet-control"))),this[e]},getButtons:function(){return this.buttons},addControls:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.options;"undefined"!=typeof t.editPolygon&&(t.editMode=t.editPolygon),"undefined"!=typeof t.deleteLayer&&(t.removalMode=t.deleteLayer),L.Util.setOptions(this,t),this.applyIconStyle(),this.isVisible=!0,this._showHideButtons()},applyIconStyle:function(){var t=this.getButtons(),e={geomanIcons:{drawMarker:"control-icon leaflet-pm-icon-marker",drawPolyline:"control-icon leaflet-pm-icon-polyline",drawRectangle:"control-icon leaflet-pm-icon-rectangle",drawPolygon:"control-icon leaflet-pm-icon-polygon",drawCircle:"control-icon leaflet-pm-icon-circle",drawCircleMarker:"control-icon leaflet-pm-icon-circle-marker",editMode:"control-icon leaflet-pm-icon-edit",dragMode:"control-icon leaflet-pm-icon-drag",cutPolygon:"control-icon leaflet-pm-icon-cut",removalMode:"control-icon leaflet-pm-icon-delete",drawText:"control-icon leaflet-pm-icon-text"}};for(var i in t){var n=t[i];L.Util.setOptions(n,{className:e.geomanIcons[i]})}},removeControls:function(){var t=this.getButtons();for(var e in t)t[e].remove();this.isVisible=!1},toggleControls:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.options;this.isVisible?this.removeControls():this.addControls(t)},_addButton:function(t,e){return this.buttons[t]=e,this.options[t]=this.options[t]||!1,this.buttons[t]},triggerClickOnToggledButtons:function(t){var e=["snappingOption"];for(var i in this.buttons)!e.includes(i)&&this.buttons[i]!==t&&this.buttons[i].toggled()&&this.buttons[i]._triggerClick()},toggleButton:function(t,e){var i=!(arguments.length>2&&arguments[2]!==undefined)||arguments[2];return"editPolygon"===t&&(t="editMode"),"deleteLayer"===t&&(t="removalMode"),i&&this.triggerClickOnToggledButtons(this.buttons[t]),!!this.buttons[t]&&this.buttons[t].toggle(e)},_defineButtons:function(){var t=this,e={className:"control-icon leaflet-pm-icon-marker",title:I("buttonTitles.drawMarkerButton"),jsClass:"Marker",onClick:function(){},afterClick:function(e,i){t.map.pm.Draw[i.button._button.jsClass].toggle()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,actions:["cancel"]},i={title:I("buttonTitles.drawPolyButton"),className:"control-icon leaflet-pm-icon-polygon",jsClass:"Polygon",onClick:function(){},afterClick:function(e,i){t.map.pm.Draw[i.button._button.jsClass].toggle()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,actions:["finish","removeLastVertex","cancel"]},n={className:"control-icon leaflet-pm-icon-polyline",title:I("buttonTitles.drawLineButton"),jsClass:"Line",onClick:function(){},afterClick:function(e,i){t.map.pm.Draw[i.button._button.jsClass].toggle()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,actions:["finish","removeLastVertex","cancel"]},r={title:I("buttonTitles.drawCircleButton"),className:"control-icon leaflet-pm-icon-circle",jsClass:"Circle",onClick:function(){},afterClick:function(e,i){t.map.pm.Draw[i.button._button.jsClass].toggle()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,actions:["cancel"]},a={title:I("buttonTitles.drawCircleMarkerButton"),className:"control-icon leaflet-pm-icon-circle-marker",jsClass:"CircleMarker",onClick:function(){},afterClick:function(e,i){t.map.pm.Draw[i.button._button.jsClass].toggle()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,actions:["cancel"]},o={title:I("buttonTitles.drawRectButton"),className:"control-icon leaflet-pm-icon-rectangle",jsClass:"Rectangle",onClick:function(){},afterClick:function(e,i){t.map.pm.Draw[i.button._button.jsClass].toggle()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,actions:["cancel"]},s={title:I("buttonTitles.editButton"),className:"control-icon leaflet-pm-icon-edit",onClick:function(){},afterClick:function(){t.map.pm.toggleGlobalEditMode()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,tool:"edit",actions:["finishMode"]},l={title:I("buttonTitles.dragButton"),className:"control-icon leaflet-pm-icon-drag",onClick:function(){},afterClick:function(){t.map.pm.toggleGlobalDragMode()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,tool:"edit",actions:["finishMode"]},h={title:I("buttonTitles.cutButton"),className:"control-icon leaflet-pm-icon-cut",jsClass:"Cut",onClick:function(){},afterClick:function(e,i){t.map.pm.Draw[i.button._button.jsClass].toggle({snappable:!0,cursorMarker:!0,allowSelfIntersection:!1})},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,tool:"edit",actions:["finish","removeLastVertex","cancel"]},u={title:I("buttonTitles.deleteButton"),className:"control-icon leaflet-pm-icon-delete",onClick:function(){},afterClick:function(){t.map.pm.toggleGlobalRemovalMode()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,tool:"edit",actions:["finishMode"]},c={title:I("buttonTitles.rotateButton"),className:"control-icon leaflet-pm-icon-rotate",onClick:function(){},afterClick:function(){t.map.pm.toggleGlobalRotateMode()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,tool:"edit",actions:["finishMode"]},p={className:"control-icon leaflet-pm-icon-text",title:I("buttonTitles.drawTextButton"),jsClass:"Text",onClick:function(){},afterClick:function(e,i){t.map.pm.Draw[i.button._button.jsClass].toggle()},doToggle:!0,toggleStatus:!1,disableOtherButtons:!0,position:this.options.position,actions:["cancel"]};this._addButton("drawMarker",new L.Control.PMButton(e)),this._addButton("drawPolyline",new L.Control.PMButton(n)),this._addButton("drawRectangle",new L.Control.PMButton(o)),this._addButton("drawPolygon",new L.Control.PMButton(i)),this._addButton("drawCircle",new L.Control.PMButton(r)),this._addButton("drawCircleMarker",new L.Control.PMButton(a)),this._addButton("drawText",new L.Control.PMButton(p)),this._addButton("editMode",new L.Control.PMButton(s)),this._addButton("dragMode",new L.Control.PMButton(l)),this._addButton("cutPolygon",new L.Control.PMButton(h)),this._addButton("removalMode",new L.Control.PMButton(u)),this._addButton("rotateMode",new L.Control.PMButton(c))},_showHideButtons:function(){if(this.isVisible){this.removeControls(),this.isVisible=!0;var t=this.getButtons(),e=[];for(var i in!1===this.options.drawControls&&(e=e.concat(Object.keys(t).filter((function(e){return!t[e]._button.tool})))),!1===this.options.editControls&&(e=e.concat(Object.keys(t).filter((function(e){return"edit"===t[e]._button.tool})))),!1===this.options.optionsControls&&(e=e.concat(Object.keys(t).filter((function(e){return"options"===t[e]._button.tool})))),!1===this.options.customControls&&(e=e.concat(Object.keys(t).filter((function(e){return"custom"===t[e]._button.tool})))),t)if(this.options[i]&&-1===e.indexOf(i)){var n=t[i]._button.tool;n||(n="draw"),t[i].setPosition(this._getBtnPosition(n)),t[i].addTo(this.map)}}},_getBtnPosition:function(t){return this.options.positions&&this.options.positions[t]?this.options.positions[t]:this.options.position},setBlockPosition:function(t,e){this.options.positions[t]=e,this._showHideButtons(),this.changeControlOrder()},getBlockPositions:function(){return this.options.positions},copyDrawControl:function(t,e){if(!e)throw new TypeError("Button has no name");"object"!==W(e)&&(e={name:e});var i=this._btnNameMapping(t);if(!e.name)throw new TypeError("Button has no name");if(this.buttons[e.name])throw new TypeError("Button with this name already exists");var n=this.map.pm.Draw.createNewDrawInstance(e.name,i);return e=Z(Z({},this.buttons[i]._button),e),{drawInstance:n,control:this.createCustomControl(e)}},createCustomControl:function(t){if(!t.name)throw new TypeError("Button has no name");if(this.buttons[t.name])throw new TypeError("Button with this name already exists");t.onClick||(t.onClick=function(){}),t.afterClick||(t.afterClick=function(){}),!1!==t.toggle&&(t.toggle=!0),t.block&&(t.block=t.block.toLowerCase()),t.block&&"draw"!==t.block||(t.block=""),t.className?-1===t.className.indexOf("control-icon")&&(t.className="control-icon ".concat(t.className)):t.className="control-icon";var e={tool:t.block,className:t.className,title:t.title||"",jsClass:t.name,onClick:t.onClick,afterClick:t.afterClick,doToggle:t.toggle,toggleStatus:!1,disableOtherButtons:!0,cssToggle:t.toggle,position:this.options.position,actions:t.actions||[],disabled:!!t.disabled};!1!==this.options[t.name]&&(this.options[t.name]=!0);var i=this._addButton(t.name,new L.Control.PMButton(e));return this.changeControlOrder(),i},changeControlOrder:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[],e=this._shapeMapping(),i=[];t.forEach((function(t){e[t]?i.push(e[t]):i.push(t)}));var n=this.getButtons(),r={};i.forEach((function(t){n[t]&&(r[t]=n[t])}));var a=Object.keys(n).filter((function(t){return!n[t]._button.tool}));a.forEach((function(t){-1===i.indexOf(t)&&(r[t]=n[t])}));var o=Object.keys(n).filter((function(t){return"edit"===n[t]._button.tool}));o.forEach((function(t){-1===i.indexOf(t)&&(r[t]=n[t])}));var s=Object.keys(n).filter((function(t){return"options"===n[t]._button.tool}));s.forEach((function(t){-1===i.indexOf(t)&&(r[t]=n[t])}));var l=Object.keys(n).filter((function(t){return"custom"===n[t]._button.tool}));l.forEach((function(t){-1===i.indexOf(t)&&(r[t]=n[t])})),Object.keys(n).forEach((function(t){-1===i.indexOf(t)&&(r[t]=n[t])})),this.map.pm.Toolbar.buttons=r,this._showHideButtons()},getControlOrder:function(){var t=this.getButtons(),e=[];for(var i in t)e.push(i);return e},changeActionsOfControl:function(t,e){var i=this._btnNameMapping(t);if(!i)throw new TypeError("No name passed");if(!e)throw new TypeError("No actions passed");if(!this.buttons[i])throw new TypeError("Button with this name not exists");this.buttons[i]._button.actions=e,this.changeControlOrder()},setButtonDisabled:function(t,e){var i=this._btnNameMapping(t);e?this.buttons[i].disable():this.buttons[i].enable()},_shapeMapping:function(){return{Marker:"drawMarker",Circle:"drawCircle",Polygon:"drawPolygon",Rectangle:"drawRectangle",Polyline:"drawPolyline",Line:"drawPolyline",CircleMarker:"drawCircleMarker",Edit:"editMode",Drag:"dragMode",Cut:"cutPolygon",Removal:"removalMode",Rotate:"rotateMode",Text:"drawText"}},_btnNameMapping:function(t){var e=this._shapeMapping();return e[t]?e[t]:t}});function tt(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function et(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?tt(Object(i),!0).forEach((function(e){it(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):tt(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function it(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}var nt={_initSnappableMarkers:function(){this.options.snapDistance=this.options.snapDistance||30,this.options.snapSegment=this.options.snapSegment===undefined||this.options.snapSegment,this._assignEvents(this._markers),this._layer.off("pm:dragstart",this._unsnap,this),this._layer.on("pm:dragstart",this._unsnap,this)},_disableSnapping:function(){this._layer.off("pm:dragstart",this._unsnap,this)},_assignEvents:function(t){var e=this;t.forEach((function(t){Array.isArray(t)?e._assignEvents(t):(t.off("drag",e._handleSnapping,e),t.on("drag",e._handleSnapping,e),t.off("dragend",e._cleanupSnapping,e),t.on("dragend",e._cleanupSnapping,e))}))},_cleanupSnapping:function(){delete this._snapList,this.throttledList&&(this._map.off("layeradd",this.throttledList,this),this.throttledList=undefined),this._map.off("pm:remove",this._handleSnapLayerRemoval,this),this.debugIndicatorLines&&this.debugIndicatorLines.forEach((function(t){t.remove()}))},_handleThrottleSnapping:function(){this.throttledList&&this._createSnapList()},_handleSnapping:function(t){var e=this,i=t.target;if(i._snapped=!1,this.throttledList||(this.throttledList=L.Util.throttle(this._handleThrottleSnapping,100,this)),this._map.pm.Keyboard.isAltKeyPressed())return!1;if(this._snapList===undefined&&(this._createSnapList(),this._map.off("layeradd",this.throttledList,this),this._map.on("layeradd",this.throttledList,this)),this._snapList.length<=0)return!1;var n=this._calcClosestLayer(i.getLatLng(),this._snapList);if(0===Object.keys(n).length)return!1;var r,a=n.layer instanceof L.Marker||n.layer instanceof L.CircleMarker||!this.options.snapSegment;r=a?n.latlng:this._checkPrioritiySnapping(n);var o=this.options.snapDistance,s={marker:i,shape:this._shape,snapLatLng:r,segment:n.segment,layer:this._layer,workingLayer:this._layer,layerInteractedWith:n.layer,distance:n.distance};if(this._fireSnapDrag(s.marker,s),this._fireSnapDrag(this._layer,s),n.distance<o){i._orgLatLng=i.getLatLng(),i.setLatLng(r),i._snapped=!0,i._snapInfo=s;var l=this._snapLatLng||{},h=r||{};l.lat===h.lat&&l.lng===h.lng||(e._snapLatLng=r,e._fireSnap(i,s),e._fireSnap(e._layer,s))}else this._snapLatLng&&(this._unsnap(s),i._snapped=!1,this._fireUnsnap(s.marker,s),this._fireUnsnap(this._layer,s));return!0},_createSnapList:function(){var t=this,e=[],i=[],n=this._map;n.off("pm:remove",this._handleSnapLayerRemoval,this),n.on("pm:remove",this._handleSnapLayerRemoval,this),n.eachLayer((function(t){if((t instanceof L.Polyline||t instanceof L.Marker||t instanceof L.CircleMarker||t instanceof L.ImageOverlay)&&!0!==t.options.snapIgnore){if(t.options.snapIgnore===undefined&&(!L.PM.optIn&&!0===t.options.pmIgnore||L.PM.optIn&&!1!==t.options.pmIgnore))return;(t instanceof L.Circle||t instanceof L.CircleMarker)&&t.pm&&t.pm._hiddenPolyCircle?e.push(t.pm._hiddenPolyCircle):t instanceof L.ImageOverlay&&(t=L.rectangle(t.getBounds())),e.push(t);var n=L.polyline([],{color:"red",pmIgnore:!0});n._pmTempLayer=!0,i.push(n),(t instanceof L.Circle||t instanceof L.CircleMarker)&&i.push(n)}})),e=(e=(e=e.filter((function(e){return t._layer!==e}))).filter((function(t){return t._latlng||t._latlngs&&!j(t._latlngs)}))).filter((function(t){return!t._pmTempLayer})),this._otherSnapLayers?(this._otherSnapLayers.forEach((function(){var t=L.polyline([],{color:"red",pmIgnore:!0});t._pmTempLayer=!0,i.push(t)})),this._snapList=e.concat(this._otherSnapLayers)):this._snapList=e,this.debugIndicatorLines=i},_handleSnapLayerRemoval:function(t){var e=t.layer,i=this._snapList.findIndex((function(t){return t._leaflet_id===e._leaflet_id}));this._snapList.splice(i,1)},_calcClosestLayer:function(t,e){var i=this,n=[],r={};return e.forEach((function(e,a){if(!e._parentCopy||e._parentCopy!==i._layer){var o=i._calcLayerDistances(t,e);i.debugIndicatorLines[a]&&i.debugIndicatorLines[a].setLatLngs([t,o.latlng]),(r.distance===undefined||o.distance<=r.distance)&&(o.distance<r.distance&&(n=[]),(r=o).layer=e,n.push(r))}})),this._getClosestLayerByPriority(n)},_calcLayerDistances:function(t,e){var i,n,r,a=this,o=this._map,s=e instanceof L.Marker||e instanceof L.CircleMarker,l=e instanceof L.Polygon,h=t,u=s?e.getLatLng():e.getLatLngs();if(s)return{latlng:et({},u),distance:this._getDistance(o,u,h)};return function c(t){t.forEach((function(e,s){if(Array.isArray(e))c(e);else if(a.options.snapSegment){var u,p=e;u=l?s+1===t.length?0:s+1:s+1===t.length?undefined:s+1;var d=t[u];if(d){var f=a._getDistanceToSegment(o,h,p,d);(n===undefined||f<n)&&(n=f,r=[p,d])}}else{var g=a._getDistance(o,h,e);(n===undefined||g<n)&&(n=g,i=e)}}))}(u),this.options.snapSegment?{latlng:et({},this._getClosestPointOnSegment(o,t,r[0],r[1])),segment:r,distance:n}:{latlng:i,distance:n}},_getClosestLayerByPriority:function(t){t=t.sort((function(t,e){return t._leaflet_id-e._leaflet_id}));var e=this._map.pm.globalOptions.snappingOrder||[],i=0,n={};return e.concat(["Marker","CircleMarker","Circle","Line","Polygon","Rectangle"]).forEach((function(t){n[t]||(i+=1,n[t]=i)})),t.sort(function(t,e){var i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"asc";if(!e||0===Object.keys(e).length)return function(t,e){return t-e};for(var n,r=Object.keys(e),a=r.length-1,o={};a>=0;)n=r[a],o[n.toLowerCase()]=e[n],a-=1;function s(t){return t instanceof L.Marker?"Marker":t instanceof L.Circle?"Circle":t instanceof L.CircleMarker?"CircleMarker":t instanceof L.Rectangle?"Rectangle":t instanceof L.Polygon?"Polygon":t instanceof L.Polyline?"Line":undefined}return function(e,n){var r,a;if("instanceofShape"===t){if(r=s(e.layer).toLowerCase(),a=s(n.layer).toLowerCase(),!r||!a)return 0}else{if(!e.hasOwnProperty(t)||!n.hasOwnProperty(t))return 0;r=e[t].toLowerCase(),a=n[t].toLowerCase()}var l=r in o?o[r]:Number.MAX_SAFE_INTEGER,h=a in o?o[a]:Number.MAX_SAFE_INTEGER,u=0;return l<h?u=-1:l>h&&(u=1),"desc"===i?-1*u:u}}("instanceofShape",n)),t[0]||{}},_checkPrioritiySnapping:function(t){var e=this._map,i=t.segment[0],n=t.segment[1],r=t.latlng,a=this._getDistance(e,i,r),o=this._getDistance(e,n,r),s=a<o?i:n,l=a<o?a:o;if(this.options.snapMiddle){var h=L.PM.Utils.calcMiddleLatLng(e,i,n),u=this._getDistance(e,h,r);u<a&&u<o&&(s=h,l=u)}return et({},l<this.options.snapDistance?s:r)},_unsnap:function(){delete this._snapLatLng},_getClosestPointOnSegment:function(t,e,i,n){var r=t.getMaxZoom();r===Infinity&&(r=t.getZoom());var a=t.project(e,r),o=t.project(i,r),s=t.project(n,r),l=L.LineUtil.closestPointOnSegment(a,o,s);return t.unproject(l,r)},_getDistanceToSegment:function(t,e,i,n){var r=t.latLngToLayerPoint(e),a=t.latLngToLayerPoint(i),o=t.latLngToLayerPoint(n);return L.LineUtil.pointToSegmentDistance(r,a,o)},_getDistance:function(t,e,i){return t.latLngToLayerPoint(e).distanceTo(t.latLngToLayerPoint(i))}};const rt=nt;const at=L.Class.extend({includes:[rt,S],options:{snappable:!0,snapDistance:20,snapMiddle:!1,allowSelfIntersection:!0,tooltips:!0,templineStyle:{},hintlineStyle:{color:"#3388ff",dashArray:"5,5"},pathOptions:null,cursorMarker:!0,finishOn:null,markerStyle:{draggable:!0,icon:L.icon()},hideMiddleMarkers:!1,minRadiusCircle:null,maxRadiusCircle:null,minRadiusCircleMarker:null,maxRadiusCircleMarker:null,editable:!1,markerEditable:!0,continueDrawing:!1,snapSegment:!0,requireSnapToFinish:!1},setOptions:function(t){L.Util.setOptions(this,t)},getOptions:function(){return this.options},initialize:function(t){var e=this,i=new L.Icon.Default;i.options.tooltipAnchor=[0,0],this.options.markerStyle.icon=i,this._map=t,this.shapes=["Marker","CircleMarker","Line","Polygon","Rectangle","Circle","Cut","Text"],this.shapes.forEach((function(t){e[t]=new L.PM.Draw[t](e._map)})),this.Marker.setOptions({continueDrawing:!0}),this.CircleMarker.setOptions({continueDrawing:!0})},setPathOptions:function(t){var e=arguments.length>1&&arguments[1]!==undefined&&arguments[1];this.options.pathOptions=e?r()(this.options.pathOptions,t):t},getShapes:function(){return this.shapes},getShape:function(){return this._shape},enable:function(t,e){if(!t)throw new Error("Error: Please pass a shape as a parameter. Possible shapes are: ".concat(this.getShapes().join(",")));this.disable(),this[t].enable(e)},disable:function(){var t=this;this.shapes.forEach((function(e){t[e].disable()}))},addControls:function(){var t=this;this.shapes.forEach((function(e){t[e].addButton()}))},getActiveShape:function(){var t,e=this;return this.shapes.forEach((function(i){e[i]._enabled&&(t=i)})),t},_setGlobalDrawMode:function(){"Cut"===this._shape?this._fireGlobalCutModeToggled():this._fireGlobalDrawModeToggled();var t=L.PM.Utils.findLayers(this._map);this._enabled?t.forEach((function(t){L.PM.Utils.disablePopup(t)})):t.forEach((function(t){L.PM.Utils.enablePopup(t)}))},createNewDrawInstance:function(t,e){var i=this._getShapeFromBtnName(e);if(this[t])throw new TypeError("Draw Type already exists");if(!L.PM.Draw[i])throw new TypeError("There is no class L.PM.Draw.".concat(i));return this[t]=new L.PM.Draw[i](this._map),this[t].toolbarButtonName=t,this[t]._shape=t,this.shapes.push(t),this[e]&&this[t].setOptions(this[e].options),this[t].setOptions(this[t].options),this[t]},_getShapeFromBtnName:function(t){var e={drawMarker:"Marker",drawCircle:"Circle",drawPolygon:"Polygon",drawPolyline:"Line",drawRectangle:"Rectangle",drawCircleMarker:"CircleMarker",editMode:"Edit",dragMode:"Drag",cutPolygon:"Cut",removalMode:"Removal",rotateMode:"Rotate",drawText:"Text"};return e[t]?e[t]:this[t]?this[t]._shape:t},_finishLayer:function(t){t.pm&&(t.pm.setOptions(this.options),t.pm._shape=this._shape,t.pm._map=this._map),this._addDrawnLayerProp(t)},_addDrawnLayerProp:function(t){t._drawnByGeoman=!0},_setPane:function(t,e){"layerPane"===e?t.options.pane=this._map.pm.globalOptions.panes&&this._map.pm.globalOptions.panes.layerPane||"overlayPane":"vertexPane"===e?t.options.pane=this._map.pm.globalOptions.panes&&this._map.pm.globalOptions.panes.vertexPane||"markerPane":"markerPane"===e&&(t.options.pane=this._map.pm.globalOptions.panes&&this._map.pm.globalOptions.panes.markerPane||"markerPane")},_isFirstLayer:function(){return 0===(this._map||this._layer._map).pm.getGeomanLayers().length}});at.Marker=at.extend({initialize:function(t){this._map=t,this._shape="Marker",this.toolbarButtonName="drawMarker"},enable:function(t){var e=this;L.Util.setOptions(this,t),this._enabled=!0,this._map.on("click",this._createMarker,this),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!0),this._hintMarker=L.marker([0,0],this.options.markerStyle),this._setPane(this._hintMarker,"markerPane"),this._hintMarker._pmTempLayer=!0,this._hintMarker.addTo(this._map),this.options.tooltips&&this._hintMarker.bindTooltip(I("tooltips.placeMarker"),{permanent:!0,offset:L.point(0,10),direction:"bottom",opacity:.8}).openTooltip(),this._layer=this._hintMarker,this._map.on("mousemove",this._syncHintMarker,this),this.options.markerEditable&&this._map.eachLayer((function(t){e.isRelevantMarker(t)&&t.pm.enable()})),this._fireDrawStart(),this._setGlobalDrawMode()},disable:function(){var t=this;this._enabled&&(this._enabled=!1,this._map.off("click",this._createMarker,this),this._hintMarker.remove(),this._map.off("mousemove",this._syncHintMarker,this),this._map.eachLayer((function(e){t.isRelevantMarker(e)&&e.pm.disable()})),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!1),this.options.snappable&&this._cleanupSnapping(),this._fireDrawEnd(),this._setGlobalDrawMode())},enabled:function(){return this._enabled},toggle:function(t){this.enabled()?this.disable():this.enable(t)},isRelevantMarker:function(t){return t instanceof L.Marker&&t.pm&&!t._pmTempLayer&&!t.pm._initTextMarker},_syncHintMarker:function(t){if(this._hintMarker.setLatLng(t.latlng),this.options.snappable){var e=t;e.target=this._hintMarker,this._handleSnapping(e)}this._fireChange(this._hintMarker.getLatLng(),"Draw")},_createMarker:function(t){if(t.latlng&&(!this.options.requireSnapToFinish||this._hintMarker._snapped||this._isFirstLayer())){this._hintMarker._snapped||this._hintMarker.setLatLng(t.latlng);var e=this._hintMarker.getLatLng(),i=new L.Marker(e,this.options.markerStyle);this._setPane(i,"markerPane"),this._finishLayer(i),i.pm||(i.options.draggable=!1),i.addTo(this._map.pm._getContainingLayer()),i.pm&&this.options.markerEditable?i.pm.enable():i.dragging&&i.dragging.disable(),this._fireCreate(i),this._cleanupSnapping(),this.options.continueDrawing||this.disable()}}});var ot=6371008.8,st={centimeters:637100880,centimetres:637100880,degrees:57.22891354143274,feet:20902260.511392,inches:39.37*ot,kilometers:6371.0088,kilometres:6371.0088,meters:ot,metres:ot,miles:3958.761333810546,millimeters:6371008800,millimetres:6371008800,nauticalmiles:ot/1852,radians:1,yards:6967335.223679999};function lt(t,e,i){void 0===i&&(i={});var n={type:"Feature"};return(0===i.id||i.id)&&(n.id=i.id),i.bbox&&(n.bbox=i.bbox),n.properties=e||{},n.geometry=t,n}function ht(t,e,i){if(void 0===i&&(i={}),!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!_t(t[0])||!_t(t[1]))throw new Error("coordinates must contain numbers");return lt({type:"Point",coordinates:t},e,i)}function ut(t,e,i){if(void 0===i&&(i={}),t.length<2)throw new Error("coordinates must be an array of two or more positions");return lt({type:"LineString",coordinates:t},e,i)}function ct(t,e){void 0===e&&(e={});var i={type:"FeatureCollection"};return e.id&&(i.id=e.id),e.bbox&&(i.bbox=e.bbox),i.features=t,i}function pt(t,e){void 0===e&&(e="kilometers");var i=st[e];if(!i)throw new Error(e+" units is invalid");return t*i}function dt(t,e){void 0===e&&(e="kilometers");var i=st[e];if(!i)throw new Error(e+" units is invalid");return t/i}function ft(t){return 180*(t%(2*Math.PI))/Math.PI}function gt(t){return t%360*Math.PI/180}function _t(t){return!isNaN(t)&&null!==t&&!Array.isArray(t)}function mt(t){var e,i,n={type:"FeatureCollection",features:[]};if("LineString"===(i="Feature"===t.type?t.geometry:t).type)e=[i.coordinates];else if("MultiLineString"===i.type)e=i.coordinates;else if("MultiPolygon"===i.type)e=[].concat.apply([],i.coordinates);else{if("Polygon"!==i.type)throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");e=i.coordinates}return e.forEach((function(t){e.forEach((function(e){for(var i=0;i<t.length-1;i++)for(var r=i;r<e.length-1;r++){if(t===e){if(1===Math.abs(i-r))continue;if(0===i&&r===t.length-2&&t[i][0]===t[t.length-1][0]&&t[i][1]===t[t.length-1][1])continue}var a=yt(t[i][0],t[i][1],t[i+1][0],t[i+1][1],e[r][0],e[r][1],e[r+1][0],e[r+1][1]);a&&n.features.push(ht([a[0],a[1]]))}}))})),n}function yt(t,e,i,n,r,a,o,s){var l,h,u,c,p={x:null,y:null,onLine1:!1,onLine2:!1};return 0===(l=(s-a)*(i-t)-(o-r)*(n-e))?null!==p.x&&null!==p.y&&p:(c=(i-t)*(h=e-a)-(n-e)*(u=t-r),h=((o-r)*h-(s-a)*u)/l,u=c/l,p.x=t+h*(i-t),p.y=e+h*(n-e),h>=0&&h<=1&&(p.onLine1=!0),u>=0&&u<=1&&(p.onLine2=!0),!(!p.onLine1||!p.onLine2)&&[p.x,p.y])}function vt(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function Lt(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?vt(Object(i),!0).forEach((function(e){bt(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):vt(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function bt(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function kt(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function Mt(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?kt(Object(i),!0).forEach((function(e){xt(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):kt(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function xt(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function wt(t){if(!t)throw new Error("coord is required");if(!Array.isArray(t)){if("Feature"===t.type&&null!==t.geometry&&"Point"===t.geometry.type)return t.geometry.coordinates;if("Point"===t.type)return t.coordinates}if(Array.isArray(t)&&t.length>=2&&!Array.isArray(t[0])&&!Array.isArray(t[1]))return t;throw new Error("coord must be GeoJSON Point or an Array of numbers")}function Ct(t){if(Array.isArray(t))return t;if("Feature"===t.type){if(null!==t.geometry)return t.geometry.coordinates}else if(t.coordinates)return t.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function Pt(t){return"Feature"===t.type?t.geometry:t}function Et(t,e){return"FeatureCollection"===t.type?"FeatureCollection":"GeometryCollection"===t.type?"GeometryCollection":"Feature"===t.type&&null!==t.geometry?t.geometry.type:t.type}function St(t,e,i){if(null!==t)for(var n,r,a,o,s,l,h,u,c=0,p=0,d=t.type,f="FeatureCollection"===d,g="Feature"===d,_=f?t.features.length:1,m=0;m<_;m++){s=(u=!!(h=f?t.features[m].geometry:g?t.geometry:t)&&"GeometryCollection"===h.type)?h.geometries.length:1;for(var y=0;y<s;y++){var v=0,L=0;if(null!==(o=u?h.geometries[y]:h)){l=o.coordinates;var b=o.type;switch(c=!i||"Polygon"!==b&&"MultiPolygon"!==b?0:1,b){case null:break;case"Point":if(!1===e(l,p,m,v,L))return!1;p++,v++;break;case"LineString":case"MultiPoint":for(n=0;n<l.length;n++){if(!1===e(l[n],p,m,v,L))return!1;p++,"MultiPoint"===b&&v++}"LineString"===b&&v++;break;case"Polygon":case"MultiLineString":for(n=0;n<l.length;n++){for(r=0;r<l[n].length-c;r++){if(!1===e(l[n][r],p,m,v,L))return!1;p++}"MultiLineString"===b&&v++,"Polygon"===b&&L++}"Polygon"===b&&v++;break;case"MultiPolygon":for(n=0;n<l.length;n++){for(L=0,r=0;r<l[n].length;r++){for(a=0;a<l[n][r].length-c;a++){if(!1===e(l[n][r][a],p,m,v,L))return!1;p++}L++}v++}break;case"GeometryCollection":for(n=0;n<o.geometries.length;n++)if(!1===St(o.geometries[n],e,i))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function Ot(t,e){if("Feature"===t.type)e(t,0);else if("FeatureCollection"===t.type)for(var i=0;i<t.features.length&&!1!==e(t.features[i],i);i++);}function Dt(t,e){var i,n,r,a,o,s,l,h,u,c,p=0,d="FeatureCollection"===t.type,f="Feature"===t.type,g=d?t.features.length:1;for(i=0;i<g;i++){for(s=d?t.features[i].geometry:f?t.geometry:t,h=d?t.features[i].properties:f?t.properties:{},u=d?t.features[i].bbox:f?t.bbox:undefined,c=d?t.features[i].id:f?t.id:undefined,o=(l=!!s&&"GeometryCollection"===s.type)?s.geometries.length:1,r=0;r<o;r++)if(null!==(a=l?s.geometries[r]:s))switch(a.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===e(a,p,h,u,c))return!1;break;case"GeometryCollection":for(n=0;n<a.geometries.length;n++)if(!1===e(a.geometries[n],p,h,u,c))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===e(null,p,h,u,c))return!1;p++}}function Rt(t,e){Dt(t,(function(t,i,n,r,a){var o,s=null===t?null:t.type;switch(s){case null:case"Point":case"LineString":case"Polygon":return!1!==e(lt(t,n,{bbox:r,id:a}),i,0)&&void 0}switch(s){case"MultiPoint":o="Point";break;case"MultiLineString":o="LineString";break;case"MultiPolygon":o="Polygon"}for(var l=0;l<t.coordinates.length;l++){var h=t.coordinates[l];if(!1===e(lt({type:o,coordinates:h},n),i,l))return!1}}))}at.Line=at.extend({initialize:function(t){this._map=t,this._shape="Line",this.toolbarButtonName="drawPolyline",this._doesSelfIntersect=!1},enable:function(t){L.Util.setOptions(this,t),this._enabled=!0,this._layerGroup=new L.LayerGroup,this._layerGroup._pmTempLayer=!0,this._layerGroup.addTo(this._map),this._layer=L.polyline([],this.options.templineStyle),this._setPane(this._layer,"layerPane"),this._layer._pmTempLayer=!0,this._layerGroup.addLayer(this._layer),this._hintline=L.polyline([],this.options.hintlineStyle),this._setPane(this._hintline,"layerPane"),this._hintline._pmTempLayer=!0,this._layerGroup.addLayer(this._hintline),this._hintMarker=L.marker(this._map.getCenter(),{interactive:!1,zIndexOffset:100,icon:L.divIcon({className:"marker-icon cursor-marker"})}),this._setPane(this._hintMarker,"vertexPane"),this._hintMarker._pmTempLayer=!0,this._layerGroup.addLayer(this._hintMarker),this.options.cursorMarker&&L.DomUtil.addClass(this._hintMarker._icon,"visible"),this.options.tooltips&&this._hintMarker.bindTooltip(I("tooltips.firstVertex"),{permanent:!0,offset:L.point(0,10),direction:"bottom",opacity:.8}).openTooltip(),this._map._container.style.cursor="crosshair",this._map.on("click",this._createVertex,this),this.options.finishOn&&"snap"!==this.options.finishOn&&this._map.on(this.options.finishOn,this._finishShape,this),"dblclick"===this.options.finishOn&&(this.tempMapDoubleClickZoomState=this._map.doubleClickZoom._enabled,this.tempMapDoubleClickZoomState&&this._map.doubleClickZoom.disable()),this._map.on("mousemove",this._syncHintMarker,this),this._hintMarker.on("move",this._syncHintLine,this),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!0),this._otherSnapLayers=[],this._fireDrawStart(),this._setGlobalDrawMode()},disable:function(){this._enabled&&(this._enabled=!1,this._map._container.style.cursor="",this._map.off("click",this._createVertex,this),this._map.off("mousemove",this._syncHintMarker,this),this.options.finishOn&&"snap"!==this.options.finishOn&&this._map.off(this.options.finishOn,this._finishShape,this),this.tempMapDoubleClickZoomState&&this._map.doubleClickZoom.enable(),this._map.removeLayer(this._layerGroup),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!1),this.options.snappable&&this._cleanupSnapping(),this._fireDrawEnd(),this._setGlobalDrawMode())},enabled:function(){return this._enabled},toggle:function(t){this.enabled()?this.disable():this.enable(t)},_syncHintLine:function(){var t=this._layer.getLatLngs();if(t.length>0){var e=t[t.length-1];this._hintline.setLatLngs([e,this._hintMarker.getLatLng()])}},_syncHintMarker:function(t){if(this._hintMarker.setLatLng(t.latlng),this.options.snappable){var e=t;e.target=this._hintMarker,this._handleSnapping(e)}this.options.allowSelfIntersection||this._handleSelfIntersection(!0,t.latlng);var i=this._layer._defaultShape().slice();i.push(this._hintMarker.getLatLng()),this._change(i)},hasSelfIntersection:function(){return mt(this._layer.toGeoJSON(15)).features.length>0},_handleSelfIntersection:function(t,e){var i=L.polyline(this._layer.getLatLngs());t&&(e||(e=this._hintMarker.getLatLng()),i.addLatLng(e));var n=mt(i.toGeoJSON(15));this._doesSelfIntersect=n.features.length>0,this._doesSelfIntersect?this._hintline.setStyle({color:"#f00000ff"}):this._hintline.isEmpty()||this._hintline.setStyle(this.options.hintlineStyle)},_createVertex:function(t){if(this.options.allowSelfIntersection||(this._handleSelfIntersection(!0,t.latlng),!this._doesSelfIntersect)){this._hintMarker._snapped||this._hintMarker.setLatLng(t.latlng);var e=this._hintMarker.getLatLng();if(e.equals(this._layer.getLatLngs()[0]))this._finishShape(t);else{this._layer._latlngInfo=this._layer._latlngInfo||[],this._layer._latlngInfo.push({latlng:e,snapInfo:this._hintMarker._snapInfo}),this._layer.addLatLng(e);var i=this._createMarker(e);this._setTooltipText(),this._hintline.setLatLngs([e,e]),this._fireVertexAdded(i,undefined,e,"Draw"),this._change(this._layer.getLatLngs()),"snap"===this.options.finishOn&&this._hintMarker._snapped&&this._finishShape(t)}}},_removeLastVertex:function(){var t=this._layer.getLatLngs(),e=t.pop();if(t.length<1)this.disable();else{var i=this._layerGroup.getLayers().filter((function(t){return t instanceof L.Marker})).filter((function(t){return!L.DomUtil.hasClass(t._icon,"cursor-marker")})).find((function(t){return t.getLatLng()===e})),n=this._layerGroup.getLayers().filter((function(t){return t instanceof L.Marker})),r=L.PM.Utils.findDeepMarkerIndex(n,i).indexPath;this._layerGroup.removeLayer(i),this._layer.setLatLngs(t),this._syncHintLine(),this._setTooltipText(),this._fireVertexRemoved(i,r,"Draw"),this._change(this._layer.getLatLngs())}},_finishShape:function(){if((this.options.allowSelfIntersection||(this._handleSelfIntersection(!1),!this._doesSelfIntersect))&&(!this.options.requireSnapToFinish||this._hintMarker._snapped||this._isFirstLayer())){var t=this._layer.getLatLngs();if(!(t.length<=1)){var e=L.polyline(t,this.options.pathOptions);this._setPane(e,"layerPane"),this._finishLayer(e),e.addTo(this._map.pm._getContainingLayer()),this._fireCreate(e),this.options.snappable&&this._cleanupSnapping(),this.disable(),this.options.continueDrawing&&this.enable()}}},_createMarker:function(t){var e=new L.Marker(t,{draggable:!1,icon:L.divIcon({className:"marker-icon"})});return this._setPane(e,"vertexPane"),e._pmTempLayer=!0,this._layerGroup.addLayer(e),e.on("click",this._finishShape,this),e},_setTooltipText:function(){var t="";t=I(this._layer.getLatLngs().flat().length<=1?"tooltips.continueLine":"tooltips.finishLine"),this._hintMarker.setTooltipContent(t)},_change:function(t){this._fireChange(t,"Draw")}}),at.Polygon=at.Line.extend({initialize:function(t){this._map=t,this._shape="Polygon",this.toolbarButtonName="drawPolygon"},_createMarker:function(t){var e=new L.Marker(t,{draggable:!1,icon:L.divIcon({className:"marker-icon"})});return this._setPane(e,"vertexPane"),e._pmTempLayer=!0,this._layerGroup.addLayer(e),1===this._layer.getLatLngs().flat().length?(e.on("click",this._finishShape,this),this._tempSnapLayerIndex=this._otherSnapLayers.push(e)-1,this.options.snappable&&this._cleanupSnapping()):e.on("click",(function(){return 1})),e},_setTooltipText:function(){var t="";t=I(this._layer.getLatLngs().flat().length<=2?"tooltips.continueLine":"tooltips.finishPoly"),this._hintMarker.setTooltipContent(t)},_finishShape:function(){if((this.options.allowSelfIntersection||(this._handleSelfIntersection(!0,this._layer.getLatLngs()[0]),!this._doesSelfIntersect))&&(!this.options.requireSnapToFinish||this._hintMarker._snapped||this._isFirstLayer())){var t=this._layer.getLatLngs();if(!(t.length<=2)){var e=L.polygon(t,this.options.pathOptions);this._setPane(e,"layerPane"),this._finishLayer(e),e.addTo(this._map.pm._getContainingLayer()),this._fireCreate(e),this._cleanupSnapping(),this._otherSnapLayers.splice(this._tempSnapLayerIndex,1),delete this._tempSnapLayerIndex,this.disable(),this.options.continueDrawing&&this.enable()}}}}),at.Rectangle=at.extend({initialize:function(t){this._map=t,this._shape="Rectangle",this.toolbarButtonName="drawRectangle"},enable:function(t){if(L.Util.setOptions(this,t),this._enabled=!0,this._layerGroup=new L.LayerGroup,this._layerGroup._pmTempLayer=!0,this._layerGroup.addTo(this._map),this._layer=L.rectangle([[0,0],[0,0]],this.options.pathOptions),this._setPane(this._layer,"layerPane"),this._layer._pmTempLayer=!0,this._startMarker=L.marker([0,0],{icon:L.divIcon({className:"marker-icon rect-start-marker"}),draggable:!1,zIndexOffset:-100,opacity:this.options.cursorMarker?1:0}),this._setPane(this._startMarker,"vertexPane"),this._startMarker._pmTempLayer=!0,this._layerGroup.addLayer(this._startMarker),this._hintMarker=L.marker([0,0],{zIndexOffset:150,icon:L.divIcon({className:"marker-icon cursor-marker"})}),this._setPane(this._hintMarker,"vertexPane"),this._hintMarker._pmTempLayer=!0,this._layerGroup.addLayer(this._hintMarker),this.options.tooltips&&this._hintMarker.bindTooltip(I("tooltips.firstVertex"),{permanent:!0,offset:L.point(0,10),direction:"bottom",opacity:.8}).openTooltip(),this.options.cursorMarker){L.DomUtil.addClass(this._hintMarker._icon,"visible"),this._styleMarkers=[];for(var e=0;e<2;e+=1){var i=L.marker([0,0],{icon:L.divIcon({className:"marker-icon rect-style-marker"}),draggable:!1,zIndexOffset:100});this._setPane(i,"vertexPane"),i._pmTempLayer=!0,this._layerGroup.addLayer(i),this._styleMarkers.push(i)}}this._map._container.style.cursor="crosshair",this._map.on("click",this._placeStartingMarkers,this),this._map.on("mousemove",this._syncHintMarker,this),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!0),this._otherSnapLayers=[],this._fireDrawStart(),this._setGlobalDrawMode()},disable:function(){this._enabled&&(this._enabled=!1,this._map._container.style.cursor="",this._map.off("click",this._finishShape,this),this._map.off("click",this._placeStartingMarkers,this),this._map.off("mousemove",this._syncHintMarker,this),this._map.removeLayer(this._layerGroup),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!1),this.options.snappable&&this._cleanupSnapping(),this._fireDrawEnd(),this._setGlobalDrawMode())},enabled:function(){return this._enabled},toggle:function(t){this.enabled()?this.disable():this.enable(t)},_placeStartingMarkers:function(t){this._hintMarker._snapped||this._hintMarker.setLatLng(t.latlng);var e=this._hintMarker.getLatLng();L.DomUtil.addClass(this._startMarker._icon,"visible"),this._startMarker.setLatLng(e),this.options.cursorMarker&&this._styleMarkers&&this._styleMarkers.forEach((function(t){L.DomUtil.addClass(t._icon,"visible"),t.setLatLng(e)})),this._map.off("click",this._placeStartingMarkers,this),this._map.on("click",this._finishShape,this),this._hintMarker.setTooltipContent(I("tooltips.finishRect")),this._setRectangleOrigin()},_setRectangleOrigin:function(){var t=this._startMarker.getLatLng();t&&(this._layerGroup.addLayer(this._layer),this._layer.setLatLngs([t,t]),this._hintMarker.on("move",this._syncRectangleSize,this))},_syncHintMarker:function(t){if(this._hintMarker.setLatLng(t.latlng),this.options.snappable){var e=t;e.target=this._hintMarker,this._handleSnapping(e)}var i=this._layerGroup&&this._layerGroup.hasLayer(this._layer)?this._layer.getLatLngs():[this._hintMarker.getLatLng()];this._fireChange(i,"Draw")},_syncRectangleSize:function(){var t=this,e=F(this._startMarker.getLatLng(),this._map),i=F(this._hintMarker.getLatLng(),this._map),n=L.PM.Utils._getRotatedRectangle(e,i,this.options.rectangleAngle||0,this._map);if(this._layer.setLatLngs(n),this.options.cursorMarker&&this._styleMarkers){var r=[];n.forEach((function(t){t.equals(e,1e-8)||t.equals(i,1e-8)||r.push(t)})),r.forEach((function(e,i){try{t._styleMarkers[i].setLatLng(e)}catch(n){}}))}},_findCorners:function(){var t=this._layer.getBounds();return[t.getNorthWest(),t.getNorthEast(),t.getSouthEast(),t.getSouthWest()]},_finishShape:function(t){this._hintMarker._snapped||this._hintMarker.setLatLng(t.latlng);var e=this._hintMarker.getLatLng(),i=this._startMarker.getLatLng();if(!this.options.requireSnapToFinish||this._hintMarker._snapped||this._isFirstLayer()){var n=L.rectangle([i,e],this.options.pathOptions);if(this.options.rectangleAngle){var r=L.PM.Utils._getRotatedRectangle(i,e,this.options.rectangleAngle||0,this._map);n.setLatLngs(r),n.pm&&n.pm._setAngle(this.options.rectangleAngle||0)}this._setPane(n,"layerPane"),this._finishLayer(n),n.addTo(this._map.pm._getContainingLayer()),this._fireCreate(n),this.disable(),this.options.continueDrawing&&this.enable()}}}),at.Circle=at.extend({initialize:function(t){this._map=t,this._shape="Circle",this.toolbarButtonName="drawCircle"},enable:function(t){L.Util.setOptions(this,t),this.options.radius=0,this._enabled=!0,this._layerGroup=new L.LayerGroup,this._layerGroup._pmTempLayer=!0,this._layerGroup.addTo(this._map),this._layer=L.circle([0,0],Lt(Lt({},this.options.templineStyle),{},{radius:0})),this._setPane(this._layer,"layerPane"),this._layer._pmTempLayer=!0,this._centerMarker=L.marker([0,0],{icon:L.divIcon({className:"marker-icon"}),draggable:!1,zIndexOffset:100}),this._setPane(this._centerMarker,"vertexPane"),this._centerMarker._pmTempLayer=!0,this._hintMarker=L.marker([0,0],{zIndexOffset:110,icon:L.divIcon({className:"marker-icon cursor-marker"})}),this._setPane(this._hintMarker,"vertexPane"),this._hintMarker._pmTempLayer=!0,this._layerGroup.addLayer(this._hintMarker),this.options.cursorMarker&&L.DomUtil.addClass(this._hintMarker._icon,"visible"),this.options.tooltips&&this._hintMarker.bindTooltip(I("tooltips.startCircle"),{permanent:!0,offset:L.point(0,10),direction:"bottom",opacity:.8}).openTooltip(),this._hintline=L.polyline([],this.options.hintlineStyle),this._setPane(this._hintline,"layerPane"),this._hintline._pmTempLayer=!0,this._layerGroup.addLayer(this._hintline),this._map._container.style.cursor="crosshair",this._map.on("click",this._placeCenterMarker,this),this._map.on("mousemove",this._syncHintMarker,this),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!0),this._otherSnapLayers=[],this._fireDrawStart(),this._setGlobalDrawMode()},disable:function(){this._enabled&&(this._enabled=!1,this._map._container.style.cursor="",this._map.off("click",this._finishShape,this),this._map.off("click",this._placeCenterMarker,this),this._map.off("mousemove",this._syncHintMarker,this),this._map.removeLayer(this._layerGroup),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!1),this.options.snappable&&this._cleanupSnapping(),this._fireDrawEnd(),this._setGlobalDrawMode())},enabled:function(){return this._enabled},toggle:function(t){this.enabled()?this.disable():this.enable(t)},_syncHintLine:function(){var t=this._centerMarker.getLatLng(),e=this._getNewDestinationOfHintMarker();this._hintline.setLatLngs([t,e])},_syncCircleRadius:function(){var t,e=this._centerMarker.getLatLng(),i=this._hintMarker.getLatLng();t=this._map.options.crs===L.CRS.Simple?this._map.distance(e,i):e.distanceTo(i),this.options.minRadiusCircle&&t<this.options.minRadiusCircle?this._layer.setRadius(this.options.minRadiusCircle):this.options.maxRadiusCircle&&t>this.options.maxRadiusCircle?this._layer.setRadius(this.options.maxRadiusCircle):this._layer.setRadius(t)},_syncHintMarker:function(t){if(this._hintMarker.setLatLng(t.latlng),this._hintMarker.setLatLng(this._getNewDestinationOfHintMarker()),this.options.snappable){var e=t;e.target=this._hintMarker,this._handleSnapping(e)}this._handleHintMarkerSnapping();var i=this._layerGroup&&this._layerGroup.hasLayer(this._centerMarker)?this._centerMarker.getLatLng():this._hintMarker.getLatLng();this._fireChange(i,"Draw")},_placeCenterMarker:function(t){this._layerGroup.addLayer(this._layer),this._layerGroup.addLayer(this._centerMarker),this._hintMarker._snapped||this._hintMarker.setLatLng(t.latlng);var e=this._hintMarker.getLatLng();this._layerGroup.addLayer(this._layer),this._centerMarker.setLatLng(e),this._map.off("click",this._placeCenterMarker,this),this._map.on("click",this._finishShape,this),this._placeCircleCenter()},_placeCircleCenter:function(){var t=this._centerMarker.getLatLng();t&&(this._layer.setLatLng(t),this._hintMarker.on("move",this._syncHintLine,this),this._hintMarker.on("move",this._syncCircleRadius,this),this._hintMarker.setTooltipContent(I("tooltips.finishCircle")),this._fireCenterPlaced(),this._fireChange(this._layer.getLatLng(),"Draw"))},_finishShape:function(t){if(!this.options.requireSnapToFinish||this._hintMarker._snapped||this._isFirstLayer()){this._hintMarker._snapped||this._hintMarker.setLatLng(t.latlng);var e,i=this._centerMarker.getLatLng(),n=this._hintMarker.getLatLng();e=this._map.options.crs===L.CRS.Simple?this._map.distance(i,n):i.distanceTo(n),this.options.minRadiusCircle&&e<this.options.minRadiusCircle?e=this.options.minRadiusCircle:this.options.maxRadiusCircle&&e>this.options.maxRadiusCircle&&(e=this.options.maxRadiusCircle);var r=Lt(Lt({},this.options.pathOptions),{},{radius:e}),a=L.circle(i,r);this._setPane(a,"layerPane"),this._finishLayer(a),a.addTo(this._map.pm._getContainingLayer()),a.pm&&a.pm._updateHiddenPolyCircle(),this._fireCreate(a),this.disable(),this.options.continueDrawing&&this.enable()}},_getNewDestinationOfHintMarker:function(){var t=this._centerMarker.getLatLng(),e=this._hintMarker.getLatLng(),i=t.distanceTo(e);return t.equals(L.latLng([0,0]))||(this.options.minRadiusCircle&&i<this.options.minRadiusCircle?e=z(this._map,t,e,this.options.minRadiusCircle):this.options.maxRadiusCircle&&i>this.options.maxRadiusCircle&&(e=z(this._map,t,e,this.options.maxRadiusCircle))),e},_handleHintMarkerSnapping:function(){if(this._hintMarker._snapped){var t=this._centerMarker.getLatLng(),e=this._hintMarker.getLatLng(),i=t.distanceTo(e);t.equals(L.latLng([0,0]))||(this.options.minRadiusCircle&&i<this.options.minRadiusCircle||this.options.maxRadiusCircle&&i>this.options.maxRadiusCircle)&&this._hintMarker.setLatLng(this._hintMarker._orgLatLng)}this._hintMarker.setLatLng(this._getNewDestinationOfHintMarker())}}),at.CircleMarker=at.Marker.extend({initialize:function(t){this._map=t,this._shape="CircleMarker",this.toolbarButtonName="drawCircleMarker",this._layerIsDragging=!1},enable:function(t){var e=this;if(L.Util.setOptions(this,t),this._enabled=!0,this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!0),this.options.editable){var i={};L.setOptions(i,this.options.templineStyle),i.radius=0,this._layerGroup=new L.LayerGroup,this._layerGroup._pmTempLayer=!0,this._layerGroup.addTo(this._map),this._layer=L.circleMarker([0,0],i),this._setPane(this._layer,"layerPane"),this._layer._pmTempLayer=!0,this._centerMarker=L.marker([0,0],{icon:L.divIcon({className:"marker-icon"}),draggable:!1,zIndexOffset:100}),this._setPane(this._centerMarker,"vertexPane"),this._centerMarker._pmTempLayer=!0,this._hintMarker=L.marker([0,0],{zIndexOffset:110,icon:L.divIcon({className:"marker-icon cursor-marker"})}),this._setPane(this._hintMarker,"vertexPane"),this._hintMarker._pmTempLayer=!0,this._layerGroup.addLayer(this._hintMarker),this.options.cursorMarker&&L.DomUtil.addClass(this._hintMarker._icon,"visible"),this.options.tooltips&&this._hintMarker.bindTooltip(I("tooltips.startCircle"),{permanent:!0,offset:L.point(0,10),direction:"bottom",opacity:.8}).openTooltip(),this._hintline=L.polyline([],this.options.hintlineStyle),this._setPane(this._hintline,"layerPane"),this._hintline._pmTempLayer=!0,this._layerGroup.addLayer(this._hintline),this._map.on("click",this._placeCenterMarker,this),this._map._container.style.cursor="crosshair"}else this._map.on("click",this._createMarker,this),this._hintMarker=L.circleMarker([0,0],this.options.templineStyle),this._setPane(this._hintMarker,"layerPane"),this._hintMarker._pmTempLayer=!0,this._hintMarker.addTo(this._map),this._layer=this._hintMarker,this.options.tooltips&&this._hintMarker.bindTooltip(I("tooltips.placeCircleMarker"),{permanent:!0,offset:L.point(0,10),direction:"bottom",opacity:.8}).openTooltip();this._map.on("mousemove",this._syncHintMarker,this),!this.options.editable&&this.options.markerEditable&&this._map.eachLayer((function(t){e.isRelevantMarker(t)&&t.pm.enable()})),this._layer.bringToBack(),this._fireDrawStart(),this._setGlobalDrawMode()},disable:function(){var t=this;this._enabled&&(this._enabled=!1,this.options.editable?(this._map._container.style.cursor="",this._map.off("click",this._finishShape,this),this._map.off("click",this._placeCenterMarker,this),this._map.removeLayer(this._layerGroup)):(this._map.off("click",this._createMarker,this),this._map.eachLayer((function(e){t.isRelevantMarker(e)&&e.pm.disable()})),this._hintMarker.remove()),this._map.off("mousemove",this._syncHintMarker,this),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!1),this.options.snappable&&this._cleanupSnapping(),this._fireDrawEnd(),this._setGlobalDrawMode())},_placeCenterMarker:function(t){this._layerGroup.addLayer(this._layer),this._layerGroup.addLayer(this._centerMarker),this._hintMarker._snapped||this._hintMarker.setLatLng(t.latlng);var e=this._hintMarker.getLatLng();this._layerGroup.addLayer(this._layer),this._centerMarker.setLatLng(e),this._map.off("click",this._placeCenterMarker,this),this._map.on("click",this._finishShape,this),this._placeCircleCenter()},_placeCircleCenter:function(){var t=this._centerMarker.getLatLng();t&&(this._layer.setLatLng(t),this._hintMarker.on("move",this._syncHintLine,this),this._hintMarker.on("move",this._syncCircleRadius,this),this._hintMarker.setTooltipContent(I("tooltips.finishCircle")),this._fireCenterPlaced(),this._fireChange(this._layer.getLatLng(),"Draw"))},_syncHintLine:function(){var t=this._centerMarker.getLatLng(),e=this._getNewDestinationOfHintMarker();this._hintline.setLatLngs([t,e])},_syncCircleRadius:function(){var t=this._centerMarker.getLatLng(),e=this._hintMarker.getLatLng(),i=this._map.project(t).distanceTo(this._map.project(e));this.options.minRadiusCircleMarker&&i<this.options.minRadiusCircleMarker?this._layer.setRadius(this.options.minRadiusCircleMarker):this.options.maxRadiusCircleMarker&&i>this.options.maxRadiusCircleMarker?this._layer.setRadius(this.options.maxRadiusCircleMarker):this._layer.setRadius(i)},_syncHintMarker:function(t){if(this._hintMarker.setLatLng(t.latlng),this._hintMarker.setLatLng(this._getNewDestinationOfHintMarker()),this.options.snappable){var e=t;e.target=this._hintMarker,this._handleSnapping(e)}this._handleHintMarkerSnapping();var i=this._layerGroup&&this._layerGroup.hasLayer(this._centerMarker)?this._centerMarker.getLatLng():this._hintMarker.getLatLng();this._fireChange(i,"Draw")},isRelevantMarker:function(t){return t instanceof L.CircleMarker&&!(t instanceof L.Circle)&&t.pm&&!t._pmTempLayer},_createMarker:function(t){if((!this.options.requireSnapToFinish||this._hintMarker._snapped||this._isFirstLayer())&&t.latlng&&!this._layerIsDragging){this._hintMarker._snapped||this._hintMarker.setLatLng(t.latlng);var e=this._hintMarker.getLatLng(),i=L.circleMarker(e,this.options.pathOptions);this._setPane(i,"layerPane"),this._finishLayer(i),i.addTo(this._map.pm._getContainingLayer()),i.pm&&this.options.markerEditable&&i.pm.enable(),this._fireCreate(i),this._cleanupSnapping(),this.options.continueDrawing||this.disable()}},_finishShape:function(t){if(!this.options.requireSnapToFinish||this._hintMarker._snapped||this._isFirstLayer()){this._hintMarker._snapped||this._hintMarker.setLatLng(t.latlng);var e=this._centerMarker.getLatLng(),i=this._hintMarker.getLatLng(),n=this._map.project(e).distanceTo(this._map.project(i));this.options.editable&&(this.options.minRadiusCircleMarker&&n<this.options.minRadiusCircleMarker?n=this.options.minRadiusCircleMarker:this.options.maxRadiusCircleMarker&&n>this.options.maxRadiusCircleMarker&&(n=this.options.maxRadiusCircleMarker));var r=Mt(Mt({},this.options.pathOptions),{},{radius:n}),a=L.circleMarker(e,r);this._setPane(a,"layerPane"),this._finishLayer(a),a.addTo(this._map.pm._getContainingLayer()),a.pm&&a.pm._updateHiddenPolyCircle(),this._fireCreate(a),this.disable(),this.options.continueDrawing&&this.enable()}},_getNewDestinationOfHintMarker:function(){var t=this._hintMarker.getLatLng();if(this.options.editable){var e=this._centerMarker.getLatLng();if(e.equals(L.latLng([0,0])))return t;var i=this._map.project(e).distanceTo(this._map.project(t));this.options.minRadiusCircleMarker&&i<this.options.minRadiusCircleMarker?t=z(this._map,e,t,this._pxRadiusToMeter(this.options.minRadiusCircleMarker)):this.options.maxRadiusCircleMarker&&i>this.options.maxRadiusCircleMarker&&(t=z(this._map,e,t,this._pxRadiusToMeter(this.options.maxRadiusCircleMarker)))}return t},_handleHintMarkerSnapping:function(){if(this.options.editable){if(this._hintMarker._snapped){var t=this._centerMarker.getLatLng(),e=this._hintMarker.getLatLng(),i=this._map.project(t).distanceTo(this._map.project(e));(this.options.minRadiusCircleMarker&&i<this.options.minRadiusCircleMarker||this.options.maxRadiusCircleMarker&&i>this.options.maxRadiusCircleMarker)&&this._hintMarker.setLatLng(this._hintMarker._orgLatLng)}this._hintMarker.setLatLng(this._getNewDestinationOfHintMarker())}},_pxRadiusToMeter:function(t){var e=this._centerMarker.getLatLng(),i=this._map.project(e),n=L.point(i.x+t,i.y);return this._map.unproject(n).distanceTo(e)}});const Bt=function(t){if(!t)throw new Error("geojson is required");var e=[];return Rt(t,(function(t){!function(t,e){var i=[],n=t.geometry;if(null!==n){switch(n.type){case"Polygon":i=Ct(n);break;case"LineString":i=[Ct(n)]}i.forEach((function(i){var n=function(t,e){var i=[];return t.reduce((function(t,n){var r,a,o,s,l,h,u=ut([t,n],e);return u.bbox=(a=n,o=(r=t)[0],s=r[1],l=a[0],h=a[1],[o<l?o:l,s<h?s:h,o>l?o:l,s>h?s:h]),i.push(u),n})),i}(i,t.properties);n.forEach((function(t){t.id=e.length,e.push(t)}))}))}}(t,e)})),ct(e)};var Tt=i(1787);function It(t,e){var i=Ct(t),n=Ct(e);if(2!==i.length)throw new Error("<intersects> line1 must only contain 2 coordinates");if(2!==n.length)throw new Error("<intersects> line2 must only contain 2 coordinates");var r=i[0][0],a=i[0][1],o=i[1][0],s=i[1][1],l=n[0][0],h=n[0][1],u=n[1][0],c=n[1][1],p=(c-h)*(o-r)-(u-l)*(s-a),d=(u-l)*(a-h)-(c-h)*(r-l),f=(o-r)*(a-h)-(s-a)*(r-l);if(0===p)return null;var g=d/p,_=f/p;return g>=0&&g<=1&&_>=0&&_<=1?ht([r+g*(o-r),a+g*(s-a)]):null}const jt=function(t,e){var i={},n=[];if("LineString"===t.type&&(t=lt(t)),"LineString"===e.type&&(e=lt(e)),"Feature"===t.type&&"Feature"===e.type&&null!==t.geometry&&null!==e.geometry&&"LineString"===t.geometry.type&&"LineString"===e.geometry.type&&2===t.geometry.coordinates.length&&2===e.geometry.coordinates.length){var r=It(t,e);return r&&n.push(r),ct(n)}var a=Tt();return a.load(Bt(e)),Ot(Bt(t),(function(t){Ot(a.search(t),(function(e){var r=It(t,e);if(r){var a=Ct(r).join(",");i[a]||(i[a]=!0,n.push(r))}}))})),ct(n)};const At=function(t,e,i){void 0===i&&(i={});var n=wt(t),r=wt(e),a=gt(r[1]-n[1]),o=gt(r[0]-n[0]),s=gt(n[1]),l=gt(r[1]),h=Math.pow(Math.sin(a/2),2)+Math.pow(Math.sin(o/2),2)*Math.cos(s)*Math.cos(l);return pt(2*Math.atan2(Math.sqrt(h),Math.sqrt(1-h)),i.units)};const Gt=function(t){var e=t[0],i=t[1],n=t[2],r=t[3];if(At(t.slice(0,2),[n,i])>=At(t.slice(0,2),[e,r])){var a=(i+r)/2;return[e,a-(n-e)/2,n,a+(n-e)/2]}var o=(e+n)/2;return[o-(r-i)/2,i,o+(r-i)/2,r]};function Nt(t){var e=[Infinity,Infinity,-Infinity,-Infinity];return St(t,(function(t){e[0]>t[0]&&(e[0]=t[0]),e[1]>t[1]&&(e[1]=t[1]),e[2]<t[0]&&(e[2]=t[0]),e[3]<t[1]&&(e[3]=t[1])})),e}Nt["default"]=Nt;const zt=Nt;const Ut=function(t,e){void 0===e&&(e={});var i=e.precision,n=e.coordinates,r=e.mutate;if(i=i===undefined||null===i||isNaN(i)?6:i,n=n===undefined||null===n||isNaN(n)?3:n,!t)throw new Error("<geojson> is required");if("number"!=typeof i)throw new Error("<precision> must be a number");if("number"!=typeof n)throw new Error("<coordinates> must be a number");!1!==r&&r!==undefined||(t=JSON.parse(JSON.stringify(t)));var a=Math.pow(10,i);return St(t,(function(t){!function(t,e,i){t.length>i&&t.splice(i,t.length);for(var n=0;n<t.length;n++)t[n]=Math.round(t[n]*e)/e}(t,a,n)})),t};function Ft(t,e,i){if(void 0===i&&(i={}),!0===i.final)return function(t,e){var i=Ft(e,t);return i=(i+180)%360}(t,e);var n=wt(t),r=wt(e),a=gt(n[0]),o=gt(r[0]),s=gt(n[1]),l=gt(r[1]),h=Math.sin(o-a)*Math.cos(l),u=Math.cos(s)*Math.sin(l)-Math.sin(s)*Math.cos(l)*Math.cos(o-a);return ft(Math.atan2(h,u))}function Vt(t,e,i,n){void 0===n&&(n={});var r=wt(t),a=gt(r[0]),o=gt(r[1]),s=gt(i),l=dt(e,n.units),h=Math.asin(Math.sin(o)*Math.cos(l)+Math.cos(o)*Math.sin(l)*Math.cos(s));return ht([ft(a+Math.atan2(Math.sin(s)*Math.sin(l)*Math.cos(o),Math.cos(l)-Math.sin(o)*Math.sin(h))),ft(h)],n.properties)}const Kt=function(t,e,i){void 0===i&&(i={});var n=ht([Infinity,Infinity],{dist:Infinity}),r=0;return Rt(t,(function(t){for(var a=Ct(t),o=0;o<a.length-1;o++){var s=ht(a[o]);s.properties.dist=At(e,s,i);var l=ht(a[o+1]);l.properties.dist=At(e,l,i);var h=At(s,l,i),u=Math.max(s.properties.dist,l.properties.dist),c=Ft(s,l),p=Vt(e,u,c+90,i),d=Vt(e,u,c-90,i),f=jt(ut([p.geometry.coordinates,d.geometry.coordinates]),ut([s.geometry.coordinates,l.geometry.coordinates])),g=null;f.features.length>0&&((g=f.features[0]).properties.dist=At(e,g,i),g.properties.location=r+At(s,g,i)),s.properties.dist<n.properties.dist&&((n=s).properties.index=o,n.properties.location=r),l.properties.dist<n.properties.dist&&((n=l).properties.index=o+1,n.properties.location=r+h),g&&g.properties.dist<n.properties.dist&&((n=g).properties.index=o),r+=h}})),n};function Ht(t,e){var i=[],n=Tt();return Rt(e,(function(e){if(i.forEach((function(t,e){t.id=e})),i.length){var r=n.search(e);if(r.features.length){var a=Jt(e,r);i=i.filter((function(t){return t.id!==a.id})),n.remove(a),Ot(qt(a,e),(function(t){i.push(t),n.insert(t)}))}}else(i=qt(t,e).features).forEach((function(t){t.bbox||(t.bbox=Gt(zt(t)))})),n.load(ct(i))})),ct(i)}function qt(t,e){var i=[],n=Ct(t)[0],r=Ct(t)[t.geometry.coordinates.length-1];if(Yt(n,wt(e))||Yt(r,wt(e)))return ct([t]);var a=Tt(),o=Bt(t);a.load(o);var s=a.search(e);if(!s.features.length)return ct([t]);var l=Jt(e,s),h=function(t,e,i){var n=i;return Ot(t,(function(t,r){n=0===r&&i===undefined?t:e(n,t,r)})),n}(o,(function(t,n,r){var a=Ct(n)[1],o=wt(e);return r===l.id?(t.push(o),i.push(ut(t)),Yt(o,a)?[o]:[o,a]):(t.push(a),t)}),[n]);return h.length>1&&i.push(ut(h)),ct(i)}function Jt(t,e){if(!e.features.length)throw new Error("lines must contain features");if(1===e.features.length)return e.features[0];var i,n=Infinity;return Ot(e,(function(e){var r=Kt(e,t).properties.dist;r<n&&(i=e,n=r)})),i}function Yt(t,e){return t[0]===e[0]&&t[1]===e[1]}const Xt=function(t,e){if(!t)throw new Error("line is required");if(!e)throw new Error("splitter is required");var i=Et(t),n=Et(e);if("LineString"!==i)throw new Error("line must be LineString");if("FeatureCollection"===n)throw new Error("splitter cannot be a FeatureCollection");if("GeometryCollection"===n)throw new Error("splitter cannot be a GeometryCollection");var r=Ut(e,{precision:7});switch(n){case"Point":return qt(t,r);case"MultiPoint":return Ht(t,r);case"LineString":case"MultiLineString":case"Polygon":case"MultiPolygon":return Ht(t,jt(t,r))}};function Zt(t,e,i){if(void 0===i&&(i={}),!t)throw new Error("point is required");if(!e)throw new Error("polygon is required");var n=wt(t),r=Pt(e),a=r.type,o=e.bbox,s=r.coordinates;if(o&&!1===function(t,e){return e[0]<=t[0]&&e[1]<=t[1]&&e[2]>=t[0]&&e[3]>=t[1]}(n,o))return!1;"Polygon"===a&&(s=[s]);for(var l=!1,h=0;h<s.length&&!l;h++)if($t(n,s[h][0],i.ignoreBoundary)){for(var u=!1,c=1;c<s[h].length&&!u;)$t(n,s[h][c],!i.ignoreBoundary)&&(u=!0),c++;u||(l=!0)}return l}function $t(t,e,i){var n=!1;e[0][0]===e[e.length-1][0]&&e[0][1]===e[e.length-1][1]&&(e=e.slice(0,e.length-1));for(var r=0,a=e.length-1;r<e.length;a=r++){var o=e[r][0],s=e[r][1],l=e[a][0],h=e[a][1];if(t[1]*(o-l)+s*(l-t[0])+h*(t[0]-o)==0&&(o-t[0])*(l-t[0])<=0&&(s-t[1])*(h-t[1])<=0)return!i;s>t[1]!=h>t[1]&&t[0]<(l-o)*(t[1]-s)/(h-s)+o&&(n=!n)}return n}function Wt(t,e,i,n,r){var a=i[0],o=i[1],s=t[0],l=t[1],h=e[0],u=e[1],c=h-s,p=u-l,d=(i[0]-s)*p-(i[1]-l)*c;if(null!==r){if(Math.abs(d)>r)return!1}else if(0!==d)return!1;return n?"start"===n?Math.abs(c)>=Math.abs(p)?c>0?s<a&&a<=h:h<=a&&a<s:p>0?l<o&&o<=u:u<=o&&o<l:"end"===n?Math.abs(c)>=Math.abs(p)?c>0?s<=a&&a<h:h<a&&a<=s:p>0?l<=o&&o<u:u<o&&o<=l:"both"===n&&(Math.abs(c)>=Math.abs(p)?c>0?s<a&&a<h:h<a&&a<s:p>0?l<o&&o<u:u<o&&o<l):Math.abs(c)>=Math.abs(p)?c>0?s<=a&&a<=h:h<=a&&a<=s:p>0?l<=o&&o<=u:u<=o&&o<=l}const Qt=function(t,e,i){void 0===i&&(i={});for(var n=wt(t),r=Ct(e),a=0;a<r.length-1;a++){var o=!1;if(i.ignoreEndVertices&&(0===a&&(o="start"),a===r.length-2&&(o="end"),0===a&&a+1===r.length-1&&(o="both")),Wt(r[a],r[a+1],n,o,"undefined"==typeof i.epsilon?null:i.epsilon))return!0}return!1};function te(t,e){var i=Pt(t),n=Pt(e),r=i.type,a=n.type,o=i.coordinates,s=n.coordinates;switch(r){case"Point":if("Point"===a)return ie(o,s);throw new Error("feature2 "+a+" geometry not supported");case"MultiPoint":switch(a){case"Point":return function(t,e){var i,n=!1;for(i=0;i<t.coordinates.length;i++)if(ie(t.coordinates[i],e.coordinates)){n=!0;break}return n}(i,n);case"MultiPoint":return function(t,e){for(var i=0,n=e.coordinates;i<n.length;i++){for(var r=n[i],a=!1,o=0,s=t.coordinates;o<s.length;o++){if(ie(r,s[o])){a=!0;break}}if(!a)return!1}return!0}(i,n);default:throw new Error("feature2 "+a+" geometry not supported")}case"LineString":switch(a){case"Point":return Qt(n,i,{ignoreEndVertices:!0});case"LineString":return function(t,e){for(var i=!1,n=0,r=e.coordinates;n<r.length;n++){var a=r[n];if(Qt({type:"Point",coordinates:a},t,{ignoreEndVertices:!0})&&(i=!0),!Qt({type:"Point",coordinates:a},t,{ignoreEndVertices:!1}))return!1}return i}(i,n);case"MultiPoint":return function(t,e){for(var i=!1,n=0,r=e.coordinates;n<r.length;n++){var a=r[n];if(Qt(a,t,{ignoreEndVertices:!0})&&(i=!0),!Qt(a,t))return!1}if(i)return!0;return!1}(i,n);default:throw new Error("feature2 "+a+" geometry not supported")}case"Polygon":switch(a){case"Point":return Zt(n,i,{ignoreBoundary:!0});case"LineString":return function(t,e){var i=!1,n=0,r=zt(t),a=zt(e);if(!ee(r,a))return!1;for(;n<e.coordinates.length-1;n++){if(Zt({type:"Point",coordinates:ne(e.coordinates[n],e.coordinates[n+1])},t,{ignoreBoundary:!0})){i=!0;break}}return i}(i,n);case"Polygon":return function(t,e){if("Feature"===t.type&&null===t.geometry)return!1;if("Feature"===e.type&&null===e.geometry)return!1;var i=zt(t),n=zt(e);if(!ee(i,n))return!1;for(var r=Pt(e).coordinates,a=0,o=r;a<o.length;a++)for(var s=0,l=o[a];s<l.length;s++){if(!Zt(l[s],t))return!1}return!0}(i,n);case"MultiPoint":return function(t,e){for(var i=0,n=e.coordinates;i<n.length;i++){if(!Zt(n[i],t,{ignoreBoundary:!0}))return!1}return!0}(i,n);default:throw new Error("feature2 "+a+" geometry not supported")}default:throw new Error("feature1 "+r+" geometry not supported")}}function ee(t,e){return!(t[0]>e[0])&&(!(t[2]<e[2])&&(!(t[1]>e[1])&&!(t[3]<e[3])))}function ie(t,e){return t[0]===e[0]&&t[1]===e[1]}function ne(t,e){return[(t[0]+e[0])/2,(t[1]+e[1])/2]}var re=i(2676),ae=i.n(re);function oe(t){var e={type:"Feature"};return e.geometry=t,e}function se(t){return"Feature"===t.type?t.geometry:t}function le(t){return t.geometry.coordinates}function he(t){return oe({type:"Polygon",coordinates:t})}function ue(t){return oe({type:"MultiPolygon",coordinates:t})}function ce(t){return Array.isArray(t)?1+ce(t[0]):-1}function pe(t){t instanceof L.Polyline&&(t=t.toGeoJSON(15));var e=le(t),i=ce(e),n=[];return i>1?e.forEach((function(t){n.push(function(t){return oe({type:"LineString",coordinates:t})}(t))})):n.push(t),n}function de(t){var e=[];return t.eachLayer((function(t){e.push(le(t.toGeoJSON(15)))})),function(t){return oe({type:"MultiLineString",coordinates:t})}(e)}function fe(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var i=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null==i)return;var n,r,a=[],o=!0,s=!1;try{for(i=i.call(t);!(o=(n=i.next()).done)&&(a.push(n.value),!e||a.length!==e);o=!0);}catch(l){s=!0,r=l}finally{try{o||null==i["return"]||i["return"]()}finally{if(s)throw r}}return a}(t,e)||function(t,e){if(!t)return;if("string"==typeof t)return ge(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(t);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return ge(t,e)}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function ge(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function _e(t){return function(t){if(Array.isArray(t))return me(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return me(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(t);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return me(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function me(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}at.Cut=at.Polygon.extend({initialize:function(t){this._map=t,this._shape="Cut",this.toolbarButtonName="cutPolygon"},_finishShape:function(){var t=this;if(this._editedLayers=[],this.options.allowSelfIntersection||(this._handleSelfIntersection(!0,this._layer.getLatLngs()[0]),!this._doesSelfIntersect)){var e=this._layer.getLatLngs(),i=L.polygon(e,this.options.pathOptions);i._latlngInfos=this._layer._latlngInfo,this.cut(i),this._cleanupSnapping(),this._otherSnapLayers.splice(this._tempSnapLayerIndex,1),delete this._tempSnapLayerIndex,this._editedLayers.forEach((function(e){var i=e.layer,n=e.originalLayer;t._fireCut(n,i,n),t._fireCut(t._map,i,n),n.pm._fireEdit()})),this._editedLayers=[],this.disable(),this.options.continueDrawing&&this.enable()}},cut:function(t){var e=this,i=this._map._layers,n=t._latlngInfos||[];Object.keys(i).map((function(t){return i[t]})).filter((function(t){return t.pm})).filter((function(t){return!t._pmTempLayer})).filter((function(t){return!L.PM.optIn&&!t.options.pmIgnore||L.PM.optIn&&!1===t.options.pmIgnore})).filter((function(t){return t instanceof L.Polyline})).filter((function(e){return e!==t})).filter((function(t){return t.pm.options.allowCutting})).filter((function(t){return!(e.options.layersToCut&&L.Util.isArray(e.options.layersToCut)&&e.options.layersToCut.length>0)||e.options.layersToCut.indexOf(t)>-1})).filter((function(t){return!e._layerGroup.hasLayer(t)})).filter((function(e){try{var i=!!jt(t.toGeoJSON(15),e.toGeoJSON(15)).features.length>0;return i||e instanceof L.Polyline&&!(e instanceof L.Polygon)?i:(n=t.toGeoJSON(15),r=e.toGeoJSON(15),a=se(n),o=se(r),!(0===(s=ae().intersection(a.coordinates,o.coordinates)).length||!(1===s.length?he(s[0]):ue(s))))}catch(l){return e instanceof L.Polygon&&console.error("You can\'t cut polygons with self-intersections"),!1}var n,r,a,o,s})).forEach((function(i){var r;if(i instanceof L.Polygon){var a=(r=L.polygon(i.getLatLngs())).getLatLngs();n.forEach((function(t){if(t&&t.snapInfo){var i=t.latlng,n=e._calcClosestLayer(i,[r]);if(n&&n.segment&&n.distance<e.options.snapDistance){var o=n.segment;if(o&&2===o.length){var s=L.PM.Utils._getIndexFromSegment(a,o),l=s.indexPath,h=s.parentPath,u=s.newIndex;(l.length>1?R()(a,h):a).splice(u,0,i)}}}}))}else r=i;var o=e._cutLayer(t,r),s=L.geoJSON(o,i.options);if(1===s.getLayers().length){var l=s.getLayers();s=fe(l,1)[0]}e._setPane(s,"layerPane");var h=s.addTo(e._map.pm._getContainingLayer());if(h.pm.enable(i.pm.options),h.pm.disable(),i._pmTempLayer=!0,t._pmTempLayer=!0,i.remove(),i.removeFrom(e._map.pm._getContainingLayer()),t.remove(),t.removeFrom(e._map.pm._getContainingLayer()),h.getLayers&&0===h.getLayers().length&&e._map.pm.removeLayer({target:h}),h instanceof L.LayerGroup?(h.eachLayer((function(t){e._addDrawnLayerProp(t)})),e._addDrawnLayerProp(h)):e._addDrawnLayerProp(h),e.options.layersToCut&&L.Util.isArray(e.options.layersToCut)&&e.options.layersToCut.length>0){var u=e.options.layersToCut.indexOf(i);u>-1&&e.options.layersToCut.splice(u,1)}e._editedLayers.push({layer:h,originalLayer:i})}))},_cutLayer:function(t,e){var i,n,r,a,o,s,l=L.geoJSON();if(e instanceof L.Polygon)n=e.toGeoJSON(15),r=t.toGeoJSON(15),a=se(n),o=se(r),i=0===(s=ae().difference(a.coordinates,o.coordinates)).length?null:1===s.length?he(s[0]):ue(s);else{var h=pe(e);h.forEach((function(e){var i=Xt(e,t.toGeoJSON(15));(i&&i.features.length>0?L.geoJSON(i):L.geoJSON(e)).getLayers().forEach((function(e){te(t.toGeoJSON(15),e.toGeoJSON(15))||e.addTo(l)}))})),i=h.length>1?de(l):l.toGeoJSON(15)}return i},_change:L.Util.falseFn}),at.Text=at.extend({initialize:function(t){this._map=t,this._shape="Text",this.toolbarButtonName="drawText"},enable:function(t){L.Util.setOptions(this,t),this._enabled=!0,this._map.on("click",this._createMarker,this),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!0),this._hintMarker=L.marker(this._map.getCenter(),{interactive:!1,zIndexOffset:100,icon:L.divIcon({className:"marker-icon cursor-marker"})}),this._setPane(this._hintMarker,"vertexPane"),this._hintMarker._pmTempLayer=!0,this._hintMarker.addTo(this._map),this.options.cursorMarker&&L.DomUtil.addClass(this._hintMarker._icon,"visible"),this.options.tooltips&&this._hintMarker.bindTooltip(I("tooltips.placeText"),{permanent:!0,offset:L.point(0,10),direction:"bottom",opacity:.8}).openTooltip(),this._layer=this._hintMarker,this._map.on("mousemove",this._syncHintMarker,this),this._fireDrawStart(),this._setGlobalDrawMode()},disable:function(){this._enabled&&(this._enabled=!1,this._map.off("click",this._createMarker,this),this._hintMarker.remove(),this._map.off("mousemove",this._syncHintMarker,this),this._map.pm.Toolbar.toggleButton(this.toolbarButtonName,!1),this.options.snappable&&this._cleanupSnapping(),this._fireDrawEnd(),this._setGlobalDrawMode())},enabled:function(){return this._enabled},toggle:function(t){this.enabled()?this.disable():this.enable(t)},_syncHintMarker:function(t){if(this._hintMarker.setLatLng(t.latlng),this.options.snappable){var e=t;e.target=this._hintMarker,this._handleSnapping(e)}},_createMarker:function(t){var e;if(t.latlng&&(!this.options.requireSnapToFinish||this._hintMarker._snapped||this._isFirstLayer())){this._hintMarker._snapped||this._hintMarker.setLatLng(t.latlng);var i=this._hintMarker.getLatLng();if(this.textArea=this._createTextArea(),null!==(e=this.options.textOptions)&&void 0!==e&&e.className){var n,r=this.options.textOptions.className.split(" ");(n=this.textArea.classList).add.apply(n,_e(r))}var a=this._createTextIcon(this.textArea),o=new L.Marker(i,{textMarker:!0,_textMarkerOverPM:!0,icon:a});if(this._setPane(o,"markerPane"),this._finishLayer(o),o.pm||(o.options.draggable=!1),o.addTo(this._map.pm._getContainingLayer()),o.pm){var s,l,h,u,c;o.pm.textArea=this.textArea,L.setOptions(o.pm,{removeIfEmpty:null===(s=null===(l=this.options.textOptions)||void 0===l?void 0:l.removeIfEmpty)||void 0===s||s});var p=null===(h=null===(u=this.options.textOptions)||void 0===u?void 0:u.focusAfterDraw)||void 0===h||h;o.pm._createTextMarker(p),null!==(c=this.options.textOptions)&&void 0!==c&&c.text&&o.pm.setText(this.options.textOptions.text)}this._fireCreate(o),this._cleanupSnapping(),this.disable(),this.options.continueDrawing&&this.enable()}},_createTextArea:function(){var t=document.createElement("textarea");return t.autofocus=!0,t.readOnly=!0,t.classList.add("pm-textarea","pm-disabled"),t},_createTextIcon:function(t){return L.divIcon({className:"pm-text-marker",html:t})}});const ye={enableLayerDrag:function(){if(this.options.draggable&&this._layer._map){this.disable(),this._layerDragEnabled=!0,this._map||(this._map=this._layer._map),(this._layer instanceof L.Marker||this._layer instanceof L.ImageOverlay)&&L.DomEvent.on(this._getDOMElem(),"dragstart",this._stopDOMImageDrag),this._layer.dragging&&this._layer.dragging.disable(),this._tempDragCoord=null,V(this._layer)instanceof L.Canvas?(this._layer.on("mouseout",this.removeDraggingClass,this),this._layer.on("mouseover",this.addDraggingClass,this)):this.addDraggingClass(),this._originalMapDragState=this._layer._map.dragging._enabled,this._safeToCacheDragState=!0;var t=this._getDOMElem();t&&(V(this._layer)instanceof L.Canvas?(this._layer.on("touchstart mousedown",this._dragMixinOnMouseDown,this),this._map.pm._addTouchEvents(t)):L.DomEvent.on(t,"touchstart mousedown",this._simulateMouseDownEvent,this)),this._fireDragEnable()}},disableLayerDrag:function(){this._layerDragEnabled=!1,V(this._layer)instanceof L.Canvas?(this._layer.off("mouseout",this.removeDraggingClass,this),this._layer.off("mouseover",this.addDraggingClass,this)):this.removeDraggingClass(),this._originalMapDragState&&this._dragging&&this._map.dragging.enable(),this._safeToCacheDragState=!1,this._layer.dragging&&this._layer.dragging.disable();var t=this._getDOMElem();t&&(V(this._layer)instanceof L.Canvas?(this._layer.off("touchstart mousedown",this._dragMixinOnMouseDown,this),this._map.pm._removeTouchEvents(t)):L.DomEvent.off(t,"touchstart mousedown",this._simulateMouseDownEvent,this)),this._layerDragged&&this._fireUpdate(),this._layerDragged=!1,this._fireDragDisable()},dragging:function(){return this._dragging},layerDragEnabled:function(){return!!this._layerDragEnabled},_simulateMouseDownEvent:function(t){var e={originalEvent:t,target:this._layer},i=t.touches?t.touches[0]:t;return e.containerPoint=this._map.mouseEventToContainerPoint(i),e.latlng=this._map.containerPointToLatLng(e.containerPoint),this._dragMixinOnMouseDown(e),!1},_simulateMouseMoveEvent:function(t){var e={originalEvent:t,target:this._layer},i=t.touches?t.touches[0]:t;return e.containerPoint=this._map.mouseEventToContainerPoint(i),e.latlng=this._map.containerPointToLatLng(e.containerPoint),this._dragMixinOnMouseMove(e),!1},_simulateMouseUpEvent:function(t){var e={originalEvent:t,target:this._layer};return-1===t.type.indexOf("touch")&&(e.containerPoint=this._map.mouseEventToContainerPoint(t),e.latlng=this._map.containerPointToLatLng(e.containerPoint)),this._dragMixinOnMouseUp(e),!1},_dragMixinOnMouseDown:function(t){if(!(t.originalEvent.button>0)){this._overwriteEventIfItComesFromMarker(t);var e=t._fromLayerSync,i=this._syncLayers("_dragMixinOnMouseDown",t);this._layer instanceof L.Marker&&(!this.options.snappable||e||i?this._disableSnapping():this._initSnappableMarkers()),this._layer instanceof L.CircleMarker&&!(this._layer instanceof L.Circle)&&(!this.options.snappable||e||i?this._layer.pm.options.editable?this._layer.pm._disableSnapping():this._layer.pm._disableSnappingDrag():this._layer.pm.options.editable||this._initSnappableMarkersDrag()),this._safeToCacheDragState&&(this._originalMapDragState=this._layer._map.dragging._enabled,this._safeToCacheDragState=!1),this._tempDragCoord=t.latlng,L.DomEvent.on(this._map.getContainer(),"touchend mouseup",this._simulateMouseUpEvent,this),L.DomEvent.on(this._map.getContainer(),"touchmove mousemove",this._simulateMouseMoveEvent,this)}},_dragMixinOnMouseMove:function(t){this._overwriteEventIfItComesFromMarker(t);var e=this._getDOMElem();this._syncLayers("_dragMixinOnMouseMove",t),this._dragging||(this._dragging=!0,L.DomUtil.addClass(e,"leaflet-pm-dragging"),this._layer instanceof L.Marker||this._layer.bringToFront(),this._originalMapDragState&&this._map.dragging.disable(),this._fireDragStart()),this._tempDragCoord||(this._tempDragCoord=t.latlng),this._onLayerDrag(t),this._layer instanceof L.CircleMarker&&this._layer.pm._updateHiddenPolyCircle()},_dragMixinOnMouseUp:function(t){var e=this,i=this._getDOMElem();return this._syncLayers("_dragMixinOnMouseUp",t),this._originalMapDragState&&this._map.dragging.enable(),this._safeToCacheDragState=!0,L.DomEvent.off(this._map.getContainer(),"touchmove mousemove",this._simulateMouseMoveEvent,this),L.DomEvent.off(this._map.getContainer(),"touchend mouseup",this._simulateMouseUpEvent,this),!!this._dragging&&(this._layer instanceof L.CircleMarker&&this._layer.pm._updateHiddenPolyCircle(),this._layerDragged=!0,window.setTimeout((function(){e._dragging=!1,i&&L.DomUtil.removeClass(i,"leaflet-pm-dragging"),e._fireDragEnd(),e._fireEdit()}),10),!0)},_onLayerDrag:function(t){var e=t.latlng,i=e.lat-this._tempDragCoord.lat,n=e.lng-this._tempDragCoord.lng,r=function u(t){return t.map((function(t){if(Array.isArray(t))return u(t);var e={lat:t.lat+i,lng:t.lng+n};return(t.alt||0===t.alt)&&(e.alt=t.alt),e}))};if(this._layer instanceof L.Circle||this._layer instanceof L.CircleMarker&&this._layer.options.editable){var a=r([this._layer.getLatLng()]);this._layer.setLatLng(a[0]),this._fireChange(this._layer.getLatLng(),"Edit")}else if(this._layer instanceof L.CircleMarker||this._layer instanceof L.Marker){var o=this._layer.getLatLng();this._layer._snapped&&(o=this._layer._orgLatLng);var s=r([o]);this._layer.setLatLng(s[0]),this._fireChange(this._layer.getLatLng(),"Edit")}else if(this._layer instanceof L.ImageOverlay){var l=r([this._layer.getBounds().getNorthWest(),this._layer.getBounds().getSouthEast()]);this._layer.setBounds(l),this._fireChange(this._layer.getBounds(),"Edit")}else{var h=r(this._layer.getLatLngs());this._layer.setLatLngs(h),this._fireChange(this._layer.getLatLngs(),"Edit")}this._tempDragCoord=e,t.layer=this._layer,this._fireDrag(t)},addDraggingClass:function(){var t=this._getDOMElem();t&&L.DomUtil.addClass(t,"leaflet-pm-draggable")},removeDraggingClass:function(){var t=this._getDOMElem();t&&L.DomUtil.removeClass(t,"leaflet-pm-draggable")},_getDOMElem:function(){var t=null;return this._layer._path?t=this._layer._path:this._layer._renderer&&this._layer._renderer._container?t=this._layer._renderer._container:this._layer._image?t=this._layer._image:this._layer._icon&&(t=this._layer._icon),t},_overwriteEventIfItComesFromMarker:function(t){t.target.getLatLng&&(!t.target._radius||t.target._radius<=10)&&(t.containerPoint=this._map.mouseEventToContainerPoint(t.originalEvent),t.latlng=this._map.containerPointToLatLng(t.containerPoint))},_syncLayers:function(t,e){var i=this;if(this.enabled())return!1;if(!e._fromLayerSync&&this._layer===e.target&&this.options.syncLayersOnDrag){e._fromLayerSync=!0;var n=[];if(L.Util.isArray(this.options.syncLayersOnDrag))n=this.options.syncLayersOnDrag,this.options.syncLayersOnDrag.forEach((function(t){t instanceof L.LayerGroup&&(n=n.concat(t.pm.getLayers(!0)))}));else if(!0===this.options.syncLayersOnDrag&&this._parentLayerGroup)for(var r in this._parentLayerGroup){var a=this._parentLayerGroup[r];a.pm&&(n=a.pm.getLayers(!0))}return L.Util.isArray(n)&&n.length>0&&(n=n.filter((function(t){return!!t.pm})).filter((function(t){return!!t.pm.options.draggable}))).forEach((function(n){n!==i._layer&&n.pm[t]&&(n._snapped=!1,n.pm[t](e))})),n.length>0}return!1},_stopDOMImageDrag:function(t){return t.preventDefault(),!1}};function ve(t,e,i){var n=i.getMaxZoom();if(n===Infinity&&(n=i.getZoom()),L.Util.isArray(t)){var r=[];return t.forEach((function(t){r.push(ve(t,e,i))})),r}return t instanceof L.LatLng?function(t,e,i,n){return i.unproject(e.transform(i.project(t,n)),n)}(t,e,i,n):null}function Le(t,e){e instanceof L.Layer&&(e=e.getLatLng());var i=t.getMaxZoom();return i===Infinity&&(i=t.getZoom()),t.project(e,i)}function be(t,e){var i=t.getMaxZoom();return i===Infinity&&(i=t.getZoom()),t.unproject(e,i)}var ke={_onRotateStart:function(t){this._preventRenderingMarkers(!0),this._rotationOriginLatLng=this._getRotationCenter().clone(),this._rotationOriginPoint=Le(this._map,this._rotationOriginLatLng),this._rotationStartPoint=Le(this._map,t.target.getLatLng()),this._initialRotateLatLng=U(this._layer),this._startAngle=this.getAngle();var e=U(this._rotationLayer,this._rotationLayer.pm._rotateOrgLatLng);this._fireRotationStart(this._rotationLayer,e),this._fireRotationStart(this._map,e)},_onRotate:function(t){var e=Le(this._map,t.target.getLatLng()),i=this._rotationStartPoint,n=this._rotationOriginPoint,r=Math.atan2(e.y-n.y,e.x-n.x)-Math.atan2(i.y-n.y,i.x-n.x);this._layer.setLatLngs(this._rotateLayer(r,this._initialRotateLatLng,this._rotationOriginLatLng,L.PM.Matrix.init(),this._map));var a=this;!function h(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[],i=arguments.length>2&&arguments[2]!==undefined?arguments[2]:-1;if(i>-1&&e.push(i),L.Util.isArray(t[0]))t.forEach((function(t,i){return h(t,e.slice(),i)}));else{var n=R()(a._markers,e);t.forEach((function(t,e){n[e].setLatLng(t)}))}}(this._layer.getLatLngs());var o=U(this._rotationLayer);this._rotationLayer.setLatLngs(this._rotateLayer(r,this._rotationLayer.pm._rotateOrgLatLng,this._rotationOriginLatLng,L.PM.Matrix.init(),this._map));var s=180*r/Math.PI,l=(s=s<0?s+360:s)+this._startAngle;this._setAngle(l),this._rotationLayer.pm._setAngle(l),this._fireRotation(this._rotationLayer,s,o),this._fireRotation(this._map,s,o),this._rotationLayer.pm._fireChange(this._rotationLayer.getLatLngs(),"Rotation")},_onRotateEnd:function(){var t=this._startAngle;delete this._rotationOriginLatLng,delete this._rotationOriginPoint,delete this._rotationStartPoint,delete this._initialRotateLatLng,delete this._startAngle;var e=U(this._rotationLayer,this._rotationLayer.pm._rotateOrgLatLng);this._rotationLayer.pm._rotateOrgLatLng=U(this._rotationLayer),this._fireRotationEnd(this._rotationLayer,t,e),this._fireRotationEnd(this._map,t,e),this._rotationLayer.pm._fireEdit(this._rotationLayer,"Rotation"),this._preventRenderingMarkers(!1),this._layerRotated=!0},_rotateLayer:function(t,e,i,n,r){var a=Le(r,i);return this._matrix=n.clone().rotate(t,a).flip(),ve(e,this._matrix,r)},_setAngle:function(t){t=t<0?t+360:t,this._angle=t%360},_getRotationCenter:function(){var t=L.polygon(this._layer.getLatLngs(),{stroke:!1,fill:!1,pmIgnore:!0}).addTo(this._layer._map),e=t.getCenter();return t.removeFrom(this._layer._map),e},enableRotate:function(){if(this.options.allowRotation){this._rotatePoly=L.polygon(this._layer.getLatLngs(),{fill:!1,stroke:!1,pmIgnore:!1,snapIgnore:!0}).addTo(this._layer._map),this._rotatePoly.pm._setAngle(this.getAngle()),this._rotatePoly.pm.setOptions(this._layer._map.pm.getGlobalOptions()),this._rotatePoly.pm.setOptions({rotate:!0,snappable:!1,hideMiddleMarkers:!0}),this._rotatePoly.pm._rotationLayer=this._layer,this._rotatePoly.pm.enable(),this._rotateOrgLatLng=U(this._layer),this._rotateEnabled=!0,this._layer.on("remove",this.disableRotate,this),this._fireRotationEnable(this._layer),this._fireRotationEnable(this._layer._map)}else this.disableRotate()},disableRotate:function(){this.rotateEnabled()&&(this._rotatePoly.pm._layerRotated&&this._fireUpdate(),this._rotatePoly.pm._layerRotated=!1,this._rotatePoly.pm.disable(),this._rotatePoly.remove(),this._rotatePoly.pm.setOptions({rotate:!1}),this._rotatePoly=undefined,this._rotateOrgLatLng=undefined,this._layer.off("remove",this.disableRotate,this),this._rotateEnabled=!1,this._fireRotationDisable(this._layer),this._fireRotationDisable(this._layer._map))},rotateEnabled:function(){return this._rotateEnabled},rotateLayer:function(t){var e=this.getAngle(),i=this._layer.getLatLngs(),n=t*(Math.PI/180);this._layer.setLatLngs(this._rotateLayer(n,this._layer.getLatLngs(),this._getRotationCenter(),L.PM.Matrix.init(),this._layer._map)),this._rotateOrgLatLng=L.polygon(this._layer.getLatLngs()).getLatLngs(),this._setAngle(this.getAngle()+t),this.rotateEnabled()&&this._rotatePoly&&this._rotatePoly.pm.enabled()&&(this._rotatePoly.setLatLngs(this._rotateLayer(n,this._rotatePoly.getLatLngs(),this._getRotationCenter(),L.PM.Matrix.init(),this._rotatePoly._map)),this._rotatePoly.pm._initMarkers());var r=this.getAngle()-e;r=r<0?r+360:r,this._startAngle=e,this._fireRotation(this._layer,r,i,this._layer),this._fireRotation(this._map,r,i,this._layer),delete this._startAngle,this._fireChange(this._layer.getLatLngs(),"Rotation")},rotateLayerToAngle:function(t){var e=t-this.getAngle();this.rotateLayer(e)},getAngle:function(){return this._angle||0}};const Me=ke;const xe=L.Class.extend({includes:[ye,rt,Me,S],options:{snappable:!0,snapDistance:20,allowSelfIntersection:!0,allowSelfIntersectionEdit:!1,preventMarkerRemoval:!1,removeLayerBelowMinVertexCount:!0,limitMarkersToCount:-1,hideMiddleMarkers:!1,snapSegment:!0,syncLayersOnDrag:!1,draggable:!0,allowEditing:!0,allowRemoval:!0,allowCutting:!0,allowRotation:!0,addVertexOn:"click",removeVertexOn:"contextmenu",removeVertexValidation:undefined,addVertexValidation:undefined,moveVertexValidation:undefined},setOptions:function(t){L.Util.setOptions(this,t)},getOptions:function(){return this.options},applyOptions:function(){},isPolygon:function(){return this._layer instanceof L.Polygon},getShape:function(){return this._shape},_setPane:function(t,e){"layerPane"===e?t.options.pane=this._map.pm.globalOptions.panes&&this._map.pm.globalOptions.panes.layerPane||"overlayPane":"vertexPane"===e?t.options.pane=this._map.pm.globalOptions.panes&&this._map.pm.globalOptions.panes.vertexPane||"markerPane":"markerPane"===e&&(t.options.pane=this._map.pm.globalOptions.panes&&this._map.pm.globalOptions.panes.markerPane||"markerPane")},remove:function(){(this._map||this._layer._map).pm.removeLayer({target:this._layer})},_vertexValidation:function(t,e){var i=e.target,n={layer:this._layer,marker:i,event:e},r="";return"move"===t?r="moveVertexValidation":"add"===t?r="addVertexValidation":"remove"===t&&(r="removeVertexValidation"),this.options[r]&&"function"==typeof this.options[r]&&!this.options[r](n)?("move"===t&&(i._cancelDragEventChain=i.getLatLng()),!1):(i._cancelDragEventChain=null,!0)},_vertexValidationDrag:function(t){return!t._cancelDragEventChain||(t._latlng=t._cancelDragEventChain,t.update(),!1)},_vertexValidationDragEnd:function(t){return!t._cancelDragEventChain||(t._cancelDragEventChain=null,!1)}});function we(t){return function(t){if(Array.isArray(t))return Ce(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return Ce(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(t);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return Ce(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Ce(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}xe.LayerGroup=L.Class.extend({initialize:function(t){var e=this;this._layerGroup=t,this._layers=this.getLayers(),this._getMap(),this._layers.forEach((function(t){return e._initLayer(t)}));this._layerGroup.on("layeradd",L.Util.throttle((function(t){if(!t.layer._pmTempLayer){e._layers=e.getLayers();var i=e._layers.filter((function(t){return!t.pm._parentLayerGroup||!(e._layerGroup._leaflet_id in t.pm._parentLayerGroup)}));i.forEach((function(t){e._initLayer(t)})),i.length>0&&e._getMap()&&e._getMap().pm.globalEditModeEnabled()&&e.enabled()&&e.enable(e.getOptions())}}),100,this),this),this._layerGroup.on("layerremove",(function(t){e._removeLayerFromGroup(t.target)}),this);this._layerGroup.on("layerremove",L.Util.throttle((function(t){t.target._pmTempLayer||(e._layers=e.getLayers())}),100,this),this)},enable:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];0===e.length&&(this._layers=this.getLayers()),this._options=t,this._layers.forEach((function(i){i instanceof L.LayerGroup?-1===e.indexOf(i._leaflet_id)&&(e.push(i._leaflet_id),i.pm.enable(t,e)):i.pm.enable(t)}))},disable:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];0===t.length&&(this._layers=this.getLayers()),this._layers.forEach((function(e){e instanceof L.LayerGroup?-1===t.indexOf(e._leaflet_id)&&(t.push(e._leaflet_id),e.pm.disable(t)):e.pm.disable()}))},enabled:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];0===t.length&&(this._layers=this.getLayers());var e=this._layers.find((function(e){return e instanceof L.LayerGroup?-1===t.indexOf(e._leaflet_id)&&(t.push(e._leaflet_id),e.pm.enabled(t)):e.pm.enabled()}));return!!e},toggleEdit:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];0===e.length&&(this._layers=this.getLayers()),this._options=t,this._layers.forEach((function(i){i instanceof L.LayerGroup?-1===e.indexOf(i._leaflet_id)&&(e.push(i._leaflet_id),i.pm.toggleEdit(t,e)):i.pm.toggleEdit(t)}))},_initLayer:function(t){var e=L.Util.stamp(this._layerGroup);t.pm._parentLayerGroup||(t.pm._parentLayerGroup={}),t.pm._parentLayerGroup[e]=this._layerGroup},_removeLayerFromGroup:function(t){if(t.pm&&t.pm._layerGroup){var e=L.Util.stamp(this._layerGroup);delete t.pm._layerGroup[e]}},dragging:function(){if(this._layers=this.getLayers(),this._layers){var t=this._layers.find((function(t){return t.pm.dragging()}));return!!t}return!1},getOptions:function(){return this.options},_getMap:function(){var t;return this._map||(null===(t=this._layers.find((function(t){return!!t._map})))||void 0===t?void 0:t._map)||null},getLayers:function(){var t=arguments.length>0&&arguments[0]!==undefined&&arguments[0],e=!(arguments.length>1&&arguments[1]!==undefined)||arguments[1],i=!(arguments.length>2&&arguments[2]!==undefined)||arguments[2],n=arguments.length>3&&arguments[3]!==undefined?arguments[3]:[],r=[];return t?this._layerGroup.getLayers().forEach((function(t){r.push(t),t instanceof L.LayerGroup&&-1===n.indexOf(t._leaflet_id)&&(n.push(t._leaflet_id),r=r.concat(t.pm.getLayers(!0,!0,!0,n)))})):r=this._layerGroup.getLayers(),i&&(r=r.filter((function(t){return!(t instanceof L.LayerGroup)}))),e&&(r=(r=(r=r.filter((function(t){return!!t.pm}))).filter((function(t){return!t._pmTempLayer}))).filter((function(t){return!L.PM.optIn&&!t.options.pmIgnore||L.PM.optIn&&!1===t.options.pmIgnore}))),r},setOptions:function(t){var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];0===e.length&&(this._layers=this.getLayers()),this.options=t,this._layers.forEach((function(i){i.pm&&(i instanceof L.LayerGroup?-1===e.indexOf(i._leaflet_id)&&(e.push(i._leaflet_id),i.pm.setOptions(t,e)):i.pm.setOptions(t))}))}}),xe.Marker=xe.extend({_shape:"Marker",initialize:function(t){this._layer=t,this._enabled=!1,this._layer.on("dragend",this._onDragEnd,this)},enable:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{draggable:!0};L.Util.setOptions(this,t),this.options.allowEditing&&this._layer._map?(this._map=this._layer._map,this.enabled()&&this.disable(),this.applyOptions(),this._layer.on("remove",this.disable,this),this._enabled=!0,this._fireEnable()):this.disable()},disable:function(){this.enabled()&&(this.disableLayerDrag(),this._layer.off("remove",this.disable,this),this._layer.off("contextmenu",this._removeMarker,this),this._layerEdited&&this._fireUpdate(),this._layerEdited=!1,this._fireDisable(),this._enabled=!1)},enabled:function(){return this._enabled},toggleEdit:function(t){this.enabled()?this.disable():this.enable(t)},applyOptions:function(){this.options.snappable?this._initSnappableMarkers():this._disableSnapping(),this.options.draggable?this.enableLayerDrag():this.disableLayerDrag(),this.options.preventMarkerRemoval||this._layer.on("contextmenu",this._removeMarker,this)},_removeMarker:function(t){var e=t.target;e.remove(),this._fireRemove(e),this._fireRemove(this._map,e)},_onDragEnd:function(){this._fireEdit(),this._layerEdited=!0},_initSnappableMarkers:function(){var t=this._layer;this.options.snapDistance=this.options.snapDistance||30,this.options.snapSegment=this.options.snapSegment===undefined||this.options.snapSegment,t.off("pm:drag",this._handleSnapping,this),t.on("pm:drag",this._handleSnapping,this),t.off("pm:dragend",this._cleanupSnapping,this),t.on("pm:dragend",this._cleanupSnapping,this),t.off("pm:dragstart",this._unsnap,this),t.on("pm:dragstart",this._unsnap,this)},_disableSnapping:function(){var t=this._layer;t.off("pm:drag",this._handleSnapping,this),t.off("pm:dragend",this._cleanupSnapping,this),t.off("pm:dragstart",this._unsnap,this)}});const Pe={filterMarkerGroup:function(){this.markerCache=[],this.createCache(),this._layer.on("pm:edit",this.createCache,this),this.applyLimitFilters({}),this._layer.on("pm:disable",this._removeMarkerLimitEvents,this),this.options.limitMarkersToCount>-1&&(this._layer.on("pm:vertexremoved",this._initMarkers,this),this._map.on("mousemove",this.applyLimitFilters,this))},_removeMarkerLimitEvents:function(){this._map.off("mousemove",this.applyLimitFilters,this),this._layer.off("pm:edit",this.createCache,this),this._layer.off("pm:disable",this._removeMarkerLimitEvents,this),this._layer.off("pm:vertexremoved",this._initMarkers,this)},createCache:function(){var t=[].concat(we(this._markerGroup.getLayers()),we(this.markerCache));this.markerCache=t.filter((function(t,e,i){return i.indexOf(t)===e}))},renderLimits:function(t){var e=this;this.markerCache.forEach((function(i){t.includes(i)?e._markerGroup.addLayer(i):e._markerGroup.removeLayer(i)}))},applyLimitFilters:function(t){var e=t.latlng,i=void 0===e?{lat:0,lng:0}:e;if(!this._preventRenderMarkers){var n=we(this._filterClosestMarkers(i));this.renderLimits(n)}},_filterClosestMarkers:function(t){var e=we(this.markerCache),i=this.options.limitMarkersToCount;return e.sort((function(e,i){return e._latlng.distanceTo(t)-i._latlng.distanceTo(t)})),e.filter((function(t,e){return!(i>-1)||e<i}))},_preventRenderMarkers:!1,_preventRenderingMarkers:function(t){this._preventRenderMarkers=!!t}};function Ee(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var i=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null==i)return;var n,r,a=[],o=!0,s=!1;try{for(i=i.call(t);!(o=(n=i.next()).done)&&(a.push(n.value),!e||a.length!==e);o=!0);}catch(l){s=!0,r=l}finally{try{o||null==i["return"]||i["return"]()}finally{if(s)throw r}}return a}(t,e)||function(t,e){if(!t)return;if("string"==typeof t)return Se(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(t);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return Se(t,e)}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Se(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function Oe(t){return function(t){if(Array.isArray(t))return De(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return De(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(t);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return De(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function De(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}xe.Line=xe.extend({includes:[Pe],_shape:"Line",initialize:function(t){this._layer=t,this._enabled=!1},enable:function(t){L.Util.setOptions(this,t),this._map=this._layer._map,this._map&&(this.options.allowEditing?(this.enabled()&&this.disable(),this._enabled=!0,this._initMarkers(),this.applyOptions(),this._layer.on("remove",this.disable,this),this.options.allowSelfIntersection||this._layer.on("pm:vertexremoved",this._handleSelfIntersectionOnVertexRemoval,this),this.options.allowSelfIntersection?this.cachedColor=undefined:("#f00000ff"!==this._layer.options.color?(this.cachedColor=this._layer.options.color,this.isRed=!1):this.isRed=!0,this._handleLayerStyle()),this._fireEnable()):this.disable())},disable:function(){if(this.enabled()&&!this._dragging){this._enabled=!1,this._markerGroup.clearLayers(),this._markerGroup.removeFrom(this._map),this._layer.off("remove",this.disable,this),this.options.allowSelfIntersection||this._layer.off("pm:vertexremoved",this._handleSelfIntersectionOnVertexRemoval,this);var t=this._layer._path?this._layer._path:this._layer._renderer._container;L.DomUtil.removeClass(t,"leaflet-pm-draggable"),this.hasSelfIntersection()&&L.DomUtil.removeClass(t,"leaflet-pm-invalid"),this._layerEdited&&this._fireUpdate(),this._layerEdited=!1,this._fireDisable()}},enabled:function(){return this._enabled},toggleEdit:function(t){return this.enabled()?this.disable():this.enable(t),this.enabled()},applyOptions:function(){this.options.snappable?this._initSnappableMarkers():this._disableSnapping()},_initMarkers:function(){var t=this,e=this._map,i=this._layer.getLatLngs();this._markerGroup&&this._markerGroup.clearLayers(),this._markerGroup=new L.LayerGroup,this._markerGroup._pmTempLayer=!0;this._markers=function n(e){if(Array.isArray(e[0]))return e.map(n,t);var i=e.map(t._createMarker,t);return!0!==t.options.hideMiddleMarkers&&e.map((function(n,r){var a=t.isPolygon()?(r+1)%e.length:r+1;return t._createMiddleMarker(i[r],i[a])})),i}(i),this.filterMarkerGroup(),e.addLayer(this._markerGroup)},_createMarker:function(t){var e=new L.Marker(t,{draggable:!0,icon:L.divIcon({className:"marker-icon"})});return this._setPane(e,"vertexPane"),e._pmTempLayer=!0,this.options.rotate?(e.on("dragstart",this._onRotateStart,this),e.on("drag",this._onRotate,this),e.on("dragend",this._onRotateEnd,this)):(e.on("click",this._onVertexClick,this),e.on("dragstart",this._onMarkerDragStart,this),e.on("move",this._onMarkerDrag,this),e.on("dragend",this._onMarkerDragEnd,this),this.options.preventMarkerRemoval||e.on(this.options.removeVertexOn,this._removeMarker,this)),this._markerGroup.addLayer(e),e},_createMiddleMarker:function(t,e){if(!t||!e)return!1;var i=L.PM.Utils.calcMiddleLatLng(this._map,t.getLatLng(),e.getLatLng()),n=this._createMarker(i),r=L.divIcon({className:"marker-icon marker-icon-middle"});return n.setIcon(r),n.leftM=t,n.rightM=e,t._middleMarkerNext=n,e._middleMarkerPrev=n,n.on(this.options.addVertexOn,this._onMiddleMarkerClick,this),n.on("movestart",this._onMiddleMarkerMoveStart,this),n},_onMiddleMarkerClick:function(t){var e=t.target;if(this._vertexValidation("add",t)){var i=L.divIcon({className:"marker-icon"});e.setIcon(i),this._addMarker(e,e.leftM,e.rightM)}},_onMiddleMarkerMoveStart:function(t){var e=t.target;e.on("moveend",this._onMiddleMarkerMoveEnd,this),this._vertexValidation("add",t)?(e._dragging=!0,this._addMarker(e,e.leftM,e.rightM)):e.on("move",this._onMiddleMarkerMovePrevent,this)},_onMiddleMarkerMovePrevent:function(t){var e=t.target;this._vertexValidationDrag(e)},_onMiddleMarkerMoveEnd:function(t){var e=t.target;if(e.off("move",this._onMiddleMarkerMovePrevent,this),e.off("moveend",this._onMiddleMarkerMoveEnd,this),this._vertexValidationDragEnd(e)){var i=L.divIcon({className:"marker-icon"});e.setIcon(i),setTimeout((function(){delete e._dragging}),100)}},_addMarker:function(t,e,i){t.off("movestart",this._onMiddleMarkerMoveStart,this),t.off(this.options.addVertexOn,this._onMiddleMarkerClick,this);var n=t.getLatLng(),r=this._layer._latlngs;delete t.leftM,delete t.rightM;var a=L.PM.Utils.findDeepMarkerIndex(this._markers,e),o=a.indexPath,s=a.index,l=a.parentPath,h=o.length>1?R()(r,l):r,u=o.length>1?R()(this._markers,l):this._markers;h.splice(s+1,0,n),u.splice(s+1,0,t),this._layer.setLatLngs(r),!0!==this.options.hideMiddleMarkers&&(this._createMiddleMarker(e,t),this._createMiddleMarker(t,i)),this._fireEdit(),this._layerEdited=!0,this._fireChange(this._layer.getLatLngs(),"Edit"),this._fireVertexAdded(t,L.PM.Utils.findDeepMarkerIndex(this._markers,t).indexPath,n),this.options.snappable&&this._initSnappableMarkers()},hasSelfIntersection:function(){return mt(this._layer.toGeoJSON(15)).features.length>0},_handleSelfIntersectionOnVertexRemoval:function(){this._handleLayerStyle(!0),this.hasSelfIntersection()&&(this._layer.setLatLngs(this._coordsBeforeEdit),this._coordsBeforeEdit=null,this._initMarkers())},_handleLayerStyle:function(t){var e=this._layer;if(this.hasSelfIntersection()){if(!this.options.allowSelfIntersection&&this.options.allowSelfIntersectionEdit&&this._updateDisabledMarkerStyle(this._markers,!0),this.isRed)return;t?this._flashLayer():(e.setStyle({color:"#f00000ff"}),this.isRed=!0),this._fireIntersect(mt(this._layer.toGeoJSON(15)))}else e.setStyle({color:this.cachedColor}),this.isRed=!1,!this.options.allowSelfIntersection&&this.options.allowSelfIntersectionEdit&&this._updateDisabledMarkerStyle(this._markers,!1)},_flashLayer:function(){var t=this;this.cachedColor||(this.cachedColor=this._layer.options.color),this._layer.setStyle({color:"#f00000ff"}),this.isRed=!0,window.setTimeout((function(){t._layer.setStyle({color:t.cachedColor}),t.isRed=!1}),200)},_updateDisabledMarkerStyle:function(t,e){var i=this;t.forEach((function(t){Array.isArray(t)?i._updateDisabledMarkerStyle(t,e):t._icon&&(e&&!i._checkMarkerAllowedToDrag(t)?L.DomUtil.addClass(t._icon,"vertexmarker-disabled"):L.DomUtil.removeClass(t._icon,"vertexmarker-disabled"))}))},_removeMarker:function(t){var e=t.target;if(this._vertexValidation("remove",t)){if(!this.options.allowSelfIntersection){var i=this._layer.getLatLngs();this._coordsBeforeEdit=JSON.parse(JSON.stringify(i))}var n=this._layer.getLatLngs(),r=L.PM.Utils.findDeepMarkerIndex(this._markers,e),a=r.indexPath,o=r.index,s=r.parentPath;if(a){var l=a.length>1?R()(n,s):n,h=a.length>1?R()(this._markers,s):this._markers;if(this.options.removeLayerBelowMinVertexCount||!(l.length<=2||this.isPolygon()&&l.length<=3)){l.splice(o,1),this._layer.setLatLngs(n),this.isPolygon()&&l.length<=2&&l.splice(0,l.length);var u=!1;if(l.length<=1&&(l.splice(0,l.length),this._layer.setLatLngs(n),this.disable(),this.enable(this.options),u=!0),j(n)&&this._layer.remove(),n=A(n),this._layer.setLatLngs(n),this._markers=A(this._markers),!u&&(h=a.length>1?R()(this._markers,s):this._markers,e._middleMarkerPrev&&this._markerGroup.removeLayer(e._middleMarkerPrev),e._middleMarkerNext&&this._markerGroup.removeLayer(e._middleMarkerNext),this._markerGroup.removeLayer(e),h)){var c,p;if(this.isPolygon()?(c=(o+1)%h.length,p=(o+(h.length-1))%h.length):(p=o-1<0?undefined:o-1,c=o+1>=h.length?undefined:o+1),c!==p){var d=h[p],f=h[c];!0!==this.options.hideMiddleMarkers&&this._createMiddleMarker(d,f)}h.splice(o,1)}this._fireEdit(),this._layerEdited=!0,this._fireVertexRemoved(e,a),this._fireChange(this._layer.getLatLngs(),"Edit")}else this._flashLayer()}}},updatePolygonCoordsFromMarkerDrag:function(t){var e=this._layer.getLatLngs(),i=t.getLatLng(),n=L.PM.Utils.findDeepMarkerIndex(this._markers,t),r=n.indexPath,a=n.index,o=n.parentPath;(r.length>1?R()(e,o):e).splice(a,1,i),this._layer.setLatLngs(e)},_getNeighborMarkers:function(t){var e=L.PM.Utils.findDeepMarkerIndex(this._markers,t),i=e.indexPath,n=e.index,r=e.parentPath,a=i.length>1?R()(this._markers,r):this._markers,o=(n+1)%a.length;return{prevMarker:a[(n+(a.length-1))%a.length],nextMarker:a[o]}},_checkMarkerAllowedToDrag:function(t){var e=this._getNeighborMarkers(t),i=e.prevMarker,n=e.nextMarker,r=L.polyline([i.getLatLng(),t.getLatLng()]),a=L.polyline([t.getLatLng(),n.getLatLng()]),o=jt(this._layer.toGeoJSON(15),r.toGeoJSON(15)).features.length,s=jt(this._layer.toGeoJSON(15),a.toGeoJSON(15)).features.length;return t.getLatLng()===this._markers[0][0].getLatLng()?s+=1:t.getLatLng()===this._markers[0][this._markers[0].length-1].getLatLng()&&(o+=1),!(o<=2&&s<=2)},_onMarkerDragStart:function(t){var e=t.target;if(this.cachedColor||(this.cachedColor=this._layer.options.color),this._vertexValidation("move",t)){var i=L.PM.Utils.findDeepMarkerIndex(this._markers,e).indexPath;this._fireMarkerDragStart(t,i),this.options.allowSelfIntersection||(this._coordsBeforeEdit=this._layer.getLatLngs()),!this.options.allowSelfIntersection&&this.options.allowSelfIntersectionEdit&&this.hasSelfIntersection()?this._markerAllowedToDrag=this._checkMarkerAllowedToDrag(e):this._markerAllowedToDrag=null}},_onMarkerDrag:function(t){var e=t.target;if(this._vertexValidationDrag(e)){var i=L.PM.Utils.findDeepMarkerIndex(this._markers,e),n=i.indexPath,r=i.index,a=i.parentPath;if(n){if(!this.options.allowSelfIntersection&&this.options.allowSelfIntersectionEdit&&this.hasSelfIntersection()&&!1===this._markerAllowedToDrag)return this._layer.setLatLngs(this._coordsBeforeEdit),this._initMarkers(),void this._handleLayerStyle();this.updatePolygonCoordsFromMarkerDrag(e);var o=n.length>1?R()(this._markers,a):this._markers,s=(r+1)%o.length,l=(r+(o.length-1))%o.length,h=e.getLatLng(),u=o[l].getLatLng(),c=o[s].getLatLng();if(e._middleMarkerNext){var p=L.PM.Utils.calcMiddleLatLng(this._map,h,c);e._middleMarkerNext.setLatLng(p)}if(e._middleMarkerPrev){var d=L.PM.Utils.calcMiddleLatLng(this._map,h,u);e._middleMarkerPrev.setLatLng(d)}this.options.allowSelfIntersection||this._handleLayerStyle(),this._fireMarkerDrag(t,n),this._fireChange(this._layer.getLatLngs(),"Edit")}}},_onMarkerDragEnd:function(t){var e=t.target;if(this._vertexValidationDragEnd(e)){var i=L.PM.Utils.findDeepMarkerIndex(this._markers,e).indexPath,n=this.hasSelfIntersection();n&&this.options.allowSelfIntersectionEdit&&this._markerAllowedToDrag&&(n=!1);var r=!this.options.allowSelfIntersection&&n;if(this._fireMarkerDragEnd(t,i,r),r)return this._layer.setLatLngs(this._coordsBeforeEdit),this._coordsBeforeEdit=null,this._initMarkers(),this.options.snappable&&this._initSnappableMarkers(),this._handleLayerStyle(),void this._fireLayerReset(t,i);!this.options.allowSelfIntersection&&this.options.allowSelfIntersectionEdit&&this._handleLayerStyle(),this._fireEdit(),this._layerEdited=!0,this._fireChange(this._layer.getLatLngs(),"Edit")}},_onVertexClick:function(t){var e=t.target;if(!e._dragging){var i=L.PM.Utils.findDeepMarkerIndex(this._markers,e).indexPath;this._fireVertexClick(t,i)}}}),xe.Polygon=xe.Line.extend({_shape:"Polygon",_checkMarkerAllowedToDrag:function(t){var e=this._getNeighborMarkers(t),i=e.prevMarker,n=e.nextMarker,r=L.polyline([i.getLatLng(),t.getLatLng()]),a=L.polyline([t.getLatLng(),n.getLatLng()]),o=jt(this._layer.toGeoJSON(15),r.toGeoJSON(15)).features.length,s=jt(this._layer.toGeoJSON(15),a.toGeoJSON(15)).features.length;return!(o<=2&&s<=2)}}),xe.Rectangle=xe.Polygon.extend({_shape:"Rectangle",_initMarkers:function(){var t=this,e=this._map,i=this._findCorners();this._markerGroup&&this._markerGroup.clearLayers(),this._markerGroup=new L.LayerGroup,this._markerGroup._pmTempLayer=!0,e.addLayer(this._markerGroup),this._markers=[],this._markers[0]=i.map(this._createMarker,this);var n=Ee(this._markers,1);this._cornerMarkers=n[0],this._layer.getLatLngs()[0].forEach((function(e,i){var n=t._cornerMarkers.find((function(t){return t._index===i}));n&&n.setLatLng(e)}))},applyOptions:function(){this.options.snappable?this._initSnappableMarkers():this._disableSnapping(),this._addMarkerEvents()},_createMarker:function(t,e){var i=new L.Marker(t,{draggable:!0,icon:L.divIcon({className:"marker-icon"})});return this._setPane(i,"vertexPane"),i._origLatLng=t,i._index=e,i._pmTempLayer=!0,this._markerGroup.addLayer(i),i},_addMarkerEvents:function(){var t=this;this._markers[0].forEach((function(e){e.on("dragstart",t._onMarkerDragStart,t),e.on("drag",t._onMarkerDrag,t),e.on("dragend",t._onMarkerDragEnd,t),t.options.preventMarkerRemoval||e.on("contextmenu",t._removeMarker,t)}))},_removeMarker:function(){return null},_onMarkerDragStart:function(t){if(this._vertexValidation("move",t)){var e=t.target,i=this._cornerMarkers;e._oppositeCornerLatLng=i.find((function(t){return t._index===(e._index+2)%4})).getLatLng(),e._snapped=!1,this._fireMarkerDragStart(t)}},_onMarkerDrag:function(t){var e=t.target;this._vertexValidationDrag(e)&&e._index!==undefined&&(this._adjustRectangleForMarkerMove(e),this._fireMarkerDrag(t),this._fireChange(this._layer.getLatLngs(),"Edit"))},_onMarkerDragEnd:function(t){var e=t.target;this._vertexValidationDragEnd(e)&&(this._cornerMarkers.forEach((function(t){delete t._oppositeCornerLatLng})),this._fireMarkerDragEnd(t),this._fireEdit(),this._layerEdited=!0,this._fireChange(this._layer.getLatLngs(),"Edit"))},_adjustRectangleForMarkerMove:function(t){L.extend(t._origLatLng,t._latlng);var e=L.PM.Utils._getRotatedRectangle(t.getLatLng(),t._oppositeCornerLatLng,this._angle||0,this._map);this._layer.setLatLngs(e),this._adjustAllMarkers(),this._layer.redraw()},_adjustAllMarkers:function(){var t=this,e=this._layer.getLatLngs()[0];e&&4!==e.length&&e.length>0?(e.forEach((function(e,i){t._cornerMarkers[i].setLatLng(e)})),this._cornerMarkers.slice(e.length).forEach((function(t){t.setLatLng(e[0])}))):e&&e.length?this._cornerMarkers.forEach((function(t){t.setLatLng(e[t._index])})):console.error("The layer has no LatLngs")},_findCorners:function(){var t=this._layer.getLatLngs()[0];return L.PM.Utils._getRotatedRectangle(t[0],t[2],this._angle||0,this._map)}}),xe.Circle=xe.extend({_shape:"Circle",initialize:function(t){this._layer=t,this._enabled=!1,this._updateHiddenPolyCircle()},enable:function(t){L.Util.setOptions(this,t),this._map=this._layer._map,this.options.allowEditing?(this.enabled()||this.disable(),this._enabled=!0,this._initMarkers(),this.applyOptions(),this._layer.on("remove",this.disable,this),this._updateHiddenPolyCircle(),this._fireEnable()):this.disable()},disable:function(){if(this.enabled()&&!this._dragging){this._centerMarker.off("dragstart",this._onCircleDragStart,this),this._centerMarker.off("drag",this._onCircleDrag,this),this._centerMarker.off("dragend",this._onCircleDragEnd,this),this._outerMarker.off("drag",this._handleOuterMarkerSnapping,this),this._layer.off("remove",this.disable,this),this._enabled=!1,this._helperLayers.clearLayers();var t=this._layer._path?this._layer._path:this._layer._renderer._container;L.DomUtil.removeClass(t,"leaflet-pm-draggable"),this._layerEdited&&this._fireUpdate(),this._layerEdited=!1,this._fireDisable()}},enabled:function(){return this._enabled},toggleEdit:function(t){this.enabled()?this.disable():this.enable(t)},_initMarkers:function(){var t=this._map;this._helperLayers&&this._helperLayers.clearLayers(),this._helperLayers=new L.LayerGroup,this._helperLayers._pmTempLayer=!0,this._helperLayers.addTo(t);var e=this._layer.getLatLng(),i=this._layer._radius,n=this._getLatLngOnCircle(e,i);this._centerMarker=this._createCenterMarker(e),this._outerMarker=this._createOuterMarker(n),this._markers=[this._centerMarker,this._outerMarker],this._createHintLine(this._centerMarker,this._outerMarker)},applyOptions:function(){this.options.snappable?(this._initSnappableMarkers(),this._outerMarker.on("drag",this._handleOuterMarkerSnapping,this),this._outerMarker.on("move",this._syncHintLine,this),this._outerMarker.on("move",this._syncCircleRadius,this),this._centerMarker.on("move",this._moveCircle,this)):this._disableSnapping()},_createHintLine:function(t,e){var i=t.getLatLng(),n=e.getLatLng();this._hintline=L.polyline([i,n],this.options.hintlineStyle),this._setPane(this._hintline,"layerPane"),this._hintline._pmTempLayer=!0,this._helperLayers.addLayer(this._hintline)},_createCenterMarker:function(t){var e=this._createMarker(t);return L.DomUtil.addClass(e._icon,"leaflet-pm-draggable"),e.on("drag",this._moveCircle,this),e.on("dragstart",this._onCircleDragStart,this),e.on("drag",this._onCircleDrag,this),e.on("dragend",this._onCircleDragEnd,this),e},_createOuterMarker:function(t){var e=this._createMarker(t);return e.on("drag",this._resizeCircle,this),e},_createMarker:function(t){var e=new L.Marker(t,{draggable:!0,icon:L.divIcon({className:"marker-icon"})});return this._setPane(e,"vertexPane"),e._origLatLng=t,e._pmTempLayer=!0,e.on("dragstart",this._onMarkerDragStart,this),e.on("drag",this._onMarkerDrag,this),e.on("dragend",this._onMarkerDragEnd,this),this._helperLayers.addLayer(e),e},_resizeCircle:function(){this._outerMarker.setLatLng(this._getNewDestinationOfOuterMarker()),this._syncHintLine(),this._syncCircleRadius()},_moveCircle:function(t){if(!t.target._cancelDragEventChain){var e=t.latlng;this._layer.setLatLng(e);var i=this._layer._radius,n=this._getLatLngOnCircle(e,i);this._outerMarker._latlng=n,this._outerMarker.update(),this._syncHintLine(),this._updateHiddenPolyCircle(),this._fireCenterPlaced("Edit"),this._fireChange(this._layer.getLatLng(),"Edit")}},_syncCircleRadius:function(){var t=this._centerMarker.getLatLng(),e=this._outerMarker.getLatLng(),i=this._map.distance(t,e);this.options.minRadiusCircle&&i<this.options.minRadiusCircle?this._layer.setRadius(this.options.minRadiusCircle):this.options.maxRadiusCircle&&i>this.options.maxRadiusCircle?this._layer.setRadius(this.options.maxRadiusCircle):this._layer.setRadius(i),this._updateHiddenPolyCircle(),this._fireChange(this._layer.getLatLng(),"Edit")},_syncHintLine:function(){var t=this._centerMarker.getLatLng(),e=this._outerMarker.getLatLng();this._hintline.setLatLngs([t,e])},_disableSnapping:function(){var t=this;this._markers.forEach((function(e){e.off("move",t._syncHintLine,t),e.off("move",t._syncCircleRadius,t),e.off("drag",t._handleSnapping,t),e.off("dragend",t._cleanupSnapping,t)})),this._layer.off("pm:dragstart",this._unsnap,this)},_onMarkerDragStart:function(t){this._vertexValidation("move",t)&&this._fireMarkerDragStart(t)},_onMarkerDrag:function(t){var e=t.target;this._vertexValidationDrag(e)&&this._fireMarkerDrag(t)},_onMarkerDragEnd:function(t){var e=t.target;this._vertexValidationDragEnd(e)&&(this._fireEdit(),this._layerEdited=!0,this._fireMarkerDragEnd(t))},_onCircleDragStart:function(t){this._vertexValidationDrag(t.target)?(delete this._vertexValidationReset,this._fireDragStart()):this._vertexValidationReset=!0},_onCircleDrag:function(t){this._vertexValidationReset||this._fireDrag(t)},_onCircleDragEnd:function(){this._vertexValidationReset?delete this._vertexValidationReset:this._fireDragEnd()},_updateHiddenPolyCircle:function(){var t=this._map&&this._map.pm._isCRSSimple();this._hiddenPolyCircle?this._hiddenPolyCircle.setLatLngs(L.PM.Utils.circleToPolygon(this._layer,200,!t).getLatLngs()):this._hiddenPolyCircle=L.PM.Utils.circleToPolygon(this._layer,200,!t),this._hiddenPolyCircle._parentCopy||(this._hiddenPolyCircle._parentCopy=this._layer)},_getLatLngOnCircle:function(t,e){var i=this._map.project(t),n=L.point(i.x+e,i.y);return this._map.unproject(n)},_getNewDestinationOfOuterMarker:function(){var t=this._centerMarker.getLatLng(),e=this._outerMarker.getLatLng(),i=this._map.distance(t,e);return this.options.minRadiusCircle&&i<this.options.minRadiusCircle?e=z(this._map,t,e,this.options.minRadiusCircle):this.options.maxRadiusCircle&&i>this.options.maxRadiusCircle&&(e=z(this._map,t,e,this.options.maxRadiusCircle)),e},_handleOuterMarkerSnapping:function(){if(this._outerMarker._snapped){var t=this._centerMarker.getLatLng(),e=this._outerMarker.getLatLng(),i=this._map.distance(t,e);(this.options.minRadiusCircle&&i<this.options.minRadiusCircle||this.options.maxRadiusCircle&&i>this.options.maxRadiusCircle)&&this._outerMarker.setLatLng(this._outerMarker._orgLatLng)}this._outerMarker.setLatLng(this._getNewDestinationOfOuterMarker())}}),xe.CircleMarker=xe.extend({_shape:"CircleMarker",initialize:function(t){this._layer=t,this._enabled=!1,this._updateHiddenPolyCircle()},enable:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{draggable:!0,snappable:!0};L.Util.setOptions(this,t),this.options.allowEditing&&this._layer._map?(this._map=this._layer._map,this.enabled()&&this.disable(),this.applyOptions(),this._layer.on("remove",this.disable,this),this._enabled=!0,this._layer.on("pm:dragstart",this._onDragStart,this),this._layer.on("pm:drag",this._onMarkerDrag,this),this._layer.on("pm:dragend",this._onMarkerDragEnd,this),this._updateHiddenPolyCircle(),this._fireEnable()):this.disable()},disable:function(){this._dragging||(this._helperLayers&&this._helperLayers.clearLayers(),this._map||(this._map=this._layer._map),this._map||(this.options.editable?(this._map.off("move",this._syncMarkers,this),this._outerMarker&&this._outerMarker.on("drag",this._handleOuterMarkerSnapping,this)):this._map.off("move",this._updateHiddenPolyCircle,this)),this.disableLayerDrag(),this._layer.off("contextmenu",this._removeMarker,this),this._layer.off("remove",this.disable,this),this.enabled()&&(this._layerEdited&&this._fireUpdate(),this._layerEdited=!1,this._fireDisable()),this._enabled=!1)},enabled:function(){return this._enabled},toggleEdit:function(t){this.enabled()?this.disable():this.enable(t)},applyOptions:function(){!this.options.editable&&this.options.draggable?this.enableLayerDrag():this.disableLayerDrag(),this.options.editable?(this._initMarkers(),this._map.on("move",this._syncMarkers,this)):this._map.on("move",this._updateHiddenPolyCircle,this),this.options.snappable?this.options.editable?(this._initSnappableMarkers(),this._centerMarker.on("drag",this._moveCircle,this),this.options.editable&&this._outerMarker.on("drag",this._handleOuterMarkerSnapping,this),this._outerMarker.on("move",this._syncHintLine,this),this._outerMarker.on("move",this._syncCircleRadius,this)):this._initSnappableMarkersDrag():this.options.editable?this._disableSnapping():this._disableSnappingDrag(),this.options.preventMarkerRemoval||this._layer.on("contextmenu",this._removeMarker,this)},_initMarkers:function(){var t=this._map;this._helperLayers&&this._helperLayers.clearLayers(),this._helperLayers=new L.LayerGroup,this._helperLayers._pmTempLayer=!0,this._helperLayers.addTo(t);var e=this._layer.getLatLng(),i=this._layer._radius,n=this._getLatLngOnCircle(e,i);this._centerMarker=this._createCenterMarker(e),this._outerMarker=this._createOuterMarker(n),this._markers=[this._centerMarker,this._outerMarker],this._createHintLine(this._centerMarker,this._outerMarker)},_getLatLngOnCircle:function(t,e){var i=this._map.project(t),n=L.point(i.x+e,i.y);return this._map.unproject(n)},_createHintLine:function(t,e){var i=t.getLatLng(),n=e.getLatLng();this._hintline=L.polyline([i,n],this.options.hintlineStyle),this._setPane(this._hintline,"layerPane"),this._hintline._pmTempLayer=!0,this._helperLayers.addLayer(this._hintline)},_createCenterMarker:function(t){var e=this._createMarker(t);return this.options.draggable?L.DomUtil.addClass(e._icon,"leaflet-pm-draggable"):e.dragging.disable(),e},_createOuterMarker:function(t){var e=this._createMarker(t);return e.on("drag",this._resizeCircle,this),e},_createMarker:function(t){var e=new L.Marker(t,{draggable:!0,icon:L.divIcon({className:"marker-icon"})});return this._setPane(e,"vertexPane"),e._origLatLng=t,e._pmTempLayer=!0,e.on("dragstart",this._onMarkerDragStart,this),e.on("drag",this._onMarkerDrag,this),e.on("dragend",this._onMarkerDragEnd,this),this._helperLayers.addLayer(e),e},_moveCircle:function(){var t=this._centerMarker.getLatLng();this._layer.setLatLng(t);var e=this._layer._radius,i=this._getLatLngOnCircle(t,e);this._outerMarker._latlng=i,this._outerMarker.update(),this._syncHintLine(),this._updateHiddenPolyCircle(),this._fireCenterPlaced("Edit"),this._fireChange(this._layer.getLatLng(),"Edit")},_syncMarkers:function(){var t=this._layer.getLatLng(),e=this._layer._radius,i=this._getLatLngOnCircle(t,e);this._outerMarker.setLatLng(i),this._centerMarker.setLatLng(t),this._syncHintLine(),this._updateHiddenPolyCircle()},_resizeCircle:function(){this._outerMarker.setLatLng(this._getNewDestinationOfOuterMarker()),this._syncHintLine(),this._syncCircleRadius()},_syncCircleRadius:function(){var t=this._centerMarker.getLatLng(),e=this._outerMarker.getLatLng(),i=this._map.project(t).distanceTo(this._map.project(e));this.options.minRadiusCircleMarker&&i<this.options.minRadiusCircleMarker?this._layer.setRadius(this.options.minRadiusCircleMarker):this.options.maxRadiusCircleMarker&&i>this.options.maxRadiusCircleMarker?this._layer.setRadius(this.options.maxRadiusCircleMarker):this._layer.setRadius(i),this._updateHiddenPolyCircle(),this._fireChange(this._layer.getLatLng(),"Edit")},_syncHintLine:function(){var t=this._centerMarker.getLatLng(),e=this._outerMarker.getLatLng();this._hintline.setLatLngs([t,e])},_removeMarker:function(){this.options.editable&&this.disable(),this._layer.remove(),this._fireRemove(this._layer),this._fireRemove(this._map,this._layer)},_onDragStart:function(){this._map.pm.Draw.CircleMarker._layerIsDragging=!0},_onMarkerDragStart:function(t){this._vertexValidation("move",t)&&this._fireMarkerDragStart(t)},_onMarkerDrag:function(t){var e=t.target;e instanceof L.Marker&&!this._vertexValidationDrag(e)||this._fireMarkerDrag(t)},_onMarkerDragEnd:function(t){this._map.pm.Draw.CircleMarker._layerIsDragging=!1;var e=t.target;this._vertexValidationDragEnd(e)&&(this.options.editable&&(this._fireEdit(),this._layerEdited=!0),this._fireMarkerDragEnd(t))},_initSnappableMarkersDrag:function(){var t=this._layer;this.options.snapDistance=this.options.snapDistance||30,this.options.snapSegment=this.options.snapSegment===undefined||this.options.snapSegment,t.off("pm:drag",this._handleSnapping,this),t.on("pm:drag",this._handleSnapping,this),t.off("pm:dragend",this._cleanupSnapping,this),t.on("pm:dragend",this._cleanupSnapping,this),t.off("pm:dragstart",this._unsnap,this),t.on("pm:dragstart",this._unsnap,this)},_disableSnappingDrag:function(){var t=this._layer;t.off("pm:drag",this._handleSnapping,this),t.off("pm:dragend",this._cleanupSnapping,this),t.off("pm:dragstart",this._unsnap,this)},_updateHiddenPolyCircle:function(){var t=this._layer._map||this._map;if(t){var e=L.PM.Utils.pxRadiusToMeterRadius(this._layer.getRadius(),t,this._layer.getLatLng()),i=L.circle(this._layer.getLatLng(),this._layer.options);i.setRadius(e);var n=t&&t.pm._isCRSSimple();this._hiddenPolyCircle?this._hiddenPolyCircle.setLatLngs(L.PM.Utils.circleToPolygon(i,200,!n).getLatLngs()):this._hiddenPolyCircle=L.PM.Utils.circleToPolygon(i,200,!n),this._hiddenPolyCircle._parentCopy||(this._hiddenPolyCircle._parentCopy=this._layer)}},_getNewDestinationOfOuterMarker:function(){var t=this._centerMarker.getLatLng(),e=this._outerMarker.getLatLng(),i=this._map.project(t).distanceTo(this._map.project(e));return this.options.minRadiusCircleMarker&&i<this.options.minRadiusCircleMarker?e=z(this._map,t,e,L.PM.Utils.pxRadiusToMeterRadius(this.options.minRadiusCircleMarker,this._map,t)):this.options.maxRadiusCircleMarker&&i>this.options.maxRadiusCircleMarker&&(e=z(this._map,t,e,L.PM.Utils.pxRadiusToMeterRadius(this.options.maxRadiusCircleMarker,this._map,t))),e},_handleOuterMarkerSnapping:function(){if(this._outerMarker._snapped){var t=this._centerMarker.getLatLng(),e=this._outerMarker.getLatLng(),i=this._map.project(t).distanceTo(this._map.project(e));(this.options.minRadiusCircleMarker&&i<this.options.minRadiusCircleMarker||this.options.maxRadiusCircleMarker&&i>this.options.maxRadiusCircleMarker)&&this._outerMarker.setLatLng(this._outerMarker._orgLatLng)}this._outerMarker.setLatLng(this._getNewDestinationOfOuterMarker())}}),xe.ImageOverlay=xe.extend({_shape:"ImageOverlay",initialize:function(t){this._layer=t,this._enabled=!1},toggleEdit:function(t){this.enabled()?this.disable():this.enable(t)},enabled:function(){return this._enabled},enable:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{draggable:!0,snappable:!0};L.Util.setOptions(this,t),this._map=this._layer._map,this._map&&(this.options.allowEditing?(this.enabled()||this.disable(),this.enableLayerDrag(),this._layer.on("remove",this.disable,this),this._enabled=!0,this._otherSnapLayers=this._findCorners(),this._fireEnable()):this.disable())},disable:function(){this._dragging||(this._map||(this._map=this._layer._map),this.disableLayerDrag(),this._layer.off("remove",this.disable,this),this.enabled()||(this._layerEdited&&this._fireUpdate(),this._layerEdited=!1,this._fireDisable()),this._enabled=!1)},_findCorners:function(){var t=this._layer.getBounds();return[t.getNorthWest(),t.getNorthEast(),t.getSouthEast(),t.getSouthWest()]}}),xe.Text=xe.extend({_shape:"Text",initialize:function(t){this._layer=t,this._enabled=!1},enable:function(t){L.Util.setOptions(this,t),this.textArea&&(this.options.allowEditing&&this._layer._map?(this._map=this._layer._map,this.enabled()&&this.disable(),this.applyOptions(),this._focusChange(),this.textArea.readOnly=!1,this.textArea.classList.remove("pm-disabled"),this._layer.on("remove",this.disable,this),L.DomEvent.on(this.textArea,"input",this._autoResize,this),L.DomEvent.on(this.textArea,"focus",this._focusChange,this),L.DomEvent.on(this.textArea,"blur",this._focusChange,this),this._layer.on("dblclick",L.DomEvent.stop),L.DomEvent.off(this.textArea,"mousedown",this._preventTextSelection),this._enabled=!0,this._fireEnable()):this.disable())},disable:function(){if(this.enabled()){this._layer.off("remove",this.disable,this),L.DomEvent.off(this.textArea,"input",this._autoResize,this),L.DomEvent.off(this.textArea,"focus",this._focusChange,this),L.DomEvent.off(this.textArea,"blur",this._focusChange,this),L.DomEvent.off(document,"click",this._documentClick,this),this._focusChange(),this.textArea.readOnly=!0,this.textArea.classList.add("pm-disabled");var t=document.activeElement;this.textArea.focus(),this.textArea.selectionStart=0,this.textArea.selectionEnd=0,L.DomEvent.on(this.textArea,"mousedown",this._preventTextSelection),t.focus(),this._disableOnBlurActive=!1,this._layerEdited&&this._fireUpdate(),this._layerEdited=!1,this._fireDisable(),this._enabled=!1}},enabled:function(){return this._enabled},toggleEdit:function(t){this.enabled()?this.disable():this.enable(t)},applyOptions:function(){this.options.snappable?this._initSnappableMarkers():this._disableSnapping()},_initSnappableMarkers:function(){var t=this._layer;this.options.snapDistance=this.options.snapDistance||30,this.options.snapSegment=this.options.snapSegment===undefined||this.options.snapSegment,t.off("pm:drag",this._handleSnapping,this),t.on("pm:drag",this._handleSnapping,this),t.off("pm:dragend",this._cleanupSnapping,this),t.on("pm:dragend",this._cleanupSnapping,this),t.off("pm:dragstart",this._unsnap,this),t.on("pm:dragstart",this._unsnap,this)},_disableSnapping:function(){var t=this._layer;t.off("pm:drag",this._handleSnapping,this),t.off("pm:dragend",this._cleanupSnapping,this),t.off("pm:dragstart",this._unsnap,this)},_autoResize:function(){this.textArea.style.height="1px",this.textArea.style.width="1px";var t=this.textArea.scrollHeight>21?this.textArea.scrollHeight:21,e=this.textArea.scrollWidth>16?this.textArea.scrollWidth:16;this.textArea.style.height="".concat(t,"px"),this.textArea.style.width="".concat(e,"px"),this._fireTextChange(this.getText())},_disableOnBlur:function(){var t=this;this._disableOnBlurActive=!0,setTimeout((function(){t.enabled()&&L.DomEvent.on(document,"click",t._documentClick,t)}),100)},_documentClick:function(t){t.target!==this.textArea&&(this.disable(),!this.getText()&&this.options.removeIfEmpty&&this.remove())},_focusChange:function(){var t=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this._hasFocus="focus"===t.type,this._hasFocus?this._applyFocus():this._removeFocus()},_applyFocus:function(){this.textArea.classList.add("pm-hasfocus"),this._map.dragging&&(this._safeToCacheDragState&&(this._originalMapDragState=this._map.dragging._enabled,this._safeToCacheDragState=!1),this._map.dragging.disable())},_removeFocus:function(){this._map.dragging&&(this._originalMapDragState&&this._map.dragging.enable(),this._safeToCacheDragState=!0),this.textArea.classList.remove("pm-hasfocus")},focus:function(){if(!this.enabled())throw new TypeError("Layer is not enabled");this.textArea.focus()},blur:function(){if(!this.enabled())throw new TypeError("Layer is not enabled");this.textArea.blur(),this._disableOnBlurActive&&this.disable()},hasFocus:function(){return this._hasFocus},getElement:function(){return this.textArea},setText:function(t){this.textArea.value=t,this._autoResize()},getText:function(){return this.textArea.value},_initTextMarker:function(){if(this.textArea=L.PM.Draw.Text.prototype._createTextArea.call(this),this.options.className){var t,e=this.options.className.split(" ");(t=this.textArea.classList).add.apply(t,Oe(e))}var i=L.PM.Draw.Text.prototype._createTextIcon.call(this,this.textArea);this._layer.setIcon(i),this._layer.once("add",this._createTextMarker,this)},_createTextMarker:function(){var t=arguments.length>0&&arguments[0]!==undefined&&arguments[0];this._layer.getElement().tabIndex=-1,this.textArea.wrap="off",this.textArea.style.overflow="hidden",this.textArea.style.height=L.DomUtil.getStyle(this.textArea,"font-size"),this.textArea.style.width="1px",this._layer.options.text&&this.setText(this._layer.options.text),this._autoResize(),t&&(this.enable(),this.focus(),this._disableOnBlur())},_preventTextSelection:function(t){t.preventDefault()}});var Re=function(t,e,i,n,r,a){this._matrix=[t,e,i,n,r,a]};Re.init=function(){return new L.PM.Matrix(1,0,0,1,0,0)},Re.prototype={transform:function(t){return this._transform(t.clone())},_transform:function(t){var e=this._matrix,i=t.x,n=t.y;return t.x=e[0]*i+e[1]*n+e[4],t.y=e[2]*i+e[3]*n+e[5],t},untransform:function(t){var e=this._matrix;return new L.Point((t.x/e[0]-e[4])/e[0],(t.y/e[2]-e[5])/e[2])},clone:function(){var t=this._matrix;return new L.PM.Matrix(t[0],t[1],t[2],t[3],t[4],t[5])},translate:function(t){return t===undefined?new L.Point(this._matrix[4],this._matrix[5]):("number"==typeof t?(e=t,i=t):(e=t.x,i=t.y),this._add(1,0,0,1,e,i));var e,i},scale:function(t,e){return t===undefined?new L.Point(this._matrix[0],this._matrix[3]):(e=e||L.point(0,0),"number"==typeof t?(i=t,n=t):(i=t.x,n=t.y),this._add(i,0,0,n,e.x,e.y)._add(1,0,0,1,-e.x,-e.y));var i,n},rotate:function(t,e){var i=Math.cos(t),n=Math.sin(t);return e=e||new L.Point(0,0),this._add(i,n,-n,i,e.x,e.y)._add(1,0,0,1,-e.x,-e.y)},flip:function(){return this._matrix[1]*=-1,this._matrix[2]*=-1,this},_add:function(t,e,i,n,r,a){var o,s=[[],[],[]],l=this._matrix,h=[[l[0],l[2],l[4]],[l[1],l[3],l[5]],[0,0,1]],u=[[t,i,r],[e,n,a],[0,0,1]];t&&t instanceof L.PM.Matrix&&(u=[[(l=t._matrix)[0],l[2],l[4]],[l[1],l[3],l[5]],[0,0,1]]);for(var c=0;c<3;c+=1)for(var p=0;p<3;p+=1){o=0;for(var d=0;d<3;d+=1)o+=h[c][d]*u[d][p];s[c][p]=o}return this._matrix=[s[0][0],s[1][0],s[0][1],s[1][1],s[0][2],s[1][2]],this}};const Be=Re;var Te={calcMiddleLatLng:function(t,e,i){var n=t.project(e),r=t.project(i);return t.unproject(n._add(r)._divideBy(2))},findLayers:function(t){var e=[];return t.eachLayer((function(t){(t instanceof L.Polyline||t instanceof L.Marker||t instanceof L.Circle||t instanceof L.CircleMarker||t instanceof L.ImageOverlay)&&e.push(t)})),e=(e=(e=e.filter((function(t){return!!t.pm}))).filter((function(t){return!t._pmTempLayer}))).filter((function(t){return!L.PM.optIn&&!t.options.pmIgnore||L.PM.optIn&&!1===t.options.pmIgnore}))},circleToPolygon:function(t){for(var e=arguments.length>1&&arguments[1]!==undefined?arguments[1]:60,i=!(arguments.length>2&&arguments[2]!==undefined)||arguments[2],n=t.getLatLng(),r=t.getRadius(),a=N(n,r,e,0,i),o=[],s=0;s<a.length;s+=1){var l=[a[s].lat,a[s].lng];o.push(l)}return L.polygon(o,t.options)},disablePopup:function(t){t.getPopup()&&(t._tempPopupCopy=t.getPopup(),t.unbindPopup())},enablePopup:function(t){t._tempPopupCopy&&(t.bindPopup(t._tempPopupCopy),delete t._tempPopupCopy)},_fireEvent:function(t,e,i){var n=arguments.length>3&&arguments[3]!==undefined&&arguments[3];t.fire(e,i,n);var r=this.getAllParentGroups(t),a=r.groups;a.forEach((function(t){t.fire(e,i,n)}))},getAllParentGroups:function(t){var e=[],i=[];return!t._pmLastGroupFetch||!t._pmLastGroupFetch.time||(new Date).getTime()-t._pmLastGroupFetch.time>1e3?(function n(t){for(var r in t._eventParents)if(-1===e.indexOf(r)){e.push(r);var a=t._eventParents[r];i.push(a),n(a)}}(t),t._pmLastGroupFetch={time:(new Date).getTime(),groups:i,groupIds:e},{groupIds:e,groups:i}):{groups:t._pmLastGroupFetch.groups,groupIds:t._pmLastGroupFetch.groupIds}},createGeodesicPolygon:N,getTranslation:I,findDeepCoordIndex:function(t,e){var i;t.some(function r(t){return function(n,a){var o=t.concat(a);return n.lat&&n.lat===e.lat&&n.lng===e.lng?(i=o,!0):Array.isArray(n)&&n.some(r(o))}}([]));var n={};return i&&(n={indexPath:i,index:i[i.length-1],parentPath:i.slice(0,i.length-1)}),n},findDeepMarkerIndex:function(t,e){var i;t.some(function r(t){return function(n,a){var o=t.concat(a);return n._leaflet_id===e._leaflet_id?(i=o,!0):Array.isArray(n)&&n.some(r(o))}}([]));var n={};return i&&(n={indexPath:i,index:i[i.length-1],parentPath:i.slice(0,i.length-1)}),n},_getIndexFromSegment:function(t,e){if(e&&2===e.length){var i=this.findDeepCoordIndex(t,e[0]),n=this.findDeepCoordIndex(t,e[1]),r=Math.max(i.index,n.index);return 0!==i.index&&0!==n.index||1===r||(r+=1),{indexA:i,indexB:n,newIndex:r,indexPath:i.indexPath,parentPath:i.parentPath}}return null},_getRotatedRectangle:function(t,e,i,n){var r=Le(n,t),a=Le(n,e),o=i*Math.PI/180,s=Math.cos(o),l=Math.sin(o),h=(a.x-r.x)*s+(a.y-r.y)*l,u=(a.y-r.y)*s-(a.x-r.x)*l,c=h*s+r.x,p=h*l+r.y,d=-u*l+r.x,f=u*s+r.y;return[be(n,r),be(n,{x:c,y:p}),be(n,a),be(n,{x:d,y:f})]},pxRadiusToMeterRadius:function(t,e,i){var n=e.project(i),r=L.point(n.x+t,n.y);return e.distance(e.unproject(r),i)}};const Ie=Te;L.PM=L.PM||{version:"2.13.0",Map:K,Toolbar:Q,Draw:at,Edit:xe,Utils:Ie,Matrix:Be,activeLang:"en",optIn:!1,initialize:function(t){this.addInitHooks(t)},setOptIn:function(t){this.optIn=!!t},addInitHooks:function(){L.Map.addInitHook((function(){this.pm=undefined,L.PM.optIn?!1===this.options.pmIgnore&&(this.pm=new L.PM.Map(this)):this.options.pmIgnore||(this.pm=new L.PM.Map(this))})),L.LayerGroup.addInitHook((function(){this.pm=undefined,L.PM.optIn?!1===this.options.pmIgnore&&(this.pm=new L.PM.Edit.LayerGroup(this)):this.options.pmIgnore||(this.pm=new L.PM.Edit.LayerGroup(this))})),L.Marker.addInitHook((function(){this.pm=undefined,L.PM.optIn?!1===this.options.pmIgnore&&(this.options.textMarker?(this.pm=new L.PM.Edit.Text(this),this.options._textMarkerOverPM||this.pm._initTextMarker(),delete this.options._textMarkerOverPM):this.pm=new L.PM.Edit.Marker(this)):this.options.pmIgnore||(this.options.textMarker?(this.pm=new L.PM.Edit.Text(this),this.options._textMarkerOverPM||this.pm._initTextMarker(),delete this.options._textMarkerOverPM):this.pm=new L.PM.Edit.Marker(this))})),L.CircleMarker.addInitHook((function(){this.pm=undefined,L.PM.optIn?!1===this.options.pmIgnore&&(this.pm=new L.PM.Edit.CircleMarker(this)):this.options.pmIgnore||(this.pm=new L.PM.Edit.CircleMarker(this))})),L.Polyline.addInitHook((function(){this.pm=undefined,L.PM.optIn?!1===this.options.pmIgnore&&(this.pm=new L.PM.Edit.Line(this)):this.options.pmIgnore||(this.pm=new L.PM.Edit.Line(this))})),L.Polygon.addInitHook((function(){this.pm=undefined,L.PM.optIn?!1===this.options.pmIgnore&&(this.pm=new L.PM.Edit.Polygon(this)):this.options.pmIgnore||(this.pm=new L.PM.Edit.Polygon(this))})),L.Rectangle.addInitHook((function(){this.pm=undefined,L.PM.optIn?!1===this.options.pmIgnore&&(this.pm=new L.PM.Edit.Rectangle(this)):this.options.pmIgnore||(this.pm=new L.PM.Edit.Rectangle(this))})),L.Circle.addInitHook((function(){this.pm=undefined,L.PM.optIn?!1===this.options.pmIgnore&&(this.pm=new L.PM.Edit.Circle(this)):this.options.pmIgnore||(this.pm=new L.PM.Edit.Circle(this))})),L.ImageOverlay.addInitHook((function(){this.pm=undefined,L.PM.optIn?!1===this.options.pmIgnore&&(this.pm=new L.PM.Edit.ImageOverlay(this)):this.options.pmIgnore||(this.pm=new L.PM.Edit.ImageOverlay(this))}))},reInitLayer:function(t){var e=this;t instanceof L.LayerGroup&&t.eachLayer((function(t){e.reInitLayer(t)})),t.pm||L.PM.optIn&&!1!==t.options.pmIgnore||t.options.pmIgnore||(t instanceof L.Map?t.pm=new L.PM.Map(t):t instanceof L.Marker?t.pm=new L.PM.Edit.Marker(t):t instanceof L.Circle?t.pm=new L.PM.Edit.Circle(t):t instanceof L.CircleMarker?t.pm=new L.PM.Edit.CircleMarker(t):t instanceof L.Rectangle?t.pm=new L.PM.Edit.Rectangle(t):t instanceof L.Polygon?t.pm=new L.PM.Edit.Polygon(t):t instanceof L.Polyline?t.pm=new L.PM.Edit.Line(t):t instanceof L.LayerGroup?t.pm=new L.PM.Edit.LayerGroup(t):t instanceof L.ImageOverlay&&(t.pm=new L.PM.Edit.ImageOverlay(t)))}},L.PM.initialize()},7107:()=>{Array.prototype.findIndex=Array.prototype.findIndex||function(t){if(null===this)throw new TypeError("Array.prototype.findIndex called on null or undefined");if("function"!=typeof t)throw new TypeError("callback must be a function");for(var e=Object(this),i=e.length>>>0,n=arguments[1],r=0;r<i;r++)if(t.call(n,e[r],r,e))return r;return-1},Array.prototype.find=Array.prototype.find||function(t){if(null===this)throw new TypeError("Array.prototype.find called on null or undefined");if("function"!=typeof t)throw new TypeError("callback must be a function");for(var e=Object(this),i=e.length>>>0,n=arguments[1],r=0;r<i;r++){var a=e[r];if(t.call(n,a,r,e))return a}},"function"!=typeof Object.assign&&(Object.assign=function(t){"use strict";if(null==t)throw new TypeError("Cannot convert undefined or null to object");t=Object(t);for(var e=1;e<arguments.length;e++){var i=arguments[e];if(null!=i)for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(t[n]=i[n])}return t}),[Element.prototype,CharacterData.prototype,DocumentType.prototype].forEach((function(t){t.hasOwnProperty("remove")||Object.defineProperty(t,"remove",{configurable:!0,enumerable:!0,writable:!0,value:function(){this.parentNode.removeChild(this)}})})),Array.prototype.includes||Object.defineProperty(Array.prototype,"includes",{value:function(t,e){if(null==this)throw new TypeError(\'"this" is null or not defined\');var i=Object(this),n=i.length>>>0;if(0===n)return!1;var r,a,o=0|e,s=Math.max(o>=0?o:n-Math.abs(o),0);for(;s<n;){if((r=i[s])===(a=t)||"number"==typeof r&&"number"==typeof a&&isNaN(r)&&isNaN(a))return!0;s++}return!1}})},1787:(t,e,i)=>{var n=i(2582),r=i(4102),a=i(1540),o=i(9705).Z,s=a.featureEach,l=(a.coordEach,r.polygon,r.featureCollection);function h(t){var e=new n(t);return e.insert=function(t){if("Feature"!==t.type)throw new Error("invalid feature");return t.bbox=t.bbox?t.bbox:o(t),n.prototype.insert.call(this,t)},e.load=function(t){var e=[];return Array.isArray(t)?t.forEach((function(t){if("Feature"!==t.type)throw new Error("invalid features");t.bbox=t.bbox?t.bbox:o(t),e.push(t)})):s(t,(function(t){if("Feature"!==t.type)throw new Error("invalid features");t.bbox=t.bbox?t.bbox:o(t),e.push(t)})),n.prototype.load.call(this,e)},e.remove=function(t,e){if("Feature"!==t.type)throw new Error("invalid feature");return t.bbox=t.bbox?t.bbox:o(t),n.prototype.remove.call(this,t,e)},e.clear=function(){return n.prototype.clear.call(this)},e.search=function(t){var e=n.prototype.search.call(this,this.toBBox(t));return l(e)},e.collides=function(t){return n.prototype.collides.call(this,this.toBBox(t))},e.all=function(){var t=n.prototype.all.call(this);return l(t)},e.toJSON=function(){return n.prototype.toJSON.call(this)},e.fromJSON=function(t){return n.prototype.fromJSON.call(this,t)},e.toBBox=function(t){var e;if(t.bbox)e=t.bbox;else if(Array.isArray(t)&&4===t.length)e=t;else if(Array.isArray(t)&&6===t.length)e=[t[0],t[1],t[3],t[4]];else if("Feature"===t.type)e=o(t);else{if("FeatureCollection"!==t.type)throw new Error("invalid geojson");e=o(t)}return{minX:e[0],minY:e[1],maxX:e[2],maxY:e[3]}},e}t.exports=h,t.exports["default"]=h},1989:(t,e,i)=>{var n=i(1789),r=i(401),a=i(7667),o=i(1327),s=i(1866);function l(t){var e=-1,i=null==t?0:t.length;for(this.clear();++e<i;){var n=t[e];this.set(n[0],n[1])}}l.prototype.clear=n,l.prototype["delete"]=r,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,t.exports=l},8407:(t,e,i)=>{var n=i(7040),r=i(4125),a=i(2117),o=i(7518),s=i(4705);function l(t){var e=-1,i=null==t?0:t.length;for(this.clear();++e<i;){var n=t[e];this.set(n[0],n[1])}}l.prototype.clear=n,l.prototype["delete"]=r,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,t.exports=l},7071:(t,e,i)=>{var n=i(852)(i(5639),"Map");t.exports=n},3369:(t,e,i)=>{var n=i(4785),r=i(1285),a=i(6e3),o=i(9916),s=i(5265);function l(t){var e=-1,i=null==t?0:t.length;for(this.clear();++e<i;){var n=t[e];this.set(n[0],n[1])}}l.prototype.clear=n,l.prototype["delete"]=r,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,t.exports=l},6384:(t,e,i)=>{var n=i(8407),r=i(7465),a=i(3779),o=i(7599),s=i(4758),l=i(4309);function h(t){var e=this.__data__=new n(t);this.size=e.size}h.prototype.clear=r,h.prototype["delete"]=a,h.prototype.get=o,h.prototype.has=s,h.prototype.set=l,t.exports=h},2705:(t,e,i)=>{var n=i(5639).Symbol;t.exports=n},1149:(t,e,i)=>{var n=i(5639).Uint8Array;t.exports=n},6874:t=>{t.exports=function(t,e,i){switch(i.length){case 0:return t.call(e);case 1:return t.call(e,i[0]);case 2:return t.call(e,i[0],i[1]);case 3:return t.call(e,i[0],i[1],i[2])}return t.apply(e,i)}},4636:(t,e,i)=>{var n=i(2545),r=i(5694),a=i(1469),o=i(4144),s=i(5776),l=i(6719),h=Object.prototype.hasOwnProperty;t.exports=function(t,e){var i=a(t),u=!i&&r(t),c=!i&&!u&&o(t),p=!i&&!u&&!c&&l(t),d=i||u||c||p,f=d?n(t.length,String):[],g=f.length;for(var _ in t)!e&&!h.call(t,_)||d&&("length"==_||c&&("offset"==_||"parent"==_)||p&&("buffer"==_||"byteLength"==_||"byteOffset"==_)||s(_,g))||f.push(_);return f}},9932:t=>{t.exports=function(t,e){for(var i=-1,n=null==t?0:t.length,r=Array(n);++i<n;)r[i]=e(t[i],i,t);return r}},6556:(t,e,i)=>{var n=i(9465),r=i(7813);t.exports=function(t,e,i){(i!==undefined&&!r(t[e],i)||i===undefined&&!(e in t))&&n(t,e,i)}},4865:(t,e,i)=>{var n=i(9465),r=i(7813),a=Object.prototype.hasOwnProperty;t.exports=function(t,e,i){var o=t[e];a.call(t,e)&&r(o,i)&&(i!==undefined||e in t)||n(t,e,i)}},8470:(t,e,i)=>{var n=i(7813);t.exports=function(t,e){for(var i=t.length;i--;)if(n(t[i][0],e))return i;return-1}},9465:(t,e,i)=>{var n=i(8777);t.exports=function(t,e,i){"__proto__"==e&&n?n(t,e,{configurable:!0,enumerable:!0,value:i,writable:!0}):t[e]=i}},3118:(t,e,i)=>{var n=i(3218),r=Object.create,a=function(){function t(){}return function(e){if(!n(e))return{};if(r)return r(e);t.prototype=e;var i=new t;return t.prototype=undefined,i}}();t.exports=a},8483:(t,e,i)=>{var n=i(5063)();t.exports=n},7786:(t,e,i)=>{var n=i(1811),r=i(327);t.exports=function(t,e){for(var i=0,a=(e=n(e,t)).length;null!=t&&i<a;)t=t[r(e[i++])];return i&&i==a?t:undefined}},4239:(t,e,i)=>{var n=i(2705),r=i(9607),a=i(2333),o=n?n.toStringTag:undefined;t.exports=function(t){return null==t?t===undefined?"[object Undefined]":"[object Null]":o&&o in Object(t)?r(t):a(t)}},8565:t=>{var e=Object.prototype.hasOwnProperty;t.exports=function(t,i){return null!=t&&e.call(t,i)}},9454:(t,e,i)=>{var n=i(4239),r=i(7005);t.exports=function(t){return r(t)&&"[object Arguments]"==n(t)}},8458:(t,e,i)=>{var n=i(3560),r=i(5346),a=i(3218),o=i(346),s=/^\\[object .+?Constructor\\]$/,l=Function.prototype,h=Object.prototype,u=l.toString,c=h.hasOwnProperty,p=RegExp("^"+u.call(c).replace(/[\\\\^$.*+?()[\\]{}|]/g,"\\\\$&").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,"$1.*?")+"$");t.exports=function(t){return!(!a(t)||r(t))&&(n(t)?p:s).test(o(t))}},8749:(t,e,i)=>{var n=i(4239),r=i(1780),a=i(7005),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,t.exports=function(t){return a(t)&&r(t.length)&&!!o[n(t)]}},313:(t,e,i)=>{var n=i(3218),r=i(5726),a=i(3498),o=Object.prototype.hasOwnProperty;t.exports=function(t){if(!n(t))return a(t);var e=r(t),i=[];for(var s in t)("constructor"!=s||!e&&o.call(t,s))&&i.push(s);return i}},2980:(t,e,i)=>{var n=i(6384),r=i(6556),a=i(8483),o=i(9783),s=i(3218),l=i(1704),h=i(6390);t.exports=function u(t,e,i,c,p){t!==e&&a(e,(function(a,l){if(p||(p=new n),s(a))o(t,e,l,i,u,c,p);else{var d=c?c(h(t,l),a,l+"",t,e,p):undefined;d===undefined&&(d=a),r(t,l,d)}}),l)}},9783:(t,e,i)=>{var n=i(6556),r=i(4626),a=i(7133),o=i(278),s=i(8517),l=i(5694),h=i(1469),u=i(9246),c=i(4144),p=i(3560),d=i(3218),f=i(8630),g=i(6719),_=i(6390),m=i(9881);t.exports=function(t,e,i,y,v,L,b){var k=_(t,i),M=_(e,i),x=b.get(M);if(x)n(t,i,x);else{var w=L?L(k,M,i+"",t,e,b):undefined,C=w===undefined;if(C){var P=h(M),E=!P&&c(M),S=!P&&!E&&g(M);w=M,P||E||S?h(k)?w=k:u(k)?w=o(k):E?(C=!1,w=r(M,!0)):S?(C=!1,w=a(M,!0)):w=[]:f(M)||l(M)?(w=k,l(k)?w=m(k):d(k)&&!p(k)||(w=s(M))):C=!1}C&&(b.set(M,w),v(w,M,y,L,b),b["delete"](M)),n(t,i,w)}}},5976:(t,e,i)=>{var n=i(6557),r=i(5357),a=i(61);t.exports=function(t,e){return a(r(t,e,n),t+"")}},6560:(t,e,i)=>{var n=i(5703),r=i(8777),a=i(6557),o=r?function(t,e){return r(t,"toString",{configurable:!0,enumerable:!1,value:n(e),writable:!0})}:a;t.exports=o},2545:t=>{t.exports=function(t,e){for(var i=-1,n=Array(t);++i<t;)n[i]=e(i);return n}},531:(t,e,i)=>{var n=i(2705),r=i(9932),a=i(1469),o=i(3448),s=n?n.prototype:undefined,l=s?s.toString:undefined;t.exports=function h(t){if("string"==typeof t)return t;if(a(t))return r(t,h)+"";if(o(t))return l?l.call(t):"";var e=t+"";return"0"==e&&1/t==-Infinity?"-0":e}},1717:t=>{t.exports=function(t){return function(e){return t(e)}}},1811:(t,e,i)=>{var n=i(1469),r=i(5403),a=i(5514),o=i(9833);t.exports=function(t,e){return n(t)?t:r(t,e)?[t]:a(o(t))}},4318:(t,e,i)=>{var n=i(1149);t.exports=function(t){var e=new t.constructor(t.byteLength);return new n(e).set(new n(t)),e}},4626:(t,e,i)=>{t=i.nmd(t);var n=i(5639),r=e&&!e.nodeType&&e,a=r&&t&&!t.nodeType&&t,o=a&&a.exports===r?n.Buffer:undefined,s=o?o.allocUnsafe:undefined;t.exports=function(t,e){if(e)return t.slice();var i=t.length,n=s?s(i):new t.constructor(i);return t.copy(n),n}},7133:(t,e,i)=>{var n=i(4318);t.exports=function(t,e){var i=e?n(t.buffer):t.buffer;return new t.constructor(i,t.byteOffset,t.length)}},278:t=>{t.exports=function(t,e){var i=-1,n=t.length;for(e||(e=Array(n));++i<n;)e[i]=t[i];return e}},8363:(t,e,i)=>{var n=i(4865),r=i(9465);t.exports=function(t,e,i,a){var o=!i;i||(i={});for(var s=-1,l=e.length;++s<l;){var h=e[s],u=a?a(i[h],t[h],h,i,t):undefined;u===undefined&&(u=t[h]),o?r(i,h,u):n(i,h,u)}return i}},4429:(t,e,i)=>{var n=i(5639)["__core-js_shared__"];t.exports=n},1463:(t,e,i)=>{var n=i(5976),r=i(6612);t.exports=function(t){return n((function(e,i){var n=-1,a=i.length,o=a>1?i[a-1]:undefined,s=a>2?i[2]:undefined;for(o=t.length>3&&"function"==typeof o?(a--,o):undefined,s&&r(i[0],i[1],s)&&(o=a<3?undefined:o,a=1),e=Object(e);++n<a;){var l=i[n];l&&t(e,l,n,o)}return e}))}},5063:t=>{t.exports=function(t){return function(e,i,n){for(var r=-1,a=Object(e),o=n(e),s=o.length;s--;){var l=o[t?s:++r];if(!1===i(a[l],l,a))break}return e}}},8777:(t,e,i)=>{var n=i(852),r=function(){try{var t=n(Object,"defineProperty");return t({},"",{}),t}catch(e){}}();t.exports=r},1957:(t,e,i)=>{var n="object"==typeof i.g&&i.g&&i.g.Object===Object&&i.g;t.exports=n},5050:(t,e,i)=>{var n=i(7019);t.exports=function(t,e){var i=t.__data__;return n(e)?i["string"==typeof e?"string":"hash"]:i.map}},852:(t,e,i)=>{var n=i(8458),r=i(7801);t.exports=function(t,e){var i=r(t,e);return n(i)?i:undefined}},5924:(t,e,i)=>{var n=i(5569)(Object.getPrototypeOf,Object);t.exports=n},9607:(t,e,i)=>{var n=i(2705),r=Object.prototype,a=r.hasOwnProperty,o=r.toString,s=n?n.toStringTag:undefined;t.exports=function(t){var e=a.call(t,s),i=t[s];try{t[s]=undefined;var n=!0}catch(l){}var r=o.call(t);return n&&(e?t[s]=i:delete t[s]),r}},7801:t=>{t.exports=function(t,e){return null==t?undefined:t[e]}},222:(t,e,i)=>{var n=i(1811),r=i(5694),a=i(1469),o=i(5776),s=i(1780),l=i(327);t.exports=function(t,e,i){for(var h=-1,u=(e=n(e,t)).length,c=!1;++h<u;){var p=l(e[h]);if(!(c=null!=t&&i(t,p)))break;t=t[p]}return c||++h!=u?c:!!(u=null==t?0:t.length)&&s(u)&&o(p,u)&&(a(t)||r(t))}},1789:(t,e,i)=>{var n=i(4536);t.exports=function(){this.__data__=n?n(null):{},this.size=0}},401:t=>{t.exports=function(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e}},7667:(t,e,i)=>{var n=i(4536),r=Object.prototype.hasOwnProperty;t.exports=function(t){var e=this.__data__;if(n){var i=e[t];return"__lodash_hash_undefined__"===i?undefined:i}return r.call(e,t)?e[t]:undefined}},1327:(t,e,i)=>{var n=i(4536),r=Object.prototype.hasOwnProperty;t.exports=function(t){var e=this.__data__;return n?e[t]!==undefined:r.call(e,t)}},1866:(t,e,i)=>{var n=i(4536);t.exports=function(t,e){var i=this.__data__;return this.size+=this.has(t)?0:1,i[t]=n&&e===undefined?"__lodash_hash_undefined__":e,this}},8517:(t,e,i)=>{var n=i(3118),r=i(5924),a=i(5726);t.exports=function(t){return"function"!=typeof t.constructor||a(t)?{}:n(r(t))}},5776:t=>{var e=/^(?:0|[1-9]\\d*)$/;t.exports=function(t,i){var n=typeof t;return!!(i=null==i?9007199254740991:i)&&("number"==n||"symbol"!=n&&e.test(t))&&t>-1&&t%1==0&&t<i}},6612:(t,e,i)=>{var n=i(7813),r=i(8612),a=i(5776),o=i(3218);t.exports=function(t,e,i){if(!o(i))return!1;var s=typeof e;return!!("number"==s?r(i)&&a(e,i.length):"string"==s&&e in i)&&n(i[e],t)}},5403:(t,e,i)=>{var n=i(1469),r=i(3448),a=/\\.|\\[(?:[^[\\]]*|(["\'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,o=/^\\w*$/;t.exports=function(t,e){if(n(t))return!1;var i=typeof t;return!("number"!=i&&"symbol"!=i&&"boolean"!=i&&null!=t&&!r(t))||(o.test(t)||!a.test(t)||null!=e&&t in Object(e))}},7019:t=>{t.exports=function(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t}},5346:(t,e,i)=>{var n,r=i(4429),a=(n=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+n:"";t.exports=function(t){return!!a&&a in t}},5726:t=>{var e=Object.prototype;t.exports=function(t){var i=t&&t.constructor;return t===("function"==typeof i&&i.prototype||e)}},7040:t=>{t.exports=function(){this.__data__=[],this.size=0}},4125:(t,e,i)=>{var n=i(8470),r=Array.prototype.splice;t.exports=function(t){var e=this.__data__,i=n(e,t);return!(i<0)&&(i==e.length-1?e.pop():r.call(e,i,1),--this.size,!0)}},2117:(t,e,i)=>{var n=i(8470);t.exports=function(t){var e=this.__data__,i=n(e,t);return i<0?undefined:e[i][1]}},7518:(t,e,i)=>{var n=i(8470);t.exports=function(t){return n(this.__data__,t)>-1}},4705:(t,e,i)=>{var n=i(8470);t.exports=function(t,e){var i=this.__data__,r=n(i,t);return r<0?(++this.size,i.push([t,e])):i[r][1]=e,this}},4785:(t,e,i)=>{var n=i(1989),r=i(8407),a=i(7071);t.exports=function(){this.size=0,this.__data__={hash:new n,map:new(a||r),string:new n}}},1285:(t,e,i)=>{var n=i(5050);t.exports=function(t){var e=n(this,t)["delete"](t);return this.size-=e?1:0,e}},6e3:(t,e,i)=>{var n=i(5050);t.exports=function(t){return n(this,t).get(t)}},9916:(t,e,i)=>{var n=i(5050);t.exports=function(t){return n(this,t).has(t)}},5265:(t,e,i)=>{var n=i(5050);t.exports=function(t,e){var i=n(this,t),r=i.size;return i.set(t,e),this.size+=i.size==r?0:1,this}},4523:(t,e,i)=>{var n=i(8306);t.exports=function(t){var e=n(t,(function(t){return 500===i.size&&i.clear(),t})),i=e.cache;return e}},4536:(t,e,i)=>{var n=i(852)(Object,"create");t.exports=n},3498:t=>{t.exports=function(t){var e=[];if(null!=t)for(var i in Object(t))e.push(i);return e}},1167:(t,e,i)=>{t=i.nmd(t);var n=i(1957),r=e&&!e.nodeType&&e,a=r&&t&&!t.nodeType&&t,o=a&&a.exports===r&&n.process,s=function(){try{var t=a&&a.require&&a.require("util").types;return t||o&&o.binding&&o.binding("util")}catch(e){}}();t.exports=s},2333:t=>{var e=Object.prototype.toString;t.exports=function(t){return e.call(t)}},5569:t=>{t.exports=function(t,e){return function(i){return t(e(i))}}},5357:(t,e,i)=>{var n=i(6874),r=Math.max;t.exports=function(t,e,i){return e=r(e===undefined?t.length-1:e,0),function(){for(var a=arguments,o=-1,s=r(a.length-e,0),l=Array(s);++o<s;)l[o]=a[e+o];o=-1;for(var h=Array(e+1);++o<e;)h[o]=a[o];return h[e]=i(l),n(t,this,h)}}},5639:(t,e,i)=>{var n=i(1957),r="object"==typeof self&&self&&self.Object===Object&&self,a=n||r||Function("return this")();t.exports=a},6390:t=>{t.exports=function(t,e){if(("constructor"!==e||"function"!=typeof t[e])&&"__proto__"!=e)return t[e]}},61:(t,e,i)=>{var n=i(6560),r=i(1275)(n);t.exports=r},1275:t=>{var e=Date.now;t.exports=function(t){var i=0,n=0;return function(){var r=e(),a=16-(r-n);if(n=r,a>0){if(++i>=800)return arguments[0]}else i=0;return t.apply(undefined,arguments)}}},7465:(t,e,i)=>{var n=i(8407);t.exports=function(){this.__data__=new n,this.size=0}},3779:t=>{t.exports=function(t){var e=this.__data__,i=e["delete"](t);return this.size=e.size,i}},7599:t=>{t.exports=function(t){return this.__data__.get(t)}},4758:t=>{t.exports=function(t){return this.__data__.has(t)}},4309:(t,e,i)=>{var n=i(8407),r=i(7071),a=i(3369);t.exports=function(t,e){var i=this.__data__;if(i instanceof n){var o=i.__data__;if(!r||o.length<199)return o.push([t,e]),this.size=++i.size,this;i=this.__data__=new a(o)}return i.set(t,e),this.size=i.size,this}},5514:(t,e,i)=>{var n=i(4523),r=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,a=/\\\\(\\\\)?/g,o=n((function(t){var e=[];return 46===t.charCodeAt(0)&&e.push(""),t.replace(r,(function(t,i,n,r){e.push(n?r.replace(a,"$1"):i||t)})),e}));t.exports=o},327:(t,e,i)=>{var n=i(3448);t.exports=function(t){if("string"==typeof t||n(t))return t;var e=t+"";return"0"==e&&1/t==-Infinity?"-0":e}},346:t=>{var e=Function.prototype.toString;t.exports=function(t){if(null!=t){try{return e.call(t)}catch(i){}try{return t+""}catch(i){}}return""}},5703:t=>{t.exports=function(t){return function(){return t}}},7813:t=>{t.exports=function(t,e){return t===e||t!=t&&e!=e}},7361:(t,e,i)=>{var n=i(7786);t.exports=function(t,e,i){var r=null==t?undefined:n(t,e);return r===undefined?i:r}},8721:(t,e,i)=>{var n=i(8565),r=i(222);t.exports=function(t,e){return null!=t&&r(t,e,n)}},6557:t=>{t.exports=function(t){return t}},5694:(t,e,i)=>{var n=i(9454),r=i(7005),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,l=n(function(){return arguments}())?n:function(t){return r(t)&&o.call(t,"callee")&&!s.call(t,"callee")};t.exports=l},1469:t=>{var e=Array.isArray;t.exports=e},8612:(t,e,i)=>{var n=i(3560),r=i(1780);t.exports=function(t){return null!=t&&r(t.length)&&!n(t)}},9246:(t,e,i)=>{var n=i(8612),r=i(7005);t.exports=function(t){return r(t)&&n(t)}},4144:(t,e,i)=>{t=i.nmd(t);var n=i(5639),r=i(5062),a=e&&!e.nodeType&&e,o=a&&t&&!t.nodeType&&t,s=o&&o.exports===a?n.Buffer:undefined,l=(s?s.isBuffer:undefined)||r;t.exports=l},3560:(t,e,i)=>{var n=i(4239),r=i(3218);t.exports=function(t){if(!r(t))return!1;var e=n(t);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},1780:t=>{t.exports=function(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=9007199254740991}},3218:t=>{t.exports=function(t){var e=typeof t;return null!=t&&("object"==e||"function"==e)}},7005:t=>{t.exports=function(t){return null!=t&&"object"==typeof t}},8630:(t,e,i)=>{var n=i(4239),r=i(5924),a=i(7005),o=Function.prototype,s=Object.prototype,l=o.toString,h=s.hasOwnProperty,u=l.call(Object);t.exports=function(t){if(!a(t)||"[object Object]"!=n(t))return!1;var e=r(t);if(null===e)return!0;var i=h.call(e,"constructor")&&e.constructor;return"function"==typeof i&&i instanceof i&&l.call(i)==u}},3448:(t,e,i)=>{var n=i(4239),r=i(7005);t.exports=function(t){return"symbol"==typeof t||r(t)&&"[object Symbol]"==n(t)}},6719:(t,e,i)=>{var n=i(8749),r=i(1717),a=i(1167),o=a&&a.isTypedArray,s=o?r(o):n;t.exports=s},1704:(t,e,i)=>{var n=i(4636),r=i(313),a=i(8612);t.exports=function(t){return a(t)?n(t,!0):r(t)}},8306:(t,e,i)=>{var n=i(3369);function r(t,e){if("function"!=typeof t||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var i=function(){var n=arguments,r=e?e.apply(this,n):n[0],a=i.cache;if(a.has(r))return a.get(r);var o=t.apply(this,n);return i.cache=a.set(r,o)||a,o};return i.cache=new(r.Cache||n),i}r.Cache=n,t.exports=r},2492:(t,e,i)=>{var n=i(2980),r=i(1463)((function(t,e,i){n(t,e,i)}));t.exports=r},5062:t=>{t.exports=function(){return!1}},9881:(t,e,i)=>{var n=i(8363),r=i(1704);t.exports=function(t){return n(t,r(t))}},9833:(t,e,i)=>{var n=i(531);t.exports=function(t){return null==t?"":n(t)}},2676:function(t){t.exports=function(){"use strict";function t(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function e(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function i(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}var n=function(){function t(t,e){this.next=null,this.key=t,this.data=e,this.left=null,this.right=null}return t}();function r(t,e){return t>e?1:t<e?-1:0}function a(t,e,i){for(var r=new n(null,null),a=r,o=r;;){var s=i(t,e.key);if(s<0){if(null===e.left)break;if(i(t,e.left.key)<0){var l=e.left;if(e.left=l.right,l.right=e,null===(e=l).left)break}o.left=e,o=e,e=e.left}else{if(!(s>0))break;if(null===e.right)break;if(i(t,e.right.key)>0&&(l=e.right,e.right=l.left,l.left=e,null===(e=l).right))break;a.right=e,a=e,e=e.right}}return a.right=e.left,o.left=e.right,e.left=r.right,e.right=r.left,e}function o(t,e,i,r){var o=new n(t,e);if(null===i)return o.left=o.right=null,o;var s=r(t,(i=a(t,i,r)).key);return s<0?(o.left=i.left,o.right=i,i.left=null):s>=0&&(o.right=i.right,o.left=i,i.right=null),o}function s(t,e,i){var n=null,r=null;if(e){var o=i((e=a(t,e,i)).key,t);0===o?(n=e.left,r=e.right):o<0?(r=e.right,e.right=null,n=e):(n=e.left,e.left=null,r=e)}return{left:n,right:r}}function l(t,e,i){return null===e?t:(null===t||((e=a(t.key,e,i)).left=t),e)}function h(t,e,i,n,r){if(t){n(e+(i?"└── ":"├── ")+r(t)+"\\n");var a=e+(i?"    ":"│   ");t.left&&h(t.left,a,!1,n,r),t.right&&h(t.right,a,!0,n,r)}}var u=function(){function t(t){void 0===t&&(t=r),this._root=null,this._size=0,this._comparator=t}return t.prototype.insert=function(t,e){return this._size++,this._root=o(t,e,this._root,this._comparator)},t.prototype.add=function(t,e){var i=new n(t,e);null===this._root&&(i.left=i.right=null,this._size++,this._root=i);var r=this._comparator,o=a(t,this._root,r),s=r(t,o.key);return 0===s?this._root=o:(s<0?(i.left=o.left,i.right=o,o.left=null):s>0&&(i.right=o.right,i.left=o,o.right=null),this._size++,this._root=i),this._root},t.prototype.remove=function(t){this._root=this._remove(t,this._root,this._comparator)},t.prototype._remove=function(t,e,i){var n;return null===e?null:0===i(t,(e=a(t,e,i)).key)?(null===e.left?n=e.right:(n=a(t,e.left,i)).right=e.right,this._size--,n):e},t.prototype.pop=function(){var t=this._root;if(t){for(;t.left;)t=t.left;return this._root=a(t.key,this._root,this._comparator),this._root=this._remove(t.key,this._root,this._comparator),{key:t.key,data:t.data}}return null},t.prototype.findStatic=function(t){for(var e=this._root,i=this._comparator;e;){var n=i(t,e.key);if(0===n)return e;e=n<0?e.left:e.right}return null},t.prototype.find=function(t){return this._root&&(this._root=a(t,this._root,this._comparator),0!==this._comparator(t,this._root.key))?null:this._root},t.prototype.contains=function(t){for(var e=this._root,i=this._comparator;e;){var n=i(t,e.key);if(0===n)return!0;e=n<0?e.left:e.right}return!1},t.prototype.forEach=function(t,e){for(var i=this._root,n=[],r=!1;!r;)null!==i?(n.push(i),i=i.left):0!==n.length?(i=n.pop(),t.call(e,i),i=i.right):r=!0;return this},t.prototype.range=function(t,e,i,n){for(var r=[],a=this._comparator,o=this._root;0!==r.length||o;)if(o)r.push(o),o=o.left;else{if(a((o=r.pop()).key,e)>0)break;if(a(o.key,t)>=0&&i.call(n,o))return this;o=o.right}return this},t.prototype.keys=function(){var t=[];return this.forEach((function(e){var i=e.key;return t.push(i)})),t},t.prototype.values=function(){var t=[];return this.forEach((function(e){var i=e.data;return t.push(i)})),t},t.prototype.min=function(){return this._root?this.minNode(this._root).key:null},t.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},t.prototype.minNode=function(t){if(void 0===t&&(t=this._root),t)for(;t.left;)t=t.left;return t},t.prototype.maxNode=function(t){if(void 0===t&&(t=this._root),t)for(;t.right;)t=t.right;return t},t.prototype.at=function(t){for(var e=this._root,i=!1,n=0,r=[];!i;)if(e)r.push(e),e=e.left;else if(r.length>0){if(e=r.pop(),n===t)return e;n++,e=e.right}else i=!0;return null},t.prototype.next=function(t){var e=this._root,i=null;if(t.right){for(i=t.right;i.left;)i=i.left;return i}for(var n=this._comparator;e;){var r=n(t.key,e.key);if(0===r)break;r<0?(i=e,e=e.left):e=e.right}return i},t.prototype.prev=function(t){var e=this._root,i=null;if(null!==t.left){for(i=t.left;i.right;)i=i.right;return i}for(var n=this._comparator;e;){var r=n(t.key,e.key);if(0===r)break;r<0?e=e.left:(i=e,e=e.right)}return i},t.prototype.clear=function(){return this._root=null,this._size=0,this},t.prototype.toList=function(){return d(this._root)},t.prototype.load=function(t,e,i){void 0===e&&(e=[]),void 0===i&&(i=!1);var n=t.length,r=this._comparator;if(i&&_(t,e,0,n-1,r),null===this._root)this._root=c(t,e,0,n),this._size=n;else{var a=g(this.toList(),p(t,e),r);n=this._size+n,this._root=f({head:a},0,n)}return this},t.prototype.isEmpty=function(){return null===this._root},Object.defineProperty(t.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),t.prototype.toString=function(t){void 0===t&&(t=function(t){return String(t.key)});var e=[];return h(this._root,"",!0,(function(t){return e.push(t)}),t),e.join("")},t.prototype.update=function(t,e,i){var n=this._comparator,r=s(t,this._root,n),a=r.left,h=r.right;n(t,e)<0?h=o(e,i,h,n):a=o(e,i,a,n),this._root=l(a,h,n)},t.prototype.split=function(t){return s(t,this._root,this._comparator)},t}();function c(t,e,i,r){var a=r-i;if(a>0){var o=i+Math.floor(a/2),s=t[o],l=e[o],h=new n(s,l);return h.left=c(t,e,i,o),h.right=c(t,e,o+1,r),h}return null}function p(t,e){for(var i=new n(null,null),r=i,a=0;a<t.length;a++)r=r.next=new n(t[a],e[a]);return r.next=null,i.next}function d(t){for(var e=t,i=[],r=!1,a=new n(null,null),o=a;!r;)e?(i.push(e),e=e.left):i.length>0?e=(e=o=o.next=i.pop()).right:r=!0;return o.next=null,a.next}function f(t,e,i){var n=i-e;if(n>0){var r=e+Math.floor(n/2),a=f(t,e,r),o=t.head;return o.left=a,t.head=t.head.next,o.right=f(t,r+1,i),o}return null}function g(t,e,i){for(var r=new n(null,null),a=r,o=t,s=e;null!==o&&null!==s;)i(o.key,s.key)<0?(a.next=o,o=o.next):(a.next=s,s=s.next),a=a.next;return null!==o?a.next=o:null!==s&&(a.next=s),r.next}function _(t,e,i,n,r){if(!(i>=n)){for(var a=t[i+n>>1],o=i-1,s=n+1;;){do{o++}while(r(t[o],a)<0);do{s--}while(r(t[s],a)>0);if(o>=s)break;var l=t[o];t[o]=t[s],t[s]=l,l=e[o],e[o]=e[s],e[s]=l}_(t,e,i,s,r),_(t,e,s+1,n,r)}}var m=function(t,e){return t.ll.x<=e.x&&e.x<=t.ur.x&&t.ll.y<=e.y&&e.y<=t.ur.y},y=function(t,e){if(e.ur.x<t.ll.x||t.ur.x<e.ll.x||e.ur.y<t.ll.y||t.ur.y<e.ll.y)return null;var i=t.ll.x<e.ll.x?e.ll.x:t.ll.x,n=t.ur.x<e.ur.x?t.ur.x:e.ur.x;return{ll:{x:i,y:t.ll.y<e.ll.y?e.ll.y:t.ll.y},ur:{x:n,y:t.ur.y<e.ur.y?t.ur.y:e.ur.y}}},v=Number.EPSILON;v===undefined&&(v=Math.pow(2,-52));var L=v*v,b=function(t,e){if(-v<t&&t<v&&-v<e&&e<v)return 0;var i=t-e;return i*i<L*t*e?0:t<e?-1:1},k=function(){function e(){t(this,e),this.reset()}return i(e,[{key:"reset",value:function(){this.xRounder=new M,this.yRounder=new M}},{key:"round",value:function(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}}]),e}(),M=function(){function e(){t(this,e),this.tree=new u,this.round(0)}return i(e,[{key:"round",value:function(t){var e=this.tree.add(t),i=this.tree.prev(e);if(null!==i&&0===b(e.key,i.key))return this.tree.remove(t),i.key;var n=this.tree.next(e);return null!==n&&0===b(e.key,n.key)?(this.tree.remove(t),n.key):t}}]),e}(),x=new k,w=function(t,e){return t.x*e.y-t.y*e.x},C=function(t,e){return t.x*e.x+t.y*e.y},P=function(t,e,i){var n={x:e.x-t.x,y:e.y-t.y},r={x:i.x-t.x,y:i.y-t.y},a=w(n,r);return b(a,0)},E=function(t){return Math.sqrt(C(t,t))},S=function(t,e,i){var n={x:e.x-t.x,y:e.y-t.y},r={x:i.x-t.x,y:i.y-t.y};return w(r,n)/E(r)/E(n)},O=function(t,e,i){var n={x:e.x-t.x,y:e.y-t.y},r={x:i.x-t.x,y:i.y-t.y};return C(r,n)/E(r)/E(n)},D=function(t,e,i){return 0===e.y?null:{x:t.x+e.x/e.y*(i-t.y),y:i}},R=function(t,e,i){return 0===e.x?null:{x:i,y:t.y+e.y/e.x*(i-t.x)}},B=function(t,e,i,n){if(0===e.x)return R(i,n,t.x);if(0===n.x)return R(t,e,i.x);if(0===e.y)return D(i,n,t.y);if(0===n.y)return D(t,e,i.y);var r=w(e,n);if(0==r)return null;var a={x:i.x-t.x,y:i.y-t.y},o=w(a,e)/r,s=w(a,n)/r;return{x:(t.x+s*e.x+(i.x+o*n.x))/2,y:(t.y+s*e.y+(i.y+o*n.y))/2}},T=function(){function e(i,n){t(this,e),i.events===undefined?i.events=[this]:i.events.push(this),this.point=i,this.isLeft=n}return i(e,null,[{key:"compare",value:function(t,i){var n=e.comparePoints(t.point,i.point);return 0!==n?n:(t.point!==i.point&&t.link(i),t.isLeft!==i.isLeft?t.isLeft?1:-1:j.compare(t.segment,i.segment))}},{key:"comparePoints",value:function(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}}]),i(e,[{key:"link",value:function(t){if(t.point===this.point)throw new Error("Tried to link already linked events");for(var e=t.point.events,i=0,n=e.length;i<n;i++){var r=e[i];this.point.events.push(r),r.point=this.point}this.checkForConsuming()}},{key:"checkForConsuming",value:function(){for(var t=this.point.events.length,e=0;e<t;e++){var i=this.point.events[e];if(i.segment.consumedBy===undefined)for(var n=e+1;n<t;n++){var r=this.point.events[n];r.consumedBy===undefined&&i.otherSE.point.events===r.otherSE.point.events&&i.segment.consume(r.segment)}}}},{key:"getAvailableLinkedEvents",value:function(){for(var t=[],e=0,i=this.point.events.length;e<i;e++){var n=this.point.events[e];n!==this&&!n.segment.ringOut&&n.segment.isInResult()&&t.push(n)}return t}},{key:"getLeftmostComparator",value:function(t){var e=this,i=new Map,n=function(n){var r=n.otherSE;i.set(n,{sine:S(e.point,t.point,r.point),cosine:O(e.point,t.point,r.point)})};return function(t,e){i.has(t)||n(t),i.has(e)||n(e);var r=i.get(t),a=r.sine,o=r.cosine,s=i.get(e),l=s.sine,h=s.cosine;return a>=0&&l>=0?o<h?1:o>h?-1:0:a<0&&l<0?o<h?-1:o>h?1:0:l<a?-1:l>a?1:0}}}]),e}(),I=0,j=function(){function e(i,n,r,a){t(this,e),this.id=++I,this.leftSE=i,i.segment=this,i.otherSE=n,this.rightSE=n,n.segment=this,n.otherSE=i,this.rings=r,this.windings=a}return i(e,null,[{key:"compare",value:function(t,e){var i=t.leftSE.point.x,n=e.leftSE.point.x,r=t.rightSE.point.x,a=e.rightSE.point.x;if(a<i)return 1;if(r<n)return-1;var o=t.leftSE.point.y,s=e.leftSE.point.y,l=t.rightSE.point.y,h=e.rightSE.point.y;if(i<n){if(s<o&&s<l)return 1;if(s>o&&s>l)return-1;var u=t.comparePoint(e.leftSE.point);if(u<0)return 1;if(u>0)return-1;var c=e.comparePoint(t.rightSE.point);return 0!==c?c:-1}if(i>n){if(o<s&&o<h)return-1;if(o>s&&o>h)return 1;var p=e.comparePoint(t.leftSE.point);if(0!==p)return p;var d=t.comparePoint(e.rightSE.point);return d<0?1:d>0?-1:1}if(o<s)return-1;if(o>s)return 1;if(r<a){var f=e.comparePoint(t.rightSE.point);if(0!==f)return f}if(r>a){var g=t.comparePoint(e.rightSE.point);if(g<0)return 1;if(g>0)return-1}if(r!==a){var _=l-o,m=r-i,y=h-s,v=a-n;if(_>m&&y<v)return 1;if(_<m&&y>v)return-1}return r>a?1:r<a||l<h?-1:l>h?1:t.id<e.id?-1:t.id>e.id?1:0}}]),i(e,[{key:"replaceRightSE",value:function(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}},{key:"bbox",value:function(){var t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}},{key:"vector",value:function(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}},{key:"isAnEndpoint",value:function(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}},{key:"comparePoint",value:function(t){if(this.isAnEndpoint(t))return 0;var e=this.leftSE.point,i=this.rightSE.point,n=this.vector();if(e.x===i.x)return t.x===e.x?0:t.x<e.x?1:-1;var r=(t.y-e.y)/n.y,a=e.x+r*n.x;if(t.x===a)return 0;var o=(t.x-e.x)/n.x,s=e.y+o*n.y;return t.y===s?0:t.y<s?-1:1}},{key:"getIntersection",value:function(t){var e=this.bbox(),i=t.bbox(),n=y(e,i);if(null===n)return null;var r=this.leftSE.point,a=this.rightSE.point,o=t.leftSE.point,s=t.rightSE.point,l=m(e,o)&&0===this.comparePoint(o),h=m(i,r)&&0===t.comparePoint(r),u=m(e,s)&&0===this.comparePoint(s),c=m(i,a)&&0===t.comparePoint(a);if(h&&l)return c&&!u?a:!c&&u?s:null;if(h)return u&&r.x===s.x&&r.y===s.y?null:r;if(l)return c&&a.x===o.x&&a.y===o.y?null:o;if(c&&u)return null;if(c)return a;if(u)return s;var p=B(r,this.vector(),o,t.vector());return null===p?null:m(n,p)?x.round(p.x,p.y):null}},{key:"split",value:function(t){var i=[],n=t.events!==undefined,r=new T(t,!0),a=new T(t,!1),o=this.rightSE;this.replaceRightSE(a),i.push(a),i.push(r);var s=new e(r,o,this.rings.slice(),this.windings.slice());return T.comparePoints(s.leftSE.point,s.rightSE.point)>0&&s.swapEvents(),T.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(r.checkForConsuming(),a.checkForConsuming()),i}},{key:"swapEvents",value:function(){var t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(var e=0,i=this.windings.length;e<i;e++)this.windings[e]*=-1}},{key:"consume",value:function(t){for(var i=this,n=t;i.consumedBy;)i=i.consumedBy;for(;n.consumedBy;)n=n.consumedBy;var r=e.compare(i,n);if(0!==r){if(r>0){var a=i;i=n,n=a}if(i.prev===n){var o=i;i=n,n=o}for(var s=0,l=n.rings.length;s<l;s++){var h=n.rings[s],u=n.windings[s],c=i.rings.indexOf(h);-1===c?(i.rings.push(h),i.windings.push(u)):i.windings[c]+=u}n.rings=null,n.windings=null,n.consumedBy=i,n.leftSE.consumedBy=i.leftSE,n.rightSE.consumedBy=i.rightSE}}},{key:"prevInResult",value:function(){return this._prevInResult!==undefined||(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null),this._prevInResult}},{key:"beforeState",value:function(){if(this._beforeState!==undefined)return this._beforeState;if(this.prev){var t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}else this._beforeState={rings:[],windings:[],multiPolys:[]};return this._beforeState}},{key:"afterState",value:function(){if(this._afterState!==undefined)return this._afterState;var t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};for(var e=this._afterState.rings,i=this._afterState.windings,n=this._afterState.multiPolys,r=0,a=this.rings.length;r<a;r++){var o=this.rings[r],s=this.windings[r],l=e.indexOf(o);-1===l?(e.push(o),i.push(s)):i[l]+=s}for(var h=[],u=[],c=0,p=e.length;c<p;c++)if(0!==i[c]){var d=e[c],f=d.poly;if(-1===u.indexOf(f))if(d.isExterior)h.push(f);else{-1===u.indexOf(f)&&u.push(f);var g=h.indexOf(d.poly);-1!==g&&h.splice(g,1)}}for(var _=0,m=h.length;_<m;_++){var y=h[_].multiPoly;-1===n.indexOf(y)&&n.push(y)}return this._afterState}},{key:"isInResult",value:function(){if(this.consumedBy)return!1;if(this._isInResult!==undefined)return this._isInResult;var t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(q.type){case"union":var i=0===t.length,n=0===e.length;this._isInResult=i!==n;break;case"intersection":var r,a;t.length<e.length?(r=t.length,a=e.length):(r=e.length,a=t.length),this._isInResult=a===q.numMultiPolys&&r<a;break;case"xor":var o=Math.abs(t.length-e.length);this._isInResult=o%2==1;break;case"difference":var s=function(t){return 1===t.length&&t[0].isSubject};this._isInResult=s(t)!==s(e);break;default:throw new Error("Unrecognized operation type found ".concat(q.type))}return this._isInResult}}],[{key:"fromRing",value:function(t,i,n){var r,a,o,s=T.comparePoints(t,i);if(s<0)r=t,a=i,o=1;else{if(!(s>0))throw new Error("Tried to create degenerate segment at [".concat(t.x,", ").concat(t.y,"]"));r=i,a=t,o=-1}return new e(new T(r,!0),new T(a,!1),[n],[o])}}]),e}(),A=function(){function e(i,n,r){if(t(this,e),!Array.isArray(i)||0===i.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=n,this.isExterior=r,this.segments=[],"number"!=typeof i[0][0]||"number"!=typeof i[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");var a=x.round(i[0][0],i[0][1]);this.bbox={ll:{x:a.x,y:a.y},ur:{x:a.x,y:a.y}};for(var o=a,s=1,l=i.length;s<l;s++){if("number"!=typeof i[s][0]||"number"!=typeof i[s][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");var h=x.round(i[s][0],i[s][1]);h.x===o.x&&h.y===o.y||(this.segments.push(j.fromRing(o,h,this)),h.x<this.bbox.ll.x&&(this.bbox.ll.x=h.x),h.y<this.bbox.ll.y&&(this.bbox.ll.y=h.y),h.x>this.bbox.ur.x&&(this.bbox.ur.x=h.x),h.y>this.bbox.ur.y&&(this.bbox.ur.y=h.y),o=h)}a.x===o.x&&a.y===o.y||this.segments.push(j.fromRing(o,a,this))}return i(e,[{key:"getSweepEvents",value:function(){for(var t=[],e=0,i=this.segments.length;e<i;e++){var n=this.segments[e];t.push(n.leftSE),t.push(n.rightSE)}return t}}]),e}(),G=function(){function e(i,n){if(t(this,e),!Array.isArray(i))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new A(i[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(var r=1,a=i.length;r<a;r++){var o=new A(i[r],this,!1);o.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=o.bbox.ll.x),o.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=o.bbox.ll.y),o.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=o.bbox.ur.x),o.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=o.bbox.ur.y),this.interiorRings.push(o)}this.multiPoly=n}return i(e,[{key:"getSweepEvents",value:function(){for(var t=this.exteriorRing.getSweepEvents(),e=0,i=this.interiorRings.length;e<i;e++)for(var n=this.interiorRings[e].getSweepEvents(),r=0,a=n.length;r<a;r++)t.push(n[r]);return t}}]),e}(),N=function(){function e(i,n){if(t(this,e),!Array.isArray(i))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof i[0][0][0]&&(i=[i])}catch(s){}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(var r=0,a=i.length;r<a;r++){var o=new G(i[r],this);o.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=o.bbox.ll.x),o.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=o.bbox.ll.y),o.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=o.bbox.ur.x),o.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=o.bbox.ur.y),this.polys.push(o)}this.isSubject=n}return i(e,[{key:"getSweepEvents",value:function(){for(var t=[],e=0,i=this.polys.length;e<i;e++)for(var n=this.polys[e].getSweepEvents(),r=0,a=n.length;r<a;r++)t.push(n[r]);return t}}]),e}(),z=function(){function e(i){t(this,e),this.events=i;for(var n=0,r=i.length;n<r;n++)i[n].segment.ringOut=this;this.poly=null}return i(e,null,[{key:"factory",value:function(t){for(var i=[],n=0,r=t.length;n<r;n++){var a=t[n];if(a.isInResult()&&!a.ringOut){for(var o=null,s=a.leftSE,l=a.rightSE,h=[s],u=s.point,c=[];o=s,s=l,h.push(s),s.point!==u;)for(;;){var p=s.getAvailableLinkedEvents();if(0===p.length){var d=h[0].point,f=h[h.length-1].point;throw new Error("Unable to complete output ring starting at [".concat(d.x,",")+" ".concat(d.y,"]. Last matching segment found ends at")+" [".concat(f.x,", ").concat(f.y,"]."))}if(1===p.length){l=p[0].otherSE;break}for(var g=null,_=0,m=c.length;_<m;_++)if(c[_].point===s.point){g=_;break}if(null===g){c.push({index:h.length,point:s.point});var y=s.getLeftmostComparator(o);l=p.sort(y)[0].otherSE;break}var v=c.splice(g)[0],L=h.splice(v.index);L.unshift(L[0].otherSE),i.push(new e(L.reverse()))}i.push(new e(h))}}return i}}]),i(e,[{key:"getGeom",value:function(){for(var t=this.events[0].point,e=[t],i=1,n=this.events.length-1;i<n;i++){var r=this.events[i].point,a=this.events[i+1].point;0!==P(r,t,a)&&(e.push(r),t=r)}if(1===e.length)return null;var o=e[0],s=e[1];0===P(o,t,s)&&e.shift(),e.push(e[0]);for(var l=this.isExteriorRing()?1:-1,h=this.isExteriorRing()?0:e.length-1,u=this.isExteriorRing()?e.length:-1,c=[],p=h;p!=u;p+=l)c.push([e[p].x,e[p].y]);return c}},{key:"isExteriorRing",value:function(){if(this._isExteriorRing===undefined){var t=this.enclosingRing();this._isExteriorRing=!t||!t.isExteriorRing()}return this._isExteriorRing}},{key:"enclosingRing",value:function(){return this._enclosingRing===undefined&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}},{key:"_calcEnclosingRing",value:function(){for(var t=this.events[0],e=1,i=this.events.length;e<i;e++){var n=this.events[e];T.compare(t,n)>0&&(t=n)}for(var r=t.segment.prevInResult(),a=r?r.prevInResult():null;;){if(!r)return null;if(!a)return r.ringOut;if(a.ringOut!==r.ringOut)return a.ringOut.enclosingRing()!==r.ringOut?r.ringOut:r.ringOut.enclosingRing();r=a.prevInResult(),a=r?r.prevInResult():null}}}]),e}(),U=function(){function e(i){t(this,e),this.exteriorRing=i,i.poly=this,this.interiorRings=[]}return i(e,[{key:"addInterior",value:function(t){this.interiorRings.push(t),t.poly=this}},{key:"getGeom",value:function(){var t=[this.exteriorRing.getGeom()];if(null===t[0])return null;for(var e=0,i=this.interiorRings.length;e<i;e++){var n=this.interiorRings[e].getGeom();null!==n&&t.push(n)}return t}}]),e}(),F=function(){function e(i){t(this,e),this.rings=i,this.polys=this._composePolys(i)}return i(e,[{key:"getGeom",value:function(){for(var t=[],e=0,i=this.polys.length;e<i;e++){var n=this.polys[e].getGeom();null!==n&&t.push(n)}return t}},{key:"_composePolys",value:function(t){for(var e=[],i=0,n=t.length;i<n;i++){var r=t[i];if(!r.poly)if(r.isExteriorRing())e.push(new U(r));else{var a=r.enclosingRing();a.poly||e.push(new U(a)),a.poly.addInterior(r)}}return e}}]),e}(),V=function(){function e(i){var n=arguments.length>1&&arguments[1]!==undefined?arguments[1]:j.compare;t(this,e),this.queue=i,this.tree=new u(n),this.segments=[]}return i(e,[{key:"process",value:function(t){var e=t.segment,i=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),i;var n=t.isLeft?this.tree.insert(e):this.tree.find(e);if(!n)throw new Error("Unable to find segment #".concat(e.id," ")+"[".concat(e.leftSE.point.x,", ").concat(e.leftSE.point.y,"] -> ")+"[".concat(e.rightSE.point.x,", ").concat(e.rightSE.point.y,"] ")+"in SweepLine tree. Please submit a bug report.");for(var r=n,a=n,o=undefined,s=undefined;o===undefined;)null===(r=this.tree.prev(r))?o=null:r.key.consumedBy===undefined&&(o=r.key);for(;s===undefined;)null===(a=this.tree.next(a))?s=null:a.key.consumedBy===undefined&&(s=a.key);if(t.isLeft){var l=null;if(o){var h=o.getIntersection(e);if(null!==h&&(e.isAnEndpoint(h)||(l=h),!o.isAnEndpoint(h)))for(var u=this._splitSafely(o,h),c=0,p=u.length;c<p;c++)i.push(u[c])}var d=null;if(s){var f=s.getIntersection(e);if(null!==f&&(e.isAnEndpoint(f)||(d=f),!s.isAnEndpoint(f)))for(var g=this._splitSafely(s,f),_=0,m=g.length;_<m;_++)i.push(g[_])}if(null!==l||null!==d){var y=null;y=null===l?d:null===d||T.comparePoints(l,d)<=0?l:d,this.queue.remove(e.rightSE),i.push(e.rightSE);for(var v=e.split(y),L=0,b=v.length;L<b;L++)i.push(v[L])}i.length>0?(this.tree.remove(e),i.push(t)):(this.segments.push(e),e.prev=o)}else{if(o&&s){var k=o.getIntersection(s);if(null!==k){if(!o.isAnEndpoint(k))for(var M=this._splitSafely(o,k),x=0,w=M.length;x<w;x++)i.push(M[x]);if(!s.isAnEndpoint(k))for(var C=this._splitSafely(s,k),P=0,E=C.length;P<E;P++)i.push(C[P])}}this.tree.remove(e)}return i}},{key:"_splitSafely",value:function(t,e){this.tree.remove(t);var i=t.rightSE;this.queue.remove(i);var n=t.split(e);return n.push(i),t.consumedBy===undefined&&this.tree.insert(t),n}}]),e}(),K="undefined"!=typeof process&&Object({"NODE_ENV":"production","VUE_APP_admin_API":"","VUE_APP_API_URL":"/","VUE_APP_BASE_API":"","VUE_APP_GOOGLEMAP_KEY":"AIzaSyCcdPcWqEAERThoT-VysC8gkjH-QJvYjo4","VUE_APP_IMGURL":"","VUE_APP_SOCKET_URL":"","BASE_URL":""}).POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,H="undefined"!=typeof process&&Object({"NODE_ENV":"production","VUE_APP_admin_API":"","VUE_APP_API_URL":"/","VUE_APP_BASE_API":"","VUE_APP_GOOGLEMAP_KEY":"AIzaSyCcdPcWqEAERThoT-VysC8gkjH-QJvYjo4","VUE_APP_IMGURL":"","VUE_APP_SOCKET_URL":"","BASE_URL":""}).POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6,q=new(function(){function e(){t(this,e)}return i(e,[{key:"run",value:function(t,e,i){q.type=t,x.reset();for(var n=[new N(e,!0)],r=0,a=i.length;r<a;r++)n.push(new N(i[r],!1));if(q.numMultiPolys=n.length,"difference"===q.type)for(var o=n[0],s=1;s<n.length;)null!==y(n[s].bbox,o.bbox)?s++:n.splice(s,1);if("intersection"===q.type)for(var l=0,h=n.length;l<h;l++)for(var c=n[l],p=l+1,d=n.length;p<d;p++)if(null===y(c.bbox,n[p].bbox))return[];for(var f=new u(T.compare),g=0,_=n.length;g<_;g++)for(var m=n[g].getSweepEvents(),v=0,L=m.length;v<L;v++)if(f.insert(m[v]),f.size>K)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");for(var b=new V(f),k=f.size,M=f.pop();M;){var w=M.key;if(f.size===k){var C=w.segment;throw new Error("Unable to pop() ".concat(w.isLeft?"left":"right"," SweepEvent ")+"[".concat(w.point.x,", ").concat(w.point.y,"] from segment #").concat(C.id," ")+"[".concat(C.leftSE.point.x,", ").concat(C.leftSE.point.y,"] -> ")+"[".concat(C.rightSE.point.x,", ").concat(C.rightSE.point.y,"] from queue. ")+"Please file a bug report.")}if(f.size>K)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");if(b.segments.length>H)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");for(var P=b.process(w),E=0,S=P.length;E<S;E++){var O=P[E];O.consumedBy===undefined&&f.insert(O)}k=f.size,M=f.pop()}x.reset();var D=z.factory(b.segments);return new F(D).getGeom()}}]),e}()),J=function(t){for(var e=arguments.length,i=new Array(e>1?e-1:0),n=1;n<e;n++)i[n-1]=arguments[n];return q.run("union",t,i)},Y=function(t){for(var e=arguments.length,i=new Array(e>1?e-1:0),n=1;n<e;n++)i[n-1]=arguments[n];return q.run("intersection",t,i)},X=function(t){for(var e=arguments.length,i=new Array(e>1?e-1:0),n=1;n<e;n++)i[n-1]=arguments[n];return q.run("xor",t,i)},Z=function(t){for(var e=arguments.length,i=new Array(e>1?e-1:0),n=1;n<e;n++)i[n-1]=arguments[n];return q.run("difference",t,i)};return{union:J,intersection:Y,xor:X,difference:Z}}()},2582:function(t){t.exports=function(){"use strict";function t(t,n,r,a,o){!function s(t,i,n,r,a){for(;r>n;){if(r-n>600){var o=r-n+1,l=i-n+1,h=Math.log(o),u=.5*Math.exp(2*h/3),c=.5*Math.sqrt(h*u*(o-u)/o)*(l-o/2<0?-1:1);s(t,i,Math.max(n,Math.floor(i-l*u/o+c)),Math.min(r,Math.floor(i+(o-l)*u/o+c)),a)}var p=t[i],d=n,f=r;for(e(t,n,i),a(t[r],p)>0&&e(t,n,r);d<f;){for(e(t,d,f),d++,f--;a(t[d],p)<0;)d++;for(;a(t[f],p)>0;)f--}0===a(t[n],p)?e(t,n,f):e(t,++f,r),f<=i&&(n=f+1),i<=f&&(r=f-1)}}(t,n,r||0,a||t.length-1,o||i)}function e(t,e,i){var n=t[e];t[e]=t[i],t[i]=n}function i(t,e){return t<e?-1:t>e?1:0}var n=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function r(t,e,i){if(!i)return e.indexOf(t);for(var n=0;n<e.length;n++)if(i(t,e[n]))return n;return-1}function a(t,e){o(t,0,t.children.length,e,t)}function o(t,e,i,n,r){r||(r=f(null)),r.minX=1/0,r.minY=1/0,r.maxX=-1/0,r.maxY=-1/0;for(var a=e;a<i;a++){var o=t.children[a];s(r,t.leaf?n(o):o)}return r}function s(t,e){return t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),t}function l(t,e){return t.minX-e.minX}function h(t,e){return t.minY-e.minY}function u(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function c(t){return t.maxX-t.minX+(t.maxY-t.minY)}function p(t,e){return t.minX<=e.minX&&t.minY<=e.minY&&e.maxX<=t.maxX&&e.maxY<=t.maxY}function d(t,e){return e.minX<=t.maxX&&e.minY<=t.maxY&&e.maxX>=t.minX&&e.maxY>=t.minY}function f(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function g(e,i,n,r,a){for(var o=[i,n];o.length;)if(!((n=o.pop())-(i=o.pop())<=r)){var s=i+Math.ceil((n-i)/r/2)*r;t(e,s,i,n,a),o.push(i,s,s,n)}}return n.prototype.all=function(){return this._all(this.data,[])},n.prototype.search=function(t){var e=this.data,i=[];if(!d(t,e))return i;for(var n=this.toBBox,r=[];e;){for(var a=0;a<e.children.length;a++){var o=e.children[a],s=e.leaf?n(o):o;d(t,s)&&(e.leaf?i.push(o):p(t,s)?this._all(o,i):r.push(o))}e=r.pop()}return i},n.prototype.collides=function(t){var e=this.data;if(!d(t,e))return!1;for(var i=[];e;){for(var n=0;n<e.children.length;n++){var r=e.children[n],a=e.leaf?this.toBBox(r):r;if(d(t,a)){if(e.leaf||p(t,a))return!0;i.push(r)}}e=i.pop()}return!1},n.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var e=0;e<t.length;e++)this.insert(t[e]);return this}var i=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===i.height)this._splitRoot(this.data,i);else{if(this.data.height<i.height){var n=this.data;this.data=i,i=n}this._insert(i,this.data.height-i.height-1,!0)}else this.data=i;return this},n.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},n.prototype.clear=function(){return this.data=f([]),this},n.prototype.remove=function(t,e){if(!t)return this;for(var i,n,a,o=this.data,s=this.toBBox(t),l=[],h=[];o||l.length;){if(o||(o=l.pop(),n=l[l.length-1],i=h.pop(),a=!0),o.leaf){var u=r(t,o.children,e);if(-1!==u)return o.children.splice(u,1),l.push(o),this._condense(l),this}a||o.leaf||!p(o,s)?n?(i++,o=n.children[i],a=!1):o=null:(l.push(o),h.push(i),i=0,n=o,o=o.children[0])}return this},n.prototype.toBBox=function(t){return t},n.prototype.compareMinX=function(t,e){return t.minX-e.minX},n.prototype.compareMinY=function(t,e){return t.minY-e.minY},n.prototype.toJSON=function(){return this.data},n.prototype.fromJSON=function(t){return this.data=t,this},n.prototype._all=function(t,e){for(var i=[];t;)t.leaf?e.push.apply(e,t.children):i.push.apply(i,t.children),t=i.pop();return e},n.prototype._build=function(t,e,i,n){var r,o=i-e+1,s=this._maxEntries;if(o<=s)return a(r=f(t.slice(e,i+1)),this.toBBox),r;n||(n=Math.ceil(Math.log(o)/Math.log(s)),s=Math.ceil(o/Math.pow(s,n-1))),(r=f([])).leaf=!1,r.height=n;var l=Math.ceil(o/s),h=l*Math.ceil(Math.sqrt(s));g(t,e,i,h,this.compareMinX);for(var u=e;u<=i;u+=h){var c=Math.min(u+h-1,i);g(t,u,c,l,this.compareMinY);for(var p=u;p<=c;p+=l){var d=Math.min(p+l-1,c);r.children.push(this._build(t,p,d,n-1))}}return a(r,this.toBBox),r},n.prototype._chooseSubtree=function(t,e,i,n){for(;n.push(e),!e.leaf&&n.length-1!==i;){for(var r=1/0,a=1/0,o=void 0,s=0;s<e.children.length;s++){var l=e.children[s],h=u(l),c=(p=t,d=l,(Math.max(d.maxX,p.maxX)-Math.min(d.minX,p.minX))*(Math.max(d.maxY,p.maxY)-Math.min(d.minY,p.minY))-h);c<a?(a=c,r=h<r?h:r,o=l):c===a&&h<r&&(r=h,o=l)}e=o||e.children[0]}var p,d;return e},n.prototype._insert=function(t,e,i){var n=i?t:this.toBBox(t),r=[],a=this._chooseSubtree(n,this.data,e,r);for(a.children.push(t),s(a,n);e>=0&&r[e].children.length>this._maxEntries;)this._split(r,e),e--;this._adjustParentBBoxes(n,r,e)},n.prototype._split=function(t,e){var i=t[e],n=i.children.length,r=this._minEntries;this._chooseSplitAxis(i,r,n);var o=this._chooseSplitIndex(i,r,n),s=f(i.children.splice(o,i.children.length-o));s.height=i.height,s.leaf=i.leaf,a(i,this.toBBox),a(s,this.toBBox),e?t[e-1].children.push(s):this._splitRoot(i,s)},n.prototype._splitRoot=function(t,e){this.data=f([t,e]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},n.prototype._chooseSplitIndex=function(t,e,i){for(var n,r,a,s,l,h,c,p=1/0,d=1/0,f=e;f<=i-e;f++){var g=o(t,0,f,this.toBBox),_=o(t,f,i,this.toBBox),m=(r=g,a=_,s=void 0,l=void 0,h=void 0,c=void 0,s=Math.max(r.minX,a.minX),l=Math.max(r.minY,a.minY),h=Math.min(r.maxX,a.maxX),c=Math.min(r.maxY,a.maxY),Math.max(0,h-s)*Math.max(0,c-l)),y=u(g)+u(_);m<p?(p=m,n=f,d=y<d?y:d):m===p&&y<d&&(d=y,n=f)}return n||i-e},n.prototype._chooseSplitAxis=function(t,e,i){var n=t.leaf?this.compareMinX:l,r=t.leaf?this.compareMinY:h;this._allDistMargin(t,e,i,n)<this._allDistMargin(t,e,i,r)&&t.children.sort(n)},n.prototype._allDistMargin=function(t,e,i,n){t.children.sort(n);for(var r=this.toBBox,a=o(t,0,e,r),l=o(t,i-e,i,r),h=c(a)+c(l),u=e;u<i-e;u++){var p=t.children[u];s(a,t.leaf?r(p):p),h+=c(a)}for(var d=i-e-1;d>=e;d--){var f=t.children[d];s(l,t.leaf?r(f):f),h+=c(l)}return h},n.prototype._adjustParentBBoxes=function(t,e,i){for(var n=i;n>=0;n--)s(e[n],t)},n.prototype._condense=function(t){for(var e=t.length-1,i=void 0;e>=0;e--)0===t[e].children.length?e>0?(i=t[e-1].children).splice(i.indexOf(t[e]),1):this.clear():a(t[e],this.toBBox)},n}()}},e={};function i(n){var r=e[n];if(r!==undefined)return r.exports;var a=e[n]={id:n,loaded:!1,exports:{}};return t[n].call(a.exports,a,a.exports,i),a.loaded=!0,a.exports}i.n=t=>{var e=t&&t.__esModule?()=>t["default"]:()=>t;return i.d(e,{a:e}),e},i.d=(t,e)=>{for(var n in e)i.o(e,n)&&!i.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},i.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.nmd=t=>(t.paths=[],t.children||(t.children=[]),t);i(414)})();\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGdlb21hbi1pby9sZWFmbGV0LWdlb21hbi1mcmVlL2Rpc3QvbGVhZmxldC1nZW9tYW4ubWluLmpzPzg0NWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscURBQU0sT0FBTyxlQUFlLGFBQWEsY0FBYyxjQUFjLDhDQUE4QyxrQ0FBa0MsNEZBQTRGLEtBQUsscUJBQXFCLGNBQWMsYUFBYSxrQkFBa0IsaUJBQWlCLEVBQUUsT0FBTyxnQkFBZ0IsOEVBQThFLGdCQUFnQixrQkFBa0Isb0JBQW9CLGdEQUFnRCxxRUFBcUUsNkVBQTZFLDBFQUEwRSxVQUFVLDJCQUEyQixNQUFNLGtCQUFrQixpQkFBaUIsRUFBRSxnQkFBZ0IsV0FBVyxLQUFLLFdBQVcsNkZBQTZGLFlBQVksdUJBQXVCLGlHQUFpRyxVQUFVLDZCQUE2QixNQUFNLGtCQUFrQixvQkFBb0Isc0ZBQXNGLFVBQVUsZ0NBQWdDLE1BQU0sZ0JBQWdCLGlCQUFpQixFQUFFLE9BQU8sMEJBQTBCLGdFQUFnRSxrQkFBa0Isd0JBQXdCLEtBQUsscUNBQXFDLE1BQU0sa0JBQWtCLHdCQUF3QixLQUFLLGdDQUFnQyxNQUFNLGtCQUFrQix3QkFBd0IsS0FBSyxrQ0FBa0MsTUFBTSxnQkFBZ0IsNkJBQTZCLG1CQUFtQiw2Q0FBNkMsV0FBVyxnQkFBZ0IsNkJBQTZCLG1CQUFtQiw2Q0FBNkMsV0FBVyxjQUFjLG1DQUFtQyxjQUFjLDZDQUE2QyxzQ0FBc0MsU0FBUyxxQ0FBcUMsa1pBQWtaLGlCQUFpQiwyT0FBMk8sZ0JBQWdCLHVOQUF1Tix3Q0FBd0Msd0JBQXdCLEtBQUssaUNBQWlDLHNDQUFzQyxtQ0FBbUMsc0NBQXNDLDJDQUEyQyx3Q0FBd0MsMENBQTBDLG9DQUFvQyx3QkFBd0IsdUJBQXVCLGNBQWMsTUFBTSx3Q0FBd0Msd0JBQXdCLHVCQUF1QixjQUFjLE1BQU0sOENBQThDLHdCQUF3Qix1QkFBdUIsY0FBYyxNQUFNLGdIQUFnSCx3QkFBd0IsS0FBSyx1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LDJDQUEyQyxTQUFTLDBDQUEwQyw0R0FBNEcsT0FBTyxJIiwiZmlsZSI6Ijg0NWEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9Pnt2YXIgdD17OTcwNToodCxlLGkpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49aSgxNTQwKTtmdW5jdGlvbiByKHQpe3ZhciBlPVtJbmZpbml0eSxJbmZpbml0eSwtSW5maW5pdHksLUluZmluaXR5XTtyZXR1cm4gbi5jb29yZEVhY2godCwoZnVuY3Rpb24odCl7ZVswXT50WzBdJiYoZVswXT10WzBdKSxlWzFdPnRbMV0mJihlWzFdPXRbMV0pLGVbMl08dFswXSYmKGVbMl09dFswXSksZVszXTx0WzFdJiYoZVszXT10WzFdKX0pKSxlfXJbXCJkZWZhdWx0XCJdPXIsZS5aPXJ9LDQxMDI6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKHQsZSxpKXt2b2lkIDA9PT1pJiYoaT17fSk7dmFyIG49e3R5cGU6XCJGZWF0dXJlXCJ9O3JldHVybigwPT09aS5pZHx8aS5pZCkmJihuLmlkPWkuaWQpLGkuYmJveCYmKG4uYmJveD1pLmJib3gpLG4ucHJvcGVydGllcz1lfHx7fSxuLmdlb21ldHJ5PXQsbn1mdW5jdGlvbiBuKHQsZSxuKXtpZih2b2lkIDA9PT1uJiYobj17fSksIXQpdGhyb3cgbmV3IEVycm9yKFwiY29vcmRpbmF0ZXMgaXMgcmVxdWlyZWRcIik7aWYoIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IEVycm9yKFwiY29vcmRpbmF0ZXMgbXVzdCBiZSBhbiBBcnJheVwiKTtpZih0Lmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgYmUgYXQgbGVhc3QgMiBudW1iZXJzIGxvbmdcIik7aWYoIWQodFswXSl8fCFkKHRbMV0pKXRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgY29udGFpbiBudW1iZXJzXCIpO3JldHVybiBpKHt0eXBlOlwiUG9pbnRcIixjb29yZGluYXRlczp0fSxlLG4pfWZ1bmN0aW9uIHIodCxlLG4pe3ZvaWQgMD09PW4mJihuPXt9KTtmb3IodmFyIHI9MCxhPXQ7cjxhLmxlbmd0aDtyKyspe3ZhciBvPWFbcl07aWYoby5sZW5ndGg8NCl0aHJvdyBuZXcgRXJyb3IoXCJFYWNoIExpbmVhclJpbmcgb2YgYSBQb2x5Z29uIG11c3QgaGF2ZSA0IG9yIG1vcmUgUG9zaXRpb25zLlwiKTtmb3IodmFyIHM9MDtzPG9bby5sZW5ndGgtMV0ubGVuZ3RoO3MrKylpZihvW28ubGVuZ3RoLTFdW3NdIT09b1swXVtzXSl0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhbmQgbGFzdCBQb3NpdGlvbiBhcmUgbm90IGVxdWl2YWxlbnQuXCIpfXJldHVybiBpKHt0eXBlOlwiUG9seWdvblwiLGNvb3JkaW5hdGVzOnR9LGUsbil9ZnVuY3Rpb24gYSh0LGUsbil7aWYodm9pZCAwPT09biYmKG49e30pLHQubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwiY29vcmRpbmF0ZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0d28gb3IgbW9yZSBwb3NpdGlvbnNcIik7cmV0dXJuIGkoe3R5cGU6XCJMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6dH0sZSxuKX1mdW5jdGlvbiBvKHQsZSl7dm9pZCAwPT09ZSYmKGU9e30pO3ZhciBpPXt0eXBlOlwiRmVhdHVyZUNvbGxlY3Rpb25cIn07cmV0dXJuIGUuaWQmJihpLmlkPWUuaWQpLGUuYmJveCYmKGkuYmJveD1lLmJib3gpLGkuZmVhdHVyZXM9dCxpfWZ1bmN0aW9uIHModCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj17fSksaSh7dHlwZTpcIk11bHRpTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOnR9LGUsbil9ZnVuY3Rpb24gbCh0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPXt9KSxpKHt0eXBlOlwiTXVsdGlQb2ludFwiLGNvb3JkaW5hdGVzOnR9LGUsbil9ZnVuY3Rpb24gaCh0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPXt9KSxpKHt0eXBlOlwiTXVsdGlQb2x5Z29uXCIsY29vcmRpbmF0ZXM6dH0sZSxuKX1mdW5jdGlvbiB1KHQsaSl7dm9pZCAwPT09aSYmKGk9XCJraWxvbWV0ZXJzXCIpO3ZhciBuPWUuZmFjdG9yc1tpXTtpZighbil0aHJvdyBuZXcgRXJyb3IoaStcIiB1bml0cyBpcyBpbnZhbGlkXCIpO3JldHVybiB0Km59ZnVuY3Rpb24gYyh0LGkpe3ZvaWQgMD09PWkmJihpPVwia2lsb21ldGVyc1wiKTt2YXIgbj1lLmZhY3RvcnNbaV07aWYoIW4pdGhyb3cgbmV3IEVycm9yKGkrXCIgdW5pdHMgaXMgaW52YWxpZFwiKTtyZXR1cm4gdC9ufWZ1bmN0aW9uIHAodCl7cmV0dXJuIDE4MCoodCUoMipNYXRoLlBJKSkvTWF0aC5QSX1mdW5jdGlvbiBkKHQpe3JldHVybiFpc05hTih0KSYmbnVsbCE9PXQmJiFBcnJheS5pc0FycmF5KHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZWFydGhSYWRpdXM9NjM3MTAwOC44LGUuZmFjdG9ycz17Y2VudGltZXRlcnM6MTAwKmUuZWFydGhSYWRpdXMsY2VudGltZXRyZXM6MTAwKmUuZWFydGhSYWRpdXMsZGVncmVlczplLmVhcnRoUmFkaXVzLzExMTMyNSxmZWV0OjMuMjgwODQqZS5lYXJ0aFJhZGl1cyxpbmNoZXM6MzkuMzcqZS5lYXJ0aFJhZGl1cyxraWxvbWV0ZXJzOmUuZWFydGhSYWRpdXMvMWUzLGtpbG9tZXRyZXM6ZS5lYXJ0aFJhZGl1cy8xZTMsbWV0ZXJzOmUuZWFydGhSYWRpdXMsbWV0cmVzOmUuZWFydGhSYWRpdXMsbWlsZXM6ZS5lYXJ0aFJhZGl1cy8xNjA5LjM0NCxtaWxsaW1ldGVyczoxZTMqZS5lYXJ0aFJhZGl1cyxtaWxsaW1ldHJlczoxZTMqZS5lYXJ0aFJhZGl1cyxuYXV0aWNhbG1pbGVzOmUuZWFydGhSYWRpdXMvMTg1MixyYWRpYW5zOjEseWFyZHM6MS4wOTM2KmUuZWFydGhSYWRpdXN9LGUudW5pdHNGYWN0b3JzPXtjZW50aW1ldGVyczoxMDAsY2VudGltZXRyZXM6MTAwLGRlZ3JlZXM6MS8xMTEzMjUsZmVldDozLjI4MDg0LGluY2hlczozOS4zNyxraWxvbWV0ZXJzOi4wMDEsa2lsb21ldHJlczouMDAxLG1ldGVyczoxLG1ldHJlczoxLG1pbGVzOjEvMTYwOS4zNDQsbWlsbGltZXRlcnM6MWUzLG1pbGxpbWV0cmVzOjFlMyxuYXV0aWNhbG1pbGVzOjEvMTg1MixyYWRpYW5zOjEvZS5lYXJ0aFJhZGl1cyx5YXJkczoxLjA5MzYxMzN9LGUuYXJlYUZhY3RvcnM9e2FjcmVzOjI0NzEwNWUtOSxjZW50aW1ldGVyczoxZTQsY2VudGltZXRyZXM6MWU0LGZlZXQ6MTAuNzYzOTEwNDE3LGhlY3RhcmVzOjFlLTQsaW5jaGVzOjE1NTAuMDAzMTAwMDA2LGtpbG9tZXRlcnM6MWUtNixraWxvbWV0cmVzOjFlLTYsbWV0ZXJzOjEsbWV0cmVzOjEsbWlsZXM6Mzg2ZS05LG1pbGxpbWV0ZXJzOjFlNixtaWxsaW1ldHJlczoxZTYseWFyZHM6MS4xOTU5OTAwNDZ9LGUuZmVhdHVyZT1pLGUuZ2VvbWV0cnk9ZnVuY3Rpb24odCxlLGkpe3N3aXRjaCh2b2lkIDA9PT1pJiYoaT17fSksdCl7Y2FzZVwiUG9pbnRcIjpyZXR1cm4gbihlKS5nZW9tZXRyeTtjYXNlXCJMaW5lU3RyaW5nXCI6cmV0dXJuIGEoZSkuZ2VvbWV0cnk7Y2FzZVwiUG9seWdvblwiOnJldHVybiByKGUpLmdlb21ldHJ5O2Nhc2VcIk11bHRpUG9pbnRcIjpyZXR1cm4gbChlKS5nZW9tZXRyeTtjYXNlXCJNdWx0aUxpbmVTdHJpbmdcIjpyZXR1cm4gcyhlKS5nZW9tZXRyeTtjYXNlXCJNdWx0aVBvbHlnb25cIjpyZXR1cm4gaChlKS5nZW9tZXRyeTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcih0K1wiIGlzIGludmFsaWRcIil9fSxlLnBvaW50PW4sZS5wb2ludHM9ZnVuY3Rpb24odCxlLGkpe3JldHVybiB2b2lkIDA9PT1pJiYoaT17fSksbyh0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG4odCxlKX0pKSxpKX0sZS5wb2x5Z29uPXIsZS5wb2x5Z29ucz1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIHZvaWQgMD09PWkmJihpPXt9KSxvKHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gcih0LGUpfSkpLGkpfSxlLmxpbmVTdHJpbmc9YSxlLmxpbmVTdHJpbmdzPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9e30pLG8odC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBhKHQsZSl9KSksaSl9LGUuZmVhdHVyZUNvbGxlY3Rpb249byxlLm11bHRpTGluZVN0cmluZz1zLGUubXVsdGlQb2ludD1sLGUubXVsdGlQb2x5Z29uPWgsZS5nZW9tZXRyeUNvbGxlY3Rpb249ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj17fSksaSh7dHlwZTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLGdlb21ldHJpZXM6dH0sZSxuKX0sZS5yb3VuZD1mdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PWUmJihlPTApLGUmJiEoZT49MCkpdGhyb3cgbmV3IEVycm9yKFwicHJlY2lzaW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7dmFyIGk9TWF0aC5wb3coMTAsZXx8MCk7cmV0dXJuIE1hdGgucm91bmQodCppKS9pfSxlLnJhZGlhbnNUb0xlbmd0aD11LGUubGVuZ3RoVG9SYWRpYW5zPWMsZS5sZW5ndGhUb0RlZ3JlZXM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcChjKHQsZSkpfSxlLmJlYXJpbmdUb0F6aW11dGg9ZnVuY3Rpb24odCl7dmFyIGU9dCUzNjA7cmV0dXJuIGU8MCYmKGUrPTM2MCksZX0sZS5yYWRpYW5zVG9EZWdyZWVzPXAsZS5kZWdyZWVzVG9SYWRpYW5zPWZ1bmN0aW9uKHQpe3JldHVybiB0JTM2MCpNYXRoLlBJLzE4MH0sZS5jb252ZXJ0TGVuZ3RoPWZ1bmN0aW9uKHQsZSxpKXtpZih2b2lkIDA9PT1lJiYoZT1cImtpbG9tZXRlcnNcIiksdm9pZCAwPT09aSYmKGk9XCJraWxvbWV0ZXJzXCIpLCEodD49MCkpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7cmV0dXJuIHUoYyh0LGUpLGkpfSxlLmNvbnZlcnRBcmVhPWZ1bmN0aW9uKHQsaSxuKXtpZih2b2lkIDA9PT1pJiYoaT1cIm1ldGVyc1wiKSx2b2lkIDA9PT1uJiYobj1cImtpbG9tZXRlcnNcIiksISh0Pj0wKSl0aHJvdyBuZXcgRXJyb3IoXCJhcmVhIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7dmFyIHI9ZS5hcmVhRmFjdG9yc1tpXTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG9yaWdpbmFsIHVuaXRzXCIpO3ZhciBhPWUuYXJlYUZhY3RvcnNbbl07aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaW5hbCB1bml0c1wiKTtyZXR1cm4gdC9yKmF9LGUuaXNOdW1iZXI9ZCxlLmlzT2JqZWN0PWZ1bmN0aW9uKHQpe3JldHVybiEhdCYmdC5jb25zdHJ1Y3Rvcj09PU9iamVjdH0sZS52YWxpZGF0ZUJCb3g9ZnVuY3Rpb24odCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiYmJveCBpcyByZXF1aXJlZFwiKTtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgRXJyb3IoXCJiYm94IG11c3QgYmUgYW4gQXJyYXlcIik7aWYoNCE9PXQubGVuZ3RoJiY2IT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYmJveCBtdXN0IGJlIGFuIEFycmF5IG9mIDQgb3IgNiBudW1iZXJzXCIpO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYoIWQodCkpdGhyb3cgbmV3IEVycm9yKFwiYmJveCBtdXN0IG9ubHkgY29udGFpbiBudW1iZXJzXCIpfSkpfSxlLnZhbGlkYXRlSWQ9ZnVuY3Rpb24odCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiaWQgaXMgcmVxdWlyZWRcIik7aWYoLTE9PT1bXCJzdHJpbmdcIixcIm51bWJlclwiXS5pbmRleE9mKHR5cGVvZiB0KSl0aHJvdyBuZXcgRXJyb3IoXCJpZCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpfX0sMTU0MDoodCxlLGkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49aSg0MTAyKTtmdW5jdGlvbiByKHQsZSxpKXtpZihudWxsIT09dClmb3IodmFyIG4sYSxvLHMsbCxoLHUsYyxwPTAsZD0wLGY9dC50eXBlLGc9XCJGZWF0dXJlQ29sbGVjdGlvblwiPT09ZixfPVwiRmVhdHVyZVwiPT09ZixtPWc/dC5mZWF0dXJlcy5sZW5ndGg6MSx5PTA7eTxtO3krKyl7bD0oYz0hISh1PWc/dC5mZWF0dXJlc1t5XS5nZW9tZXRyeTpfP3QuZ2VvbWV0cnk6dCkmJlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT11LnR5cGUpP3UuZ2VvbWV0cmllcy5sZW5ndGg6MTtmb3IodmFyIHY9MDt2PGw7disrKXt2YXIgTD0wLGI9MDtpZihudWxsIT09KHM9Yz91Lmdlb21ldHJpZXNbdl06dSkpe2g9cy5jb29yZGluYXRlczt2YXIgaz1zLnR5cGU7c3dpdGNoKHA9IWl8fFwiUG9seWdvblwiIT09ayYmXCJNdWx0aVBvbHlnb25cIiE9PWs/MDoxLGspe2Nhc2UgbnVsbDpicmVhaztjYXNlXCJQb2ludFwiOmlmKCExPT09ZShoLGQseSxMLGIpKXJldHVybiExO2QrKyxMKys7YnJlYWs7Y2FzZVwiTGluZVN0cmluZ1wiOmNhc2VcIk11bHRpUG9pbnRcIjpmb3Iobj0wO248aC5sZW5ndGg7bisrKXtpZighMT09PWUoaFtuXSxkLHksTCxiKSlyZXR1cm4hMTtkKyssXCJNdWx0aVBvaW50XCI9PT1rJiZMKyt9XCJMaW5lU3RyaW5nXCI9PT1rJiZMKys7YnJlYWs7Y2FzZVwiUG9seWdvblwiOmNhc2VcIk11bHRpTGluZVN0cmluZ1wiOmZvcihuPTA7bjxoLmxlbmd0aDtuKyspe2ZvcihhPTA7YTxoW25dLmxlbmd0aC1wO2ErKyl7aWYoITE9PT1lKGhbbl1bYV0sZCx5LEwsYikpcmV0dXJuITE7ZCsrfVwiTXVsdGlMaW5lU3RyaW5nXCI9PT1rJiZMKyssXCJQb2x5Z29uXCI9PT1rJiZiKyt9XCJQb2x5Z29uXCI9PT1rJiZMKys7YnJlYWs7Y2FzZVwiTXVsdGlQb2x5Z29uXCI6Zm9yKG49MDtuPGgubGVuZ3RoO24rKyl7Zm9yKGI9MCxhPTA7YTxoW25dLmxlbmd0aDthKyspe2ZvcihvPTA7bzxoW25dW2FdLmxlbmd0aC1wO28rKyl7aWYoITE9PT1lKGhbbl1bYV1bb10sZCx5LEwsYikpcmV0dXJuITE7ZCsrfWIrK31MKyt9YnJlYWs7Y2FzZVwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6Zm9yKG49MDtuPHMuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWlmKCExPT09cihzLmdlb21ldHJpZXNbbl0sZSxpKSlyZXR1cm4hMTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvbWV0cnkgVHlwZVwiKX19fX19ZnVuY3Rpb24gYSh0LGUpe3ZhciBpO3N3aXRjaCh0LnR5cGUpe2Nhc2VcIkZlYXR1cmVDb2xsZWN0aW9uXCI6Zm9yKGk9MDtpPHQuZmVhdHVyZXMubGVuZ3RoJiYhMSE9PWUodC5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzLGkpO2krKyk7YnJlYWs7Y2FzZVwiRmVhdHVyZVwiOmUodC5wcm9wZXJ0aWVzLDApfX1mdW5jdGlvbiBvKHQsZSl7aWYoXCJGZWF0dXJlXCI9PT10LnR5cGUpZSh0LDApO2Vsc2UgaWYoXCJGZWF0dXJlQ29sbGVjdGlvblwiPT09dC50eXBlKWZvcih2YXIgaT0wO2k8dC5mZWF0dXJlcy5sZW5ndGgmJiExIT09ZSh0LmZlYXR1cmVzW2ldLGkpO2krKyk7fWZ1bmN0aW9uIHModCxlKXt2YXIgaSxuLHIsYSxvLHMsbCxoLHUsYyxwPTAsZD1cIkZlYXR1cmVDb2xsZWN0aW9uXCI9PT10LnR5cGUsZj1cIkZlYXR1cmVcIj09PXQudHlwZSxnPWQ/dC5mZWF0dXJlcy5sZW5ndGg6MTtmb3IoaT0wO2k8ZztpKyspe2ZvcihzPWQ/dC5mZWF0dXJlc1tpXS5nZW9tZXRyeTpmP3QuZ2VvbWV0cnk6dCxoPWQ/dC5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzOmY/dC5wcm9wZXJ0aWVzOnt9LHU9ZD90LmZlYXR1cmVzW2ldLmJib3g6Zj90LmJib3g6dW5kZWZpbmVkLGM9ZD90LmZlYXR1cmVzW2ldLmlkOmY/dC5pZDp1bmRlZmluZWQsbz0obD0hIXMmJlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT1zLnR5cGUpP3MuZ2VvbWV0cmllcy5sZW5ndGg6MSxyPTA7cjxvO3IrKylpZihudWxsIT09KGE9bD9zLmdlb21ldHJpZXNbcl06cykpc3dpdGNoKGEudHlwZSl7Y2FzZVwiUG9pbnRcIjpjYXNlXCJMaW5lU3RyaW5nXCI6Y2FzZVwiTXVsdGlQb2ludFwiOmNhc2VcIlBvbHlnb25cIjpjYXNlXCJNdWx0aUxpbmVTdHJpbmdcIjpjYXNlXCJNdWx0aVBvbHlnb25cIjppZighMT09PWUoYSxwLGgsdSxjKSlyZXR1cm4hMTticmVhaztjYXNlXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjpmb3Iobj0wO248YS5nZW9tZXRyaWVzLmxlbmd0aDtuKyspaWYoITE9PT1lKGEuZ2VvbWV0cmllc1tuXSxwLGgsdSxjKSlyZXR1cm4hMTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvbWV0cnkgVHlwZVwiKX1lbHNlIGlmKCExPT09ZShudWxsLHAsaCx1LGMpKXJldHVybiExO3ArK319ZnVuY3Rpb24gbCh0LGUpe3ModCwoZnVuY3Rpb24odCxpLHIsYSxvKXt2YXIgcyxsPW51bGw9PT10P251bGw6dC50eXBlO3N3aXRjaChsKXtjYXNlIG51bGw6Y2FzZVwiUG9pbnRcIjpjYXNlXCJMaW5lU3RyaW5nXCI6Y2FzZVwiUG9seWdvblwiOnJldHVybiExIT09ZShuLmZlYXR1cmUodCxyLHtiYm94OmEsaWQ6b30pLGksMCkmJnZvaWQgMH1zd2l0Y2gobCl7Y2FzZVwiTXVsdGlQb2ludFwiOnM9XCJQb2ludFwiO2JyZWFrO2Nhc2VcIk11bHRpTGluZVN0cmluZ1wiOnM9XCJMaW5lU3RyaW5nXCI7YnJlYWs7Y2FzZVwiTXVsdGlQb2x5Z29uXCI6cz1cIlBvbHlnb25cIn1mb3IodmFyIGg9MDtoPHQuY29vcmRpbmF0ZXMubGVuZ3RoO2grKyl7dmFyIHU9e3R5cGU6cyxjb29yZGluYXRlczp0LmNvb3JkaW5hdGVzW2hdfTtpZighMT09PWUobi5mZWF0dXJlKHUsciksaSxoKSlyZXR1cm4hMX19KSl9ZnVuY3Rpb24gaCh0LGUpe2wodCwoZnVuY3Rpb24odCxpLGEpe3ZhciBvPTA7aWYodC5nZW9tZXRyeSl7dmFyIHM9dC5nZW9tZXRyeS50eXBlO2lmKFwiUG9pbnRcIiE9PXMmJlwiTXVsdGlQb2ludFwiIT09cyl7dmFyIGwsaD0wLHU9MCxjPTA7cmV0dXJuITEhPT1yKHQsKGZ1bmN0aW9uKHIscyxwLGQsZil7aWYobD09PXVuZGVmaW5lZHx8aT5ofHxkPnV8fGY+YylyZXR1cm4gbD1yLGg9aSx1PWQsYz1mLHZvaWQobz0wKTt2YXIgZz1uLmxpbmVTdHJpbmcoW2wscl0sdC5wcm9wZXJ0aWVzKTtpZighMT09PWUoZyxpLGEsZixvKSlyZXR1cm4hMTtvKyssbD1yfSkpJiZ2b2lkIDB9fX0pKX1mdW5jdGlvbiB1KHQsZSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyByZXF1aXJlZFwiKTtsKHQsKGZ1bmN0aW9uKHQsaSxyKXtpZihudWxsIT09dC5nZW9tZXRyeSl7dmFyIGE9dC5nZW9tZXRyeS50eXBlLG89dC5nZW9tZXRyeS5jb29yZGluYXRlcztzd2l0Y2goYSl7Y2FzZVwiTGluZVN0cmluZ1wiOmlmKCExPT09ZSh0LGksciwwLDApKXJldHVybiExO2JyZWFrO2Nhc2VcIlBvbHlnb25cIjpmb3IodmFyIHM9MDtzPG8ubGVuZ3RoO3MrKylpZighMT09PWUobi5saW5lU3RyaW5nKG9bc10sdC5wcm9wZXJ0aWVzKSxpLHIscykpcmV0dXJuITF9fX0pKX1lLmNvb3JkQWxsPWZ1bmN0aW9uKHQpe3ZhciBlPVtdO3JldHVybiByKHQsKGZ1bmN0aW9uKHQpe2UucHVzaCh0KX0pKSxlfSxlLmNvb3JkRWFjaD1yLGUuY29vcmRSZWR1Y2U9ZnVuY3Rpb24odCxlLGksbil7dmFyIGE9aTtyZXR1cm4gcih0LChmdW5jdGlvbih0LG4scixvLHMpe2E9MD09PW4mJmk9PT11bmRlZmluZWQ/dDplKGEsdCxuLHIsbyxzKX0pLG4pLGF9LGUuZmVhdHVyZUVhY2g9byxlLmZlYXR1cmVSZWR1Y2U9ZnVuY3Rpb24odCxlLGkpe3ZhciBuPWk7cmV0dXJuIG8odCwoZnVuY3Rpb24odCxyKXtuPTA9PT1yJiZpPT09dW5kZWZpbmVkP3Q6ZShuLHQscil9KSksbn0sZS5maW5kUG9pbnQ9ZnVuY3Rpb24odCxlKXtpZihlPWV8fHt9LCFuLmlzT2JqZWN0KGUpKXRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMgaXMgaW52YWxpZFwiKTt2YXIgaSxyPWUuZmVhdHVyZUluZGV4fHwwLGE9ZS5tdWx0aUZlYXR1cmVJbmRleHx8MCxvPWUuZ2VvbWV0cnlJbmRleHx8MCxzPWUuY29vcmRJbmRleHx8MCxsPWUucHJvcGVydGllcztzd2l0Y2godC50eXBlKXtjYXNlXCJGZWF0dXJlQ29sbGVjdGlvblwiOnI8MCYmKHI9dC5mZWF0dXJlcy5sZW5ndGgrciksbD1sfHx0LmZlYXR1cmVzW3JdLnByb3BlcnRpZXMsaT10LmZlYXR1cmVzW3JdLmdlb21ldHJ5O2JyZWFrO2Nhc2VcIkZlYXR1cmVcIjpsPWx8fHQucHJvcGVydGllcyxpPXQuZ2VvbWV0cnk7YnJlYWs7Y2FzZVwiUG9pbnRcIjpjYXNlXCJNdWx0aVBvaW50XCI6cmV0dXJuIG51bGw7Y2FzZVwiTGluZVN0cmluZ1wiOmNhc2VcIlBvbHlnb25cIjpjYXNlXCJNdWx0aUxpbmVTdHJpbmdcIjpjYXNlXCJNdWx0aVBvbHlnb25cIjppPXQ7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIGludmFsaWRcIil9aWYobnVsbD09PWkpcmV0dXJuIG51bGw7dmFyIGg9aS5jb29yZGluYXRlcztzd2l0Y2goaS50eXBlKXtjYXNlXCJQb2ludFwiOnJldHVybiBuLnBvaW50KGgsbCxlKTtjYXNlXCJNdWx0aVBvaW50XCI6cmV0dXJuIGE8MCYmKGE9aC5sZW5ndGgrYSksbi5wb2ludChoW2FdLGwsZSk7Y2FzZVwiTGluZVN0cmluZ1wiOnJldHVybiBzPDAmJihzPWgubGVuZ3RoK3MpLG4ucG9pbnQoaFtzXSxsLGUpO2Nhc2VcIlBvbHlnb25cIjpyZXR1cm4gbzwwJiYobz1oLmxlbmd0aCtvKSxzPDAmJihzPWhbb10ubGVuZ3RoK3MpLG4ucG9pbnQoaFtvXVtzXSxsLGUpO2Nhc2VcIk11bHRpTGluZVN0cmluZ1wiOnJldHVybiBhPDAmJihhPWgubGVuZ3RoK2EpLHM8MCYmKHM9aFthXS5sZW5ndGgrcyksbi5wb2ludChoW2FdW3NdLGwsZSk7Y2FzZVwiTXVsdGlQb2x5Z29uXCI6cmV0dXJuIGE8MCYmKGE9aC5sZW5ndGgrYSksbzwwJiYobz1oW2FdLmxlbmd0aCtvKSxzPDAmJihzPWhbYV1bb10ubGVuZ3RoLXMpLG4ucG9pbnQoaFthXVtvXVtzXSxsLGUpfXRocm93IG5ldyBFcnJvcihcImdlb2pzb24gaXMgaW52YWxpZFwiKX0sZS5maW5kU2VnbWVudD1mdW5jdGlvbih0LGUpe2lmKGU9ZXx8e30sIW4uaXNPYmplY3QoZSkpdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucyBpcyBpbnZhbGlkXCIpO3ZhciBpLHI9ZS5mZWF0dXJlSW5kZXh8fDAsYT1lLm11bHRpRmVhdHVyZUluZGV4fHwwLG89ZS5nZW9tZXRyeUluZGV4fHwwLHM9ZS5zZWdtZW50SW5kZXh8fDAsbD1lLnByb3BlcnRpZXM7c3dpdGNoKHQudHlwZSl7Y2FzZVwiRmVhdHVyZUNvbGxlY3Rpb25cIjpyPDAmJihyPXQuZmVhdHVyZXMubGVuZ3RoK3IpLGw9bHx8dC5mZWF0dXJlc1tyXS5wcm9wZXJ0aWVzLGk9dC5mZWF0dXJlc1tyXS5nZW9tZXRyeTticmVhaztjYXNlXCJGZWF0dXJlXCI6bD1sfHx0LnByb3BlcnRpZXMsaT10Lmdlb21ldHJ5O2JyZWFrO2Nhc2VcIlBvaW50XCI6Y2FzZVwiTXVsdGlQb2ludFwiOnJldHVybiBudWxsO2Nhc2VcIkxpbmVTdHJpbmdcIjpjYXNlXCJQb2x5Z29uXCI6Y2FzZVwiTXVsdGlMaW5lU3RyaW5nXCI6Y2FzZVwiTXVsdGlQb2x5Z29uXCI6aT10O2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyBpbnZhbGlkXCIpfWlmKG51bGw9PT1pKXJldHVybiBudWxsO3ZhciBoPWkuY29vcmRpbmF0ZXM7c3dpdGNoKGkudHlwZSl7Y2FzZVwiUG9pbnRcIjpjYXNlXCJNdWx0aVBvaW50XCI6cmV0dXJuIG51bGw7Y2FzZVwiTGluZVN0cmluZ1wiOnJldHVybiBzPDAmJihzPWgubGVuZ3RoK3MtMSksbi5saW5lU3RyaW5nKFtoW3NdLGhbcysxXV0sbCxlKTtjYXNlXCJQb2x5Z29uXCI6cmV0dXJuIG88MCYmKG89aC5sZW5ndGgrbyksczwwJiYocz1oW29dLmxlbmd0aCtzLTEpLG4ubGluZVN0cmluZyhbaFtvXVtzXSxoW29dW3MrMV1dLGwsZSk7Y2FzZVwiTXVsdGlMaW5lU3RyaW5nXCI6cmV0dXJuIGE8MCYmKGE9aC5sZW5ndGgrYSksczwwJiYocz1oW2FdLmxlbmd0aCtzLTEpLG4ubGluZVN0cmluZyhbaFthXVtzXSxoW2FdW3MrMV1dLGwsZSk7Y2FzZVwiTXVsdGlQb2x5Z29uXCI6cmV0dXJuIGE8MCYmKGE9aC5sZW5ndGgrYSksbzwwJiYobz1oW2FdLmxlbmd0aCtvKSxzPDAmJihzPWhbYV1bb10ubGVuZ3RoLXMtMSksbi5saW5lU3RyaW5nKFtoW2FdW29dW3NdLGhbYV1bb11bcysxXV0sbCxlKX10aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIGludmFsaWRcIil9LGUuZmxhdHRlbkVhY2g9bCxlLmZsYXR0ZW5SZWR1Y2U9ZnVuY3Rpb24odCxlLGkpe3ZhciBuPWk7cmV0dXJuIGwodCwoZnVuY3Rpb24odCxyLGEpe249MD09PXImJjA9PT1hJiZpPT09dW5kZWZpbmVkP3Q6ZShuLHQscixhKX0pKSxufSxlLmdlb21FYWNoPXMsZS5nZW9tUmVkdWNlPWZ1bmN0aW9uKHQsZSxpKXt2YXIgbj1pO3JldHVybiBzKHQsKGZ1bmN0aW9uKHQscixhLG8scyl7bj0wPT09ciYmaT09PXVuZGVmaW5lZD90OmUobix0LHIsYSxvLHMpfSkpLG59LGUubGluZUVhY2g9dSxlLmxpbmVSZWR1Y2U9ZnVuY3Rpb24odCxlLGkpe3ZhciBuPWk7cmV0dXJuIHUodCwoZnVuY3Rpb24odCxyLGEsbyl7bj0wPT09ciYmaT09PXVuZGVmaW5lZD90OmUobix0LHIsYSxvKX0pKSxufSxlLnByb3BFYWNoPWEsZS5wcm9wUmVkdWNlPWZ1bmN0aW9uKHQsZSxpKXt2YXIgbj1pO3JldHVybiBhKHQsKGZ1bmN0aW9uKHQscil7bj0wPT09ciYmaT09PXVuZGVmaW5lZD90OmUobix0LHIpfSkpLG59LGUuc2VnbWVudEVhY2g9aCxlLnNlZ21lbnRSZWR1Y2U9ZnVuY3Rpb24odCxlLGkpe3ZhciBuPWkscj0hMTtyZXR1cm4gaCh0LChmdW5jdGlvbih0LGEsbyxzLGwpe249ITE9PT1yJiZpPT09dW5kZWZpbmVkP3Q6ZShuLHQsYSxvLHMsbCkscj0hMH0pKSxufX0sNDE0Oih0LGUsaSk9PntcInVzZSBzdHJpY3RcIjtpKDcxMDcpO3ZhciBuPWkoMjQ5Mikscj1pLm4obik7Y29uc3QgYT1KU09OLnBhcnNlKCd7XCJ0b29sdGlwc1wiOntcInBsYWNlTWFya2VyXCI6XCJDbGljayB0byBwbGFjZSBtYXJrZXJcIixcImZpcnN0VmVydGV4XCI6XCJDbGljayB0byBwbGFjZSBmaXJzdCB2ZXJ0ZXhcIixcImNvbnRpbnVlTGluZVwiOlwiQ2xpY2sgdG8gY29udGludWUgZHJhd2luZ1wiLFwiZmluaXNoTGluZVwiOlwiQ2xpY2sgYW55IGV4aXN0aW5nIG1hcmtlciB0byBmaW5pc2hcIixcImZpbmlzaFBvbHlcIjpcIkNsaWNrIGZpcnN0IG1hcmtlciB0byBmaW5pc2hcIixcImZpbmlzaFJlY3RcIjpcIkNsaWNrIHRvIGZpbmlzaFwiLFwic3RhcnRDaXJjbGVcIjpcIkNsaWNrIHRvIHBsYWNlIGNpcmNsZSBjZW50ZXJcIixcImZpbmlzaENpcmNsZVwiOlwiQ2xpY2sgdG8gZmluaXNoIGNpcmNsZVwiLFwicGxhY2VDaXJjbGVNYXJrZXJcIjpcIkNsaWNrIHRvIHBsYWNlIGNpcmNsZSBtYXJrZXJcIixcInBsYWNlVGV4dFwiOlwiQ2xpY2sgdG8gcGxhY2UgdGV4dFwifSxcImFjdGlvbnNcIjp7XCJmaW5pc2hcIjpcIkZpbmlzaFwiLFwiY2FuY2VsXCI6XCJDYW5jZWxcIixcInJlbW92ZUxhc3RWZXJ0ZXhcIjpcIlJlbW92ZSBMYXN0IFZlcnRleFwifSxcImJ1dHRvblRpdGxlc1wiOntcImRyYXdNYXJrZXJCdXR0b25cIjpcIkRyYXcgTWFya2VyXCIsXCJkcmF3UG9seUJ1dHRvblwiOlwiRHJhdyBQb2x5Z29uc1wiLFwiZHJhd0xpbmVCdXR0b25cIjpcIkRyYXcgUG9seWxpbmVcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcIkRyYXcgQ2lyY2xlXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwiRHJhdyBSZWN0YW5nbGVcIixcImVkaXRCdXR0b25cIjpcIkVkaXQgTGF5ZXJzXCIsXCJkcmFnQnV0dG9uXCI6XCJEcmFnIExheWVyc1wiLFwiY3V0QnV0dG9uXCI6XCJDdXQgTGF5ZXJzXCIsXCJkZWxldGVCdXR0b25cIjpcIlJlbW92ZSBMYXllcnNcIixcImRyYXdDaXJjbGVNYXJrZXJCdXR0b25cIjpcIkRyYXcgQ2lyY2xlIE1hcmtlclwiLFwic25hcHBpbmdCdXR0b25cIjpcIlNuYXAgZHJhZ2dlZCBtYXJrZXIgdG8gb3RoZXIgbGF5ZXJzIGFuZCB2ZXJ0aWNlc1wiLFwicGlubmluZ0J1dHRvblwiOlwiUGluIHNoYXJlZCB2ZXJ0aWNlcyB0b2dldGhlclwiLFwicm90YXRlQnV0dG9uXCI6XCJSb3RhdGUgTGF5ZXJzXCIsXCJkcmF3VGV4dEJ1dHRvblwiOlwiRHJhdyBUZXh0XCJ9fScpLG89SlNPTi5wYXJzZSgne1widG9vbHRpcHNcIjp7XCJwbGFjZU1hcmtlclwiOlwiUGxhdHppZXJlIGRlbiBNYXJrZXIgbWl0IEtsaWNrXCIsXCJmaXJzdFZlcnRleFwiOlwiUGxhdHppZXJlIGRlbiBlcnN0ZW4gTWFya2VyIG1pdCBLbGlja1wiLFwiY29udGludWVMaW5lXCI6XCJLbGlja2UsIHVtIHdlaXRlciB6dSB6ZWljaG5lblwiLFwiZmluaXNoTGluZVwiOlwiQmVlbmRlIG1pdCBLbGljayBhdWYgZXhpc3RpZXJlbmRlbiBNYXJrZXJcIixcImZpbmlzaFBvbHlcIjpcIkJlZW5kZSBtaXQgS2xpY2sgYXVmIGVyc3RlbiBNYXJrZXJcIixcImZpbmlzaFJlY3RcIjpcIkJlZW5kZSBtaXQgS2xpY2tcIixcInN0YXJ0Q2lyY2xlXCI6XCJQbGF0emllcmUgZGFzIEtyZWlzemVudHJ1bSBtaXQgS2xpY2tcIixcImZpbmlzaENpcmNsZVwiOlwiQmVlbmRlIGRlbiBLcmVpcyBtaXQgS2xpY2tcIixcInBsYWNlQ2lyY2xlTWFya2VyXCI6XCJQbGF0emllcmUgZGVuIEtyZWlzbWFya2VyIG1pdCBLbGlja1wiLFwicGxhY2VUZXh0XCI6XCJQbGF0emllcmUgZGVuIFRleHQgbWl0IEtsaWNrXCJ9LFwiYWN0aW9uc1wiOntcImZpbmlzaFwiOlwiQmVlbmRlblwiLFwiY2FuY2VsXCI6XCJBYmJyZWNoZW5cIixcInJlbW92ZUxhc3RWZXJ0ZXhcIjpcIkxldHp0ZW4gVmVydGV4IGzDtnNjaGVuXCJ9LFwiYnV0dG9uVGl0bGVzXCI6e1wiZHJhd01hcmtlckJ1dHRvblwiOlwiTWFya2VyIHplaWNobmVuXCIsXCJkcmF3UG9seUJ1dHRvblwiOlwiUG9seWdvbiB6ZWljaG5lblwiLFwiZHJhd0xpbmVCdXR0b25cIjpcIlBvbHlsaW5lIHplaWNobmVuXCIsXCJkcmF3Q2lyY2xlQnV0dG9uXCI6XCJLcmVpcyB6ZWljaG5lblwiLFwiZHJhd1JlY3RCdXR0b25cIjpcIlJlY2h0ZWNrIHplaWNobmVuXCIsXCJlZGl0QnV0dG9uXCI6XCJMYXllciBlZGl0aWVyZW5cIixcImRyYWdCdXR0b25cIjpcIkxheWVyIGJld2VnZW5cIixcImN1dEJ1dHRvblwiOlwiTGF5ZXIgc2NobmVpZGVuXCIsXCJkZWxldGVCdXR0b25cIjpcIkxheWVyIGzDtnNjaGVuXCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCJLcmVpc21hcmtlciB6ZWljaG5lblwiLFwic25hcHBpbmdCdXR0b25cIjpcIkJld2VndGVyIExheWVyIGFuIGFuZGVyZSBMYXllciBvZGVyIFZlcnRleGUgZWluaGFja2VuXCIsXCJwaW5uaW5nQnV0dG9uXCI6XCJWZXJ0ZXhlIGFuIGRlciBnbGVpY2hlbiBQb3NpdGlvbiB2ZXJrbsO8cGZlblwiLFwicm90YXRlQnV0dG9uXCI6XCJMYXllciBkcmVoZW5cIixcImRyYXdUZXh0QnV0dG9uXCI6XCJUZXh0IHplaWNobmVuXCJ9fScpLHM9SlNPTi5wYXJzZSgne1widG9vbHRpcHNcIjp7XCJwbGFjZU1hcmtlclwiOlwiQ2xpY2NhIHBlciBwb3NpemlvbmFyZSB1biBNYXJrZXJcIixcImZpcnN0VmVydGV4XCI6XCJDbGljY2EgcGVyIHBvc2l6aW9uYXJlIGlsIHByaW1vIHZlcnRpY2VcIixcImNvbnRpbnVlTGluZVwiOlwiQ2xpY2NhIHBlciBjb250aW51YXJlIGEgZGlzZWduYXJlXCIsXCJmaW5pc2hMaW5lXCI6XCJDbGljY2EgcXVhbHNpYXNpIG1hcmtlciBlc2lzdGVudGUgcGVyIHRlcm1pbmFyZVwiLFwiZmluaXNoUG9seVwiOlwiQ2xpY2NhIGlsIHByaW1vIG1hcmtlciBwZXIgdGVybWluYXJlXCIsXCJmaW5pc2hSZWN0XCI6XCJDbGljY2EgcGVyIHRlcm1pbmFyZVwiLFwic3RhcnRDaXJjbGVcIjpcIkNsaWNjYSBwZXIgcG9zaXppb25hcmUgaWwgcHVudG8gY2VudHJhbGUgZGVsIGNlcmNoaW9cIixcImZpbmlzaENpcmNsZVwiOlwiQ2xpY2NhIHBlciB0ZXJtaW5hcmUgaWwgY2VyY2hpb1wiLFwicGxhY2VDaXJjbGVNYXJrZXJcIjpcIkNsaWNjYSBwZXIgcG9zaXppb25hcmUgdW4gTWFya2VyIGRlbCBjaGVyY2hpb1wifSxcImFjdGlvbnNcIjp7XCJmaW5pc2hcIjpcIlRlcm1pbmFcIixcImNhbmNlbFwiOlwiQW5udWxsYVwiLFwicmVtb3ZlTGFzdFZlcnRleFwiOlwiUmltdW92aSBsXFwndWx0aW1vIHZlcnRpY2VcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCJEaXNlZ25hIE1hcmtlclwiLFwiZHJhd1BvbHlCdXR0b25cIjpcIkRpc2VnbmEgUG9saWdvbmlcIixcImRyYXdMaW5lQnV0dG9uXCI6XCJEaXNlZ25hIFBvbGlsaW5lYVwiLFwiZHJhd0NpcmNsZUJ1dHRvblwiOlwiRGlzZWduYSBDZXJjaGlvXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwiRGlzZWduYSBSZXR0YW5nb2xvXCIsXCJlZGl0QnV0dG9uXCI6XCJNb2RpZmljYSBMaXZlbGxpXCIsXCJkcmFnQnV0dG9uXCI6XCJTcG9zdGEgTGl2ZWxsaVwiLFwiY3V0QnV0dG9uXCI6XCJSaXRhZ2xpYSBMaXZlbGxpXCIsXCJkZWxldGVCdXR0b25cIjpcIkVsaW1pbmEgTGl2ZWxsaVwiLFwiZHJhd0NpcmNsZU1hcmtlckJ1dHRvblwiOlwiRGlzZWduYSBNYXJrZXIgZGVsIENlcmNoaW9cIixcInNuYXBwaW5nQnV0dG9uXCI6XCJTbmFwIGhhIHRyYXNjaW5hdG8gaWwgcGVubmFyZWxsbyBzdSBhbHRyaSBzdHJhdGkgZSB2ZXJ0aWNpXCIsXCJwaW5uaW5nQnV0dG9uXCI6XCJQaW4gY29uZGl2aXNvIHZlcnRpY2kgaW5zaWVtZVwifX0nKSxsPUpTT04ucGFyc2UoJ3tcInRvb2x0aXBzXCI6e1wicGxhY2VNYXJrZXJcIjpcIktsaWsgdW50dWsgbWVuZW1wYXRrYW4gbWFya2VyXCIsXCJmaXJzdFZlcnRleFwiOlwiS2xpayB1bnR1ayBtZW5lbXBhdGthbiB2ZXJ0ZXggcGVydGFtYVwiLFwiY29udGludWVMaW5lXCI6XCJLbGlrIHVudHVrIG1lbmVydXNrYW4gZGlnaXRhc2lcIixcImZpbmlzaExpbmVcIjpcIktsaWsgcGFkYSBzZW1iYXJhbmcgbWFya2VyIHlhbmcgYWRhIHVudHVrIG1lbmdha2hpcmlcIixcImZpbmlzaFBvbHlcIjpcIktsaWsgbWFya2VyIHBlcnRhbWEgdW50dWsgbWVuZ2FraGlyaVwiLFwiZmluaXNoUmVjdFwiOlwiS2xpayB1bnR1ayBtZW5nYWtoaXJpXCIsXCJzdGFydENpcmNsZVwiOlwiS2xpayB1bnR1ayBtZW5lbXBhdGthbiB0aXRpayBwdXNhdCBsaW5na2FyYW5cIixcImZpbmlzaENpcmNsZVwiOlwiS2xpayB1bnR1ayBtZW5nYWtoaXJpIGxpbmdrYXJhblwiLFwicGxhY2VDaXJjbGVNYXJrZXJcIjpcIktsaWsgdW50dWsgbWVuZW1wYXRrYW4gcGVuYW5kYSBsaW5na2FyYW5uXCJ9LFwiYWN0aW9uc1wiOntcImZpbmlzaFwiOlwiU2VsZXNhaVwiLFwiY2FuY2VsXCI6XCJCYXRhbFwiLFwicmVtb3ZlTGFzdFZlcnRleFwiOlwiSGlsYW5na2FuIFZlcnRleCBUZXJha2hpclwifSxcImJ1dHRvblRpdGxlc1wiOntcImRyYXdNYXJrZXJCdXR0b25cIjpcIkRpZ2l0YXNpIE1hcmtlclwiLFwiZHJhd1BvbHlCdXR0b25cIjpcIkRpZ2l0YXNpIFBvbHlnb25cIixcImRyYXdMaW5lQnV0dG9uXCI6XCJEaWdpdGFzaSBQb2x5bGluZVwiLFwiZHJhd0NpcmNsZUJ1dHRvblwiOlwiRGlnaXRhc2kgTGluZ2thcmFuXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwiRGlnaXRhc2kgU2VnaSBFbXBhdFwiLFwiZWRpdEJ1dHRvblwiOlwiRWRpdCBMYXllclwiLFwiZHJhZ0J1dHRvblwiOlwiR2VzZXIgTGF5ZXJcIixcImN1dEJ1dHRvblwiOlwiUG90b25nIExheWVyXCIsXCJkZWxldGVCdXR0b25cIjpcIkhpbGFuZ2thbiBMYXllclwiLFwiZHJhd0NpcmNsZU1hcmtlckJ1dHRvblwiOlwiRGlnaXRhc2kgUGVuYW5kYSBMaW5na2FyYW5cIixcInNuYXBwaW5nQnV0dG9uXCI6XCJKZXByZXRrYW4gcGVuYW5kYSB5YW5nIGRpdGFyaWsga2UgbGFwaXNhbiBkYW4gc2ltcHVsIGxhaW5cIixcInBpbm5pbmdCdXR0b25cIjpcIlNlbWF0a2FuIHNpbXB1bCBiZXJzYW1hIGJlcnNhbWFcIn19JyksaD1KU09OLnBhcnNlKCd7XCJ0b29sdGlwc1wiOntcInBsYWNlTWFya2VyXCI6XCJBZGF1Z8SDIHVuIHB1bmN0XCIsXCJmaXJzdFZlcnRleFwiOlwiQXBhc8SDIGFpY2kgcGVudHJ1IGEgYWTEg3VnYSBwcmltdWwgVmVydGV4XCIsXCJjb250aW51ZUxpbmVcIjpcIkFwYXPEgyBhaWNpIHBlbnRydSBhIGNvbnRpbnVhIGRlc2VudWxcIixcImZpbmlzaExpbmVcIjpcIkFwYXPEgyBwZSBvcmljZSBvYmllY3QgcGVudHJ1IGEgZmluaXNhIGRlc2VudWxcIixcImZpbmlzaFBvbHlcIjpcIkFwYXPEgyBwZSBwcmltdWwgb2JpZWN0IHBlbnRydSBhIGZpbmlzYVwiLFwiZmluaXNoUmVjdFwiOlwiQXBhc8SDIHBlbnRydSBhIGZpbmlzYVwiLFwic3RhcnRDaXJjbGVcIjpcIkFwYXPEgyBwZW50cnUgYSBkZXNlbmEgdW4gY2VyY1wiLFwiZmluaXNoQ2lyY2xlXCI6XCJBcGFzxIMgcGVudHJ1IGEgZmluaXNhIHVuIGNlcmNcIixcInBsYWNlQ2lyY2xlTWFya2VyXCI6XCJBZGF1Z8SDIHVuIHB1bmN0XCJ9LFwiYWN0aW9uc1wiOntcImZpbmlzaFwiOlwiVGVybWluxINcIixcImNhbmNlbFwiOlwiQW51bGVhesSDXCIsXCJyZW1vdmVMYXN0VmVydGV4XCI6XCLImHRlcmdlIHVsdGltdWwgVmVydGV4XCJ9LFwiYnV0dG9uVGl0bGVzXCI6e1wiZHJhd01hcmtlckJ1dHRvblwiOlwiQWRhdWfEgyBvIGJ1bGluxINcIixcImRyYXdQb2x5QnV0dG9uXCI6XCJEZXNlbmVhesSDIHVuIHBvbGlnb25cIixcImRyYXdMaW5lQnV0dG9uXCI6XCJEZXNlbmVhesSDIG8gbGluaWVcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcIkRlc2VuZWF6xIMgdW4gY2VyY1wiLFwiZHJhd1JlY3RCdXR0b25cIjpcIkRlc2VuZWF6xIMgdW4gZHJlcHR1bmdoaVwiLFwiZWRpdEJ1dHRvblwiOlwiRWRpdGVhesSDIHN0cmF0dXJpbGVcIixcImRyYWdCdXR0b25cIjpcIk11dMSDIHN0cmF0dXJpbGVcIixcImN1dEJ1dHRvblwiOlwiVGFpZSBzdHJhdHVyaWxlXCIsXCJkZWxldGVCdXR0b25cIjpcIsiYdGVyZ2Ugc3RyYXR1cmlsZVwiLFwiZHJhd0NpcmNsZU1hcmtlckJ1dHRvblwiOlwiRGVzZW5lYXrEgyBtYXJjYXRvcnVsIGNlcmN1bHVpXCIsXCJzbmFwcGluZ0J1dHRvblwiOlwiRml4YcibaSBtYXJjYXRvcnVsIGdsaXNhdCBwZSBhbHRlIHN0cmF0dXJpIMiZaSB2w6JyZnVyaVwiLFwicGlubmluZ0J1dHRvblwiOlwiRml4YcibaSB2w6JyZnVyaWxlIHBhcnRhamF0ZSDDrm1wcmV1bsSDXCJ9fScpLHU9SlNPTi5wYXJzZSgne1widG9vbHRpcHNcIjp7XCJwbGFjZU1hcmtlclwiOlwi0J3QsNC20LzQuNGC0LUsINGH0YLQvtCx0Ysg0L3QsNC90LXRgdGC0Lgg0LzQsNGA0LrQtdGAXCIsXCJmaXJzdFZlcnRleFwiOlwi0J3QsNC20LzQuNGC0LUsINGH0YLQvtCx0Ysg0L3QsNC90LXRgdGC0Lgg0L/QtdGA0LLRi9C5INC+0LHRitC10LrRglwiLFwiY29udGludWVMaW5lXCI6XCLQndCw0LbQvNC40YLQtSwg0YfRgtC+0LHRiyDQv9GA0L7QtNC+0LvQttC40YLRjCDRgNC40YHQvtCy0LDQvdC40LVcIixcImZpbmlzaExpbmVcIjpcItCd0LDQttC80LjRgtC1INC70Y7QsdC+0Lkg0YHRg9GJ0LXRgdGC0LLRg9GO0YnQuNC5INC80LDRgNC60LXRgCDQtNC70Y8g0LfQsNCy0LXRgNGI0LXQvdC40Y9cIixcImZpbmlzaFBvbHlcIjpcItCS0YvQsdC10YDQuNGC0LUg0L/QtdGA0LLRg9GOINGC0L7Rh9C60YMsINGH0YLQvtCx0Ysg0LfQsNC60L7QvdGH0LjRgtGMXCIsXCJmaW5pc2hSZWN0XCI6XCLQndCw0LbQvNC40YLQtSwg0YfRgtC+0LHRiyDQt9Cw0LrQvtC90YfQuNGC0YxcIixcInN0YXJ0Q2lyY2xlXCI6XCLQndCw0LbQvNC40YLQtSwg0YfRgtC+0LHRiyDQtNC+0LHQsNCy0LjRgtGMINGG0LXQvdGC0YAg0LrRgNGD0LPQsFwiLFwiZmluaXNoQ2lyY2xlXCI6XCLQndCw0LbQvNC40YLQtSwg0YfRgtC+0LHRiyDQt9Cw0LTQsNGC0Ywg0YDQsNC00LjRg9GBXCIsXCJwbGFjZUNpcmNsZU1hcmtlclwiOlwi0J3QsNC20LzQuNGC0LUsINGH0YLQvtCx0Ysg0L3QsNC90LXRgdGC0Lgg0LrRgNGD0LPQvtCy0L7QuSDQvNCw0YDQutC10YBcIn0sXCJhY3Rpb25zXCI6e1wiZmluaXNoXCI6XCLQl9Cw0LLQtdGA0YjQuNGC0YxcIixcImNhbmNlbFwiOlwi0J7RgtC80LXQvdC40YLRjFwiLFwicmVtb3ZlTGFzdFZlcnRleFwiOlwi0J7RgtC80LXQvdC40YLRjCDQv9C+0YHQu9C10LTQvdC10LUg0LTQtdC50YHRgtCy0LjQtVwifSxcImJ1dHRvblRpdGxlc1wiOntcImRyYXdNYXJrZXJCdXR0b25cIjpcItCU0L7QsdCw0LLQuNGC0Ywg0LzQsNGA0LrQtdGAXCIsXCJkcmF3UG9seUJ1dHRvblwiOlwi0KDQuNGB0L7QstCw0YLRjCDQv9C+0LvQuNCz0L7QvVwiLFwiZHJhd0xpbmVCdXR0b25cIjpcItCg0LjRgdC+0LLQsNGC0Ywg0LrRgNC40LLRg9GOXCIsXCJkcmF3Q2lyY2xlQnV0dG9uXCI6XCLQoNC40YHQvtCy0LDRgtGMINC60YDRg9CzXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwi0KDQuNGB0L7QstCw0YLRjCDQv9GA0Y/QvNC+0YPQs9C+0LvRjNC90LjQulwiLFwiZWRpdEJ1dHRvblwiOlwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0Ywg0YHQu9C+0LlcIixcImRyYWdCdXR0b25cIjpcItCf0LXRgNC10L3QtdGB0YLQuCDRgdC70L7QuVwiLFwiY3V0QnV0dG9uXCI6XCLQktGL0YDQtdC30LDRgtGMINGB0LvQvtC5XCIsXCJkZWxldGVCdXR0b25cIjpcItCj0LTQsNC70LjRgtGMINGB0LvQvtC5XCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCLQlNC+0LHQsNCy0LjRgtGMINC60YDRg9Cz0L7QstC+0Lkg0LzQsNGA0LrQtdGAXCIsXCJzbmFwcGluZ0J1dHRvblwiOlwi0J/RgNC40LLRj9C30LDRgtGMINC/0LXRgNC10YLQsNGB0LrQuNCy0LDQtdC80YvQuSDQvNCw0YDQutC10YAg0Log0LTRgNGD0LPQuNC8INGB0LvQvtGP0Lwg0Lgg0LLQtdGA0YjQuNC90LDQvFwiLFwicGlubmluZ0J1dHRvblwiOlwi0KHQstGP0LfQsNGC0Ywg0L7QsdGJ0LjQtSDRgtC+0YfQutC4INCy0LzQtdGB0YLQtVwifX0nKSxjPUpTT04ucGFyc2UoJ3tcInRvb2x0aXBzXCI6e1wicGxhY2VNYXJrZXJcIjpcIlByZXNpb25hIHBhcmEgY29sb2NhciB1biBtYXJjYWRvclwiLFwiZmlyc3RWZXJ0ZXhcIjpcIlByZXNpb25hIHBhcmEgY29sb2NhciBlbCBwcmltZXIgdsOpcnRpY2VcIixcImNvbnRpbnVlTGluZVwiOlwiUHJlc2lvbmEgcGFyYSBjb250aW51YXIgZGlidWphbmRvXCIsXCJmaW5pc2hMaW5lXCI6XCJQcmVzaW9uYSBjdWFscXVpZXIgbWFyY2Fkb3IgZXhpc3RlbnRlIHBhcmEgZmluYWxpemFyXCIsXCJmaW5pc2hQb2x5XCI6XCJQcmVzaW9uYSBlbCBwcmltZXIgbWFyY2Fkb3IgcGFyYSBmaW5hbGl6YXJcIixcImZpbmlzaFJlY3RcIjpcIlByZXNpb25hIHBhcmEgZmluYWxpemFyXCIsXCJzdGFydENpcmNsZVwiOlwiUHJlc2lvbmEgcGFyYSBjb2xvY2FyIGVsIGNlbnRybyBkZWwgY2lyY3Vsb1wiLFwiZmluaXNoQ2lyY2xlXCI6XCJQcmVzaW9uYSBwYXJhIGZpbmFsaXphciBlbCBjaXJjdWxvXCIsXCJwbGFjZUNpcmNsZU1hcmtlclwiOlwiUHJlc2lvbmEgcGFyYSBjb2xvY2FyIHVuIG1hcmNhZG9yIGRlIGNpcmN1bG9cIn0sXCJhY3Rpb25zXCI6e1wiZmluaXNoXCI6XCJGaW5hbGl6YXJcIixcImNhbmNlbFwiOlwiQ2FuY2VsYXJcIixcInJlbW92ZUxhc3RWZXJ0ZXhcIjpcIlJlbW92ZXIgdWx0aW1vIHbDqXJ0aWNlXCJ9LFwiYnV0dG9uVGl0bGVzXCI6e1wiZHJhd01hcmtlckJ1dHRvblwiOlwiRGlidWphciBNYXJjYWRvclwiLFwiZHJhd1BvbHlCdXR0b25cIjpcIkRpYnVqYXIgUG9sw61nb25vXCIsXCJkcmF3TGluZUJ1dHRvblwiOlwiRGlidWphciBMw61uZWFcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcIkRpYnVqYXIgQ2lyY3Vsb1wiLFwiZHJhd1JlY3RCdXR0b25cIjpcIkRpYnVqYXIgUmVjdMOhbmd1bG9cIixcImVkaXRCdXR0b25cIjpcIkVkaXRhciBDYXBhc1wiLFwiZHJhZ0J1dHRvblwiOlwiQXJyYXN0cmFyIENhcGFzXCIsXCJjdXRCdXR0b25cIjpcIkNvcnRhciBDYXBhc1wiLFwiZGVsZXRlQnV0dG9uXCI6XCJSZW1vdmVyIENhcGFzXCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCJEaWJ1amFyIE1hcmNhZG9yIGRlIENpcmN1bG9cIixcInNuYXBwaW5nQnV0dG9uXCI6XCJFbCBtYXJjYWRvciBkZSBTbmFwIGFycmFzdHJhZG8gYSBvdHJhcyBjYXBhcyB5IHbDqXJ0aWNlc1wiLFwicGlubmluZ0J1dHRvblwiOlwiRmlqYXIganVudG9zIGxvcyB2w6lydGljZXMgY29tcGFydGlkb3NcIn19JykscD1KU09OLnBhcnNlKCd7XCJ0b29sdGlwc1wiOntcInBsYWNlTWFya2VyXCI6XCJLbGlrIG9tIGVlbiBtYXJrZXIgdGUgcGxhYXRzZW5cIixcImZpcnN0VmVydGV4XCI6XCJLbGlrIG9tIGhldCBlZXJzdGUgcHVudCB0ZSBwbGFhdHNlblwiLFwiY29udGludWVMaW5lXCI6XCJLbGlrIG9tIHRlIGJsaWp2ZW4gdGVrZW5lblwiLFwiZmluaXNoTGluZVwiOlwiS2xpayBvcCBlZW4gYmVzdGFhbmQgcHVudCBvbSB0ZSBiZcOraW5kaWdlblwiLFwiZmluaXNoUG9seVwiOlwiS2xpayBvcCBoZXQgZWVyc3QgcHVudCBvbSB0ZSBiZcOraW5kaWdlblwiLFwiZmluaXNoUmVjdFwiOlwiS2xpayBvbSB0ZSBiZcOraW5kaWdlblwiLFwic3RhcnRDaXJjbGVcIjpcIktsaWsgb20gaGV0IG1pZGRlbHB1bnQgdGUgcGxhYXRzZW5cIixcImZpbmlzaENpcmNsZVwiOlwiS2xpayBvbSBkZSBjaXJrZWwgdGUgYmXDq2luZGlnZW5cIixcInBsYWNlQ2lyY2xlTWFya2VyXCI6XCJLbGlrIG9tIGVlbiBtYXJrZXIgdGUgcGxhYXRzZW5cIn0sXCJhY3Rpb25zXCI6e1wiZmluaXNoXCI6XCJCZXdhYXJcIixcImNhbmNlbFwiOlwiQW5udWxlZXJcIixcInJlbW92ZUxhc3RWZXJ0ZXhcIjpcIlZlcndpamRlciBsYWF0c3RlIHB1bnRcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCJQbGFhdHMgTWFya2VyXCIsXCJkcmF3UG9seUJ1dHRvblwiOlwiVGVrZW4gZWVuIHZsYWtcIixcImRyYXdMaW5lQnV0dG9uXCI6XCJUZWtlbiBlZW4gbGlqblwiLFwiZHJhd0NpcmNsZUJ1dHRvblwiOlwiVGVrZW4gZWVuIGNpcmtlbFwiLFwiZHJhd1JlY3RCdXR0b25cIjpcIlRla2VuIGVlbiB2aWVya2FudFwiLFwiZWRpdEJ1dHRvblwiOlwiQmV3ZXJrXCIsXCJkcmFnQnV0dG9uXCI6XCJWZXJwbGFhdHNcIixcImN1dEJ1dHRvblwiOlwiS25pcFwiLFwiZGVsZXRlQnV0dG9uXCI6XCJWZXJ3aWpkZXJcIixcImRyYXdDaXJjbGVNYXJrZXJCdXR0b25cIjpcIlBsYWF0cyBNYXJrZXJcIixcInNuYXBwaW5nQnV0dG9uXCI6XCJTbmFwIGdlc2xlZXB0ZSBtYXJrZXIgbmFhciBhbmRlcmUgbGFnZW4gZW4gaG9la3B1bnRlblwiLFwicGlubmluZ0J1dHRvblwiOlwiU3BlbGQgZ2VkZWVsZGUgaG9la3B1bnRlbiBzYW1lblwifX0nKSxkPUpTT04ucGFyc2UoJ3tcInRvb2x0aXBzXCI6e1wicGxhY2VNYXJrZXJcIjpcIkNsaXF1ZXogcG91ciBwbGFjZXIgdW4gbWFycXVldXJcIixcImZpcnN0VmVydGV4XCI6XCJDbGlxdWV6IHBvdXIgcGxhY2VyIGxlIHByZW1pZXIgc29tbWV0XCIsXCJjb250aW51ZUxpbmVcIjpcIkNsaXF1ZXogcG91ciBjb250aW51ZXIgw6AgZGVzc2luZXJcIixcImZpbmlzaExpbmVcIjpcIkNsaXF1ZXogc3VyIG5cXCdpbXBvcnRlIHF1ZWwgbWFycXVldXIgcG91ciB0ZXJtaW5lclwiLFwiZmluaXNoUG9seVwiOlwiQ2xpcXVleiBzdXIgbGUgcHJlbWllciBtYXJxdWV1ciBwb3VyIHRlcm1pbmVyXCIsXCJmaW5pc2hSZWN0XCI6XCJDbGlxdWV6IHBvdXIgdGVybWluZXJcIixcInN0YXJ0Q2lyY2xlXCI6XCJDbGlxdWV6IHBvdXIgcGxhY2VyIGxlIGNlbnRyZSBkdSBjZXJjbGVcIixcImZpbmlzaENpcmNsZVwiOlwiQ2xpcXVleiBwb3VyIGZpbmlyIGxlIGNlcmNsZVwiLFwicGxhY2VDaXJjbGVNYXJrZXJcIjpcIkNsaXF1ZXogcG91ciBwbGFjZXIgbGUgbWFycXVldXIgY2lyY3VsYWlyZVwifSxcImFjdGlvbnNcIjp7XCJmaW5pc2hcIjpcIlRlcm1pbmVyXCIsXCJjYW5jZWxcIjpcIkFubnVsZXJcIixcInJlbW92ZUxhc3RWZXJ0ZXhcIjpcIlJldGlyZXIgbGUgZGVybmllciBzb21tZXRcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCJQbGFjZXIgZGVzIG1hcnF1ZXVyc1wiLFwiZHJhd1BvbHlCdXR0b25cIjpcIkRlc3NpbmVyIGRlcyBwb2x5Z29uZXNcIixcImRyYXdMaW5lQnV0dG9uXCI6XCJEZXNzaW5lciBkZXMgcG9seWxpZ25lc1wiLFwiZHJhd0NpcmNsZUJ1dHRvblwiOlwiRGVzc2luZXIgdW4gY2VyY2xlXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwiRGVzc2luZXIgdW4gcmVjdGFuZ2xlXCIsXCJlZGl0QnV0dG9uXCI6XCLDiWRpdGVyIGRlcyBjYWxxdWVzXCIsXCJkcmFnQnV0dG9uXCI6XCJEw6lwbGFjZXIgZGVzIGNhbHF1ZXNcIixcImN1dEJ1dHRvblwiOlwiQ291cGVyIGRlcyBjYWxxdWVzXCIsXCJkZWxldGVCdXR0b25cIjpcIlN1cHByaW1lciBkZXMgY2FscXVlc1wiLFwiZHJhd0NpcmNsZU1hcmtlckJ1dHRvblwiOlwiRGVzc2luZXIgdW4gbWFycXVldXIgY2lyY3VsYWlyZVwiLFwic25hcHBpbmdCdXR0b25cIjpcIkdsaXNzZXIgbGUgbWFycXVldXIgdmVycyBkXFwnYXV0cmVzIGNvdWNoZXMgZXQgc29tbWV0c1wiLFwicGlubmluZ0J1dHRvblwiOlwiw4lwaW5nbGVyIGVuc2VtYmxlIGxlcyBzb21tZXRzIHBhcnRhZ8Opc1wiLFwicm90YXRlQnV0dG9uXCI6XCJUb3VybmVyIGRlcyBjYWxxdWVzXCJ9fScpLGY9SlNPTi5wYXJzZSgne1widG9vbHRpcHNcIjp7XCJwbGFjZU1hcmtlclwiOlwi5Y2V5Ye75pS+572u5qCH6K6wXCIsXCJmaXJzdFZlcnRleFwiOlwi5Y2V5Ye75pS+572u6aaW5Liq6aG254K5XCIsXCJjb250aW51ZUxpbmVcIjpcIuWNleWHu+e7p+e7ree7mOWItlwiLFwiZmluaXNoTGluZVwiOlwi5Y2V5Ye75Lu75L2V5a2Y5Zyo55qE5qCH6K6w5Lul5a6M5oiQXCIsXCJmaW5pc2hQb2x5XCI6XCLljZXlh7vnrKzkuIDkuKrmoIforrDku6XlrozmiJBcIixcImZpbmlzaFJlY3RcIjpcIuWNleWHu+WujOaIkFwiLFwic3RhcnRDaXJjbGVcIjpcIuWNleWHu+aUvue9ruWchuW/g1wiLFwiZmluaXNoQ2lyY2xlXCI6XCLljZXlh7vlrozmiJDlnIblvaJcIixcInBsYWNlQ2lyY2xlTWFya2VyXCI6XCLngrnlh7vmlL7nva7lnIblvaLmoIforrBcIn0sXCJhY3Rpb25zXCI6e1wiZmluaXNoXCI6XCLlrozmiJBcIixcImNhbmNlbFwiOlwi5Y+W5raIXCIsXCJyZW1vdmVMYXN0VmVydGV4XCI6XCLnp7vpmaTmnIDlkI7nmoTpobbngrlcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCLnu5jliLbmoIforrBcIixcImRyYXdQb2x5QnV0dG9uXCI6XCLnu5jliLblpJrovrnlvaJcIixcImRyYXdMaW5lQnV0dG9uXCI6XCLnu5jliLbnur/mrrVcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcIue7mOWItuWchuW9olwiLFwiZHJhd1JlY3RCdXR0b25cIjpcIue7mOWItumVv+aWueW9olwiLFwiZWRpdEJ1dHRvblwiOlwi57yW6L6R5Zu+5bGCXCIsXCJkcmFnQnV0dG9uXCI6XCLmi5bmi73lm77lsYJcIixcImN1dEJ1dHRvblwiOlwi5Ymq5YiH5Zu+5bGCXCIsXCJkZWxldGVCdXR0b25cIjpcIuWIoOmZpOWbvuWxglwiLFwiZHJhd0NpcmNsZU1hcmtlckJ1dHRvblwiOlwi55S75ZyG5ZyI5qCH6K6wXCIsXCJzbmFwcGluZ0J1dHRvblwiOlwi5bCG5ouW5Yqo55qE5qCH6K6w5o2V5o2J5Yiw5YW25LuW5Zu+5bGC5ZKM6aG254K5XCIsXCJwaW5uaW5nQnV0dG9uXCI6XCLlsIblhbHkuqvpobbngrnlm7rlrprlnKjkuIDotbdcIn19JyksZz1KU09OLnBhcnNlKCd7XCJ0b29sdGlwc1wiOntcInBsYWNlTWFya2VyXCI6XCLllq7mk4rmlL7nva7mqJnoqJhcIixcImZpcnN0VmVydGV4XCI6XCLllq7mk4rmlL7nva7nrKzkuIDlgIvpoILpu55cIixcImNvbnRpbnVlTGluZVwiOlwi5Zau5pOK57m857qM57mq6KO9XCIsXCJmaW5pc2hMaW5lXCI6XCLllq7mk4rku7vkvZXlrZjlnKjnmoTmqJnoqJjku6XlrozmiJBcIixcImZpbmlzaFBvbHlcIjpcIuWWruaTiuesrOS4gOWAi+aomeiomOS7peWujOaIkFwiLFwiZmluaXNoUmVjdFwiOlwi5Zau5pOK5a6M5oiQXCIsXCJzdGFydENpcmNsZVwiOlwi5Zau5pOK5pS+572u5ZyT5b+DXCIsXCJmaW5pc2hDaXJjbGVcIjpcIuWWruaTiuWujOaIkOWck+W9olwiLFwicGxhY2VDaXJjbGVNYXJrZXJcIjpcIum7nuaTiuaUvue9ruWck+W9ouaomeiomFwifSxcImFjdGlvbnNcIjp7XCJmaW5pc2hcIjpcIuWujOaIkFwiLFwiY2FuY2VsXCI6XCLlj5bmtohcIixcInJlbW92ZUxhc3RWZXJ0ZXhcIjpcIuenu+mZpOacgOW+jOS4gOWAi+mggum7nlwifSxcImJ1dHRvblRpdGxlc1wiOntcImRyYXdNYXJrZXJCdXR0b25cIjpcIuaUvue9ruaomeiomFwiLFwiZHJhd1BvbHlCdXR0b25cIjpcIue5quijveWkmumCiuW9olwiLFwiZHJhd0xpbmVCdXR0b25cIjpcIue5quijvee3muautVwiLFwiZHJhd0NpcmNsZUJ1dHRvblwiOlwi57mq6KO95ZyT5b2iXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwi57mq6KO95pa55b2iXCIsXCJlZGl0QnV0dG9uXCI6XCLnt6jovK/lnJblvaJcIixcImRyYWdCdXR0b25cIjpcIuenu+WLleWcluW9olwiLFwiY3V0QnV0dG9uXCI6XCLoo4HliIflnJblvaJcIixcImRlbGV0ZUJ1dHRvblwiOlwi5Yiq6Zmk5ZyW5b2iXCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCLnlavlnJPlnIjmqJnoqJhcIixcInNuYXBwaW5nQnV0dG9uXCI6XCLlsIfmi5bli5XnmoTmqJnoqJjlsI3pvYrliLDlhbbku5blnJblsaTlkozpoILpu55cIixcInBpbm5pbmdCdXR0b25cIjpcIuWwh+WFseS6q+mggum7nuWbuuWumuWcqOS4gOi1t1wifX0nKSxfPXtlbjphLGRlOm8saXQ6cyxpZDpsLHJvOmgscnU6dSxlczpjLG5sOnAsZnI6ZCxwdF9icjpKU09OLnBhcnNlKCd7XCJ0b29sdGlwc1wiOntcInBsYWNlTWFya2VyXCI6XCJDbGlxdWUgcGFyYSBwb3NpY2lvbmFyIG8gbWFyY2Fkb3JcIixcImZpcnN0VmVydGV4XCI6XCJDbGlxdWUgcGFyYSBwb3NpY2lvbmFyIG8gcHJpbWVpcm8gdsOpcnRpY2VcIixcImNvbnRpbnVlTGluZVwiOlwiQ2xpcXVlIHBhcmEgY29udGludWFyIGRlc2VuaGFuZG9cIixcImZpbmlzaExpbmVcIjpcIkNsaXF1ZSBlbSBxdWFscXVlciBtYXJjYWRvciBleGlzdGVudGUgcGFyYSBmaW5hbGl6YXJcIixcImZpbmlzaFBvbHlcIjpcIkNsaXF1ZSBubyBwcmltZWlybyBwb250byBwYXJhIGZlY2hhciBvIHBvbMOtZ29ub1wiLFwiZmluaXNoUmVjdFwiOlwiQ2xpcXVlIHBhcmEgZmluYWxpemFyXCIsXCJzdGFydENpcmNsZVwiOlwiQ2xpcXVlIHBhcmEgcG9zaWNpb25hciBvIGNlbnRybyBkbyBjw61yY3Vsb1wiLFwiZmluaXNoQ2lyY2xlXCI6XCJDbGlxdWUgcGFyYSBmZWNoYXIgbyBjw61yY3Vsb1wiLFwicGxhY2VDaXJjbGVNYXJrZXJcIjpcIkNsaXF1ZSBwYXJhIHBvc2ljaW9uYXIgbyBtYXJjYWRvciBjaXJjdWxhclwifSxcImFjdGlvbnNcIjp7XCJmaW5pc2hcIjpcIkZpbmFsaXphclwiLFwiY2FuY2VsXCI6XCJDYW5jZWxhclwiLFwicmVtb3ZlTGFzdFZlcnRleFwiOlwiUmVtb3ZlciDDumx0aW1vIHbDqXJ0aWNlXCJ9LFwiYnV0dG9uVGl0bGVzXCI6e1wiZHJhd01hcmtlckJ1dHRvblwiOlwiRGVzZW5oYXIgdW0gbWFyY2Fkb3JcIixcImRyYXdQb2x5QnV0dG9uXCI6XCJEZXNlbmhhciB1bSBwb2zDrWdvbm9cIixcImRyYXdMaW5lQnV0dG9uXCI6XCJEZXNlbmhhciB1bWEgcG9saWxpbmhhXCIsXCJkcmF3Q2lyY2xlQnV0dG9uXCI6XCJEZXNlbmhhciB1bSBjw61yY3Vsb1wiLFwiZHJhd1JlY3RCdXR0b25cIjpcIkRlc2VuaGFyIHVtIHJldMOibmd1bG9cIixcImVkaXRCdXR0b25cIjpcIkVkaXRhciBjYW1hZGEocylcIixcImRyYWdCdXR0b25cIjpcIk1vdmVyIGNhbWFkYShzKVwiLFwiY3V0QnV0dG9uXCI6XCJSZWNvcnRhciBjYW1hZGEocylcIixcImRlbGV0ZUJ1dHRvblwiOlwiUmVtb3ZlciBjYW1hZGEocylcIixcImRyYXdDaXJjbGVNYXJrZXJCdXR0b25cIjpcIk1hcmNhZG9yIGRlIGPDrXJjdWxvcyBkZSBkZXNlbmhvXCIsXCJzbmFwcGluZ0J1dHRvblwiOlwiTWFyY2Fkb3IgYXJyYXN0YWRvIHBhcmEgb3V0cmFzIGNhbWFkYXMgZSB2w6lydGljZXNcIixcInBpbm5pbmdCdXR0b25cIjpcIlbDqXJ0aWNlcyBjb21wYXJ0aWxoYWRvcyBkZSBwaW5vcyBqdW50b3NcIn19Jyksemg6Zix6aF90dzpnLHBsOkpTT04ucGFyc2UoJ3tcInRvb2x0aXBzXCI6e1wicGxhY2VNYXJrZXJcIjpcIktsaWtuaWosIGFieSB1c3Rhd2nEhyB6bmFjem5pa1wiLFwiZmlyc3RWZXJ0ZXhcIjpcIktsaWtuaWosIGFieSB1c3Rhd2nEhyBwaWVyd3N6eSBwdW5rdFwiLFwiY29udGludWVMaW5lXCI6XCJLbGlrbmlqLCBhYnkga29udHludW93YcSHIHJ5c293YW5pZVwiLFwiZmluaXNoTGluZVwiOlwiS2xpa25paiBkb3dvbG55IHB1bmt0LCBhYnkgemFrb8WEY3p5xIdcIixcImZpbmlzaFBvbHlcIjpcIktsaWtuaWogcGllcndzenkgcHVua3QsIGFieSB6YWtvxYRjennEh1wiLFwiZmluaXNoUmVjdFwiOlwiS2xpa25paiwgYWJ5IHpha2/FhGN6ecSHXCIsXCJzdGFydENpcmNsZVwiOlwiS2xpa25paiwgYWJ5IHVzdGF3acSHIMWbcm9kZWsga2/FgmFcIixcImZpbmlzaENpcmNsZVwiOlwiS2xpa25paiwgYWJ5IHpha2/FhGN6ecSHIHJ5c293YW5pZSBrb8WCYVwiLFwicGxhY2VDaXJjbGVNYXJrZXJcIjpcIktsaWtuaWosIGFieSB1c3Rhd2nEhyBva3LEhWfFgnkgem5hY3puaWtcIn0sXCJhY3Rpb25zXCI6e1wiZmluaXNoXCI6XCJaYWtvxYRjelwiLFwiY2FuY2VsXCI6XCJBbnVsdWpcIixcInJlbW92ZUxhc3RWZXJ0ZXhcIjpcIlVzdcWEIG9zdGF0bmkgcHVua3RcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCJOYXJ5c3VqIHpuYWN6bmlrXCIsXCJkcmF3UG9seUJ1dHRvblwiOlwiTmFyeXN1aiB3aWVsb2vEhXRcIixcImRyYXdMaW5lQnV0dG9uXCI6XCJOYXJ5c3VqIMWbY2llxbxrxJlcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcIk5hcnlzdWoga2/Fgm9cIixcImRyYXdSZWN0QnV0dG9uXCI6XCJOYXJ5c3VqIHByb3N0b2vEhXRcIixcImVkaXRCdXR0b25cIjpcIkVkeXR1alwiLFwiZHJhZ0J1dHRvblwiOlwiUHJ6ZXN1xYRcIixcImN1dEJ1dHRvblwiOlwiV3l0bmlqXCIsXCJkZWxldGVCdXR0b25cIjpcIlVzdcWEXCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCJOYXJ5c3VqIG9rcsSFZ8WCeSB6bmFjem5pa1wiLFwic25hcHBpbmdCdXR0b25cIjpcIlNuYXAgcHJ6ZWNpxIVnbmnEmXR5IG1hcmtlciBuYSBpbm5lIHdhcnN0d3kgaSB3aWVyemNob8WCa2lcIixcInBpbm5pbmdCdXR0b25cIjpcIlN3b3J6ZcWEIHdzcMOzbG5lIHdpZXJ6Y2hvxYJraSByYXplbVwifX0nKSxzdjpKU09OLnBhcnNlKCd7XCJ0b29sdGlwc1wiOntcInBsYWNlTWFya2VyXCI6XCJLbGlja2EgZsO2ciBhdHQgcGxhY2VyYSBtYXJrw7ZyXCIsXCJmaXJzdFZlcnRleFwiOlwiS2xpY2thIGbDtnIgYXR0IHBsYWNlcmEgZsO2cnN0YSBow7ZybmV0XCIsXCJjb250aW51ZUxpbmVcIjpcIktsaWNrYSBmw7ZyIGF0dCBmb3J0c8OkdHRhIHJpdGFcIixcImZpbmlzaExpbmVcIjpcIktsaWNrYSBww6UgZW4gZXhpc3RlcmFuZGUgcHVua3QgZsO2ciBhdHQgc2x1dGbDtnJhXCIsXCJmaW5pc2hQb2x5XCI6XCJLbGlja2EgcMOlIGRlbiBmw7Zyc3RhIHB1bmt0ZW4gZsO2ciBhdHQgc2x1dGbDtnJhXCIsXCJmaW5pc2hSZWN0XCI6XCJLbGlja2EgZsO2ciBhdHQgc2x1dGbDtnJhXCIsXCJzdGFydENpcmNsZVwiOlwiS2xpY2thIGbDtnIgYXR0IHBsYWNlcmEgY2lya2VsbnMgY2VudHJ1bVwiLFwiZmluaXNoQ2lyY2xlXCI6XCJLbGlja2EgZsO2ciBhdHQgc2x1dGbDtnJhIGNpcmtlbG5cIixcInBsYWNlQ2lyY2xlTWFya2VyXCI6XCJLbGlja2EgZsO2ciBhdHQgcGxhY2VyYSBjaXJrZWxtYXJrw7ZyXCJ9LFwiYWN0aW9uc1wiOntcImZpbmlzaFwiOlwiU2x1dGbDtnJcIixcImNhbmNlbFwiOlwiQXZicnl0XCIsXCJyZW1vdmVMYXN0VmVydGV4XCI6XCJUYSBib3J0IHNpc3RhIGjDtnJuZXRcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCJSaXRhIE1hcmvDtnJcIixcImRyYXdQb2x5QnV0dG9uXCI6XCJSaXRhIFBvbHlnb25lclwiLFwiZHJhd0xpbmVCdXR0b25cIjpcIlJpdGEgTGluamVcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcIlJpdGEgQ2lya2VsXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwiUml0YSBSZWt0YW5nZWxcIixcImVkaXRCdXR0b25cIjpcIlJlZGlnZXJhIExhZ2VyXCIsXCJkcmFnQnV0dG9uXCI6XCJEcmEgTGFnZXJcIixcImN1dEJ1dHRvblwiOlwiS2xpcHAgaSBMYWdlclwiLFwiZGVsZXRlQnV0dG9uXCI6XCJUYSBib3J0IExhZ2VyXCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCJSaXRhIENpcmtlbG1hcmvDtnJcIixcInNuYXBwaW5nQnV0dG9uXCI6XCJTbsOkcHAgZHJhIG1hcmvDtnJlbiB0aWxsIGFuZHJhIGxhZ2VyIG9jaCBow7ZyblwiLFwicGlubmluZ0J1dHRvblwiOlwiRsOkc3QgZGVsYWRlIGjDtnJuIHRpbGxzYW1tYW5zXCJ9fScpLGVsOkpTT04ucGFyc2UoJ3tcInRvb2x0aXBzXCI6e1wicGxhY2VNYXJrZXJcIjpcIs6azqzOvc+EzrUgzrrOu865zrogzrPOuc6xIM69zrEgz4TOv8+Azr/OuM61z4TOrs+DzrXPhM61IM6UzrXOr866z4TOt1wiLFwiZmlyc3RWZXJ0ZXhcIjpcIs6azqzOvc+EzrUgzrrOu865zrogzrPOuc6xIM69zrEgz4TOv8+Azr/OuM61z4TOrs+DzrXPhM61IM+Ezr8gz4DPgc+Oz4TOvyDPg863zrzOtc6vzr9cIixcImNvbnRpbnVlTGluZVwiOlwizprOrM69z4TOtSDOus67zrnOuiDOs865zrEgzr3OsSDPg8+Fzr3Otc+Hzq/Pg861z4TOtSDOvc6xIM+Dz4fOtc60zrnOrM62zrXPhM61XCIsXCJmaW5pc2hMaW5lXCI6XCLOms6szr3PhM61IM66zrvOuc66IM+DzrUgzr/PgM6/zrnOv869zrTOrs+Azr/PhM61IM+Fz4DOrM+Bz4fOv869IM+DzrfOvM61zq/OvyDOs865zrEgzr3OsSDOv867zr/Ous67zrfPgc+JzrjOtc6vXCIsXCJmaW5pc2hQb2x5XCI6XCLOms6szr3PhM61IM66zrvOuc66IM+Dz4TOvyDPgM+Bz47PhM6/IM+DzrfOvM61zq/OvyDOs865zrEgzr3OsSDPhM61zrvOtc65z47Pg861z4TOtVwiLFwiZmluaXNoUmVjdFwiOlwizprOrM69z4TOtSDOus67zrnOuiDOs865zrEgzr3OsSDPhM61zrvOtc65z47Pg861z4TOtVwiLFwic3RhcnRDaXJjbGVcIjpcIs6azqzOvc+EzrUgzrrOu865zrogzrPOuc6xIM69zrEgz4TOv8+Azr/OuM61z4TOrs+DzrXPhM61IM66zq3Ovc+Ez4HOvyDOms+NzrrOu86/z4VcIixcImZpbmlzaENpcmNsZVwiOlwizprOrM69z4TOtSDOus67zrnOuiDOs865zrEgzr3OsSDOv867zr/Ous67zrfPgc+Oz4POtc+EzrUgz4TOv869IM6az43Ous67zr9cIixcInBsYWNlQ2lyY2xlTWFya2VyXCI6XCLOms6szr3PhM61IM66zrvOuc66IM6zzrnOsSDOvc6xIM+Ezr/PgM6/zrjOtc+Ezq7Pg861z4TOtSDOms+FzrrOu865zrrPjCDOlM61zq/Ous+EzrdcIn0sXCJhY3Rpb25zXCI6e1wiZmluaXNoXCI6XCLOpM6tzrvOv8+CXCIsXCJjYW5jZWxcIjpcIs6RzrrPjc+Bz4nPg863XCIsXCJyZW1vdmVMYXN0VmVydGV4XCI6XCLOms6xz4TOrM+BzrPOt8+Dzrcgz4TOtc67zrXPhc+EzrHOr86/z4Ugz4POt868zrXOr86/z4VcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCLOo8+HzrXOtM6vzrHPg863IM6UzrXOr866z4TOt1wiLFwiZHJhd1BvbHlCdXR0b25cIjpcIs6jz4fOtc60zq/Osc+DzrcgzqDOv867z4XOs8+Ozr3Ov8+FXCIsXCJkcmF3TGluZUJ1dHRvblwiOlwizqPPh861zrTOr86xz4POtyDOk8+BzrHOvM68zq7PglwiLFwiZHJhd0NpcmNsZUJ1dHRvblwiOlwizqPPh861zrTOr86xz4POtyDOms+NzrrOu86/z4VcIixcImRyYXdSZWN0QnV0dG9uXCI6XCLOo8+HzrXOtM6vzrHPg863IM6fz4HOuM6/zrPPic69zq/Ov8+FXCIsXCJlZGl0QnV0dG9uXCI6XCLOlc+AzrXOvs61z4HOs86xz4POr86xIM6Vz4DOuc+Azq3OtM+Jzr1cIixcImRyYWdCdXR0b25cIjpcIs6czrXPhM6xz4bOv8+BzqwgzpXPgM65z4DOrc60z4nOvVwiLFwiY3V0QnV0dG9uXCI6XCLOkc+Azr/Ous6/z4DOriDOlc+AzrnPgM6tzrTPic69XCIsXCJkZWxldGVCdXR0b25cIjpcIs6azrHPhM6sz4HOs863z4POtyDOlc+AzrnPgM6tzrTPic69XCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCLOo8+HzrXOtM6vzrHPg863IM6az4XOus67zrnOus6/z40gzpTOtc6vzrrPhM63XCIsXCJzbmFwcGluZ0J1dHRvblwiOlwizqDPgc6/z4POus+MzrvOu863z4POtyDPhM6/z4UgzpTOtc6vzrrPhM63IM68zrXPhM6xz4bOv8+BzqzPgiDPg861IM6szrvOu86xIM6Vz4DOr8+AzrXOtM6xIM66zrHOuSDOms6/z4HPhc+Gzq3PglwiLFwicGlubmluZ0J1dHRvblwiOlwizqDOtc+BzrnOus6/z4DOriDOus6/zrnOvc+Ozr0gzrrOv8+Bz4XPhs+Ozr0gzrzOsc62zq9cIn19JyksaHU6SlNPTi5wYXJzZSgne1widG9vbHRpcHNcIjp7XCJwbGFjZU1hcmtlclwiOlwiS2F0dGludHNvbiBhIGplbMO2bMWRIGVsaGVseWV6w6lzw6loZXpcIixcImZpcnN0VmVydGV4XCI6XCJLYXR0aW50c29uIGF6IGVsc8WRIHBvbnQgZWxoZWx5ZXrDqXPDqWhlelwiLFwiY29udGludWVMaW5lXCI6XCJLYXR0aW50c29uIGEga8O2dmV0a2V6xZEgcG9udCBlbGhlbHllesOpc8OpaGV6XCIsXCJmaW5pc2hMaW5lXCI6XCJBIGJlZmVqZXrDqXNoZXoga2F0dGludHNvbiBlZ3kgbWVnbMOpdsWRIHBvbnRyYVwiLFwiZmluaXNoUG9seVwiOlwiQSBiZWZlamV6w6lzaGV6IGthdHRpbnRzb24gYXogZWxzxZEgcG9udHJhXCIsXCJmaW5pc2hSZWN0XCI6XCJLYXR0aW50c29uIGEgYmVmZWplesOpc2hlelwiLFwic3RhcnRDaXJjbGVcIjpcIkthdHRpbnRzb24gYSBrw7ZyIGvDtnrDqXBwb250asOhbmFrIGVsaGVseWV6w6lzw6loZXpcIixcImZpbmlzaENpcmNsZVwiOlwiS2F0dGludHNvbiBhIGvDtnIgYmVmZWplesOpc8OpaGV6XCIsXCJwbGFjZUNpcmNsZU1hcmtlclwiOlwiS2F0dGludHNvbiBhIGvDtnJqZWzDtmzFkSBlbGhlbHllesOpc8OpaGV6XCJ9LFwiYWN0aW9uc1wiOntcImZpbmlzaFwiOlwiQmVmZWplesOpc1wiLFwiY2FuY2VsXCI6XCJNw6lnc2VcIixcInJlbW92ZUxhc3RWZXJ0ZXhcIjpcIlV0b2xzw7MgcG9udCBlbHTDoXZvbMOtdMOhc2FcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCJKZWzDtmzFkSByYWp6b2zDoXNhXCIsXCJkcmF3UG9seUJ1dHRvblwiOlwiUG9saWdvbiByYWp6b2zDoXNhXCIsXCJkcmF3TGluZUJ1dHRvblwiOlwiVm9uYWwgcmFqem9sw6FzYVwiLFwiZHJhd0NpcmNsZUJ1dHRvblwiOlwiS8O2ciByYWp6b2zDoXNhXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwiTsOpZ3l6ZXQgcmFqem9sw6FzYVwiLFwiZWRpdEJ1dHRvblwiOlwiRWxlbWVrIHN6ZXJrZXN6dMOpc2VcIixcImRyYWdCdXR0b25cIjpcIkVsZW1layBtb3pnYXTDoXNhXCIsXCJjdXRCdXR0b25cIjpcIkVsZW1layB2w6Fnw6FzYVwiLFwiZGVsZXRlQnV0dG9uXCI6XCJFbGVtZWsgdMO2cmzDqXNlXCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCJLw7ZyIGplbMO2bMWRIHJhanpvbMOhc2FcIixcInNuYXBwaW5nQnV0dG9uXCI6XCJLYXBjc29samEgYSBqZWzDtmx0xZF0IG3DoXNpayBlbGVtaGV6IHZhZ3kgcG9udGhvelwiLFwicGlubmluZ0J1dHRvblwiOlwiS8O2esO2cyBwb250b2sgw7Zzc3pla8O2dMOpc2VcIn19JyksZGE6SlNPTi5wYXJzZSgne1widG9vbHRpcHNcIjp7XCJwbGFjZU1hcmtlclwiOlwiVHJ5ayBmb3IgYXQgcGxhY2VyZSBlbiBtYXJrw7hyXCIsXCJmaXJzdFZlcnRleFwiOlwiVHJ5ayBmb3IgYXQgcGxhY2VyZSBkZXQgZsO4cnN0ZSBwdW5rdFwiLFwiY29udGludWVMaW5lXCI6XCJUcnlrIGZvciBhdCBmb3J0c8OmdHRlIGxpbmplblwiLFwiZmluaXNoTGluZVwiOlwiVHJ5ayBww6UgZXQgZWtzaXN0ZXJlbmRlIHB1bmt0IGZvciBhdCBhZnNsdXR0ZVwiLFwiZmluaXNoUG9seVwiOlwiVHJ5ayBww6UgZGV0IGbDuHJzdGUgcHVua3QgZm9yIGF0IGFmc2x1dHRlXCIsXCJmaW5pc2hSZWN0XCI6XCJUcnlrIGZvciBhdCBhZnNsdXR0ZVwiLFwic3RhcnRDaXJjbGVcIjpcIlRyeWsgZm9yIGF0IHBsYWNlcmUgY2lya2xlbnMgY2VudGVyXCIsXCJmaW5pc2hDaXJjbGVcIjpcIlRyeWsgZm9yIGF0IGFmc2x1dHRlIGNpcmtsZW5cIixcInBsYWNlQ2lyY2xlTWFya2VyXCI6XCJUcnlrIGZvciBhdCBwbGFjZXJlIGVuIGNpcmtlbG1hcmvDuHJcIn0sXCJhY3Rpb25zXCI6e1wiZmluaXNoXCI6XCJBZnNsdXRcIixcImNhbmNlbFwiOlwiQWZicnlkXCIsXCJyZW1vdmVMYXN0VmVydGV4XCI6XCJGamVybiBzaWRzdGUgcHVua3RcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCJQbGFjZXIgbWFya8O4clwiLFwiZHJhd1BvbHlCdXR0b25cIjpcIlRlZ24gcG9seWdvblwiLFwiZHJhd0xpbmVCdXR0b25cIjpcIlRlZ24gbGluamVcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcIlRlZ24gY2lya2VsXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwiVGVnbiBmaXJrYW50XCIsXCJlZGl0QnV0dG9uXCI6XCJSZWRpZ2VyXCIsXCJkcmFnQnV0dG9uXCI6XCJUcsOma1wiLFwiY3V0QnV0dG9uXCI6XCJLbGlwXCIsXCJkZWxldGVCdXR0b25cIjpcIkZqZXJuXCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCJUZWduIGNpcmtlbG1hcmvDuHJcIixcInNuYXBwaW5nQnV0dG9uXCI6XCJGYXN0Z8O4ciB0cnVra2V0IG1hcmvDuHIgdGlsIGFuZHJlIGVsZW1lbnRlclwiLFwicGlubmluZ0J1dHRvblwiOlwiU2FtbWVubMOmZyBkZWx0ZSBlbGVtZW50ZXJcIn19Jyksbm86SlNPTi5wYXJzZSgne1widG9vbHRpcHNcIjp7XCJwbGFjZU1hcmtlclwiOlwiS2xpa2sgZm9yIMOlIHBsYXNzZXJlIHB1bmt0XCIsXCJmaXJzdFZlcnRleFwiOlwiS2xpa2sgZm9yIMOlIHBsYXNzZXJlIGbDuHJzdGUgcHVua3RcIixcImNvbnRpbnVlTGluZVwiOlwiS2xpa2sgZm9yIMOlIHRlZ25lIHZpZGVyZVwiLFwiZmluaXNoTGluZVwiOlwiS2xpa2sgcMOlIGV0IGVrc2lzdGVyZW5kZSBwdW5rdCBmb3Igw6UgZnVsbGbDuHJlXCIsXCJmaW5pc2hQb2x5XCI6XCJLbGlrayBmw7hyc3RlIHB1bmt0IGZvciDDpSBmdWxsZsO4cmVcIixcImZpbmlzaFJlY3RcIjpcIktsaWtrIGZvciDDpSBmdWxsZsO4cmVcIixcInN0YXJ0Q2lyY2xlXCI6XCJLbGlrayBmb3Igw6Ugc2V0dGUgc2lya2VsIG1pZHRwdW5rdFwiLFwiZmluaXNoQ2lyY2xlXCI6XCJLbGlrayBmb3Igw6UgZnVsbGbDuHJlIHNpcmtlbFwiLFwicGxhY2VDaXJjbGVNYXJrZXJcIjpcIktsaWtrIGZvciDDpSBwbGFzc2VyZSBzaXJrZWxcIn0sXCJhY3Rpb25zXCI6e1wiZmluaXNoXCI6XCJGdWxsZsO4clwiLFwiY2FuY2VsXCI6XCJLYW5zZWxsZXJcIixcInJlbW92ZUxhc3RWZXJ0ZXhcIjpcIkZqZXJuIGZvcnJpZ2UgcHVua3RcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCJUZWduIFB1bmt0XCIsXCJkcmF3UG9seUJ1dHRvblwiOlwiVGVnbiBGbGF0ZVwiLFwiZHJhd0xpbmVCdXR0b25cIjpcIlRlZ24gTGluamVcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcIlRlZ24gU2lya2VsXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwiVGVnbiByZWt0YW5nZWxcIixcImVkaXRCdXR0b25cIjpcIlJlZGlnZXIgT2JqZWt0ZXJcIixcImRyYWdCdXR0b25cIjpcIkRyYSBPYmpla3RlclwiLFwiY3V0QnV0dG9uXCI6XCJLdXR0IE9iamVrdGVyXCIsXCJkZWxldGVCdXR0b25cIjpcIkZqZXJuIE9iamVrdGVyXCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCJUZWduIHNpcmtlbC1wdW5rdFwiLFwic25hcHBpbmdCdXR0b25cIjpcIkZlc3QgZHJhdHQgcHVua3QgdGlsIGFuZHJlIG9iamVrdGVyIG9nIHB1bmt0XCIsXCJwaW5uaW5nQnV0dG9uXCI6XCJQaW4gZGVsdGUgcHVua3Qgc2FtbWVuXCJ9fScpLGZhOkpTT04ucGFyc2UoJ3tcInRvb2x0aXBzXCI6e1wicGxhY2VNYXJrZXJcIjpcItqp2YTbjNqpINio2LHYp9uMINis2KfZhtmF2KfbjNuMINmG2LTYp9mGXCIsXCJmaXJzdFZlcnRleFwiOlwi2qnZhNuM2qkg2KjYsdin24wg2LHYs9mFINin2YjZhNuM2YYg2LHYo9izXCIsXCJjb250aW51ZUxpbmVcIjpcItqp2YTbjNqpINio2LHYp9uMINin2K/Yp9mF2Ycg2LHYs9mFXCIsXCJmaW5pc2hMaW5lXCI6XCLaqdmE24zaqSDYsdmI24wg2YfYsSDZhti02KfZhiDZhdmI2KzZiNivINio2LHYp9uMINm+2KfbjNin2YZcIixcImZpbmlzaFBvbHlcIjpcItqp2YTbjNqpINix2YjbjCDYp9mI2YTbjNmGINmG2LTYp9mGINio2LHYp9uMINm+2KfbjNin2YZcIixcImZpbmlzaFJlY3RcIjpcItqp2YTbjNqpINio2LHYp9uMINm+2KfbjNin2YZcIixcInN0YXJ0Q2lyY2xlXCI6XCLaqdmE24zaqSDYqNix2KfbjCDYsdiz2YUg2YXYsdqp2LIg2K/Yp9uM2LHZh1wiLFwiZmluaXNoQ2lyY2xlXCI6XCLaqdmE24zaqSDYqNix2KfbjCDZvtin24zYp9mGINix2LPZhSDYr9in24zYsdmHXCIsXCJwbGFjZUNpcmNsZU1hcmtlclwiOlwi2qnZhNuM2qkg2KjYsdin24wg2LHYs9mFINmG2LTYp9mGINiv2KfbjNix2YdcIn0sXCJhY3Rpb25zXCI6e1wiZmluaXNoXCI6XCLZvtin24zYp9mGXCIsXCJjYW5jZWxcIjpcItmE2YHZiFwiLFwicmVtb3ZlTGFzdFZlcnRleFwiOlwi2K3YsNmBINii2K7YsduM2YYg2LHYo9izXCJ9LFwiYnV0dG9uVGl0bGVzXCI6e1wiZHJhd01hcmtlckJ1dHRvblwiOlwi2K/YsdisINmG2LTYp9mGXCIsXCJkcmF3UG9seUJ1dHRvblwiOlwi2LHYs9mFINqG2YbYr9i22YTYuduMXCIsXCJkcmF3TGluZUJ1dHRvblwiOlwi2LHYs9mFINiu2LdcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcItix2LPZhSDYr9in24zYsdmHXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwi2LHYs9mFINqG2YfYp9ix2LbZhNi524xcIixcImVkaXRCdXR0b25cIjpcItmI24zYsdin24zYtCDZhNin24zZh+KAjNmH2KdcIixcImRyYWdCdXR0b25cIjpcItis2KfYqNis2KfbjNuMINmE2KfbjNmH4oCM2YfYp1wiLFwiY3V0QnV0dG9uXCI6XCLYqNix2LQg2YTYp9uM2YfigIzZh9inXCIsXCJkZWxldGVCdXR0b25cIjpcItit2LDZgSDZhNin24zZh+KAjNmH2KdcIixcImRyYXdDaXJjbGVNYXJrZXJCdXR0b25cIjpcItix2LPZhSDZhti02KfZhiDYr9in24zYsdmHXCIsXCJzbmFwcGluZ0J1dHRvblwiOlwi2YbYtNin2Ybar9ixINix2Kcg2KjZhyDZhNin24zZh+KAjNmH2Kcg2Ygg2LHYptmI2LMg2K/bjNqv2LEg2Kjaqdi024zYr1wiLFwicGlubmluZ0J1dHRvblwiOlwi2LHYptmI2LMg2YXYtNiq2LHaqSDYsdinINio2Kcg2YfZhSDZvtuM2YYg2qnZhtuM2K9cIixcInJvdGF0ZUJ1dHRvblwiOlwi2obYsdiu2LQg2YTYp9uM2YdcIn19JyksdWE6SlNPTi5wYXJzZSgne1widG9vbHRpcHNcIjp7XCJwbGFjZU1hcmtlclwiOlwi0J3QsNGC0LjRgdC90ZbRgtGMLCDRidC+0LEg0L3QsNC90LXRgdGC0Lgg0LzQsNGA0LrQtdGAXCIsXCJmaXJzdFZlcnRleFwiOlwi0J3QsNGC0LjRgdC90ZbRgtGMLCDRidC+0LEg0L3QsNC90LXRgdGC0Lgg0L/QtdGA0YjRgyDQstC10YDRiNC40L3Rg1wiLFwiY29udGludWVMaW5lXCI6XCLQndCw0YLQuNGB0L3RltGC0YwsINGJ0L7QsSDQv9GA0L7QtNC+0LLQttC40YLQuCDQvNCw0LvRjtCy0LDRgtC4XCIsXCJmaW5pc2hMaW5lXCI6XCLQndCw0YLQuNGB0L3RltGC0Ywg0LHRg9C00Ywt0Y/QutC40Lkg0ZbRgdC90YPRjtGH0LjQuSDQvNCw0YDQutC10YAg0LTQu9GPINC30LDQstC10YDRiNC10L3QvdGPXCIsXCJmaW5pc2hQb2x5XCI6XCLQktC40LHQtdGA0ZbRgtGMINC/0LXRgNGI0LjQuSDQvNCw0YDQutC10YAsINGJ0L7QsSDQt9Cw0LLQtdGA0YjQuNGC0LhcIixcImZpbmlzaFJlY3RcIjpcItCd0LDRgtC40YHQvdGW0YLRjCwg0YnQvtCxINC30LDQstC10YDRiNC40YLQuFwiLFwic3RhcnRDaXJjbGVcIjpcItCd0LDRgtC40YHQvdGW0YLRjCwg0YnQvtCxINC00L7QtNCw0YLQuCDRhtC10L3RgtGAINC60L7Qu9CwXCIsXCJmaW5pc2hDaXJjbGVcIjpcItCd0LDRgtC40YHQvdGW0YLRjCwg0YnQvtCxINC30LDQstC10YDRiNC40YLQuCDQutC+0LvQvlwiLFwicGxhY2VDaXJjbGVNYXJrZXJcIjpcItCd0LDRgtC40YHQvdGW0YLRjCwg0YnQvtCxINC90LDQvdC10YHRgtC4INC60YDRg9Cz0L7QstC40Lkg0LzQsNGA0LrQtdGAXCJ9LFwiYWN0aW9uc1wiOntcImZpbmlzaFwiOlwi0JfQsNCy0LXRgNGI0LjRgtC4XCIsXCJjYW5jZWxcIjpcItCS0ZbQtNC80ZbQvdC40YLQuFwiLFwicmVtb3ZlTGFzdFZlcnRleFwiOlwi0JLQuNC00LDQu9C40YLQuCDQv9C+0L/QtdGA0LXQtNC90Y4g0LLQtdGA0YjQuNC90YNcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCLQnNCw0LvRjtCy0LDRgtC4INC80LDRgNC60LXRgFwiLFwiZHJhd1BvbHlCdXR0b25cIjpcItCc0LDQu9GO0LLQsNGC0Lgg0L/QvtC70ZbQs9C+0L1cIixcImRyYXdMaW5lQnV0dG9uXCI6XCLQnNCw0LvRjtCy0LDRgtC4INC60YDQuNCy0YNcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcItCc0LDQu9GO0LLQsNGC0Lgg0LrQvtC70L5cIixcImRyYXdSZWN0QnV0dG9uXCI6XCLQnNCw0LvRjtCy0LDRgtC4INC/0YDRj9C80L7QutGD0YLQvdC40LpcIixcImVkaXRCdXR0b25cIjpcItCg0LXQtNCw0LPRg9Cy0LDRgtC4INGI0LDRgNC4XCIsXCJkcmFnQnV0dG9uXCI6XCLQn9C10YDQtdC90LXRgdGC0Lgg0YjQsNGA0LhcIixcImN1dEJ1dHRvblwiOlwi0JLQuNGA0ZbQt9Cw0YLQuCDRiNCw0YDQuFwiLFwiZGVsZXRlQnV0dG9uXCI6XCLQktC40LTQsNC70LjRgtC4INGI0LDRgNC4XCIsXCJkcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCI6XCLQnNCw0LvRjtCy0LDRgtC4INC60YDRg9Cz0L7QstC40Lkg0LzQsNGA0LrQtdGAXCIsXCJzbmFwcGluZ0J1dHRvblwiOlwi0J/RgNC40LLigJnRj9C30LDRgtC4INC/0LXRgNC10YLRj9Cz0L3Rg9GC0LjQuSDQvNCw0YDQutC10YAg0LTQviDRltC90YjQuNGFINGI0LDRgNGW0LIg0YLQsCDQstC10YDRiNC40L1cIixcInBpbm5pbmdCdXR0b25cIjpcItCX0LJcXCfRj9C30LDRgtC4INGB0L/RltC70YzQvdGWINCy0LXRgNGI0LjQvdC4INGA0LDQt9C+0LxcIn19JyksdHI6SlNPTi5wYXJzZSgne1widG9vbHRpcHNcIjp7XCJwbGFjZU1hcmtlclwiOlwixLDFn2FyZXTDp2kgeWVybGXFn3Rpcm1layBpw6dpbiB0xLFrbGF5xLFuXCIsXCJmaXJzdFZlcnRleFwiOlwixLBsayB0ZXBlIG5va3Rhc8SxbsSxIHllcmxlxZ90aXJtZWsgacOnaW4gdMSxa2xhecSxblwiLFwiY29udGludWVMaW5lXCI6XCLDh2l6aW1lIGRldmFtIGV0bWVrIGnDp2luIHTEsWtsYXnEsW5cIixcImZpbmlzaExpbmVcIjpcIkJpdGlybWVrIGnDp2luIG1ldmN1dCBoZXJoYW5naSBiaXIgacWfYXJldMOnaXlpIHTEsWtsYXnEsW5cIixcImZpbmlzaFBvbHlcIjpcIkJpdGlybWVrIGnDp2luIGlsayBpxZ9hcmV0w6dpeWkgdMSxa2xhecSxblwiLFwiZmluaXNoUmVjdFwiOlwiQml0aXJtZWsgacOnaW4gdMSxa2xhecSxblwiLFwic3RhcnRDaXJjbGVcIjpcIkRhaXJlIG1lcmtlemluZSB5ZXJsZcWfdGlybWVrIGnDp2luIHTEsWtsYXnEsW5cIixcImZpbmlzaENpcmNsZVwiOlwiRGFpcmV5aSBiaXRpcm1layBpw6dpbiB0xLFrbGF5xLFuXCIsXCJwbGFjZUNpcmNsZU1hcmtlclwiOlwiRGFpcmUgacWfYXJldMOnaXNpIHllcmxlxZ90aXJtZWsgacOnaW4gdMSxa2xhecSxblwifSxcImFjdGlvbnNcIjp7XCJmaW5pc2hcIjpcIkJpdGlyXCIsXCJjYW5jZWxcIjpcIsSwcHRhbFwiLFwicmVtb3ZlTGFzdFZlcnRleFwiOlwiU29uIGvDtsWfZXlpIGthbGTEsXJcIn0sXCJidXR0b25UaXRsZXNcIjp7XCJkcmF3TWFya2VyQnV0dG9uXCI6XCLDh2l6aW0gxLDFn2FyZXTDp2lzaVwiLFwiZHJhd1BvbHlCdXR0b25cIjpcIsOHb2tnZW5sZXIgw6dpelwiLFwiZHJhd0xpbmVCdXR0b25cIjpcIsOHb2tsdSDDp2l6Z2kgw6dpelwiLFwiZHJhd0NpcmNsZUJ1dHRvblwiOlwiw4dlbWJlciDDp2l6XCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwiRGlrZMO2cnRnZW4gw6dpelwiLFwiZWRpdEJ1dHRvblwiOlwiS2F0bWFubGFyxLEgZMO8emVubGVcIixcImRyYWdCdXR0b25cIjpcIkthdG1hbmxhcsSxIHPDvHLDvGtsZVwiLFwiY3V0QnV0dG9uXCI6XCJLYXRtYW5sYXLEsSBrZXNcIixcImRlbGV0ZUJ1dHRvblwiOlwiS2F0bWFubGFyxLEga2FsZMSxclwiLFwiZHJhd0NpcmNsZU1hcmtlckJ1dHRvblwiOlwiRGFpcmUgacWfYXJldMOnaXNpIMOnaXpcIixcInNuYXBwaW5nQnV0dG9uXCI6XCJTw7xyw7xrbGVuZW4gacWfYXJldMOnaXlpIGRpxJ9lciBrYXRtYW5sYXJhIHZlIGvDtsWfZWxlcmUgeWFwxLHFn3TEsXJcIixcInBpbm5pbmdCdXR0b25cIjpcIlBheWxhxZ/EsWxhbiBrw7bFn2VsZXJpIGJpcmJpcmluZSBzYWJpdGxlXCJ9fScpLGN6OkpTT04ucGFyc2UoJ3tcInRvb2x0aXBzXCI6e1wicGxhY2VNYXJrZXJcIjpcIktsaWtudXTDrW0gdnl0dm/FmcOtdGUgem5hxI1rdVwiLFwiZmlyc3RWZXJ0ZXhcIjpcIktsaWtudXTDrW0gdnl0dm/FmcOtdGUgcHJ2bsOtIG9iamVrdFwiLFwiY29udGludWVMaW5lXCI6XCJLbGlrbnV0w61tIHBva3JhxI11anRlIHYga3Jlc2xlbsOtXCIsXCJmaW5pc2hMaW5lXCI6XCJLbGlrbnV0w60gbmEgbGlib3ZvbG5vdSBleGlzdHVqw61jw60gem5hxI1rdSBwcm8gZG9rb27EjWVuw61cIixcImZpbmlzaFBvbHlcIjpcIlZ5YmVydGUgcHJ2bsOtIGJvZCBwcm8gZG9rb27EjWVuw61cIixcImZpbmlzaFJlY3RcIjpcIktsaWtuxJt0ZSBwcm8gZG9rb27EjWVuw61cIixcInN0YXJ0Q2lyY2xlXCI6XCJLbGlrbnV0w61tIHDFmWlkZWp0ZSBzdMWZZWQga3J1aHVcIixcImZpbmlzaENpcmNsZVwiOlwi0J3QsNC20LzQuNGC0LUsINGH0YLQvtCx0Ysg0LfQsNC00LDRgtGMINGA0LDQtNC40YPRgVwiLFwicGxhY2VDaXJjbGVNYXJrZXJcIjpcIktsaWtudXTDrW0gbmFzdGF2dGUgcG9sb23Em3JcIn0sXCJhY3Rpb25zXCI6e1wiZmluaXNoXCI6XCJEb2tvbsSNaXRcIixcImNhbmNlbFwiOlwiWnJ1xaFpdFwiLFwicmVtb3ZlTGFzdFZlcnRleFwiOlwiWnJ1xaFpdCBwb3NsZWRuw60gYWtjaVwifSxcImJ1dHRvblRpdGxlc1wiOntcImRyYXdNYXJrZXJCdXR0b25cIjpcIlDFmWlkYXQgem5hxI1rdVwiLFwiZHJhd1BvbHlCdXR0b25cIjpcIk5ha3Jlc2xpdCBwb2x5Z29uXCIsXCJkcmF3TGluZUJ1dHRvblwiOlwiTmFrcmVzbGl0IGvFmWl2a3VcIixcImRyYXdDaXJjbGVCdXR0b25cIjpcIk5ha3Jlc2xpdCBrcnVoXCIsXCJkcmF3UmVjdEJ1dHRvblwiOlwiTmFrcmVzbGl0IG9iZMOpbG7DrWtcIixcImVkaXRCdXR0b25cIjpcIlVwcmF2aXQgdnJzdHZ1XCIsXCJkcmFnQnV0dG9uXCI6XCJQxZllbmVzdGUgdnJzdHZ1XCIsXCJjdXRCdXR0b25cIjpcIlZ5am1vdXQgdnJzdHZ1XCIsXCJkZWxldGVCdXR0b25cIjpcIlNtYXphdCB2cnN0dnVcIixcImRyYXdDaXJjbGVNYXJrZXJCdXR0b25cIjpcIlDFmWlkYXQga3J1aG92b3Ugem5hxI1rdVwiLFwic25hcHBpbmdCdXR0b25cIjpcIk5hdsOhemF0IHRhxb5ub3Ugem5hxI1rdSBrIGRhbMWhw61tIHZyc3R2w6FtIGEgdnJjaG9sxa9tXCIsXCJwaW5uaW5nQnV0dG9uXCI6XCJTcG9qaXQgc3BvbGXEjW7DqSBib2R5IGRvaHJvbWFkeVwifX0nKX07ZnVuY3Rpb24gbSh0LGUpe3ZhciBpPU9iamVjdC5rZXlzKHQpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7ZSYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbil9cmV0dXJuIGl9ZnVuY3Rpb24geSh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbZV0/YXJndW1lbnRzW2VdOnt9O2UlMj9tKE9iamVjdChpKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dih0LGUsaVtlXSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXModCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpKSk6bShPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLGUpKX0pKX1yZXR1cm4gdH1mdW5jdGlvbiB2KHQsZSxpKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPWksdH1jb25zdCBiPXtfZ2xvYmFsRWRpdE1vZGVFbmFibGVkOiExLGVuYWJsZUdsb2JhbEVkaXRNb2RlOmZ1bmN0aW9uKHQpe3RoaXMuX2dsb2JhbEVkaXRNb2RlRW5hYmxlZD0hMCx0aGlzLlRvb2xiYXIudG9nZ2xlQnV0dG9uKFwiZWRpdE1vZGVcIix0aGlzLmdsb2JhbEVkaXRNb2RlRW5hYmxlZCgpKSxMLlBNLlV0aWxzLmZpbmRMYXllcnModGhpcy5tYXApLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UucG0uZW5hYmxlKHQpfSkpLHRoaXMudGhyb3R0bGVkUmVJbml0RWRpdHx8KHRoaXMudGhyb3R0bGVkUmVJbml0RWRpdD1MLlV0aWwudGhyb3R0bGUodGhpcy5oYW5kbGVMYXllckFkZGl0aW9uSW5HbG9iYWxFZGl0TW9kZSwxMDAsdGhpcykpLHRoaXMuX2FkZGVkTGF5ZXJzPXt9LHRoaXMubWFwLm9uKFwibGF5ZXJhZGRcIix0aGlzLl9sYXllckFkZGVkLHRoaXMpLHRoaXMubWFwLm9uKFwibGF5ZXJhZGRcIix0aGlzLnRocm90dGxlZFJlSW5pdEVkaXQsdGhpcyksdGhpcy5fZmlyZUdsb2JhbEVkaXRNb2RlVG9nZ2xlZCghMCl9LGRpc2FibGVHbG9iYWxFZGl0TW9kZTpmdW5jdGlvbigpe3RoaXMuX2dsb2JhbEVkaXRNb2RlRW5hYmxlZD0hMSxMLlBNLlV0aWxzLmZpbmRMYXllcnModGhpcy5tYXApLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucG0uZGlzYWJsZSgpfSkpLHRoaXMubWFwLm9mZihcImxheWVyYWRkXCIsdGhpcy50aHJvdHRsZWRSZUluaXRFZGl0LHRoaXMpLHRoaXMuVG9vbGJhci50b2dnbGVCdXR0b24oXCJlZGl0TW9kZVwiLHRoaXMuZ2xvYmFsRWRpdE1vZGVFbmFibGVkKCkpLHRoaXMuX2ZpcmVHbG9iYWxFZGl0TW9kZVRvZ2dsZWQoITEpfSxnbG9iYWxFZGl0RW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdsb2JhbEVkaXRNb2RlRW5hYmxlZCgpfSxnbG9iYWxFZGl0TW9kZUVuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZ2xvYmFsRWRpdE1vZGVFbmFibGVkfSx0b2dnbGVHbG9iYWxFZGl0TW9kZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp0aGlzLmdsb2JhbE9wdGlvbnM7dGhpcy5nbG9iYWxFZGl0TW9kZUVuYWJsZWQoKT90aGlzLmRpc2FibGVHbG9iYWxFZGl0TW9kZSgpOnRoaXMuZW5hYmxlR2xvYmFsRWRpdE1vZGUodCl9LGhhbmRsZUxheWVyQWRkaXRpb25Jbkdsb2JhbEVkaXRNb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fYWRkZWRMYXllcnM7Zm9yKHZhciBlIGluIHRoaXMuX2FkZGVkTGF5ZXJzPXt9LHQpe3ZhciBpPXRbZV07dGhpcy5faXNSZWxldmFudEZvckVkaXQoaSkmJnRoaXMuZ2xvYmFsRWRpdE1vZGVFbmFibGVkKCkmJmkucG0uZW5hYmxlKHkoe30sdGhpcy5nbG9iYWxPcHRpb25zKSl9fSxfbGF5ZXJBZGRlZDpmdW5jdGlvbih0KXt2YXIgZT10LmxheWVyO3RoaXMuX2FkZGVkTGF5ZXJzW0wuc3RhbXAoZSldPWV9LF9pc1JlbGV2YW50Rm9yRWRpdDpmdW5jdGlvbih0KXtyZXR1cm4gdC5wbSYmISh0IGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSYmKCFMLlBNLm9wdEluJiYhdC5vcHRpb25zLnBtSWdub3JlfHxMLlBNLm9wdEluJiYhMT09PXQub3B0aW9ucy5wbUlnbm9yZSkmJiF0Ll9wbVRlbXBMYXllciYmdC5wbS5vcHRpb25zLmFsbG93RWRpdGluZ319O2NvbnN0IGs9e19nbG9iYWxEcmFnTW9kZUVuYWJsZWQ6ITEsZW5hYmxlR2xvYmFsRHJhZ01vZGU6ZnVuY3Rpb24oKXt2YXIgdD1MLlBNLlV0aWxzLmZpbmRMYXllcnModGhpcy5tYXApO3RoaXMuX2dsb2JhbERyYWdNb2RlRW5hYmxlZD0hMCx0aGlzLl9hZGRlZExheWVyc0RyYWc9e30sdC5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnBtLmVuYWJsZUxheWVyRHJhZygpfSkpLHRoaXMudGhyb3R0bGVkUmVJbml0RHJhZ3x8KHRoaXMudGhyb3R0bGVkUmVJbml0RHJhZz1MLlV0aWwudGhyb3R0bGUodGhpcy5yZWluaXRHbG9iYWxEcmFnTW9kZSwxMDAsdGhpcykpLHRoaXMubWFwLm9uKFwibGF5ZXJhZGRcIix0aGlzLnRocm90dGxlZFJlSW5pdERyYWcsdGhpcyksdGhpcy5tYXAub24oXCJsYXllcmFkZFwiLHRoaXMuX2xheWVyQWRkZWREcmFnLHRoaXMpLHRoaXMuVG9vbGJhci50b2dnbGVCdXR0b24oXCJkcmFnTW9kZVwiLHRoaXMuZ2xvYmFsRHJhZ01vZGVFbmFibGVkKCkpLHRoaXMuX2ZpcmVHbG9iYWxEcmFnTW9kZVRvZ2dsZWQoITApfSxkaXNhYmxlR2xvYmFsRHJhZ01vZGU6ZnVuY3Rpb24oKXt2YXIgdD1MLlBNLlV0aWxzLmZpbmRMYXllcnModGhpcy5tYXApO3RoaXMuX2dsb2JhbERyYWdNb2RlRW5hYmxlZD0hMSx0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucG0uZGlzYWJsZUxheWVyRHJhZygpfSkpLHRoaXMubWFwLm9mZihcImxheWVyYWRkXCIsdGhpcy50aHJvdHRsZWRSZUluaXREcmFnLHRoaXMpLHRoaXMuVG9vbGJhci50b2dnbGVCdXR0b24oXCJkcmFnTW9kZVwiLHRoaXMuZ2xvYmFsRHJhZ01vZGVFbmFibGVkKCkpLHRoaXMuX2ZpcmVHbG9iYWxEcmFnTW9kZVRvZ2dsZWQoITEpfSxnbG9iYWxEcmFnTW9kZUVuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuX2dsb2JhbERyYWdNb2RlRW5hYmxlZH0sdG9nZ2xlR2xvYmFsRHJhZ01vZGU6ZnVuY3Rpb24oKXt0aGlzLmdsb2JhbERyYWdNb2RlRW5hYmxlZCgpP3RoaXMuZGlzYWJsZUdsb2JhbERyYWdNb2RlKCk6dGhpcy5lbmFibGVHbG9iYWxEcmFnTW9kZSgpfSxyZWluaXRHbG9iYWxEcmFnTW9kZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2FkZGVkTGF5ZXJzRHJhZztmb3IodmFyIGUgaW4gdGhpcy5fYWRkZWRMYXllcnNEcmFnPXt9LHQpe3ZhciBpPXRbZV07dGhpcy5faXNSZWxldmFudEZvckRyYWcoaSkmJnRoaXMuZ2xvYmFsRHJhZ01vZGVFbmFibGVkKCkmJmkucG0uZW5hYmxlTGF5ZXJEcmFnKCl9fSxfbGF5ZXJBZGRlZERyYWc6ZnVuY3Rpb24odCl7dmFyIGU9dC5sYXllcjt0aGlzLl9hZGRlZExheWVyc0RyYWdbTC5zdGFtcChlKV09ZX0sX2lzUmVsZXZhbnRGb3JEcmFnOmZ1bmN0aW9uKHQpe3JldHVybiB0LnBtJiYhKHQgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApJiYoIUwuUE0ub3B0SW4mJiF0Lm9wdGlvbnMucG1JZ25vcmV8fEwuUE0ub3B0SW4mJiExPT09dC5vcHRpb25zLnBtSWdub3JlKSYmIXQuX3BtVGVtcExheWVyJiZ0LnBtLm9wdGlvbnMuZHJhZ2dhYmxlfX07Y29uc3QgTT17X2dsb2JhbFJlbW92YWxNb2RlRW5hYmxlZDohMSxlbmFibGVHbG9iYWxSZW1vdmFsTW9kZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5fZ2xvYmFsUmVtb3ZhbE1vZGVFbmFibGVkPSEwLHRoaXMubWFwLmVhY2hMYXllcigoZnVuY3Rpb24oZSl7dC5faXNSZWxldmFudEZvclJlbW92YWwoZSkmJihlLnBtLmRpc2FibGUoKSxlLm9uKFwiY2xpY2tcIix0LnJlbW92ZUxheWVyLHQpKX0pKSx0aGlzLnRocm90dGxlZFJlSW5pdFJlbW92YWx8fCh0aGlzLnRocm90dGxlZFJlSW5pdFJlbW92YWw9TC5VdGlsLnRocm90dGxlKHRoaXMucmVpbml0R2xvYmFsUmVtb3ZhbE1vZGUsMTAwLHRoaXMpKSx0aGlzLm1hcC5vbihcImxheWVyYWRkXCIsdGhpcy50aHJvdHRsZWRSZUluaXRSZW1vdmFsLHRoaXMpLHRoaXMuVG9vbGJhci50b2dnbGVCdXR0b24oXCJyZW1vdmFsTW9kZVwiLHRoaXMuZ2xvYmFsUmVtb3ZhbE1vZGVFbmFibGVkKCkpLHRoaXMuX2ZpcmVHbG9iYWxSZW1vdmFsTW9kZVRvZ2dsZWQoITApfSxkaXNhYmxlR2xvYmFsUmVtb3ZhbE1vZGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuX2dsb2JhbFJlbW92YWxNb2RlRW5hYmxlZD0hMSx0aGlzLm1hcC5lYWNoTGF5ZXIoKGZ1bmN0aW9uKGUpe2Uub2ZmKFwiY2xpY2tcIix0LnJlbW92ZUxheWVyLHQpfSkpLHRoaXMubWFwLm9mZihcImxheWVyYWRkXCIsdGhpcy50aHJvdHRsZWRSZUluaXRSZW1vdmFsLHRoaXMpLHRoaXMuVG9vbGJhci50b2dnbGVCdXR0b24oXCJyZW1vdmFsTW9kZVwiLHRoaXMuZ2xvYmFsUmVtb3ZhbE1vZGVFbmFibGVkKCkpLHRoaXMuX2ZpcmVHbG9iYWxSZW1vdmFsTW9kZVRvZ2dsZWQoITEpfSxnbG9iYWxSZW1vdmFsRW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdsb2JhbFJlbW92YWxNb2RlRW5hYmxlZCgpfSxnbG9iYWxSZW1vdmFsTW9kZUVuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuX2dsb2JhbFJlbW92YWxNb2RlRW5hYmxlZH0sdG9nZ2xlR2xvYmFsUmVtb3ZhbE1vZGU6ZnVuY3Rpb24oKXt0aGlzLmdsb2JhbFJlbW92YWxNb2RlRW5hYmxlZCgpP3RoaXMuZGlzYWJsZUdsb2JhbFJlbW92YWxNb2RlKCk6dGhpcy5lbmFibGVHbG9iYWxSZW1vdmFsTW9kZSgpfSxyZWluaXRHbG9iYWxSZW1vdmFsTW9kZTpmdW5jdGlvbih0KXt2YXIgZT10LmxheWVyO3RoaXMuX2lzUmVsZXZhbnRGb3JSZW1vdmFsKGUpJiZ0aGlzLmdsb2JhbFJlbW92YWxNb2RlRW5hYmxlZCgpJiYodGhpcy5kaXNhYmxlR2xvYmFsUmVtb3ZhbE1vZGUoKSx0aGlzLmVuYWJsZUdsb2JhbFJlbW92YWxNb2RlKCkpfSxyZW1vdmVMYXllcjpmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldDt0aGlzLl9pc1JlbGV2YW50Rm9yUmVtb3ZhbChlKSYmIWUucG0uZHJhZ2dpbmcoKSYmKGUucmVtb3ZlRnJvbSh0aGlzLm1hcC5wbS5fZ2V0Q29udGFpbmluZ0xheWVyKCkpLGUucmVtb3ZlKCksZSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cD8odGhpcy5fZmlyZVJlbW92ZUxheWVyR3JvdXAoZSksdGhpcy5fZmlyZVJlbW92ZUxheWVyR3JvdXAodGhpcy5tYXAsZSkpOihlLnBtLl9maXJlUmVtb3ZlKGUpLGUucG0uX2ZpcmVSZW1vdmUodGhpcy5tYXAsZSkpKX0sX2lzUmVsZXZhbnRGb3JSZW1vdmFsOmZ1bmN0aW9uKHQpe3JldHVybiB0LnBtJiYhKHQgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApJiYoIUwuUE0ub3B0SW4mJiF0Lm9wdGlvbnMucG1JZ25vcmV8fEwuUE0ub3B0SW4mJiExPT09dC5vcHRpb25zLnBtSWdub3JlKSYmIXQuX3BtVGVtcExheWVyJiZ0LnBtLm9wdGlvbnMuYWxsb3dSZW1vdmFsfX07Y29uc3QgeD17X2dsb2JhbFJvdGF0ZU1vZGVFbmFibGVkOiExLGVuYWJsZUdsb2JhbFJvdGF0ZU1vZGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuX2dsb2JhbFJvdGF0ZU1vZGVFbmFibGVkPSEwLEwuUE0uVXRpbHMuZmluZExheWVycyh0aGlzLm1hcCkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEwuUG9seWxpbmV9KSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC5faXNSZWxldmFudEZvclJvdGF0ZShlKSYmZS5wbS5lbmFibGVSb3RhdGUoKX0pKSx0aGlzLnRocm90dGxlZFJlSW5pdFJvdGF0ZXx8KHRoaXMudGhyb3R0bGVkUmVJbml0Um90YXRlPUwuVXRpbC50aHJvdHRsZSh0aGlzLl9yZWluaXRHbG9iYWxSb3RhdGVNb2RlLDEwMCx0aGlzKSksdGhpcy5tYXAub24oXCJsYXllcmFkZFwiLHRoaXMudGhyb3R0bGVkUmVJbml0Um90YXRlLHRoaXMpLHRoaXMuVG9vbGJhci50b2dnbGVCdXR0b24oXCJyb3RhdGVNb2RlXCIsdGhpcy5nbG9iYWxSb3RhdGVNb2RlRW5hYmxlZCgpKSx0aGlzLl9maXJlR2xvYmFsUm90YXRlTW9kZVRvZ2dsZWQoKX0sZGlzYWJsZUdsb2JhbFJvdGF0ZU1vZGU6ZnVuY3Rpb24oKXt0aGlzLl9nbG9iYWxSb3RhdGVNb2RlRW5hYmxlZD0hMSxMLlBNLlV0aWxzLmZpbmRMYXllcnModGhpcy5tYXApLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBMLlBvbHlsaW5lfSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucG0uZGlzYWJsZVJvdGF0ZSgpfSkpLHRoaXMubWFwLm9mZihcImxheWVyYWRkXCIsdGhpcy50aHJvdHRsZWRSZUluaXRSb3RhdGUsdGhpcyksdGhpcy5Ub29sYmFyLnRvZ2dsZUJ1dHRvbihcInJvdGF0ZU1vZGVcIix0aGlzLmdsb2JhbFJvdGF0ZU1vZGVFbmFibGVkKCkpLHRoaXMuX2ZpcmVHbG9iYWxSb3RhdGVNb2RlVG9nZ2xlZCgpfSxnbG9iYWxSb3RhdGVNb2RlRW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiEhdGhpcy5fZ2xvYmFsUm90YXRlTW9kZUVuYWJsZWR9LHRvZ2dsZUdsb2JhbFJvdGF0ZU1vZGU6ZnVuY3Rpb24oKXt0aGlzLmdsb2JhbFJvdGF0ZU1vZGVFbmFibGVkKCk/dGhpcy5kaXNhYmxlR2xvYmFsUm90YXRlTW9kZSgpOnRoaXMuZW5hYmxlR2xvYmFsUm90YXRlTW9kZSgpfSxfcmVpbml0R2xvYmFsUm90YXRlTW9kZTpmdW5jdGlvbih0KXt2YXIgZT10LmxheWVyO3RoaXMuX2lzUmVsZXZhbnRGb3JSb3RhdGUoZSkmJnRoaXMuZ2xvYmFsUm90YXRlTW9kZUVuYWJsZWQoKSYmKHRoaXMuZGlzYWJsZUdsb2JhbFJvdGF0ZU1vZGUoKSx0aGlzLmVuYWJsZUdsb2JhbFJvdGF0ZU1vZGUoKSl9LF9pc1JlbGV2YW50Rm9yUm90YXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0LnBtJiYhKHQgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApJiYoIUwuUE0ub3B0SW4mJiF0Lm9wdGlvbnMucG1JZ25vcmV8fEwuUE0ub3B0SW4mJiExPT09dC5vcHRpb25zLnBtSWdub3JlKSYmIXQuX3BtVGVtcExheWVyJiZ0LnBtLm9wdGlvbnMuYWxsb3dSb3RhdGlvbn19O2Z1bmN0aW9uIHcodCxlKXt2YXIgaT1PYmplY3Qua2V5cyh0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO2UmJihuPW4uZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGUpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG4pfXJldHVybiBpfWZ1bmN0aW9uIEModCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIGk9bnVsbCE9YXJndW1lbnRzW2VdP2FyZ3VtZW50c1tlXTp7fTtlJTI/dyhPYmplY3QoaSksITApLmZvckVhY2goKGZ1bmN0aW9uKGUpe1AodCxlLGlbZV0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoaSkpOncoT2JqZWN0KGkpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaSxlKSl9KSl9cmV0dXJuIHR9ZnVuY3Rpb24gUCh0LGUsaSl7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1pLHR9dmFyIEU9e19maXJlRHJhd1N0YXJ0OmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOlwiRHJhd1wiLGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOnt9O3RoaXMuX19maXJlKHRoaXMuX21hcCxcInBtOmRyYXdzdGFydFwiLHtzaGFwZTp0aGlzLl9zaGFwZSx3b3JraW5nTGF5ZXI6dGhpcy5fbGF5ZXJ9LHQsZSl9LF9maXJlRHJhd0VuZDpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTpcIkRyYXdcIixlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1sxXTp7fTt0aGlzLl9fZmlyZSh0aGlzLl9tYXAsXCJwbTpkcmF3ZW5kXCIse3NoYXBlOnRoaXMuX3NoYXBlfSx0LGUpfSxfZmlyZUNyZWF0ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06XCJEcmF3XCIsaT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06e307dGhpcy5fX2ZpcmUodGhpcy5fbWFwLFwicG06Y3JlYXRlXCIse3NoYXBlOnRoaXMuX3NoYXBlLG1hcmtlcjp0LGxheWVyOnR9LGUsaSl9LF9maXJlQ2VudGVyUGxhY2VkOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOlwiRHJhd1wiLGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOnt9LGk9XCJEcmF3XCI9PT10P3RoaXMuX2xheWVyOnVuZGVmaW5lZCxuPVwiRHJhd1wiIT09dD90aGlzLl9sYXllcjp1bmRlZmluZWQ7dGhpcy5fX2ZpcmUodGhpcy5fbGF5ZXIsXCJwbTpjZW50ZXJwbGFjZWRcIix7c2hhcGU6dGhpcy5fc2hhcGUsd29ya2luZ0xheWVyOmksbGF5ZXI6bixsYXRsbmc6dGhpcy5fbGF5ZXIuZ2V0TGF0TG5nKCl9LHQsZSl9LF9maXJlQ3V0OmZ1bmN0aW9uKHQsZSxpKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106XCJEcmF3XCIscj1hcmd1bWVudHMubGVuZ3RoPjQmJmFyZ3VtZW50c1s0XSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbNF06e307dGhpcy5fX2ZpcmUodCxcInBtOmN1dFwiLHtzaGFwZTp0aGlzLl9zaGFwZSxsYXllcjplLG9yaWdpbmFsTGF5ZXI6aX0sbixyKX0sX2ZpcmVFZGl0OmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnRoaXMuX2xheWVyLGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOlwiRWRpdFwiLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzJdOnt9O3RoaXMuX19maXJlKHQsXCJwbTplZGl0XCIse2xheWVyOnRoaXMuX2xheWVyLHNoYXBlOnRoaXMuZ2V0U2hhcGUoKX0sZSxpKX0sX2ZpcmVFbmFibGU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06XCJFZGl0XCIsZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06e307dGhpcy5fX2ZpcmUodGhpcy5fbGF5ZXIsXCJwbTplbmFibGVcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSx0LGUpfSxfZmlyZURpc2FibGU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06XCJFZGl0XCIsZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06e307dGhpcy5fX2ZpcmUodGhpcy5fbGF5ZXIsXCJwbTpkaXNhYmxlXCIse2xheWVyOnRoaXMuX2xheWVyLHNoYXBlOnRoaXMuZ2V0U2hhcGUoKX0sdCxlKX0sX2ZpcmVVcGRhdGU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06XCJFZGl0XCIsZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06e307dGhpcy5fX2ZpcmUodGhpcy5fbGF5ZXIsXCJwbTp1cGRhdGVcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSx0LGUpfSxfZmlyZU1hcmtlckRyYWdTdGFydDpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06dW5kZWZpbmVkLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzJdOlwiRWRpdFwiLG49YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT11bmRlZmluZWQ/YXJndW1lbnRzWzNdOnt9O3RoaXMuX19maXJlKHRoaXMuX2xheWVyLFwicG06bWFya2VyZHJhZ3N0YXJ0XCIse2xheWVyOnRoaXMuX2xheWVyLG1hcmtlckV2ZW50OnQsc2hhcGU6dGhpcy5nZXRTaGFwZSgpLGluZGV4UGF0aDplfSxpLG4pfSxfZmlyZU1hcmtlckRyYWc6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOnVuZGVmaW5lZCxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTpcIkVkaXRcIixuPWFyZ3VtZW50cy5sZW5ndGg+MyYmYXJndW1lbnRzWzNdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1szXTp7fTt0aGlzLl9fZmlyZSh0aGlzLl9sYXllcixcInBtOm1hcmtlcmRyYWdcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsbWFya2VyRXZlbnQ6dCxzaGFwZTp0aGlzLmdldFNoYXBlKCksaW5kZXhQYXRoOmV9LGksbil9LF9maXJlTWFya2VyRHJhZ0VuZDpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06dW5kZWZpbmVkLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzJdOnVuZGVmaW5lZCxuPWFyZ3VtZW50cy5sZW5ndGg+MyYmYXJndW1lbnRzWzNdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1szXTpcIkVkaXRcIixyPWFyZ3VtZW50cy5sZW5ndGg+NCYmYXJndW1lbnRzWzRdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1s0XTp7fTt0aGlzLl9fZmlyZSh0aGlzLl9sYXllcixcInBtOm1hcmtlcmRyYWdlbmRcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsbWFya2VyRXZlbnQ6dCxzaGFwZTp0aGlzLmdldFNoYXBlKCksaW5kZXhQYXRoOmUsaW50ZXJzZWN0aW9uUmVzZXQ6aX0sbixyKX0sX2ZpcmVEcmFnU3RhcnQ6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06XCJFZGl0XCIsZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06e307dGhpcy5fX2ZpcmUodGhpcy5fbGF5ZXIsXCJwbTpkcmFnc3RhcnRcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSx0LGUpfSxfZmlyZURyYWc6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOlwiRWRpdFwiLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzJdOnt9O3RoaXMuX19maXJlKHRoaXMuX2xheWVyLFwicG06ZHJhZ1wiLEMoQyh7fSx0KSx7fSx7c2hhcGU6dGhpcy5nZXRTaGFwZSgpfSksZSxpKX0sX2ZpcmVEcmFnRW5kOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOlwiRWRpdFwiLGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOnt9O3RoaXMuX19maXJlKHRoaXMuX2xheWVyLFwicG06ZHJhZ2VuZFwiLHtsYXllcjp0aGlzLl9sYXllcixzaGFwZTp0aGlzLmdldFNoYXBlKCl9LHQsZSl9LF9maXJlRHJhZ0VuYWJsZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTpcIkVkaXRcIixlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1sxXTp7fTt0aGlzLl9fZmlyZSh0aGlzLl9sYXllcixcInBtOmRyYWdlbmFibGVcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSx0LGUpfSxfZmlyZURyYWdEaXNhYmxlOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOlwiRWRpdFwiLGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOnt9O3RoaXMuX19maXJlKHRoaXMuX2xheWVyLFwicG06ZHJhZ2Rpc2FibGVcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSx0LGUpfSxfZmlyZVJlbW92ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06dCxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTpcIkVkaXRcIixuPWFyZ3VtZW50cy5sZW5ndGg+MyYmYXJndW1lbnRzWzNdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1szXTp7fTt0aGlzLl9fZmlyZSh0LFwicG06cmVtb3ZlXCIse2xheWVyOmUsc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSxpLG4pfSxfZmlyZVZlcnRleEFkZGVkOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106XCJFZGl0XCIscj1hcmd1bWVudHMubGVuZ3RoPjQmJmFyZ3VtZW50c1s0XSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbNF06e307dGhpcy5fX2ZpcmUodGhpcy5fbGF5ZXIsXCJwbTp2ZXJ0ZXhhZGRlZFwiLHtsYXllcjp0aGlzLl9sYXllcix3b3JraW5nTGF5ZXI6dGhpcy5fbGF5ZXIsbWFya2VyOnQsaW5kZXhQYXRoOmUsbGF0bG5nOmksc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSxuLHIpfSxfZmlyZVZlcnRleFJlbW92ZWQ6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06XCJFZGl0XCIsbj1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106e307dGhpcy5fX2ZpcmUodGhpcy5fbGF5ZXIsXCJwbTp2ZXJ0ZXhyZW1vdmVkXCIse2xheWVyOnRoaXMuX2xheWVyLG1hcmtlcjp0LGluZGV4UGF0aDplLHNoYXBlOnRoaXMuZ2V0U2hhcGUoKX0saSxuKX0sX2ZpcmVWZXJ0ZXhDbGljazpmdW5jdGlvbih0LGUpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTpcIkVkaXRcIixuPWFyZ3VtZW50cy5sZW5ndGg+MyYmYXJndW1lbnRzWzNdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1szXTp7fTt0aGlzLl9fZmlyZSh0aGlzLl9sYXllcixcInBtOnZlcnRleGNsaWNrXCIse2xheWVyOnRoaXMuX2xheWVyLG1hcmtlckV2ZW50OnQsaW5kZXhQYXRoOmUsc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSxpLG4pfSxfZmlyZUludGVyc2VjdDpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06XCJFZGl0XCIsaT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06e307dGhpcy5fX2ZpcmUodGhpcy5fbGF5ZXIsXCJwbTppbnRlcnNlY3RcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsaW50ZXJzZWN0aW9uOnQsc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSxlLGkpfSxfZmlyZUxheWVyUmVzZXQ6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06XCJFZGl0XCIsbj1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106e307dGhpcy5fX2ZpcmUodGhpcy5fbGF5ZXIsXCJwbTpsYXllcnJlc2V0XCIse2xheWVyOnRoaXMuX2xheWVyLG1hcmtlckV2ZW50OnQsaW5kZXhQYXRoOmUsc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSxpLG4pfSxfZmlyZUNoYW5nZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06XCJFZGl0XCIsaT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06e307dGhpcy5fX2ZpcmUodGhpcy5fbGF5ZXIsXCJwbTpjaGFuZ2VcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsbGF0bG5nczp0LHNoYXBlOnRoaXMuZ2V0U2hhcGUoKX0sZSxpKX0sX2ZpcmVUZXh0Q2hhbmdlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1sxXTpcIkVkaXRcIixpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTp7fTt0aGlzLl9fZmlyZSh0aGlzLl9sYXllcixcInBtOnRleHRjaGFuZ2VcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsdGV4dDp0LHNoYXBlOnRoaXMuZ2V0U2hhcGUoKX0sZSxpKX0sX2ZpcmVTbmFwRHJhZzpmdW5jdGlvbih0LGUpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTpcIlNuYXBwaW5nXCIsbj1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106e307dGhpcy5fX2ZpcmUodCxcInBtOnNuYXBkcmFnXCIsZSxpLG4pfSxfZmlyZVNuYXA6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06XCJTbmFwcGluZ1wiLG49YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT11bmRlZmluZWQ/YXJndW1lbnRzWzNdOnt9O3RoaXMuX19maXJlKHQsXCJwbTpzbmFwXCIsZSxpLG4pfSxfZmlyZVVuc25hcDpmdW5jdGlvbih0LGUpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTpcIlNuYXBwaW5nXCIsbj1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106e307dGhpcy5fX2ZpcmUodCxcInBtOnVuc25hcFwiLGUsaSxuKX0sX2ZpcmVSb3RhdGlvbkVuYWJsZTpmdW5jdGlvbih0LGUpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTpcIlJvdGF0aW9uXCIsbj1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106e307dGhpcy5fX2ZpcmUodCxcInBtOnJvdGF0ZWVuYWJsZVwiLHtsYXllcjp0aGlzLl9sYXllcixoZWxwTGF5ZXI6dGhpcy5fcm90YXRlUG9seSxzaGFwZTp0aGlzLmdldFNoYXBlKCl9LGksbil9LF9maXJlUm90YXRpb25EaXNhYmxlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1sxXTpcIlJvdGF0aW9uXCIsaT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06e307dGhpcy5fX2ZpcmUodCxcInBtOnJvdGF0ZWRpc2FibGVcIix7bGF5ZXI6dGhpcy5fbGF5ZXIsc2hhcGU6dGhpcy5nZXRTaGFwZSgpfSxlLGkpfSxfZmlyZVJvdGF0aW9uU3RhcnQ6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06XCJSb3RhdGlvblwiLG49YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT11bmRlZmluZWQ/YXJndW1lbnRzWzNdOnt9O3RoaXMuX19maXJlKHQsXCJwbTpyb3RhdGVzdGFydFwiLHtsYXllcjp0aGlzLl9yb3RhdGlvbkxheWVyLGhlbHBMYXllcjp0aGlzLl9sYXllcixzdGFydEFuZ2xlOnRoaXMuX3N0YXJ0QW5nbGUsb3JpZ2luTGF0TG5nczplfSxpLG4pfSxfZmlyZVJvdGF0aW9uOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106dGhpcy5fcm90YXRpb25MYXllcixyPWFyZ3VtZW50cy5sZW5ndGg+NCYmYXJndW1lbnRzWzRdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1s0XTpcIlJvdGF0aW9uXCIsYT1hcmd1bWVudHMubGVuZ3RoPjUmJmFyZ3VtZW50c1s1XSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbNV06e307dGhpcy5fX2ZpcmUodCxcInBtOnJvdGF0ZVwiLHtsYXllcjpuLGhlbHBMYXllcjp0aGlzLl9sYXllcixzdGFydEFuZ2xlOnRoaXMuX3N0YXJ0QW5nbGUsYW5nbGU6bi5wbS5nZXRBbmdsZSgpLGFuZ2xlRGlmZjplLG9sZExhdExuZ3M6aSxuZXdMYXRMbmdzOm4uZ2V0TGF0TG5ncygpfSxyLGEpfSxfZmlyZVJvdGF0aW9uRW5kOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106XCJSb3RhdGlvblwiLHI9YXJndW1lbnRzLmxlbmd0aD40JiZhcmd1bWVudHNbNF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzRdOnt9O3RoaXMuX19maXJlKHQsXCJwbTpyb3RhdGVlbmRcIix7bGF5ZXI6dGhpcy5fcm90YXRpb25MYXllcixoZWxwTGF5ZXI6dGhpcy5fbGF5ZXIsc3RhcnRBbmdsZTplLGFuZ2xlOnRoaXMuX3JvdGF0aW9uTGF5ZXIucG0uZ2V0QW5nbGUoKSxvcmlnaW5MYXRMbmdzOmksbmV3TGF0TG5nczp0aGlzLl9yb3RhdGlvbkxheWVyLmdldExhdExuZ3MoKX0sbixyKX0sX2ZpcmVBY3Rpb25DbGljazpmdW5jdGlvbih0LGUsaSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT11bmRlZmluZWQ/YXJndW1lbnRzWzNdOlwiVG9vbGJhclwiLHI9YXJndW1lbnRzLmxlbmd0aD40JiZhcmd1bWVudHNbNF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzRdOnt9O3RoaXMuX19maXJlKHRoaXMuX21hcCxcInBtOmFjdGlvbmNsaWNrXCIse3RleHQ6dC50ZXh0LGFjdGlvbjp0LGJ0bk5hbWU6ZSxidXR0b246aX0sbixyKX0sX2ZpcmVCdXR0b25DbGljazpmdW5jdGlvbih0LGUpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTpcIlRvb2xiYXJcIixuPWFyZ3VtZW50cy5sZW5ndGg+MyYmYXJndW1lbnRzWzNdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1szXTp7fTt0aGlzLl9fZmlyZSh0aGlzLl9tYXAsXCJwbTpidXR0b25jbGlja1wiLHtidG5OYW1lOnQsYnV0dG9uOmV9LGksbil9LF9maXJlTGFuZ0NoYW5nZTpmdW5jdGlvbih0LGUsaSxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjQmJmFyZ3VtZW50c1s0XSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbNF06XCJHbG9iYWxcIixhPWFyZ3VtZW50cy5sZW5ndGg+NSYmYXJndW1lbnRzWzVdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1s1XTp7fTt0aGlzLl9fZmlyZSh0aGlzLm1hcCxcInBtOmxhbmdjaGFuZ2VcIix7b2xkTGFuZzp0LGFjdGl2ZUxhbmc6ZSxmYWxsYmFjazppLHRyYW5zbGF0aW9uczpufSxyLGEpfSxfZmlyZUdsb2JhbERyYWdNb2RlVG9nZ2xlZDpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06XCJHbG9iYWxcIixpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTp7fTt0aGlzLl9fZmlyZSh0aGlzLm1hcCxcInBtOmdsb2JhbGRyYWdtb2RldG9nZ2xlZFwiLHtlbmFibGVkOnQsbWFwOnRoaXMubWFwfSxlLGkpfSxfZmlyZUdsb2JhbEVkaXRNb2RlVG9nZ2xlZDpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06XCJHbG9iYWxcIixpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTp7fTt0aGlzLl9fZmlyZSh0aGlzLm1hcCxcInBtOmdsb2JhbGVkaXRtb2RldG9nZ2xlZFwiLHtlbmFibGVkOnQsbWFwOnRoaXMubWFwfSxlLGkpfSxfZmlyZUdsb2JhbFJlbW92YWxNb2RlVG9nZ2xlZDpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06XCJHbG9iYWxcIixpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTp7fTt0aGlzLl9fZmlyZSh0aGlzLm1hcCxcInBtOmdsb2JhbHJlbW92YWxtb2RldG9nZ2xlZFwiLHtlbmFibGVkOnQsbWFwOnRoaXMubWFwfSxlLGkpfSxfZmlyZUdsb2JhbEN1dE1vZGVUb2dnbGVkOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOlwiR2xvYmFsXCIsZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06e307dGhpcy5fX2ZpcmUodGhpcy5fbWFwLFwicG06Z2xvYmFsY3V0bW9kZXRvZ2dsZWRcIix7ZW5hYmxlZDohIXRoaXMuX2VuYWJsZWQsbWFwOnRoaXMuX21hcH0sdCxlKX0sX2ZpcmVHbG9iYWxEcmF3TW9kZVRvZ2dsZWQ6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06XCJHbG9iYWxcIixlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1sxXTp7fTt0aGlzLl9fZmlyZSh0aGlzLl9tYXAsXCJwbTpnbG9iYWxkcmF3bW9kZXRvZ2dsZWRcIix7ZW5hYmxlZDp0aGlzLl9lbmFibGVkLHNoYXBlOnRoaXMuX3NoYXBlLG1hcDp0aGlzLl9tYXB9LHQsZSl9LF9maXJlR2xvYmFsUm90YXRlTW9kZVRvZ2dsZWQ6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06XCJHbG9iYWxcIixlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1sxXTp7fTt0aGlzLl9fZmlyZSh0aGlzLm1hcCxcInBtOmdsb2JhbHJvdGF0ZW1vZGV0b2dnbGVkXCIse2VuYWJsZWQ6dGhpcy5nbG9iYWxSb3RhdGVNb2RlRW5hYmxlZCgpLG1hcDp0aGlzLm1hcH0sdCxlKX0sX2ZpcmVSZW1vdmVMYXllckdyb3VwOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1sxXTp0LGk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzJdOlwiRWRpdFwiLG49YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT11bmRlZmluZWQ/YXJndW1lbnRzWzNdOnt9O3RoaXMuX19maXJlKHQsXCJwbTpyZW1vdmVcIix7bGF5ZXI6ZSxzaGFwZTp1bmRlZmluZWR9LGksbil9LF9maXJlS2V5ZXZlbnRFdmVudDpmdW5jdGlvbih0LGUsaSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT11bmRlZmluZWQ/YXJndW1lbnRzWzNdOlwiR2xvYmFsXCIscj1hcmd1bWVudHMubGVuZ3RoPjQmJmFyZ3VtZW50c1s0XSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbNF06e307dGhpcy5fX2ZpcmUodGhpcy5tYXAsXCJwbTprZXlldmVudFwiLHtldmVudDp0LGV2ZW50VHlwZTplLGZvY3VzT246aX0sbixyKX0sX19maXJlOmZ1bmN0aW9uKHQsZSxpLG4pe3ZhciBhPWFyZ3VtZW50cy5sZW5ndGg+NCYmYXJndW1lbnRzWzRdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1s0XTp7fTtpPXIoKShpLGEse3NvdXJjZTpufSksTC5QTS5VdGlscy5fZmlyZUV2ZW50KHQsZSxpKX19O2NvbnN0IFM9RTtjb25zdCBPPXtfbGFzdEV2ZW50czp7a2V5ZG93bjp1bmRlZmluZWQsa2V5dXA6dW5kZWZpbmVkLGN1cnJlbnQ6dW5kZWZpbmVkfSxfaW5pdEtleUxpc3RlbmVyOmZ1bmN0aW9uKHQpe3RoaXMubWFwPXQsTC5Eb21FdmVudC5vbihkb2N1bWVudCxcImtleWRvd24ga2V5dXBcIix0aGlzLl9vbktleUxpc3RlbmVyLHRoaXMpLEwuRG9tRXZlbnQub24od2luZG93LFwiYmx1clwiLHRoaXMuX29uQmx1cix0aGlzKX0sX29uS2V5TGlzdGVuZXI6ZnVuY3Rpb24odCl7dmFyIGU9XCJkb2N1bWVudFwiO3RoaXMubWFwLmdldENvbnRhaW5lcigpLmNvbnRhaW5zKHQudGFyZ2V0KSYmKGU9XCJtYXBcIik7dmFyIGk9e2V2ZW50OnQsZXZlbnRUeXBlOnQudHlwZSxmb2N1c09uOmV9O3RoaXMuX2xhc3RFdmVudHNbdC50eXBlXT1pLHRoaXMuX2xhc3RFdmVudHMuY3VycmVudD1pLHRoaXMubWFwLnBtLl9maXJlS2V5ZXZlbnRFdmVudCh0LHQudHlwZSxlKX0sX29uQmx1cjpmdW5jdGlvbih0KXt0LmFsdEtleT0hMTt2YXIgZT17ZXZlbnQ6dCxldmVudFR5cGU6dC50eXBlLGZvY3VzT246XCJkb2N1bWVudFwifTt0aGlzLl9sYXN0RXZlbnRzW3QudHlwZV09ZSx0aGlzLl9sYXN0RXZlbnRzLmN1cnJlbnQ9ZX0sZ2V0TGFzdEtleUV2ZW50OmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOlwiY3VycmVudFwiO3JldHVybiB0aGlzLl9sYXN0RXZlbnRzW3RdfSxpc1NoaWZ0S2V5UHJlc3NlZDpmdW5jdGlvbigpe3ZhciB0O3JldHVybiBudWxsPT09KHQ9dGhpcy5fbGFzdEV2ZW50cy5jdXJyZW50KXx8dm9pZCAwPT09dD92b2lkIDA6dC5ldmVudC5zaGlmdEtleX0saXNBbHRLZXlQcmVzc2VkOmZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIG51bGw9PT0odD10aGlzLl9sYXN0RXZlbnRzLmN1cnJlbnQpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmV2ZW50LmFsdEtleX0saXNDdHJsS2V5UHJlc3NlZDpmdW5jdGlvbigpe3ZhciB0O3JldHVybiBudWxsPT09KHQ9dGhpcy5fbGFzdEV2ZW50cy5jdXJyZW50KXx8dm9pZCAwPT09dD92b2lkIDA6dC5ldmVudC5jdHJsS2V5fSxpc01ldGFLZXlQcmVzc2VkOmZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIG51bGw9PT0odD10aGlzLl9sYXN0RXZlbnRzLmN1cnJlbnQpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmV2ZW50Lm1ldGFLZXl9LGdldFByZXNzZWRLZXk6ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbnVsbD09PSh0PXRoaXMuX2xhc3RFdmVudHMuY3VycmVudCl8fHZvaWQgMD09PXQ/dm9pZCAwOnQuZXZlbnQua2V5fX07dmFyIEQ9aSg3MzYxKSxSPWkubihEKSxCPWkoODcyMSksVD1pLm4oQik7ZnVuY3Rpb24gSSh0KXt2YXIgZT1MLlBNLmFjdGl2ZUxhbmc7cmV0dXJuIFQoKShfLGUpfHwoZT1cImVuXCIpLFIoKShfW2VdLHQpfWZ1bmN0aW9uIGoodCl7cmV0dXJuIWZ1bmN0aW9uIGUodCl7cmV0dXJuIHQuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hW251bGwsXCJcIix1bmRlZmluZWRdLmluY2x1ZGVzKHQpfSkpLnJlZHVjZSgoZnVuY3Rpb24odCxpKXtyZXR1cm4gdC5jb25jYXQoQXJyYXkuaXNBcnJheShpKT9lKGkpOmkpfSksW10pfSh0KS5sZW5ndGh9ZnVuY3Rpb24gQSh0KXtyZXR1cm4gdC5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIDAhPT1lLmxlbmd0aCYmdC5wdXNoKEFycmF5LmlzQXJyYXkoZSk/QShlKTplKSx0fSksW10pfWZ1bmN0aW9uIEcodCxlLGkpe2Zvcih2YXIgbixyLGEsbz02Mzc4MTM3LHM9NjM1Njc1Mi4zMTQyLGw9MS8yOTguMjU3MjIzNTYzLGg9dC5sbmcsdT10LmxhdCxjPWkscD1NYXRoLlBJLGQ9ZSpwLzE4MCxmPU1hdGguc2luKGQpLGc9TWF0aC5jb3MoZCksXz0oMS1sKSpNYXRoLnRhbih1KnAvMTgwKSxtPTEvTWF0aC5zcXJ0KDErXypfKSx5PV8qbSx2PU1hdGguYXRhbjIoXyxnKSxiPW0qZixrPTEtYipiLE09ayoobypvLXMqcykvKHMqcykseD0xK00vMTYzODQqKDQwOTYrTSooTSooMzIwLTE3NSpNKS03NjgpKSx3PU0vMTAyNCooMjU2K00qKE0qKDc0LTQ3Kk0pLTEyOCkpLEM9Yy8ocyp4KSxQPTIqTWF0aC5QSTtNYXRoLmFicyhDLVApPjFlLTEyOyl7bj1NYXRoLmNvcygyKnYrQyksUD1DLEM9Yy8ocyp4KSt3KihyPU1hdGguc2luKEMpKSoobit3LzQqKChhPU1hdGguY29zKEMpKSooMipuKm4tMSktdy82Km4qKDQqcipyLTMpKig0Km4qbi0zKSkpfXZhciBFPXkqci1tKmEqZyxTPU1hdGguYXRhbjIoeSphK20qcipnLCgxLWwpKk1hdGguc3FydChiKmIrRSpFKSksTz1sLzE2KmsqKDQrbCooNC0zKmspKSxEPWgrMTgwKihNYXRoLmF0YW4yKHIqZixtKmEteSpyKmcpLSgxLU8pKmwqYiooQytPKnIqKG4rTyphKigyKm4qbi0xKSkpKS9wLFI9MTgwKlMvcDtyZXR1cm4gTC5sYXRMbmcoRCxSKX1mdW5jdGlvbiBOKHQsZSxpLG4pe2Zvcih2YXIgcixhLG89IShhcmd1bWVudHMubGVuZ3RoPjQmJmFyZ3VtZW50c1s0XSE9PXVuZGVmaW5lZCl8fGFyZ3VtZW50c1s0XSxzPVtdLGw9MDtsPGk7bCs9MSl7aWYobylyPUcodCwzNjAqbC9pK24sZSksYT1MLmxhdExuZyhyLmxuZyxyLmxhdCk7ZWxzZXt2YXIgaD10LmxhdCtNYXRoLmNvcygyKmwqTWF0aC5QSS9pKSplLHU9dC5sbmcrTWF0aC5zaW4oMipsKk1hdGguUEkvaSkqZTthPUwubGF0TG5nKGgsdSl9cy5wdXNoKGEpfXJldHVybiBzfWZ1bmN0aW9uIHoodCxlLGksbil7dmFyIHI9ZnVuY3Rpb24odCxlLGkpe3ZhciBuPXQubGF0TG5nVG9Db250YWluZXJQb2ludChlKSxyPXQubGF0TG5nVG9Db250YWluZXJQb2ludChpKSxhPTE4MCpNYXRoLmF0YW4yKHIueS1uLnksci54LW4ueCkvTWF0aC5QSSs5MDtyZXR1cm4gYSsoYTwwPzM2MDowKX0odCxlLGkpO3JldHVybiBmdW5jdGlvbih0LGUsaSl7ZT0oZSszNjApJTM2MDt2YXIgbj1NYXRoLlBJLzE4MCxyPTE4MC9NYXRoLlBJLGE9NjM3ODEzNyxvPXQubG5nKm4scz10LmxhdCpuLGw9ZSpuLGg9TWF0aC5zaW4ocyksdT1NYXRoLmNvcyhzKSxjPU1hdGguY29zKGkvYSkscD1NYXRoLnNpbihpL2EpLGQ9TWF0aC5hc2luKGgqYyt1KnAqTWF0aC5jb3MobCkpLGY9bytNYXRoLmF0YW4yKE1hdGguc2luKGwpKnAqdSxjLWgqTWF0aC5zaW4oZCkpO3JldHVybiBmPShmKj1yKT4xODA/Zi0zNjA6ZjwtMTgwP2YrMzYwOmYsTC5sYXRMbmcoW2QqcixmXSl9KGUscixuKX1mdW5jdGlvbiBVKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1sxXTp0LmdldExhdExuZ3MoKTtyZXR1cm4gdCBpbnN0YW5jZW9mIEwuUG9seWdvbj9MLnBvbHlnb24oZSkuZ2V0TGF0TG5ncygpOkwucG9seWxpbmUoZSkuZ2V0TGF0TG5ncygpfWZ1bmN0aW9uIEYodCxlKXt2YXIgaSxuO2lmKG51bGwhPT0oaT1lLm9wdGlvbnMuY3JzKSYmdm9pZCAwIT09aSYmbnVsbCE9PShuPWkucHJvamVjdGlvbikmJnZvaWQgMCE9PW4mJm4uTUFYX0xBVElUVURFKXt2YXIgcixhLG89bnVsbD09PShyPWUub3B0aW9ucy5jcnMpfHx2b2lkIDA9PT1yfHxudWxsPT09KGE9ci5wcm9qZWN0aW9uKXx8dm9pZCAwPT09YT92b2lkIDA6YS5NQVhfTEFUSVRVREU7dC5sYXQ9TWF0aC5tYXgoTWF0aC5taW4obyx0LmxhdCksLW8pfXJldHVybiB0fWZ1bmN0aW9uIFYodCl7cmV0dXJuIHQub3B0aW9ucy5yZW5kZXJlcnx8dC5fbWFwJiYodC5fbWFwLl9nZXRQYW5lUmVuZGVyZXIodC5vcHRpb25zLnBhbmUpfHx0Ll9tYXAub3B0aW9ucy5yZW5kZXJlcnx8dC5fbWFwLl9yZW5kZXJlcil8fHQuX3JlbmRlcmVyfWNvbnN0IEs9TC5DbGFzcy5leHRlbmQoe2luY2x1ZGVzOltiLGssTSx4LFNdLGluaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5tYXA9dCx0aGlzLkRyYXc9bmV3IEwuUE0uRHJhdyh0KSx0aGlzLlRvb2xiYXI9bmV3IEwuUE0uVG9vbGJhcih0KSx0aGlzLktleWJvYXJkPU8sdGhpcy5nbG9iYWxPcHRpb25zPXtzbmFwcGFibGU6ITAsbGF5ZXJHcm91cDp1bmRlZmluZWQsc25hcHBpbmdPcmRlcjpbXCJNYXJrZXJcIixcIkNpcmNsZU1hcmtlclwiLFwiQ2lyY2xlXCIsXCJMaW5lXCIsXCJQb2x5Z29uXCIsXCJSZWN0YW5nbGVcIl0scGFuZXM6e3ZlcnRleFBhbmU6XCJtYXJrZXJQYW5lXCIsbGF5ZXJQYW5lOlwib3ZlcmxheVBhbmVcIixtYXJrZXJQYW5lOlwibWFya2VyUGFuZVwifSxkcmFnZ2FibGU6ITB9LHRoaXMuS2V5Ym9hcmQuX2luaXRLZXlMaXN0ZW5lcih0KX0sc2V0TGFuZzpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTpcImVuXCIsZT1hcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnVuZGVmaW5lZCxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTpcImVuXCIsbj1MLlBNLmFjdGl2ZUxhbmc7ZSYmKF9bdF09cigpKF9baV0sZSkpLEwuUE0uYWN0aXZlTGFuZz10LHRoaXMubWFwLnBtLlRvb2xiYXIucmVpbml0KCksdGhpcy5fZmlyZUxhbmdDaGFuZ2Uobix0LGksX1t0XSl9LGFkZENvbnRyb2xzOmZ1bmN0aW9uKHQpe3RoaXMuVG9vbGJhci5hZGRDb250cm9scyh0KX0scmVtb3ZlQ29udHJvbHM6ZnVuY3Rpb24oKXt0aGlzLlRvb2xiYXIucmVtb3ZlQ29udHJvbHMoKX0sdG9nZ2xlQ29udHJvbHM6ZnVuY3Rpb24oKXt0aGlzLlRvb2xiYXIudG9nZ2xlQ29udHJvbHMoKX0sY29udHJvbHNWaXNpYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuVG9vbGJhci5pc1Zpc2libGV9LGVuYWJsZURyYXc6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06XCJQb2x5Z29uXCIsZT1hcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnVuZGVmaW5lZDtcIlBvbHlcIj09PXQmJih0PVwiUG9seWdvblwiKSx0aGlzLkRyYXcuZW5hYmxlKHQsZSl9LGRpc2FibGVEcmF3OmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOlwiUG9seWdvblwiO1wiUG9seVwiPT09dCYmKHQ9XCJQb2x5Z29uXCIpLHRoaXMuRHJhdy5kaXNhYmxlKHQpfSxzZXRQYXRoT3B0aW9uczpmdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOnt9LG49aS5pZ25vcmVTaGFwZXN8fFtdLHI9aS5tZXJnZXx8ITE7dGhpcy5tYXAucG0uRHJhdy5zaGFwZXMuZm9yRWFjaCgoZnVuY3Rpb24oaSl7LTE9PT1uLmluZGV4T2YoaSkmJmUubWFwLnBtLkRyYXdbaV0uc2V0UGF0aE9wdGlvbnModCxyKX0pKX0sZ2V0R2xvYmFsT3B0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdsb2JhbE9wdGlvbnN9LHNldEdsb2JhbE9wdGlvbnM6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxpPXIoKSh0aGlzLmdsb2JhbE9wdGlvbnMsdCksbj0hMTt0aGlzLm1hcC5wbS5EcmF3LkNpcmNsZU1hcmtlci5lbmFibGVkKCkmJnRoaXMubWFwLnBtLkRyYXcuQ2lyY2xlTWFya2VyLm9wdGlvbnMuZWRpdGFibGUhPT1pLmVkaXRhYmxlJiYodGhpcy5tYXAucG0uRHJhdy5DaXJjbGVNYXJrZXIuZGlzYWJsZSgpLG49ITApLHRoaXMubWFwLnBtLkRyYXcuc2hhcGVzLmZvckVhY2goKGZ1bmN0aW9uKHQpe2UubWFwLnBtLkRyYXdbdF0uc2V0T3B0aW9ucyhpKX0pKSxuJiZ0aGlzLm1hcC5wbS5EcmF3LkNpcmNsZU1hcmtlci5lbmFibGUoKSxMLlBNLlV0aWxzLmZpbmRMYXllcnModGhpcy5tYXApLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucG0uc2V0T3B0aW9ucyhpKX0pKSx0aGlzLmFwcGx5R2xvYmFsT3B0aW9ucygpLHRoaXMuZ2xvYmFsT3B0aW9ucz1pfSxhcHBseUdsb2JhbE9wdGlvbnM6ZnVuY3Rpb24oKXtMLlBNLlV0aWxzLmZpbmRMYXllcnModGhpcy5tYXApLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucG0uZW5hYmxlZCgpJiZ0LnBtLmFwcGx5T3B0aW9ucygpfSkpfSxnbG9iYWxEcmF3TW9kZUVuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuRHJhdy5nZXRBY3RpdmVTaGFwZSgpfSxnbG9iYWxDdXRNb2RlRW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiEhdGhpcy5EcmF3LkN1dC5lbmFibGVkKCl9LGVuYWJsZUdsb2JhbEN1dE1vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuRHJhdy5DdXQuZW5hYmxlKHQpfSx0b2dnbGVHbG9iYWxDdXRNb2RlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLkRyYXcuQ3V0LnRvZ2dsZSh0KX0sZGlzYWJsZUdsb2JhbEN1dE1vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5EcmF3LkN1dC5kaXNhYmxlKCl9LGdldEdlb21hbkxheWVyczpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkJiZhcmd1bWVudHNbMF0sZT1MLlBNLlV0aWxzLmZpbmRMYXllcnModGhpcy5tYXApO2lmKCF0KXJldHVybiBlO3ZhciBpPUwuZmVhdHVyZUdyb3VwKCk7cmV0dXJuIGkuX3BtVGVtcExheWVyPSEwLGUuZm9yRWFjaCgoZnVuY3Rpb24odCl7aS5hZGRMYXllcih0KX0pKSxpfSxnZXRHZW9tYW5EcmF3TGF5ZXJzOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQmJmFyZ3VtZW50c1swXSxlPUwuUE0uVXRpbHMuZmluZExheWVycyh0aGlzLm1hcCkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hMD09PXQuX2RyYXduQnlHZW9tYW59KSk7aWYoIXQpcmV0dXJuIGU7dmFyIGk9TC5mZWF0dXJlR3JvdXAoKTtyZXR1cm4gaS5fcG1UZW1wTGF5ZXI9ITAsZS5mb3JFYWNoKChmdW5jdGlvbih0KXtpLmFkZExheWVyKHQpfSkpLGl9LF9nZXRDb250YWluaW5nTGF5ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nbG9iYWxPcHRpb25zLmxheWVyR3JvdXAmJnRoaXMuZ2xvYmFsT3B0aW9ucy5sYXllckdyb3VwIGluc3RhbmNlb2YgTC5MYXllckdyb3VwP3RoaXMuZ2xvYmFsT3B0aW9ucy5sYXllckdyb3VwOnRoaXMubWFwfSxfaXNDUlNTaW1wbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAub3B0aW9ucy5jcnM9PT1MLkNSUy5TaW1wbGV9LF90b3VjaEV2ZW50Q291bnRlcjowLF9hZGRUb3VjaEV2ZW50czpmdW5jdGlvbih0KXswPT09dGhpcy5fdG91Y2hFdmVudENvdW50ZXImJihMLkRvbUV2ZW50Lm9uKHQsXCJ0b3VjaG1vdmVcIix0aGlzLl9jYW52YXNUb3VjaE1vdmUsdGhpcyksTC5Eb21FdmVudC5vbih0LFwidG91Y2hzdGFydCB0b3VjaGVuZCB0b3VjaGNhbmNlbFwiLHRoaXMuX2NhbnZhc1RvdWNoQ2xpY2ssdGhpcykpLHRoaXMuX3RvdWNoRXZlbnRDb3VudGVyKz0xfSxfcmVtb3ZlVG91Y2hFdmVudHM6ZnVuY3Rpb24odCl7MT09PXRoaXMuX3RvdWNoRXZlbnRDb3VudGVyJiYoTC5Eb21FdmVudC5vZmYodCxcInRvdWNobW92ZVwiLHRoaXMuX2NhbnZhc1RvdWNoTW92ZSx0aGlzKSxMLkRvbUV2ZW50Lm9mZih0LFwidG91Y2hzdGFydCB0b3VjaGVuZCB0b3VjaGNhbmNlbFwiLHRoaXMuX2NhbnZhc1RvdWNoQ2xpY2ssdGhpcykpLHRoaXMuX3RvdWNoRXZlbnRDb3VudGVyPXRoaXMuX3RvdWNoRXZlbnRDb3VudGVyPD0xPzA6dGhpcy5fdG91Y2hFdmVudENvdW50ZXItMX0sX2NhbnZhc1RvdWNoTW92ZTpmdW5jdGlvbih0KXtWKHRoaXMubWFwKS5fb25Nb3VzZU1vdmUodGhpcy5fY3JlYXRlTW91c2VFdmVudChcIm1vdXNlbW92ZVwiLHQpKX0sX2NhbnZhc1RvdWNoQ2xpY2s6ZnVuY3Rpb24odCl7dmFyIGU9XCJcIjtcInRvdWNoc3RhcnRcIj09PXQudHlwZXx8XCJwb2ludGVyZG93blwiPT09dC50eXBlP2U9XCJtb3VzZWRvd25cIjpcInRvdWNoZW5kXCI9PT10LnR5cGV8fFwicG9pbnRlcnVwXCI9PT10LnR5cGU/ZT1cIm1vdXNldXBcIjpcInRvdWNoY2FuY2VsXCIhPT10LnR5cGUmJlwicG9pbnRlcmNhbmNlbFwiIT09dC50eXBlfHwoZT1cIm1vdXNldXBcIiksZSYmVih0aGlzLm1hcCkuX29uQ2xpY2sodGhpcy5fY3JlYXRlTW91c2VFdmVudChlLHQpKX0sX2NyZWF0ZU1vdXNlRXZlbnQ6ZnVuY3Rpb24odCxlKXt2YXIgaSxuPWUudG91Y2hlc1swXXx8ZS5jaGFuZ2VkVG91Y2hlc1swXTt0cnl7aT1uZXcgTW91c2VFdmVudCh0LHtidWJibGVzOmUuYnViYmxlcyxjYW5jZWxhYmxlOmUuY2FuY2VsYWJsZSx2aWV3OmUudmlldyxkZXRhaWw6bi5kZXRhaWwsc2NyZWVuWDpuLnNjcmVlblgsc2NyZWVuWTpuLnNjcmVlblksY2xpZW50WDpuLmNsaWVudFgsY2xpZW50WTpuLmNsaWVudFksY3RybEtleTplLmN0cmxLZXksYWx0S2V5OmUuYWx0S2V5LHNoaWZ0S2V5OmUuc2hpZnRLZXksbWV0YUtleTplLm1ldGFLZXksYnV0dG9uOmUuYnV0dG9uLHJlbGF0ZWRUYXJnZXQ6ZS5yZWxhdGVkVGFyZ2V0fSl9Y2F0Y2gocil7KGk9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKSkuaW5pdE1vdXNlRXZlbnQodCxlLmJ1YmJsZXMsZS5jYW5jZWxhYmxlLGUudmlldyxuLmRldGFpbCxuLnNjcmVlblgsbi5zY3JlZW5ZLG4uY2xpZW50WCxuLmNsaWVudFksZS5jdHJsS2V5LGUuYWx0S2V5LGUuc2hpZnRLZXksZS5tZXRhS2V5LGUuYnV0dG9uLGUucmVsYXRlZFRhcmdldCl9cmV0dXJuIGl9fSk7ZnVuY3Rpb24gSCh0LGUpe3ZhciBpPU9iamVjdC5rZXlzKHQpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7ZSYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbil9cmV0dXJuIGl9ZnVuY3Rpb24gcSh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbZV0/YXJndW1lbnRzW2VdOnt9O2UlMj9IKE9iamVjdChpKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7Sih0LGUsaVtlXSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXModCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpKSk6SChPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLGUpKX0pKX1yZXR1cm4gdH1mdW5jdGlvbiBKKHQsZSxpKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPWksdH1jb25zdCBZPUwuQ29udHJvbC5leHRlbmQoe2luY2x1ZGVzOltTXSxvcHRpb25zOntwb3NpdGlvbjpcInRvcGxlZnRcIn0saW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9idXR0b249cShxKHt9LHRoaXMub3B0aW9ucyksdCl9LG9uQWRkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9tYXA9dCx0aGlzLl9tYXAucG0uVG9vbGJhci5vcHRpb25zLm9uZUJsb2NrP3RoaXMuX2NvbnRhaW5lcj10aGlzLl9tYXAucG0uVG9vbGJhci5fY3JlYXRlQ29udGFpbmVyKHRoaXMub3B0aW9ucy5wb3NpdGlvbik6XCJlZGl0XCI9PT10aGlzLl9idXR0b24udG9vbD90aGlzLl9jb250YWluZXI9dGhpcy5fbWFwLnBtLlRvb2xiYXIuZWRpdENvbnRhaW5lcjpcIm9wdGlvbnNcIj09PXRoaXMuX2J1dHRvbi50b29sP3RoaXMuX2NvbnRhaW5lcj10aGlzLl9tYXAucG0uVG9vbGJhci5vcHRpb25zQ29udGFpbmVyOlwiY3VzdG9tXCI9PT10aGlzLl9idXR0b24udG9vbD90aGlzLl9jb250YWluZXI9dGhpcy5fbWFwLnBtLlRvb2xiYXIuY3VzdG9tQ29udGFpbmVyOnRoaXMuX2NvbnRhaW5lcj10aGlzLl9tYXAucG0uVG9vbGJhci5kcmF3Q29udGFpbmVyLHRoaXMuYnV0dG9uc0RvbU5vZGU9dGhpcy5fbWFrZUJ1dHRvbih0aGlzLl9idXR0b24pLHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmJ1dHRvbnNEb21Ob2RlKSx0aGlzLl9jb250YWluZXJ9LG9uUmVtb3ZlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnV0dG9uc0RvbU5vZGUucmVtb3ZlKCksdGhpcy5fY29udGFpbmVyfSxnZXRUZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1dHRvbi50ZXh0fSxnZXRJY29uVXJsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1dHRvbi5pY29uVXJsfSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5fYnV0dG9uPXt9LHRoaXMuX3VwZGF0ZSgpfSx0b2dnbGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2J1dHRvbi50b2dnbGVTdGF0dXM9XCJib29sZWFuXCI9PXR5cGVvZiB0P3Q6IXRoaXMuX2J1dHRvbi50b2dnbGVTdGF0dXMsdGhpcy5fYXBwbHlTdHlsZUNsYXNzZXMoKSx0aGlzLl9idXR0b24udG9nZ2xlU3RhdHVzfSx0b2dnbGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1dHRvbi50b2dnbGVTdGF0dXN9LG9uQ3JlYXRlOmZ1bmN0aW9uKCl7dGhpcy50b2dnbGUoITEpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7dGhpcy50b2dnbGUoITEpLHRoaXMuX2J1dHRvbi5kaXNhYmxlZD0hMCx0aGlzLl91cGRhdGVEaXNhYmxlZCgpfSxlbmFibGU6ZnVuY3Rpb24oKXt0aGlzLl9idXR0b24uZGlzYWJsZWQ9ITEsdGhpcy5fdXBkYXRlRGlzYWJsZWQoKX0sX3RyaWdnZXJDbGljazpmdW5jdGlvbih0KXt0JiZ0LnByZXZlbnREZWZhdWx0KCksdGhpcy5fYnV0dG9uLmRpc2FibGVkfHwodGhpcy5fYnV0dG9uLm9uQ2xpY2sodCx7YnV0dG9uOnRoaXMsZXZlbnQ6dH0pLHRoaXMuX2NsaWNrZWQodCksdGhpcy5fYnV0dG9uLmFmdGVyQ2xpY2sodCx7YnV0dG9uOnRoaXMsZXZlbnQ6dH0pKX0sX21ha2VCdXR0b246ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxpPXRoaXMub3B0aW9ucy5wb3NpdGlvbi5pbmRleE9mKFwicmlnaHRcIik+LTE/XCJwb3MtcmlnaHRcIjpcIlwiLG49TC5Eb21VdGlsLmNyZWF0ZShcImRpdlwiLFwiYnV0dG9uLWNvbnRhaW5lciAgXCIuY29uY2F0KGkpLHRoaXMuX2NvbnRhaW5lcik7dC50aXRsZSYmbi5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLHQudGl0bGUpO3ZhciByPUwuRG9tVXRpbC5jcmVhdGUoXCJhXCIsXCJsZWFmbGV0LWJ1dHRvbnMtY29udHJvbC1idXR0b25cIixuKTtyLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImJ1dHRvblwiKSxyLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCIwXCIpLHIuaHJlZj1cIiNcIjt2YXIgYT1MLkRvbVV0aWwuY3JlYXRlKFwiZGl2XCIsXCJsZWFmbGV0LXBtLWFjdGlvbnMtY29udGFpbmVyIFwiLmNvbmNhdChpKSxuKSxvPXQuYWN0aW9ucyxzPXtjYW5jZWw6e3RleHQ6SShcImFjdGlvbnMuY2FuY2VsXCIpLG9uQ2xpY2s6ZnVuY3Rpb24oKXt0aGlzLl90cmlnZ2VyQ2xpY2soKX19LGZpbmlzaE1vZGU6e3RleHQ6SShcImFjdGlvbnMuZmluaXNoXCIpLG9uQ2xpY2s6ZnVuY3Rpb24oKXt0aGlzLl90cmlnZ2VyQ2xpY2soKX19LHJlbW92ZUxhc3RWZXJ0ZXg6e3RleHQ6SShcImFjdGlvbnMucmVtb3ZlTGFzdFZlcnRleFwiKSxvbkNsaWNrOmZ1bmN0aW9uKCl7dGhpcy5fbWFwLnBtLkRyYXdbdC5qc0NsYXNzXS5fcmVtb3ZlTGFzdFZlcnRleCgpfX0sZmluaXNoOnt0ZXh0OkkoXCJhY3Rpb25zLmZpbmlzaFwiKSxvbkNsaWNrOmZ1bmN0aW9uKGUpe3RoaXMuX21hcC5wbS5EcmF3W3QuanNDbGFzc10uX2ZpbmlzaFNoYXBlKGUpfX19O28uZm9yRWFjaCgoZnVuY3Rpb24obil7dmFyIHIsbz1cInN0cmluZ1wiPT10eXBlb2Ygbj9uOm4ubmFtZTtpZihzW29dKXI9c1tvXTtlbHNle2lmKCFuLnRleHQpcmV0dXJuO3I9bn12YXIgbD1MLkRvbVV0aWwuY3JlYXRlKFwiYVwiLFwibGVhZmxldC1wbS1hY3Rpb24gXCIuY29uY2F0KGksXCIgYWN0aW9uLVwiKS5jb25jYXQobyksYSk7aWYobC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsXCJidXR0b25cIiksbC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLFwiMFwiKSxsLmhyZWY9XCIjXCIsbC5pbm5lckhUTUw9ci50ZXh0LEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obCksTC5Eb21FdmVudC5vbihsLFwiY2xpY2tcIixMLkRvbUV2ZW50LnN0b3ApLCF0LmRpc2FibGVkJiZyLm9uQ2xpY2spe0wuRG9tRXZlbnQuYWRkTGlzdGVuZXIobCxcImNsaWNrXCIsKGZ1bmN0aW9uKGkpe2kucHJldmVudERlZmF1bHQoKTt2YXIgbj1cIlwiLGE9ZS5fbWFwLnBtLlRvb2xiYXIuYnV0dG9ucztmb3IodmFyIG8gaW4gYSlpZihhW29dLl9idXR0b249PT10KXtuPW87YnJlYWt9ZS5fZmlyZUFjdGlvbkNsaWNrKHIsbix0KX0pLGUpLEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIobCxcImNsaWNrXCIsci5vbkNsaWNrLGUpfX0pKSx0LnRvZ2dsZVN0YXR1cyYmTC5Eb21VdGlsLmFkZENsYXNzKG4sXCJhY3RpdmVcIik7dmFyIGw9TC5Eb21VdGlsLmNyZWF0ZShcImRpdlwiLFwiY29udHJvbC1pY29uXCIscik7cmV0dXJuIHQuaWNvblVybCYmbC5zZXRBdHRyaWJ1dGUoXCJzcmNcIix0Lmljb25VcmwpLHQuY2xhc3NOYW1lJiZMLkRvbVV0aWwuYWRkQ2xhc3MobCx0LmNsYXNzTmFtZSksTC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihyKSxMLkRvbUV2ZW50Lm9uKHIsXCJjbGlja1wiLEwuRG9tRXZlbnQuc3RvcCksdC5kaXNhYmxlZHx8KEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIocixcImNsaWNrXCIsdGhpcy5fb25CdG5DbGljayx0aGlzKSxMLkRvbUV2ZW50LmFkZExpc3RlbmVyKHIsXCJjbGlja1wiLHRoaXMuX3RyaWdnZXJDbGljayx0aGlzKSksdC5kaXNhYmxlZCYmKEwuRG9tVXRpbC5hZGRDbGFzcyhyLFwicG0tZGlzYWJsZWRcIiksci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsXCJ0cnVlXCIpKSxufSxfYXBwbHlTdHlsZUNsYXNzZXM6ZnVuY3Rpb24oKXt0aGlzLl9jb250YWluZXImJih0aGlzLl9idXR0b24udG9nZ2xlU3RhdHVzJiYhMSE9PXRoaXMuX2J1dHRvbi5jc3NUb2dnbGU/KEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLmJ1dHRvbnNEb21Ob2RlLFwiYWN0aXZlXCIpLEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsXCJhY3RpdmVDaGlsZFwiKSk6KEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLmJ1dHRvbnNEb21Ob2RlLFwiYWN0aXZlXCIpLEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsXCJhY3RpdmVDaGlsZFwiKSkpfSxfb25CdG5DbGljazpmdW5jdGlvbigpe3RoaXMuX2J1dHRvbi5kaXNhYmxlT3RoZXJCdXR0b25zJiZ0aGlzLl9tYXAucG0uVG9vbGJhci50cmlnZ2VyQ2xpY2tPblRvZ2dsZWRCdXR0b25zKHRoaXMpO3ZhciB0PVwiXCIsZT10aGlzLl9tYXAucG0uVG9vbGJhci5idXR0b25zO2Zvcih2YXIgaSBpbiBlKWlmKGVbaV0uX2J1dHRvbj09PXRoaXMuX2J1dHRvbil7dD1pO2JyZWFrfXRoaXMuX2ZpcmVCdXR0b25DbGljayh0LHRoaXMuX2J1dHRvbil9LF9jbGlja2VkOmZ1bmN0aW9uKCl7dGhpcy5fYnV0dG9uLmRvVG9nZ2xlJiZ0aGlzLnRvZ2dsZSgpfSxfdXBkYXRlRGlzYWJsZWQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9jb250YWluZXIpe3ZhciB0PVwicG0tZGlzYWJsZWRcIixlPXRoaXMuYnV0dG9uc0RvbU5vZGUuY2hpbGRyZW5bMF07dGhpcy5fYnV0dG9uLmRpc2FibGVkPyhMLkRvbVV0aWwuYWRkQ2xhc3MoZSx0KSxlLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIixcInRydWVcIiksTC5Eb21FdmVudC5vZmYoZSxcImNsaWNrXCIsdGhpcy5fdHJpZ2dlckNsaWNrLHRoaXMpLEwuRG9tRXZlbnQub2ZmKGUsXCJjbGlja1wiLHRoaXMuX29uQnRuQ2xpY2ssdGhpcykpOihMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZSx0KSxlLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIixcImZhbHNlXCIpLEwuRG9tRXZlbnQub24oZSxcImNsaWNrXCIsdGhpcy5fdHJpZ2dlckNsaWNrLHRoaXMpLEwuRG9tRXZlbnQub24oZSxcImNsaWNrXCIsdGhpcy5fb25CdG5DbGljayx0aGlzKSl9fX0pO2Z1bmN0aW9uIFgodCxlKXt2YXIgaT1PYmplY3Qua2V5cyh0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO2UmJihuPW4uZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGUpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG4pfXJldHVybiBpfWZ1bmN0aW9uIFoodCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIGk9bnVsbCE9YXJndW1lbnRzW2VdP2FyZ3VtZW50c1tlXTp7fTtlJTI/WChPYmplY3QoaSksITApLmZvckVhY2goKGZ1bmN0aW9uKGUpeyQodCxlLGlbZV0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoaSkpOlgoT2JqZWN0KGkpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaSxlKSl9KSl9cmV0dXJuIHR9ZnVuY3Rpb24gJCh0LGUsaSl7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1pLHR9ZnVuY3Rpb24gVyh0KXtyZXR1cm4gVz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSxXKHQpfUwuQ29udHJvbC5QTUJ1dHRvbj1ZO2NvbnN0IFE9TC5DbGFzcy5leHRlbmQoe29wdGlvbnM6e2RyYXdNYXJrZXI6ITAsZHJhd1JlY3RhbmdsZTohMCxkcmF3UG9seWxpbmU6ITAsZHJhd1BvbHlnb246ITAsZHJhd0NpcmNsZTohMCxkcmF3Q2lyY2xlTWFya2VyOiEwLGRyYXdUZXh0OiEwLGVkaXRNb2RlOiEwLGRyYWdNb2RlOiEwLGN1dFBvbHlnb246ITAscmVtb3ZhbE1vZGU6ITAscm90YXRlTW9kZTohMCxzbmFwcGluZ09wdGlvbjohMCxkcmF3Q29udHJvbHM6ITAsZWRpdENvbnRyb2xzOiEwLG9wdGlvbnNDb250cm9sczohMCxjdXN0b21Db250cm9sczohMCxvbmVCbG9jazohMSxwb3NpdGlvbjpcInRvcGxlZnRcIixwb3NpdGlvbnM6e2RyYXc6XCJcIixlZGl0OlwiXCIsb3B0aW9uczpcIlwiLGN1c3RvbTpcIlwifX0sY3VzdG9tQnV0dG9uczpbXSxpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuaW5pdCh0KX0scmVpbml0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5pc1Zpc2libGU7dGhpcy5yZW1vdmVDb250cm9scygpLHRoaXMuX2RlZmluZUJ1dHRvbnMoKSx0JiZ0aGlzLmFkZENvbnRyb2xzKCl9LGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5tYXA9dCx0aGlzLmJ1dHRvbnM9e30sdGhpcy5pc1Zpc2libGU9ITEsdGhpcy5kcmF3Q29udGFpbmVyPUwuRG9tVXRpbC5jcmVhdGUoXCJkaXZcIixcImxlYWZsZXQtcG0tdG9vbGJhciBsZWFmbGV0LXBtLWRyYXcgbGVhZmxldC1iYXIgbGVhZmxldC1jb250cm9sXCIpLHRoaXMuZWRpdENvbnRhaW5lcj1MLkRvbVV0aWwuY3JlYXRlKFwiZGl2XCIsXCJsZWFmbGV0LXBtLXRvb2xiYXIgbGVhZmxldC1wbS1lZGl0IGxlYWZsZXQtYmFyIGxlYWZsZXQtY29udHJvbFwiKSx0aGlzLm9wdGlvbnNDb250YWluZXI9TC5Eb21VdGlsLmNyZWF0ZShcImRpdlwiLFwibGVhZmxldC1wbS10b29sYmFyIGxlYWZsZXQtcG0tb3B0aW9ucyBsZWFmbGV0LWJhciBsZWFmbGV0LWNvbnRyb2xcIiksdGhpcy5jdXN0b21Db250YWluZXI9TC5Eb21VdGlsLmNyZWF0ZShcImRpdlwiLFwibGVhZmxldC1wbS10b29sYmFyIGxlYWZsZXQtcG0tY3VzdG9tIGxlYWZsZXQtYmFyIGxlYWZsZXQtY29udHJvbFwiKSx0aGlzLl9kZWZpbmVCdXR0b25zKCl9LF9jcmVhdGVDb250YWluZXI6ZnVuY3Rpb24odCl7dmFyIGU9XCJcIi5jb25jYXQodCxcIkNvbnRhaW5lclwiKTtyZXR1cm4gdGhpc1tlXXx8KHRoaXNbZV09TC5Eb21VdGlsLmNyZWF0ZShcImRpdlwiLFwibGVhZmxldC1wbS10b29sYmFyIGxlYWZsZXQtcG0tXCIuY29uY2F0KHQsXCIgbGVhZmxldC1iYXIgbGVhZmxldC1jb250cm9sXCIpKSksdGhpc1tlXX0sZ2V0QnV0dG9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1dHRvbnN9LGFkZENvbnRyb2xzOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnRoaXMub3B0aW9ucztcInVuZGVmaW5lZFwiIT10eXBlb2YgdC5lZGl0UG9seWdvbiYmKHQuZWRpdE1vZGU9dC5lZGl0UG9seWdvbiksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQuZGVsZXRlTGF5ZXImJih0LnJlbW92YWxNb2RlPXQuZGVsZXRlTGF5ZXIpLEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsdCksdGhpcy5hcHBseUljb25TdHlsZSgpLHRoaXMuaXNWaXNpYmxlPSEwLHRoaXMuX3Nob3dIaWRlQnV0dG9ucygpfSxhcHBseUljb25TdHlsZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0QnV0dG9ucygpLGU9e2dlb21hbkljb25zOntkcmF3TWFya2VyOlwiY29udHJvbC1pY29uIGxlYWZsZXQtcG0taWNvbi1tYXJrZXJcIixkcmF3UG9seWxpbmU6XCJjb250cm9sLWljb24gbGVhZmxldC1wbS1pY29uLXBvbHlsaW5lXCIsZHJhd1JlY3RhbmdsZTpcImNvbnRyb2wtaWNvbiBsZWFmbGV0LXBtLWljb24tcmVjdGFuZ2xlXCIsZHJhd1BvbHlnb246XCJjb250cm9sLWljb24gbGVhZmxldC1wbS1pY29uLXBvbHlnb25cIixkcmF3Q2lyY2xlOlwiY29udHJvbC1pY29uIGxlYWZsZXQtcG0taWNvbi1jaXJjbGVcIixkcmF3Q2lyY2xlTWFya2VyOlwiY29udHJvbC1pY29uIGxlYWZsZXQtcG0taWNvbi1jaXJjbGUtbWFya2VyXCIsZWRpdE1vZGU6XCJjb250cm9sLWljb24gbGVhZmxldC1wbS1pY29uLWVkaXRcIixkcmFnTW9kZTpcImNvbnRyb2wtaWNvbiBsZWFmbGV0LXBtLWljb24tZHJhZ1wiLGN1dFBvbHlnb246XCJjb250cm9sLWljb24gbGVhZmxldC1wbS1pY29uLWN1dFwiLHJlbW92YWxNb2RlOlwiY29udHJvbC1pY29uIGxlYWZsZXQtcG0taWNvbi1kZWxldGVcIixkcmF3VGV4dDpcImNvbnRyb2wtaWNvbiBsZWFmbGV0LXBtLWljb24tdGV4dFwifX07Zm9yKHZhciBpIGluIHQpe3ZhciBuPXRbaV07TC5VdGlsLnNldE9wdGlvbnMobix7Y2xhc3NOYW1lOmUuZ2VvbWFuSWNvbnNbaV19KX19LHJlbW92ZUNvbnRyb2xzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRCdXR0b25zKCk7Zm9yKHZhciBlIGluIHQpdFtlXS5yZW1vdmUoKTt0aGlzLmlzVmlzaWJsZT0hMX0sdG9nZ2xlQ29udHJvbHM6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06dGhpcy5vcHRpb25zO3RoaXMuaXNWaXNpYmxlP3RoaXMucmVtb3ZlQ29udHJvbHMoKTp0aGlzLmFkZENvbnRyb2xzKHQpfSxfYWRkQnV0dG9uOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYnV0dG9uc1t0XT1lLHRoaXMub3B0aW9uc1t0XT10aGlzLm9wdGlvbnNbdF18fCExLHRoaXMuYnV0dG9uc1t0XX0sdHJpZ2dlckNsaWNrT25Ub2dnbGVkQnV0dG9uczpmdW5jdGlvbih0KXt2YXIgZT1bXCJzbmFwcGluZ09wdGlvblwiXTtmb3IodmFyIGkgaW4gdGhpcy5idXR0b25zKSFlLmluY2x1ZGVzKGkpJiZ0aGlzLmJ1dHRvbnNbaV0hPT10JiZ0aGlzLmJ1dHRvbnNbaV0udG9nZ2xlZCgpJiZ0aGlzLmJ1dHRvbnNbaV0uX3RyaWdnZXJDbGljaygpfSx0b2dnbGVCdXR0b246ZnVuY3Rpb24odCxlKXt2YXIgaT0hKGFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkKXx8YXJndW1lbnRzWzJdO3JldHVyblwiZWRpdFBvbHlnb25cIj09PXQmJih0PVwiZWRpdE1vZGVcIiksXCJkZWxldGVMYXllclwiPT09dCYmKHQ9XCJyZW1vdmFsTW9kZVwiKSxpJiZ0aGlzLnRyaWdnZXJDbGlja09uVG9nZ2xlZEJ1dHRvbnModGhpcy5idXR0b25zW3RdKSwhIXRoaXMuYnV0dG9uc1t0XSYmdGhpcy5idXR0b25zW3RdLnRvZ2dsZShlKX0sX2RlZmluZUJ1dHRvbnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9e2NsYXNzTmFtZTpcImNvbnRyb2wtaWNvbiBsZWFmbGV0LXBtLWljb24tbWFya2VyXCIsdGl0bGU6SShcImJ1dHRvblRpdGxlcy5kcmF3TWFya2VyQnV0dG9uXCIpLGpzQ2xhc3M6XCJNYXJrZXJcIixvbkNsaWNrOmZ1bmN0aW9uKCl7fSxhZnRlckNsaWNrOmZ1bmN0aW9uKGUsaSl7dC5tYXAucG0uRHJhd1tpLmJ1dHRvbi5fYnV0dG9uLmpzQ2xhc3NdLnRvZ2dsZSgpfSxkb1RvZ2dsZTohMCx0b2dnbGVTdGF0dXM6ITEsZGlzYWJsZU90aGVyQnV0dG9uczohMCxwb3NpdGlvbjp0aGlzLm9wdGlvbnMucG9zaXRpb24sYWN0aW9uczpbXCJjYW5jZWxcIl19LGk9e3RpdGxlOkkoXCJidXR0b25UaXRsZXMuZHJhd1BvbHlCdXR0b25cIiksY2xhc3NOYW1lOlwiY29udHJvbC1pY29uIGxlYWZsZXQtcG0taWNvbi1wb2x5Z29uXCIsanNDbGFzczpcIlBvbHlnb25cIixvbkNsaWNrOmZ1bmN0aW9uKCl7fSxhZnRlckNsaWNrOmZ1bmN0aW9uKGUsaSl7dC5tYXAucG0uRHJhd1tpLmJ1dHRvbi5fYnV0dG9uLmpzQ2xhc3NdLnRvZ2dsZSgpfSxkb1RvZ2dsZTohMCx0b2dnbGVTdGF0dXM6ITEsZGlzYWJsZU90aGVyQnV0dG9uczohMCxwb3NpdGlvbjp0aGlzLm9wdGlvbnMucG9zaXRpb24sYWN0aW9uczpbXCJmaW5pc2hcIixcInJlbW92ZUxhc3RWZXJ0ZXhcIixcImNhbmNlbFwiXX0sbj17Y2xhc3NOYW1lOlwiY29udHJvbC1pY29uIGxlYWZsZXQtcG0taWNvbi1wb2x5bGluZVwiLHRpdGxlOkkoXCJidXR0b25UaXRsZXMuZHJhd0xpbmVCdXR0b25cIiksanNDbGFzczpcIkxpbmVcIixvbkNsaWNrOmZ1bmN0aW9uKCl7fSxhZnRlckNsaWNrOmZ1bmN0aW9uKGUsaSl7dC5tYXAucG0uRHJhd1tpLmJ1dHRvbi5fYnV0dG9uLmpzQ2xhc3NdLnRvZ2dsZSgpfSxkb1RvZ2dsZTohMCx0b2dnbGVTdGF0dXM6ITEsZGlzYWJsZU90aGVyQnV0dG9uczohMCxwb3NpdGlvbjp0aGlzLm9wdGlvbnMucG9zaXRpb24sYWN0aW9uczpbXCJmaW5pc2hcIixcInJlbW92ZUxhc3RWZXJ0ZXhcIixcImNhbmNlbFwiXX0scj17dGl0bGU6SShcImJ1dHRvblRpdGxlcy5kcmF3Q2lyY2xlQnV0dG9uXCIpLGNsYXNzTmFtZTpcImNvbnRyb2wtaWNvbiBsZWFmbGV0LXBtLWljb24tY2lyY2xlXCIsanNDbGFzczpcIkNpcmNsZVwiLG9uQ2xpY2s6ZnVuY3Rpb24oKXt9LGFmdGVyQ2xpY2s6ZnVuY3Rpb24oZSxpKXt0Lm1hcC5wbS5EcmF3W2kuYnV0dG9uLl9idXR0b24uanNDbGFzc10udG9nZ2xlKCl9LGRvVG9nZ2xlOiEwLHRvZ2dsZVN0YXR1czohMSxkaXNhYmxlT3RoZXJCdXR0b25zOiEwLHBvc2l0aW9uOnRoaXMub3B0aW9ucy5wb3NpdGlvbixhY3Rpb25zOltcImNhbmNlbFwiXX0sYT17dGl0bGU6SShcImJ1dHRvblRpdGxlcy5kcmF3Q2lyY2xlTWFya2VyQnV0dG9uXCIpLGNsYXNzTmFtZTpcImNvbnRyb2wtaWNvbiBsZWFmbGV0LXBtLWljb24tY2lyY2xlLW1hcmtlclwiLGpzQ2xhc3M6XCJDaXJjbGVNYXJrZXJcIixvbkNsaWNrOmZ1bmN0aW9uKCl7fSxhZnRlckNsaWNrOmZ1bmN0aW9uKGUsaSl7dC5tYXAucG0uRHJhd1tpLmJ1dHRvbi5fYnV0dG9uLmpzQ2xhc3NdLnRvZ2dsZSgpfSxkb1RvZ2dsZTohMCx0b2dnbGVTdGF0dXM6ITEsZGlzYWJsZU90aGVyQnV0dG9uczohMCxwb3NpdGlvbjp0aGlzLm9wdGlvbnMucG9zaXRpb24sYWN0aW9uczpbXCJjYW5jZWxcIl19LG89e3RpdGxlOkkoXCJidXR0b25UaXRsZXMuZHJhd1JlY3RCdXR0b25cIiksY2xhc3NOYW1lOlwiY29udHJvbC1pY29uIGxlYWZsZXQtcG0taWNvbi1yZWN0YW5nbGVcIixqc0NsYXNzOlwiUmVjdGFuZ2xlXCIsb25DbGljazpmdW5jdGlvbigpe30sYWZ0ZXJDbGljazpmdW5jdGlvbihlLGkpe3QubWFwLnBtLkRyYXdbaS5idXR0b24uX2J1dHRvbi5qc0NsYXNzXS50b2dnbGUoKX0sZG9Ub2dnbGU6ITAsdG9nZ2xlU3RhdHVzOiExLGRpc2FibGVPdGhlckJ1dHRvbnM6ITAscG9zaXRpb246dGhpcy5vcHRpb25zLnBvc2l0aW9uLGFjdGlvbnM6W1wiY2FuY2VsXCJdfSxzPXt0aXRsZTpJKFwiYnV0dG9uVGl0bGVzLmVkaXRCdXR0b25cIiksY2xhc3NOYW1lOlwiY29udHJvbC1pY29uIGxlYWZsZXQtcG0taWNvbi1lZGl0XCIsb25DbGljazpmdW5jdGlvbigpe30sYWZ0ZXJDbGljazpmdW5jdGlvbigpe3QubWFwLnBtLnRvZ2dsZUdsb2JhbEVkaXRNb2RlKCl9LGRvVG9nZ2xlOiEwLHRvZ2dsZVN0YXR1czohMSxkaXNhYmxlT3RoZXJCdXR0b25zOiEwLHBvc2l0aW9uOnRoaXMub3B0aW9ucy5wb3NpdGlvbix0b29sOlwiZWRpdFwiLGFjdGlvbnM6W1wiZmluaXNoTW9kZVwiXX0sbD17dGl0bGU6SShcImJ1dHRvblRpdGxlcy5kcmFnQnV0dG9uXCIpLGNsYXNzTmFtZTpcImNvbnRyb2wtaWNvbiBsZWFmbGV0LXBtLWljb24tZHJhZ1wiLG9uQ2xpY2s6ZnVuY3Rpb24oKXt9LGFmdGVyQ2xpY2s6ZnVuY3Rpb24oKXt0Lm1hcC5wbS50b2dnbGVHbG9iYWxEcmFnTW9kZSgpfSxkb1RvZ2dsZTohMCx0b2dnbGVTdGF0dXM6ITEsZGlzYWJsZU90aGVyQnV0dG9uczohMCxwb3NpdGlvbjp0aGlzLm9wdGlvbnMucG9zaXRpb24sdG9vbDpcImVkaXRcIixhY3Rpb25zOltcImZpbmlzaE1vZGVcIl19LGg9e3RpdGxlOkkoXCJidXR0b25UaXRsZXMuY3V0QnV0dG9uXCIpLGNsYXNzTmFtZTpcImNvbnRyb2wtaWNvbiBsZWFmbGV0LXBtLWljb24tY3V0XCIsanNDbGFzczpcIkN1dFwiLG9uQ2xpY2s6ZnVuY3Rpb24oKXt9LGFmdGVyQ2xpY2s6ZnVuY3Rpb24oZSxpKXt0Lm1hcC5wbS5EcmF3W2kuYnV0dG9uLl9idXR0b24uanNDbGFzc10udG9nZ2xlKHtzbmFwcGFibGU6ITAsY3Vyc29yTWFya2VyOiEwLGFsbG93U2VsZkludGVyc2VjdGlvbjohMX0pfSxkb1RvZ2dsZTohMCx0b2dnbGVTdGF0dXM6ITEsZGlzYWJsZU90aGVyQnV0dG9uczohMCxwb3NpdGlvbjp0aGlzLm9wdGlvbnMucG9zaXRpb24sdG9vbDpcImVkaXRcIixhY3Rpb25zOltcImZpbmlzaFwiLFwicmVtb3ZlTGFzdFZlcnRleFwiLFwiY2FuY2VsXCJdfSx1PXt0aXRsZTpJKFwiYnV0dG9uVGl0bGVzLmRlbGV0ZUJ1dHRvblwiKSxjbGFzc05hbWU6XCJjb250cm9sLWljb24gbGVhZmxldC1wbS1pY29uLWRlbGV0ZVwiLG9uQ2xpY2s6ZnVuY3Rpb24oKXt9LGFmdGVyQ2xpY2s6ZnVuY3Rpb24oKXt0Lm1hcC5wbS50b2dnbGVHbG9iYWxSZW1vdmFsTW9kZSgpfSxkb1RvZ2dsZTohMCx0b2dnbGVTdGF0dXM6ITEsZGlzYWJsZU90aGVyQnV0dG9uczohMCxwb3NpdGlvbjp0aGlzLm9wdGlvbnMucG9zaXRpb24sdG9vbDpcImVkaXRcIixhY3Rpb25zOltcImZpbmlzaE1vZGVcIl19LGM9e3RpdGxlOkkoXCJidXR0b25UaXRsZXMucm90YXRlQnV0dG9uXCIpLGNsYXNzTmFtZTpcImNvbnRyb2wtaWNvbiBsZWFmbGV0LXBtLWljb24tcm90YXRlXCIsb25DbGljazpmdW5jdGlvbigpe30sYWZ0ZXJDbGljazpmdW5jdGlvbigpe3QubWFwLnBtLnRvZ2dsZUdsb2JhbFJvdGF0ZU1vZGUoKX0sZG9Ub2dnbGU6ITAsdG9nZ2xlU3RhdHVzOiExLGRpc2FibGVPdGhlckJ1dHRvbnM6ITAscG9zaXRpb246dGhpcy5vcHRpb25zLnBvc2l0aW9uLHRvb2w6XCJlZGl0XCIsYWN0aW9uczpbXCJmaW5pc2hNb2RlXCJdfSxwPXtjbGFzc05hbWU6XCJjb250cm9sLWljb24gbGVhZmxldC1wbS1pY29uLXRleHRcIix0aXRsZTpJKFwiYnV0dG9uVGl0bGVzLmRyYXdUZXh0QnV0dG9uXCIpLGpzQ2xhc3M6XCJUZXh0XCIsb25DbGljazpmdW5jdGlvbigpe30sYWZ0ZXJDbGljazpmdW5jdGlvbihlLGkpe3QubWFwLnBtLkRyYXdbaS5idXR0b24uX2J1dHRvbi5qc0NsYXNzXS50b2dnbGUoKX0sZG9Ub2dnbGU6ITAsdG9nZ2xlU3RhdHVzOiExLGRpc2FibGVPdGhlckJ1dHRvbnM6ITAscG9zaXRpb246dGhpcy5vcHRpb25zLnBvc2l0aW9uLGFjdGlvbnM6W1wiY2FuY2VsXCJdfTt0aGlzLl9hZGRCdXR0b24oXCJkcmF3TWFya2VyXCIsbmV3IEwuQ29udHJvbC5QTUJ1dHRvbihlKSksdGhpcy5fYWRkQnV0dG9uKFwiZHJhd1BvbHlsaW5lXCIsbmV3IEwuQ29udHJvbC5QTUJ1dHRvbihuKSksdGhpcy5fYWRkQnV0dG9uKFwiZHJhd1JlY3RhbmdsZVwiLG5ldyBMLkNvbnRyb2wuUE1CdXR0b24obykpLHRoaXMuX2FkZEJ1dHRvbihcImRyYXdQb2x5Z29uXCIsbmV3IEwuQ29udHJvbC5QTUJ1dHRvbihpKSksdGhpcy5fYWRkQnV0dG9uKFwiZHJhd0NpcmNsZVwiLG5ldyBMLkNvbnRyb2wuUE1CdXR0b24ocikpLHRoaXMuX2FkZEJ1dHRvbihcImRyYXdDaXJjbGVNYXJrZXJcIixuZXcgTC5Db250cm9sLlBNQnV0dG9uKGEpKSx0aGlzLl9hZGRCdXR0b24oXCJkcmF3VGV4dFwiLG5ldyBMLkNvbnRyb2wuUE1CdXR0b24ocCkpLHRoaXMuX2FkZEJ1dHRvbihcImVkaXRNb2RlXCIsbmV3IEwuQ29udHJvbC5QTUJ1dHRvbihzKSksdGhpcy5fYWRkQnV0dG9uKFwiZHJhZ01vZGVcIixuZXcgTC5Db250cm9sLlBNQnV0dG9uKGwpKSx0aGlzLl9hZGRCdXR0b24oXCJjdXRQb2x5Z29uXCIsbmV3IEwuQ29udHJvbC5QTUJ1dHRvbihoKSksdGhpcy5fYWRkQnV0dG9uKFwicmVtb3ZhbE1vZGVcIixuZXcgTC5Db250cm9sLlBNQnV0dG9uKHUpKSx0aGlzLl9hZGRCdXR0b24oXCJyb3RhdGVNb2RlXCIsbmV3IEwuQ29udHJvbC5QTUJ1dHRvbihjKSl9LF9zaG93SGlkZUJ1dHRvbnM6ZnVuY3Rpb24oKXtpZih0aGlzLmlzVmlzaWJsZSl7dGhpcy5yZW1vdmVDb250cm9scygpLHRoaXMuaXNWaXNpYmxlPSEwO3ZhciB0PXRoaXMuZ2V0QnV0dG9ucygpLGU9W107Zm9yKHZhciBpIGluITE9PT10aGlzLm9wdGlvbnMuZHJhd0NvbnRyb2xzJiYoZT1lLmNvbmNhdChPYmplY3Qua2V5cyh0KS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiF0W2VdLl9idXR0b24udG9vbH0pKSkpLCExPT09dGhpcy5vcHRpb25zLmVkaXRDb250cm9scyYmKGU9ZS5jb25jYXQoT2JqZWN0LmtleXModCkuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm5cImVkaXRcIj09PXRbZV0uX2J1dHRvbi50b29sfSkpKSksITE9PT10aGlzLm9wdGlvbnMub3B0aW9uc0NvbnRyb2xzJiYoZT1lLmNvbmNhdChPYmplY3Qua2V5cyh0KS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVyblwib3B0aW9uc1wiPT09dFtlXS5fYnV0dG9uLnRvb2x9KSkpKSwhMT09PXRoaXMub3B0aW9ucy5jdXN0b21Db250cm9scyYmKGU9ZS5jb25jYXQoT2JqZWN0LmtleXModCkuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm5cImN1c3RvbVwiPT09dFtlXS5fYnV0dG9uLnRvb2x9KSkpKSx0KWlmKHRoaXMub3B0aW9uc1tpXSYmLTE9PT1lLmluZGV4T2YoaSkpe3ZhciBuPXRbaV0uX2J1dHRvbi50b29sO258fChuPVwiZHJhd1wiKSx0W2ldLnNldFBvc2l0aW9uKHRoaXMuX2dldEJ0blBvc2l0aW9uKG4pKSx0W2ldLmFkZFRvKHRoaXMubWFwKX19fSxfZ2V0QnRuUG9zaXRpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbnMmJnRoaXMub3B0aW9ucy5wb3NpdGlvbnNbdF0/dGhpcy5vcHRpb25zLnBvc2l0aW9uc1t0XTp0aGlzLm9wdGlvbnMucG9zaXRpb259LHNldEJsb2NrUG9zaXRpb246ZnVuY3Rpb24odCxlKXt0aGlzLm9wdGlvbnMucG9zaXRpb25zW3RdPWUsdGhpcy5fc2hvd0hpZGVCdXR0b25zKCksdGhpcy5jaGFuZ2VDb250cm9sT3JkZXIoKX0sZ2V0QmxvY2tQb3NpdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uc30sY29weURyYXdDb250cm9sOmZ1bmN0aW9uKHQsZSl7aWYoIWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJ1dHRvbiBoYXMgbm8gbmFtZVwiKTtcIm9iamVjdFwiIT09VyhlKSYmKGU9e25hbWU6ZX0pO3ZhciBpPXRoaXMuX2J0bk5hbWVNYXBwaW5nKHQpO2lmKCFlLm5hbWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJ1dHRvbiBoYXMgbm8gbmFtZVwiKTtpZih0aGlzLmJ1dHRvbnNbZS5uYW1lXSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQnV0dG9uIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzXCIpO3ZhciBuPXRoaXMubWFwLnBtLkRyYXcuY3JlYXRlTmV3RHJhd0luc3RhbmNlKGUubmFtZSxpKTtyZXR1cm4gZT1aKFooe30sdGhpcy5idXR0b25zW2ldLl9idXR0b24pLGUpLHtkcmF3SW5zdGFuY2U6bixjb250cm9sOnRoaXMuY3JlYXRlQ3VzdG9tQ29udHJvbChlKX19LGNyZWF0ZUN1c3RvbUNvbnRyb2w6ZnVuY3Rpb24odCl7aWYoIXQubmFtZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQnV0dG9uIGhhcyBubyBuYW1lXCIpO2lmKHRoaXMuYnV0dG9uc1t0Lm5hbWVdKXRocm93IG5ldyBUeXBlRXJyb3IoXCJCdXR0b24gd2l0aCB0aGlzIG5hbWUgYWxyZWFkeSBleGlzdHNcIik7dC5vbkNsaWNrfHwodC5vbkNsaWNrPWZ1bmN0aW9uKCl7fSksdC5hZnRlckNsaWNrfHwodC5hZnRlckNsaWNrPWZ1bmN0aW9uKCl7fSksITEhPT10LnRvZ2dsZSYmKHQudG9nZ2xlPSEwKSx0LmJsb2NrJiYodC5ibG9jaz10LmJsb2NrLnRvTG93ZXJDYXNlKCkpLHQuYmxvY2smJlwiZHJhd1wiIT09dC5ibG9ja3x8KHQuYmxvY2s9XCJcIiksdC5jbGFzc05hbWU/LTE9PT10LmNsYXNzTmFtZS5pbmRleE9mKFwiY29udHJvbC1pY29uXCIpJiYodC5jbGFzc05hbWU9XCJjb250cm9sLWljb24gXCIuY29uY2F0KHQuY2xhc3NOYW1lKSk6dC5jbGFzc05hbWU9XCJjb250cm9sLWljb25cIjt2YXIgZT17dG9vbDp0LmJsb2NrLGNsYXNzTmFtZTp0LmNsYXNzTmFtZSx0aXRsZTp0LnRpdGxlfHxcIlwiLGpzQ2xhc3M6dC5uYW1lLG9uQ2xpY2s6dC5vbkNsaWNrLGFmdGVyQ2xpY2s6dC5hZnRlckNsaWNrLGRvVG9nZ2xlOnQudG9nZ2xlLHRvZ2dsZVN0YXR1czohMSxkaXNhYmxlT3RoZXJCdXR0b25zOiEwLGNzc1RvZ2dsZTp0LnRvZ2dsZSxwb3NpdGlvbjp0aGlzLm9wdGlvbnMucG9zaXRpb24sYWN0aW9uczp0LmFjdGlvbnN8fFtdLGRpc2FibGVkOiEhdC5kaXNhYmxlZH07ITEhPT10aGlzLm9wdGlvbnNbdC5uYW1lXSYmKHRoaXMub3B0aW9uc1t0Lm5hbWVdPSEwKTt2YXIgaT10aGlzLl9hZGRCdXR0b24odC5uYW1lLG5ldyBMLkNvbnRyb2wuUE1CdXR0b24oZSkpO3JldHVybiB0aGlzLmNoYW5nZUNvbnRyb2xPcmRlcigpLGl9LGNoYW5nZUNvbnRyb2xPcmRlcjpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTpbXSxlPXRoaXMuX3NoYXBlTWFwcGluZygpLGk9W107dC5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RdP2kucHVzaChlW3RdKTppLnB1c2godCl9KSk7dmFyIG49dGhpcy5nZXRCdXR0b25zKCkscj17fTtpLmZvckVhY2goKGZ1bmN0aW9uKHQpe25bdF0mJihyW3RdPW5bdF0pfSkpO3ZhciBhPU9iamVjdC5rZXlzKG4pLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIW5bdF0uX2J1dHRvbi50b29sfSkpO2EuZm9yRWFjaCgoZnVuY3Rpb24odCl7LTE9PT1pLmluZGV4T2YodCkmJihyW3RdPW5bdF0pfSkpO3ZhciBvPU9iamVjdC5rZXlzKG4pLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuXCJlZGl0XCI9PT1uW3RdLl9idXR0b24udG9vbH0pKTtvLmZvckVhY2goKGZ1bmN0aW9uKHQpey0xPT09aS5pbmRleE9mKHQpJiYoclt0XT1uW3RdKX0pKTt2YXIgcz1PYmplY3Qua2V5cyhuKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVyblwib3B0aW9uc1wiPT09blt0XS5fYnV0dG9uLnRvb2x9KSk7cy5mb3JFYWNoKChmdW5jdGlvbih0KXstMT09PWkuaW5kZXhPZih0KSYmKHJbdF09blt0XSl9KSk7dmFyIGw9T2JqZWN0LmtleXMobikuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm5cImN1c3RvbVwiPT09blt0XS5fYnV0dG9uLnRvb2x9KSk7bC5mb3JFYWNoKChmdW5jdGlvbih0KXstMT09PWkuaW5kZXhPZih0KSYmKHJbdF09blt0XSl9KSksT2JqZWN0LmtleXMobikuZm9yRWFjaCgoZnVuY3Rpb24odCl7LTE9PT1pLmluZGV4T2YodCkmJihyW3RdPW5bdF0pfSkpLHRoaXMubWFwLnBtLlRvb2xiYXIuYnV0dG9ucz1yLHRoaXMuX3Nob3dIaWRlQnV0dG9ucygpfSxnZXRDb250cm9sT3JkZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldEJ1dHRvbnMoKSxlPVtdO2Zvcih2YXIgaSBpbiB0KWUucHVzaChpKTtyZXR1cm4gZX0sY2hhbmdlQWN0aW9uc09mQ29udHJvbDpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuX2J0bk5hbWVNYXBwaW5nKHQpO2lmKCFpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBuYW1lIHBhc3NlZFwiKTtpZighZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gYWN0aW9ucyBwYXNzZWRcIik7aWYoIXRoaXMuYnV0dG9uc1tpXSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQnV0dG9uIHdpdGggdGhpcyBuYW1lIG5vdCBleGlzdHNcIik7dGhpcy5idXR0b25zW2ldLl9idXR0b24uYWN0aW9ucz1lLHRoaXMuY2hhbmdlQ29udHJvbE9yZGVyKCl9LHNldEJ1dHRvbkRpc2FibGVkOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcy5fYnRuTmFtZU1hcHBpbmcodCk7ZT90aGlzLmJ1dHRvbnNbaV0uZGlzYWJsZSgpOnRoaXMuYnV0dG9uc1tpXS5lbmFibGUoKX0sX3NoYXBlTWFwcGluZzpmdW5jdGlvbigpe3JldHVybntNYXJrZXI6XCJkcmF3TWFya2VyXCIsQ2lyY2xlOlwiZHJhd0NpcmNsZVwiLFBvbHlnb246XCJkcmF3UG9seWdvblwiLFJlY3RhbmdsZTpcImRyYXdSZWN0YW5nbGVcIixQb2x5bGluZTpcImRyYXdQb2x5bGluZVwiLExpbmU6XCJkcmF3UG9seWxpbmVcIixDaXJjbGVNYXJrZXI6XCJkcmF3Q2lyY2xlTWFya2VyXCIsRWRpdDpcImVkaXRNb2RlXCIsRHJhZzpcImRyYWdNb2RlXCIsQ3V0OlwiY3V0UG9seWdvblwiLFJlbW92YWw6XCJyZW1vdmFsTW9kZVwiLFJvdGF0ZTpcInJvdGF0ZU1vZGVcIixUZXh0OlwiZHJhd1RleHRcIn19LF9idG5OYW1lTWFwcGluZzpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9zaGFwZU1hcHBpbmcoKTtyZXR1cm4gZVt0XT9lW3RdOnR9fSk7ZnVuY3Rpb24gdHQodCxlKXt2YXIgaT1PYmplY3Qua2V5cyh0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO2UmJihuPW4uZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGUpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG4pfXJldHVybiBpfWZ1bmN0aW9uIGV0KHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBpPW51bGwhPWFyZ3VtZW50c1tlXT9hcmd1bWVudHNbZV06e307ZSUyP3R0KE9iamVjdChpKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aXQodCxlLGlbZV0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoaSkpOnR0KE9iamVjdChpKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksZSkpfSkpfXJldHVybiB0fWZ1bmN0aW9uIGl0KHQsZSxpKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPWksdH12YXIgbnQ9e19pbml0U25hcHBhYmxlTWFya2VyczpmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5zbmFwRGlzdGFuY2U9dGhpcy5vcHRpb25zLnNuYXBEaXN0YW5jZXx8MzAsdGhpcy5vcHRpb25zLnNuYXBTZWdtZW50PXRoaXMub3B0aW9ucy5zbmFwU2VnbWVudD09PXVuZGVmaW5lZHx8dGhpcy5vcHRpb25zLnNuYXBTZWdtZW50LHRoaXMuX2Fzc2lnbkV2ZW50cyh0aGlzLl9tYXJrZXJzKSx0aGlzLl9sYXllci5vZmYoXCJwbTpkcmFnc3RhcnRcIix0aGlzLl91bnNuYXAsdGhpcyksdGhpcy5fbGF5ZXIub24oXCJwbTpkcmFnc3RhcnRcIix0aGlzLl91bnNuYXAsdGhpcyl9LF9kaXNhYmxlU25hcHBpbmc6ZnVuY3Rpb24oKXt0aGlzLl9sYXllci5vZmYoXCJwbTpkcmFnc3RhcnRcIix0aGlzLl91bnNuYXAsdGhpcyl9LF9hc3NpZ25FdmVudHM6ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe0FycmF5LmlzQXJyYXkodCk/ZS5fYXNzaWduRXZlbnRzKHQpOih0Lm9mZihcImRyYWdcIixlLl9oYW5kbGVTbmFwcGluZyxlKSx0Lm9uKFwiZHJhZ1wiLGUuX2hhbmRsZVNuYXBwaW5nLGUpLHQub2ZmKFwiZHJhZ2VuZFwiLGUuX2NsZWFudXBTbmFwcGluZyxlKSx0Lm9uKFwiZHJhZ2VuZFwiLGUuX2NsZWFudXBTbmFwcGluZyxlKSl9KSl9LF9jbGVhbnVwU25hcHBpbmc6ZnVuY3Rpb24oKXtkZWxldGUgdGhpcy5fc25hcExpc3QsdGhpcy50aHJvdHRsZWRMaXN0JiYodGhpcy5fbWFwLm9mZihcImxheWVyYWRkXCIsdGhpcy50aHJvdHRsZWRMaXN0LHRoaXMpLHRoaXMudGhyb3R0bGVkTGlzdD11bmRlZmluZWQpLHRoaXMuX21hcC5vZmYoXCJwbTpyZW1vdmVcIix0aGlzLl9oYW5kbGVTbmFwTGF5ZXJSZW1vdmFsLHRoaXMpLHRoaXMuZGVidWdJbmRpY2F0b3JMaW5lcyYmdGhpcy5kZWJ1Z0luZGljYXRvckxpbmVzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucmVtb3ZlKCl9KSl9LF9oYW5kbGVUaHJvdHRsZVNuYXBwaW5nOmZ1bmN0aW9uKCl7dGhpcy50aHJvdHRsZWRMaXN0JiZ0aGlzLl9jcmVhdGVTbmFwTGlzdCgpfSxfaGFuZGxlU25hcHBpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxpPXQudGFyZ2V0O2lmKGkuX3NuYXBwZWQ9ITEsdGhpcy50aHJvdHRsZWRMaXN0fHwodGhpcy50aHJvdHRsZWRMaXN0PUwuVXRpbC50aHJvdHRsZSh0aGlzLl9oYW5kbGVUaHJvdHRsZVNuYXBwaW5nLDEwMCx0aGlzKSksdGhpcy5fbWFwLnBtLktleWJvYXJkLmlzQWx0S2V5UHJlc3NlZCgpKXJldHVybiExO2lmKHRoaXMuX3NuYXBMaXN0PT09dW5kZWZpbmVkJiYodGhpcy5fY3JlYXRlU25hcExpc3QoKSx0aGlzLl9tYXAub2ZmKFwibGF5ZXJhZGRcIix0aGlzLnRocm90dGxlZExpc3QsdGhpcyksdGhpcy5fbWFwLm9uKFwibGF5ZXJhZGRcIix0aGlzLnRocm90dGxlZExpc3QsdGhpcykpLHRoaXMuX3NuYXBMaXN0Lmxlbmd0aDw9MClyZXR1cm4hMTt2YXIgbj10aGlzLl9jYWxjQ2xvc2VzdExheWVyKGkuZ2V0TGF0TG5nKCksdGhpcy5fc25hcExpc3QpO2lmKDA9PT1PYmplY3Qua2V5cyhuKS5sZW5ndGgpcmV0dXJuITE7dmFyIHIsYT1uLmxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXJ8fG4ubGF5ZXIgaW5zdGFuY2VvZiBMLkNpcmNsZU1hcmtlcnx8IXRoaXMub3B0aW9ucy5zbmFwU2VnbWVudDtyPWE/bi5sYXRsbmc6dGhpcy5fY2hlY2tQcmlvcml0aXlTbmFwcGluZyhuKTt2YXIgbz10aGlzLm9wdGlvbnMuc25hcERpc3RhbmNlLHM9e21hcmtlcjppLHNoYXBlOnRoaXMuX3NoYXBlLHNuYXBMYXRMbmc6cixzZWdtZW50Om4uc2VnbWVudCxsYXllcjp0aGlzLl9sYXllcix3b3JraW5nTGF5ZXI6dGhpcy5fbGF5ZXIsbGF5ZXJJbnRlcmFjdGVkV2l0aDpuLmxheWVyLGRpc3RhbmNlOm4uZGlzdGFuY2V9O2lmKHRoaXMuX2ZpcmVTbmFwRHJhZyhzLm1hcmtlcixzKSx0aGlzLl9maXJlU25hcERyYWcodGhpcy5fbGF5ZXIscyksbi5kaXN0YW5jZTxvKXtpLl9vcmdMYXRMbmc9aS5nZXRMYXRMbmcoKSxpLnNldExhdExuZyhyKSxpLl9zbmFwcGVkPSEwLGkuX3NuYXBJbmZvPXM7dmFyIGw9dGhpcy5fc25hcExhdExuZ3x8e30saD1yfHx7fTtsLmxhdD09PWgubGF0JiZsLmxuZz09PWgubG5nfHwoZS5fc25hcExhdExuZz1yLGUuX2ZpcmVTbmFwKGkscyksZS5fZmlyZVNuYXAoZS5fbGF5ZXIscykpfWVsc2UgdGhpcy5fc25hcExhdExuZyYmKHRoaXMuX3Vuc25hcChzKSxpLl9zbmFwcGVkPSExLHRoaXMuX2ZpcmVVbnNuYXAocy5tYXJrZXIscyksdGhpcy5fZmlyZVVuc25hcCh0aGlzLl9sYXllcixzKSk7cmV0dXJuITB9LF9jcmVhdGVTbmFwTGlzdDpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1bXSxpPVtdLG49dGhpcy5fbWFwO24ub2ZmKFwicG06cmVtb3ZlXCIsdGhpcy5faGFuZGxlU25hcExheWVyUmVtb3ZhbCx0aGlzKSxuLm9uKFwicG06cmVtb3ZlXCIsdGhpcy5faGFuZGxlU25hcExheWVyUmVtb3ZhbCx0aGlzKSxuLmVhY2hMYXllcigoZnVuY3Rpb24odCl7aWYoKHQgaW5zdGFuY2VvZiBMLlBvbHlsaW5lfHx0IGluc3RhbmNlb2YgTC5NYXJrZXJ8fHQgaW5zdGFuY2VvZiBMLkNpcmNsZU1hcmtlcnx8dCBpbnN0YW5jZW9mIEwuSW1hZ2VPdmVybGF5KSYmITAhPT10Lm9wdGlvbnMuc25hcElnbm9yZSl7aWYodC5vcHRpb25zLnNuYXBJZ25vcmU9PT11bmRlZmluZWQmJighTC5QTS5vcHRJbiYmITA9PT10Lm9wdGlvbnMucG1JZ25vcmV8fEwuUE0ub3B0SW4mJiExIT09dC5vcHRpb25zLnBtSWdub3JlKSlyZXR1cm47KHQgaW5zdGFuY2VvZiBMLkNpcmNsZXx8dCBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyKSYmdC5wbSYmdC5wbS5faGlkZGVuUG9seUNpcmNsZT9lLnB1c2godC5wbS5faGlkZGVuUG9seUNpcmNsZSk6dCBpbnN0YW5jZW9mIEwuSW1hZ2VPdmVybGF5JiYodD1MLnJlY3RhbmdsZSh0LmdldEJvdW5kcygpKSksZS5wdXNoKHQpO3ZhciBuPUwucG9seWxpbmUoW10se2NvbG9yOlwicmVkXCIscG1JZ25vcmU6ITB9KTtuLl9wbVRlbXBMYXllcj0hMCxpLnB1c2gobiksKHQgaW5zdGFuY2VvZiBMLkNpcmNsZXx8dCBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyKSYmaS5wdXNoKG4pfX0pKSxlPShlPShlPWUuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gdC5fbGF5ZXIhPT1lfSkpKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0Ll9sYXRsbmd8fHQuX2xhdGxuZ3MmJiFqKHQuX2xhdGxuZ3MpfSkpKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiF0Ll9wbVRlbXBMYXllcn0pKSx0aGlzLl9vdGhlclNuYXBMYXllcnM/KHRoaXMuX290aGVyU25hcExheWVycy5mb3JFYWNoKChmdW5jdGlvbigpe3ZhciB0PUwucG9seWxpbmUoW10se2NvbG9yOlwicmVkXCIscG1JZ25vcmU6ITB9KTt0Ll9wbVRlbXBMYXllcj0hMCxpLnB1c2godCl9KSksdGhpcy5fc25hcExpc3Q9ZS5jb25jYXQodGhpcy5fb3RoZXJTbmFwTGF5ZXJzKSk6dGhpcy5fc25hcExpc3Q9ZSx0aGlzLmRlYnVnSW5kaWNhdG9yTGluZXM9aX0sX2hhbmRsZVNuYXBMYXllclJlbW92YWw6ZnVuY3Rpb24odCl7dmFyIGU9dC5sYXllcixpPXRoaXMuX3NuYXBMaXN0LmZpbmRJbmRleCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuX2xlYWZsZXRfaWQ9PT1lLl9sZWFmbGV0X2lkfSkpO3RoaXMuX3NuYXBMaXN0LnNwbGljZShpLDEpfSxfY2FsY0Nsb3Nlc3RMYXllcjpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMsbj1bXSxyPXt9O3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUsYSl7aWYoIWUuX3BhcmVudENvcHl8fGUuX3BhcmVudENvcHkhPT1pLl9sYXllcil7dmFyIG89aS5fY2FsY0xheWVyRGlzdGFuY2VzKHQsZSk7aS5kZWJ1Z0luZGljYXRvckxpbmVzW2FdJiZpLmRlYnVnSW5kaWNhdG9yTGluZXNbYV0uc2V0TGF0TG5ncyhbdCxvLmxhdGxuZ10pLChyLmRpc3RhbmNlPT09dW5kZWZpbmVkfHxvLmRpc3RhbmNlPD1yLmRpc3RhbmNlKSYmKG8uZGlzdGFuY2U8ci5kaXN0YW5jZSYmKG49W10pLChyPW8pLmxheWVyPWUsbi5wdXNoKHIpKX19KSksdGhpcy5fZ2V0Q2xvc2VzdExheWVyQnlQcmlvcml0eShuKX0sX2NhbGNMYXllckRpc3RhbmNlczpmdW5jdGlvbih0LGUpe3ZhciBpLG4scixhPXRoaXMsbz10aGlzLl9tYXAscz1lIGluc3RhbmNlb2YgTC5NYXJrZXJ8fGUgaW5zdGFuY2VvZiBMLkNpcmNsZU1hcmtlcixsPWUgaW5zdGFuY2VvZiBMLlBvbHlnb24saD10LHU9cz9lLmdldExhdExuZygpOmUuZ2V0TGF0TG5ncygpO2lmKHMpcmV0dXJue2xhdGxuZzpldCh7fSx1KSxkaXN0YW5jZTp0aGlzLl9nZXREaXN0YW5jZShvLHUsaCl9O3JldHVybiBmdW5jdGlvbiBjKHQpe3QuZm9yRWFjaCgoZnVuY3Rpb24oZSxzKXtpZihBcnJheS5pc0FycmF5KGUpKWMoZSk7ZWxzZSBpZihhLm9wdGlvbnMuc25hcFNlZ21lbnQpe3ZhciB1LHA9ZTt1PWw/cysxPT09dC5sZW5ndGg/MDpzKzE6cysxPT09dC5sZW5ndGg/dW5kZWZpbmVkOnMrMTt2YXIgZD10W3VdO2lmKGQpe3ZhciBmPWEuX2dldERpc3RhbmNlVG9TZWdtZW50KG8saCxwLGQpOyhuPT09dW5kZWZpbmVkfHxmPG4pJiYobj1mLHI9W3AsZF0pfX1lbHNle3ZhciBnPWEuX2dldERpc3RhbmNlKG8saCxlKTsobj09PXVuZGVmaW5lZHx8ZzxuKSYmKG49ZyxpPWUpfX0pKX0odSksdGhpcy5vcHRpb25zLnNuYXBTZWdtZW50P3tsYXRsbmc6ZXQoe30sdGhpcy5fZ2V0Q2xvc2VzdFBvaW50T25TZWdtZW50KG8sdCxyWzBdLHJbMV0pKSxzZWdtZW50OnIsZGlzdGFuY2U6bn06e2xhdGxuZzppLGRpc3RhbmNlOm59fSxfZ2V0Q2xvc2VzdExheWVyQnlQcmlvcml0eTpmdW5jdGlvbih0KXt0PXQuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fbGVhZmxldF9pZC1lLl9sZWFmbGV0X2lkfSkpO3ZhciBlPXRoaXMuX21hcC5wbS5nbG9iYWxPcHRpb25zLnNuYXBwaW5nT3JkZXJ8fFtdLGk9MCxuPXt9O3JldHVybiBlLmNvbmNhdChbXCJNYXJrZXJcIixcIkNpcmNsZU1hcmtlclwiLFwiQ2lyY2xlXCIsXCJMaW5lXCIsXCJQb2x5Z29uXCIsXCJSZWN0YW5nbGVcIl0pLmZvckVhY2goKGZ1bmN0aW9uKHQpe25bdF18fChpKz0xLG5bdF09aSl9KSksdC5zb3J0KGZ1bmN0aW9uKHQsZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzJdOlwiYXNjXCI7aWYoIWV8fDA9PT1PYmplY3Qua2V5cyhlKS5sZW5ndGgpcmV0dXJuIGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQtZX07Zm9yKHZhciBuLHI9T2JqZWN0LmtleXMoZSksYT1yLmxlbmd0aC0xLG89e307YT49MDspbj1yW2FdLG9bbi50b0xvd2VyQ2FzZSgpXT1lW25dLGEtPTE7ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEwuTWFya2VyP1wiTWFya2VyXCI6dCBpbnN0YW5jZW9mIEwuQ2lyY2xlP1wiQ2lyY2xlXCI6dCBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyP1wiQ2lyY2xlTWFya2VyXCI6dCBpbnN0YW5jZW9mIEwuUmVjdGFuZ2xlP1wiUmVjdGFuZ2xlXCI6dCBpbnN0YW5jZW9mIEwuUG9seWdvbj9cIlBvbHlnb25cIjp0IGluc3RhbmNlb2YgTC5Qb2x5bGluZT9cIkxpbmVcIjp1bmRlZmluZWR9cmV0dXJuIGZ1bmN0aW9uKGUsbil7dmFyIHIsYTtpZihcImluc3RhbmNlb2ZTaGFwZVwiPT09dCl7aWYocj1zKGUubGF5ZXIpLnRvTG93ZXJDYXNlKCksYT1zKG4ubGF5ZXIpLnRvTG93ZXJDYXNlKCksIXJ8fCFhKXJldHVybiAwfWVsc2V7aWYoIWUuaGFzT3duUHJvcGVydHkodCl8fCFuLmhhc093blByb3BlcnR5KHQpKXJldHVybiAwO3I9ZVt0XS50b0xvd2VyQ2FzZSgpLGE9blt0XS50b0xvd2VyQ2FzZSgpfXZhciBsPXIgaW4gbz9vW3JdOk51bWJlci5NQVhfU0FGRV9JTlRFR0VSLGg9YSBpbiBvP29bYV06TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsdT0wO3JldHVybiBsPGg/dT0tMTpsPmgmJih1PTEpLFwiZGVzY1wiPT09aT8tMSp1OnV9fShcImluc3RhbmNlb2ZTaGFwZVwiLG4pKSx0WzBdfHx7fX0sX2NoZWNrUHJpb3JpdGl5U25hcHBpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fbWFwLGk9dC5zZWdtZW50WzBdLG49dC5zZWdtZW50WzFdLHI9dC5sYXRsbmcsYT10aGlzLl9nZXREaXN0YW5jZShlLGksciksbz10aGlzLl9nZXREaXN0YW5jZShlLG4scikscz1hPG8/aTpuLGw9YTxvP2E6bztpZih0aGlzLm9wdGlvbnMuc25hcE1pZGRsZSl7dmFyIGg9TC5QTS5VdGlscy5jYWxjTWlkZGxlTGF0TG5nKGUsaSxuKSx1PXRoaXMuX2dldERpc3RhbmNlKGUsaCxyKTt1PGEmJnU8byYmKHM9aCxsPXUpfXJldHVybiBldCh7fSxsPHRoaXMub3B0aW9ucy5zbmFwRGlzdGFuY2U/czpyKX0sX3Vuc25hcDpmdW5jdGlvbigpe2RlbGV0ZSB0aGlzLl9zbmFwTGF0TG5nfSxfZ2V0Q2xvc2VzdFBvaW50T25TZWdtZW50OmZ1bmN0aW9uKHQsZSxpLG4pe3ZhciByPXQuZ2V0TWF4Wm9vbSgpO3I9PT1JbmZpbml0eSYmKHI9dC5nZXRab29tKCkpO3ZhciBhPXQucHJvamVjdChlLHIpLG89dC5wcm9qZWN0KGkscikscz10LnByb2plY3QobixyKSxsPUwuTGluZVV0aWwuY2xvc2VzdFBvaW50T25TZWdtZW50KGEsbyxzKTtyZXR1cm4gdC51bnByb2plY3QobCxyKX0sX2dldERpc3RhbmNlVG9TZWdtZW50OmZ1bmN0aW9uKHQsZSxpLG4pe3ZhciByPXQubGF0TG5nVG9MYXllclBvaW50KGUpLGE9dC5sYXRMbmdUb0xheWVyUG9pbnQoaSksbz10LmxhdExuZ1RvTGF5ZXJQb2ludChuKTtyZXR1cm4gTC5MaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlKHIsYSxvKX0sX2dldERpc3RhbmNlOmZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gdC5sYXRMbmdUb0xheWVyUG9pbnQoZSkuZGlzdGFuY2VUbyh0LmxhdExuZ1RvTGF5ZXJQb2ludChpKSl9fTtjb25zdCBydD1udDtjb25zdCBhdD1MLkNsYXNzLmV4dGVuZCh7aW5jbHVkZXM6W3J0LFNdLG9wdGlvbnM6e3NuYXBwYWJsZTohMCxzbmFwRGlzdGFuY2U6MjAsc25hcE1pZGRsZTohMSxhbGxvd1NlbGZJbnRlcnNlY3Rpb246ITAsdG9vbHRpcHM6ITAsdGVtcGxpbmVTdHlsZTp7fSxoaW50bGluZVN0eWxlOntjb2xvcjpcIiMzMzg4ZmZcIixkYXNoQXJyYXk6XCI1LDVcIn0scGF0aE9wdGlvbnM6bnVsbCxjdXJzb3JNYXJrZXI6ITAsZmluaXNoT246bnVsbCxtYXJrZXJTdHlsZTp7ZHJhZ2dhYmxlOiEwLGljb246TC5pY29uKCl9LGhpZGVNaWRkbGVNYXJrZXJzOiExLG1pblJhZGl1c0NpcmNsZTpudWxsLG1heFJhZGl1c0NpcmNsZTpudWxsLG1pblJhZGl1c0NpcmNsZU1hcmtlcjpudWxsLG1heFJhZGl1c0NpcmNsZU1hcmtlcjpudWxsLGVkaXRhYmxlOiExLG1hcmtlckVkaXRhYmxlOiEwLGNvbnRpbnVlRHJhd2luZzohMSxzbmFwU2VnbWVudDohMCxyZXF1aXJlU25hcFRvRmluaXNoOiExfSxzZXRPcHRpb25zOmZ1bmN0aW9uKHQpe0wuVXRpbC5zZXRPcHRpb25zKHRoaXMsdCl9LGdldE9wdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT1uZXcgTC5JY29uLkRlZmF1bHQ7aS5vcHRpb25zLnRvb2x0aXBBbmNob3I9WzAsMF0sdGhpcy5vcHRpb25zLm1hcmtlclN0eWxlLmljb249aSx0aGlzLl9tYXA9dCx0aGlzLnNoYXBlcz1bXCJNYXJrZXJcIixcIkNpcmNsZU1hcmtlclwiLFwiTGluZVwiLFwiUG9seWdvblwiLFwiUmVjdGFuZ2xlXCIsXCJDaXJjbGVcIixcIkN1dFwiLFwiVGV4dFwiXSx0aGlzLnNoYXBlcy5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RdPW5ldyBMLlBNLkRyYXdbdF0oZS5fbWFwKX0pKSx0aGlzLk1hcmtlci5zZXRPcHRpb25zKHtjb250aW51ZURyYXdpbmc6ITB9KSx0aGlzLkNpcmNsZU1hcmtlci5zZXRPcHRpb25zKHtjb250aW51ZURyYXdpbmc6ITB9KX0sc2V0UGF0aE9wdGlvbnM6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQmJmFyZ3VtZW50c1sxXTt0aGlzLm9wdGlvbnMucGF0aE9wdGlvbnM9ZT9yKCkodGhpcy5vcHRpb25zLnBhdGhPcHRpb25zLHQpOnR9LGdldFNoYXBlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoYXBlc30sZ2V0U2hhcGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2hhcGV9LGVuYWJsZTpmdW5jdGlvbih0LGUpe2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkVycm9yOiBQbGVhc2UgcGFzcyBhIHNoYXBlIGFzIGEgcGFyYW1ldGVyLiBQb3NzaWJsZSBzaGFwZXMgYXJlOiBcIi5jb25jYXQodGhpcy5nZXRTaGFwZXMoKS5qb2luKFwiLFwiKSkpO3RoaXMuZGlzYWJsZSgpLHRoaXNbdF0uZW5hYmxlKGUpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLnNoYXBlcy5mb3JFYWNoKChmdW5jdGlvbihlKXt0W2VdLmRpc2FibGUoKX0pKX0sYWRkQ29udHJvbHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuc2hhcGVzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3RbZV0uYWRkQnV0dG9uKCl9KSl9LGdldEFjdGl2ZVNoYXBlOmZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzO3JldHVybiB0aGlzLnNoYXBlcy5mb3JFYWNoKChmdW5jdGlvbihpKXtlW2ldLl9lbmFibGVkJiYodD1pKX0pKSx0fSxfc2V0R2xvYmFsRHJhd01vZGU6ZnVuY3Rpb24oKXtcIkN1dFwiPT09dGhpcy5fc2hhcGU/dGhpcy5fZmlyZUdsb2JhbEN1dE1vZGVUb2dnbGVkKCk6dGhpcy5fZmlyZUdsb2JhbERyYXdNb2RlVG9nZ2xlZCgpO3ZhciB0PUwuUE0uVXRpbHMuZmluZExheWVycyh0aGlzLl9tYXApO3RoaXMuX2VuYWJsZWQ/dC5mb3JFYWNoKChmdW5jdGlvbih0KXtMLlBNLlV0aWxzLmRpc2FibGVQb3B1cCh0KX0pKTp0LmZvckVhY2goKGZ1bmN0aW9uKHQpe0wuUE0uVXRpbHMuZW5hYmxlUG9wdXAodCl9KSl9LGNyZWF0ZU5ld0RyYXdJbnN0YW5jZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuX2dldFNoYXBlRnJvbUJ0bk5hbWUoZSk7aWYodGhpc1t0XSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHJhdyBUeXBlIGFscmVhZHkgZXhpc3RzXCIpO2lmKCFMLlBNLkRyYXdbaV0pdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZXJlIGlzIG5vIGNsYXNzIEwuUE0uRHJhdy5cIi5jb25jYXQoaSkpO3JldHVybiB0aGlzW3RdPW5ldyBMLlBNLkRyYXdbaV0odGhpcy5fbWFwKSx0aGlzW3RdLnRvb2xiYXJCdXR0b25OYW1lPXQsdGhpc1t0XS5fc2hhcGU9dCx0aGlzLnNoYXBlcy5wdXNoKHQpLHRoaXNbZV0mJnRoaXNbdF0uc2V0T3B0aW9ucyh0aGlzW2VdLm9wdGlvbnMpLHRoaXNbdF0uc2V0T3B0aW9ucyh0aGlzW3RdLm9wdGlvbnMpLHRoaXNbdF19LF9nZXRTaGFwZUZyb21CdG5OYW1lOmZ1bmN0aW9uKHQpe3ZhciBlPXtkcmF3TWFya2VyOlwiTWFya2VyXCIsZHJhd0NpcmNsZTpcIkNpcmNsZVwiLGRyYXdQb2x5Z29uOlwiUG9seWdvblwiLGRyYXdQb2x5bGluZTpcIkxpbmVcIixkcmF3UmVjdGFuZ2xlOlwiUmVjdGFuZ2xlXCIsZHJhd0NpcmNsZU1hcmtlcjpcIkNpcmNsZU1hcmtlclwiLGVkaXRNb2RlOlwiRWRpdFwiLGRyYWdNb2RlOlwiRHJhZ1wiLGN1dFBvbHlnb246XCJDdXRcIixyZW1vdmFsTW9kZTpcIlJlbW92YWxcIixyb3RhdGVNb2RlOlwiUm90YXRlXCIsZHJhd1RleHQ6XCJUZXh0XCJ9O3JldHVybiBlW3RdP2VbdF06dGhpc1t0XT90aGlzW3RdLl9zaGFwZTp0fSxfZmluaXNoTGF5ZXI6ZnVuY3Rpb24odCl7dC5wbSYmKHQucG0uc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpLHQucG0uX3NoYXBlPXRoaXMuX3NoYXBlLHQucG0uX21hcD10aGlzLl9tYXApLHRoaXMuX2FkZERyYXduTGF5ZXJQcm9wKHQpfSxfYWRkRHJhd25MYXllclByb3A6ZnVuY3Rpb24odCl7dC5fZHJhd25CeUdlb21hbj0hMH0sX3NldFBhbmU6ZnVuY3Rpb24odCxlKXtcImxheWVyUGFuZVwiPT09ZT90Lm9wdGlvbnMucGFuZT10aGlzLl9tYXAucG0uZ2xvYmFsT3B0aW9ucy5wYW5lcyYmdGhpcy5fbWFwLnBtLmdsb2JhbE9wdGlvbnMucGFuZXMubGF5ZXJQYW5lfHxcIm92ZXJsYXlQYW5lXCI6XCJ2ZXJ0ZXhQYW5lXCI9PT1lP3Qub3B0aW9ucy5wYW5lPXRoaXMuX21hcC5wbS5nbG9iYWxPcHRpb25zLnBhbmVzJiZ0aGlzLl9tYXAucG0uZ2xvYmFsT3B0aW9ucy5wYW5lcy52ZXJ0ZXhQYW5lfHxcIm1hcmtlclBhbmVcIjpcIm1hcmtlclBhbmVcIj09PWUmJih0Lm9wdGlvbnMucGFuZT10aGlzLl9tYXAucG0uZ2xvYmFsT3B0aW9ucy5wYW5lcyYmdGhpcy5fbWFwLnBtLmdsb2JhbE9wdGlvbnMucGFuZXMubWFya2VyUGFuZXx8XCJtYXJrZXJQYW5lXCIpfSxfaXNGaXJzdExheWVyOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT0odGhpcy5fbWFwfHx0aGlzLl9sYXllci5fbWFwKS5wbS5nZXRHZW9tYW5MYXllcnMoKS5sZW5ndGh9fSk7YXQuTWFya2VyPWF0LmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9tYXA9dCx0aGlzLl9zaGFwZT1cIk1hcmtlclwiLHRoaXMudG9vbGJhckJ1dHRvbk5hbWU9XCJkcmF3TWFya2VyXCJ9LGVuYWJsZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO0wuVXRpbC5zZXRPcHRpb25zKHRoaXMsdCksdGhpcy5fZW5hYmxlZD0hMCx0aGlzLl9tYXAub24oXCJjbGlja1wiLHRoaXMuX2NyZWF0ZU1hcmtlcix0aGlzKSx0aGlzLl9tYXAucG0uVG9vbGJhci50b2dnbGVCdXR0b24odGhpcy50b29sYmFyQnV0dG9uTmFtZSwhMCksdGhpcy5faGludE1hcmtlcj1MLm1hcmtlcihbMCwwXSx0aGlzLm9wdGlvbnMubWFya2VyU3R5bGUpLHRoaXMuX3NldFBhbmUodGhpcy5faGludE1hcmtlcixcIm1hcmtlclBhbmVcIiksdGhpcy5faGludE1hcmtlci5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5faGludE1hcmtlci5hZGRUbyh0aGlzLl9tYXApLHRoaXMub3B0aW9ucy50b29sdGlwcyYmdGhpcy5faGludE1hcmtlci5iaW5kVG9vbHRpcChJKFwidG9vbHRpcHMucGxhY2VNYXJrZXJcIikse3Blcm1hbmVudDohMCxvZmZzZXQ6TC5wb2ludCgwLDEwKSxkaXJlY3Rpb246XCJib3R0b21cIixvcGFjaXR5Oi44fSkub3BlblRvb2x0aXAoKSx0aGlzLl9sYXllcj10aGlzLl9oaW50TWFya2VyLHRoaXMuX21hcC5vbihcIm1vdXNlbW92ZVwiLHRoaXMuX3N5bmNIaW50TWFya2VyLHRoaXMpLHRoaXMub3B0aW9ucy5tYXJrZXJFZGl0YWJsZSYmdGhpcy5fbWFwLmVhY2hMYXllcigoZnVuY3Rpb24odCl7ZS5pc1JlbGV2YW50TWFya2VyKHQpJiZ0LnBtLmVuYWJsZSgpfSkpLHRoaXMuX2ZpcmVEcmF3U3RhcnQoKSx0aGlzLl9zZXRHbG9iYWxEcmF3TW9kZSgpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLl9lbmFibGVkJiYodGhpcy5fZW5hYmxlZD0hMSx0aGlzLl9tYXAub2ZmKFwiY2xpY2tcIix0aGlzLl9jcmVhdGVNYXJrZXIsdGhpcyksdGhpcy5faGludE1hcmtlci5yZW1vdmUoKSx0aGlzLl9tYXAub2ZmKFwibW91c2Vtb3ZlXCIsdGhpcy5fc3luY0hpbnRNYXJrZXIsdGhpcyksdGhpcy5fbWFwLmVhY2hMYXllcigoZnVuY3Rpb24oZSl7dC5pc1JlbGV2YW50TWFya2VyKGUpJiZlLnBtLmRpc2FibGUoKX0pKSx0aGlzLl9tYXAucG0uVG9vbGJhci50b2dnbGVCdXR0b24odGhpcy50b29sYmFyQnV0dG9uTmFtZSwhMSksdGhpcy5vcHRpb25zLnNuYXBwYWJsZSYmdGhpcy5fY2xlYW51cFNuYXBwaW5nKCksdGhpcy5fZmlyZURyYXdFbmQoKSx0aGlzLl9zZXRHbG9iYWxEcmF3TW9kZSgpKX0sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkfSx0b2dnbGU6ZnVuY3Rpb24odCl7dGhpcy5lbmFibGVkKCk/dGhpcy5kaXNhYmxlKCk6dGhpcy5lbmFibGUodCl9LGlzUmVsZXZhbnRNYXJrZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBMLk1hcmtlciYmdC5wbSYmIXQuX3BtVGVtcExheWVyJiYhdC5wbS5faW5pdFRleHRNYXJrZXJ9LF9zeW5jSGludE1hcmtlcjpmdW5jdGlvbih0KXtpZih0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyh0LmxhdGxuZyksdGhpcy5vcHRpb25zLnNuYXBwYWJsZSl7dmFyIGU9dDtlLnRhcmdldD10aGlzLl9oaW50TWFya2VyLHRoaXMuX2hhbmRsZVNuYXBwaW5nKGUpfXRoaXMuX2ZpcmVDaGFuZ2UodGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKSxcIkRyYXdcIil9LF9jcmVhdGVNYXJrZXI6ZnVuY3Rpb24odCl7aWYodC5sYXRsbmcmJighdGhpcy5vcHRpb25zLnJlcXVpcmVTbmFwVG9GaW5pc2h8fHRoaXMuX2hpbnRNYXJrZXIuX3NuYXBwZWR8fHRoaXMuX2lzRmlyc3RMYXllcigpKSl7dGhpcy5faGludE1hcmtlci5fc25hcHBlZHx8dGhpcy5faGludE1hcmtlci5zZXRMYXRMbmcodC5sYXRsbmcpO3ZhciBlPXRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCksaT1uZXcgTC5NYXJrZXIoZSx0aGlzLm9wdGlvbnMubWFya2VyU3R5bGUpO3RoaXMuX3NldFBhbmUoaSxcIm1hcmtlclBhbmVcIiksdGhpcy5fZmluaXNoTGF5ZXIoaSksaS5wbXx8KGkub3B0aW9ucy5kcmFnZ2FibGU9ITEpLGkuYWRkVG8odGhpcy5fbWFwLnBtLl9nZXRDb250YWluaW5nTGF5ZXIoKSksaS5wbSYmdGhpcy5vcHRpb25zLm1hcmtlckVkaXRhYmxlP2kucG0uZW5hYmxlKCk6aS5kcmFnZ2luZyYmaS5kcmFnZ2luZy5kaXNhYmxlKCksdGhpcy5fZmlyZUNyZWF0ZShpKSx0aGlzLl9jbGVhbnVwU25hcHBpbmcoKSx0aGlzLm9wdGlvbnMuY29udGludWVEcmF3aW5nfHx0aGlzLmRpc2FibGUoKX19fSk7dmFyIG90PTYzNzEwMDguOCxzdD17Y2VudGltZXRlcnM6NjM3MTAwODgwLGNlbnRpbWV0cmVzOjYzNzEwMDg4MCxkZWdyZWVzOjU3LjIyODkxMzU0MTQzMjc0LGZlZXQ6MjA5MDIyNjAuNTExMzkyLGluY2hlczozOS4zNypvdCxraWxvbWV0ZXJzOjYzNzEuMDA4OCxraWxvbWV0cmVzOjYzNzEuMDA4OCxtZXRlcnM6b3QsbWV0cmVzOm90LG1pbGVzOjM5NTguNzYxMzMzODEwNTQ2LG1pbGxpbWV0ZXJzOjYzNzEwMDg4MDAsbWlsbGltZXRyZXM6NjM3MTAwODgwMCxuYXV0aWNhbG1pbGVzOm90LzE4NTIscmFkaWFuczoxLHlhcmRzOjY5NjczMzUuMjIzNjc5OTk5fTtmdW5jdGlvbiBsdCh0LGUsaSl7dm9pZCAwPT09aSYmKGk9e30pO3ZhciBuPXt0eXBlOlwiRmVhdHVyZVwifTtyZXR1cm4oMD09PWkuaWR8fGkuaWQpJiYobi5pZD1pLmlkKSxpLmJib3gmJihuLmJib3g9aS5iYm94KSxuLnByb3BlcnRpZXM9ZXx8e30sbi5nZW9tZXRyeT10LG59ZnVuY3Rpb24gaHQodCxlLGkpe2lmKHZvaWQgMD09PWkmJihpPXt9KSwhdCl0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBpcyByZXF1aXJlZFwiKTtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGFuIEFycmF5XCIpO2lmKHQubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwiY29vcmRpbmF0ZXMgbXVzdCBiZSBhdCBsZWFzdCAyIG51bWJlcnMgbG9uZ1wiKTtpZighX3QodFswXSl8fCFfdCh0WzFdKSl0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGNvbnRhaW4gbnVtYmVyc1wiKTtyZXR1cm4gbHQoe3R5cGU6XCJQb2ludFwiLGNvb3JkaW5hdGVzOnR9LGUsaSl9ZnVuY3Rpb24gdXQodCxlLGkpe2lmKHZvaWQgMD09PWkmJihpPXt9KSx0Lmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHdvIG9yIG1vcmUgcG9zaXRpb25zXCIpO3JldHVybiBsdCh7dHlwZTpcIkxpbmVTdHJpbmdcIixjb29yZGluYXRlczp0fSxlLGkpfWZ1bmN0aW9uIGN0KHQsZSl7dm9pZCAwPT09ZSYmKGU9e30pO3ZhciBpPXt0eXBlOlwiRmVhdHVyZUNvbGxlY3Rpb25cIn07cmV0dXJuIGUuaWQmJihpLmlkPWUuaWQpLGUuYmJveCYmKGkuYmJveD1lLmJib3gpLGkuZmVhdHVyZXM9dCxpfWZ1bmN0aW9uIHB0KHQsZSl7dm9pZCAwPT09ZSYmKGU9XCJraWxvbWV0ZXJzXCIpO3ZhciBpPXN0W2VdO2lmKCFpKXRocm93IG5ldyBFcnJvcihlK1wiIHVuaXRzIGlzIGludmFsaWRcIik7cmV0dXJuIHQqaX1mdW5jdGlvbiBkdCh0LGUpe3ZvaWQgMD09PWUmJihlPVwia2lsb21ldGVyc1wiKTt2YXIgaT1zdFtlXTtpZighaSl0aHJvdyBuZXcgRXJyb3IoZStcIiB1bml0cyBpcyBpbnZhbGlkXCIpO3JldHVybiB0L2l9ZnVuY3Rpb24gZnQodCl7cmV0dXJuIDE4MCoodCUoMipNYXRoLlBJKSkvTWF0aC5QSX1mdW5jdGlvbiBndCh0KXtyZXR1cm4gdCUzNjAqTWF0aC5QSS8xODB9ZnVuY3Rpb24gX3QodCl7cmV0dXJuIWlzTmFOKHQpJiZudWxsIT09dCYmIUFycmF5LmlzQXJyYXkodCl9ZnVuY3Rpb24gbXQodCl7dmFyIGUsaSxuPXt0eXBlOlwiRmVhdHVyZUNvbGxlY3Rpb25cIixmZWF0dXJlczpbXX07aWYoXCJMaW5lU3RyaW5nXCI9PT0oaT1cIkZlYXR1cmVcIj09PXQudHlwZT90Lmdlb21ldHJ5OnQpLnR5cGUpZT1baS5jb29yZGluYXRlc107ZWxzZSBpZihcIk11bHRpTGluZVN0cmluZ1wiPT09aS50eXBlKWU9aS5jb29yZGluYXRlcztlbHNlIGlmKFwiTXVsdGlQb2x5Z29uXCI9PT1pLnR5cGUpZT1bXS5jb25jYXQuYXBwbHkoW10saS5jb29yZGluYXRlcyk7ZWxzZXtpZihcIlBvbHlnb25cIiE9PWkudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIGEgTGluZVN0cmluZywgTXVsdGlMaW5lU3RyaW5nLCBQb2x5Z29uLCBvciBNdWx0aVBvbHlnb24gRmVhdHVyZSBvciBHZW9tZXRyeVwiKTtlPWkuY29vcmRpbmF0ZXN9cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZS5mb3JFYWNoKChmdW5jdGlvbihlKXtmb3IodmFyIGk9MDtpPHQubGVuZ3RoLTE7aSsrKWZvcih2YXIgcj1pO3I8ZS5sZW5ndGgtMTtyKyspe2lmKHQ9PT1lKXtpZigxPT09TWF0aC5hYnMoaS1yKSljb250aW51ZTtpZigwPT09aSYmcj09PXQubGVuZ3RoLTImJnRbaV1bMF09PT10W3QubGVuZ3RoLTFdWzBdJiZ0W2ldWzFdPT09dFt0Lmxlbmd0aC0xXVsxXSljb250aW51ZX12YXIgYT15dCh0W2ldWzBdLHRbaV1bMV0sdFtpKzFdWzBdLHRbaSsxXVsxXSxlW3JdWzBdLGVbcl1bMV0sZVtyKzFdWzBdLGVbcisxXVsxXSk7YSYmbi5mZWF0dXJlcy5wdXNoKGh0KFthWzBdLGFbMV1dKSl9fSkpfSkpLG59ZnVuY3Rpb24geXQodCxlLGksbixyLGEsbyxzKXt2YXIgbCxoLHUsYyxwPXt4Om51bGwseTpudWxsLG9uTGluZTE6ITEsb25MaW5lMjohMX07cmV0dXJuIDA9PT0obD0ocy1hKSooaS10KS0oby1yKSoobi1lKSk/bnVsbCE9PXAueCYmbnVsbCE9PXAueSYmcDooYz0oaS10KSooaD1lLWEpLShuLWUpKih1PXQtciksaD0oKG8tcikqaC0ocy1hKSp1KS9sLHU9Yy9sLHAueD10K2gqKGktdCkscC55PWUraCoobi1lKSxoPj0wJiZoPD0xJiYocC5vbkxpbmUxPSEwKSx1Pj0wJiZ1PD0xJiYocC5vbkxpbmUyPSEwKSwhKCFwLm9uTGluZTF8fCFwLm9uTGluZTIpJiZbcC54LHAueV0pfWZ1bmN0aW9uIHZ0KHQsZSl7dmFyIGk9T2JqZWN0LmtleXModCk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KTtlJiYobj1uLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxlKS5lbnVtZXJhYmxlfSkpKSxpLnB1c2guYXBwbHkoaSxuKX1yZXR1cm4gaX1mdW5jdGlvbiBMdCh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbZV0/YXJndW1lbnRzW2VdOnt9O2UlMj92dChPYmplY3QoaSksITApLmZvckVhY2goKGZ1bmN0aW9uKGUpe2J0KHQsZSxpW2VdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGkpKTp2dChPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLGUpKX0pKX1yZXR1cm4gdH1mdW5jdGlvbiBidCh0LGUsaSl7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1pLHR9ZnVuY3Rpb24ga3QodCxlKXt2YXIgaT1PYmplY3Qua2V5cyh0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO2UmJihuPW4uZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGUpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG4pfXJldHVybiBpfWZ1bmN0aW9uIE10KHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBpPW51bGwhPWFyZ3VtZW50c1tlXT9hcmd1bWVudHNbZV06e307ZSUyP2t0KE9iamVjdChpKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7eHQodCxlLGlbZV0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoaSkpOmt0KE9iamVjdChpKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksZSkpfSkpfXJldHVybiB0fWZ1bmN0aW9uIHh0KHQsZSxpKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPWksdH1mdW5jdGlvbiB3dCh0KXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJjb29yZCBpcyByZXF1aXJlZFwiKTtpZighQXJyYXkuaXNBcnJheSh0KSl7aWYoXCJGZWF0dXJlXCI9PT10LnR5cGUmJm51bGwhPT10Lmdlb21ldHJ5JiZcIlBvaW50XCI9PT10Lmdlb21ldHJ5LnR5cGUpcmV0dXJuIHQuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7aWYoXCJQb2ludFwiPT09dC50eXBlKXJldHVybiB0LmNvb3JkaW5hdGVzfWlmKEFycmF5LmlzQXJyYXkodCkmJnQubGVuZ3RoPj0yJiYhQXJyYXkuaXNBcnJheSh0WzBdKSYmIUFycmF5LmlzQXJyYXkodFsxXSkpcmV0dXJuIHQ7dGhyb3cgbmV3IEVycm9yKFwiY29vcmQgbXVzdCBiZSBHZW9KU09OIFBvaW50IG9yIGFuIEFycmF5IG9mIG51bWJlcnNcIil9ZnVuY3Rpb24gQ3QodCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdDtpZihcIkZlYXR1cmVcIj09PXQudHlwZSl7aWYobnVsbCE9PXQuZ2VvbWV0cnkpcmV0dXJuIHQuZ2VvbWV0cnkuY29vcmRpbmF0ZXN9ZWxzZSBpZih0LmNvb3JkaW5hdGVzKXJldHVybiB0LmNvb3JkaW5hdGVzO3Rocm93IG5ldyBFcnJvcihcImNvb3JkcyBtdXN0IGJlIEdlb0pTT04gRmVhdHVyZSwgR2VvbWV0cnkgT2JqZWN0IG9yIGFuIEFycmF5XCIpfWZ1bmN0aW9uIFB0KHQpe3JldHVyblwiRmVhdHVyZVwiPT09dC50eXBlP3QuZ2VvbWV0cnk6dH1mdW5jdGlvbiBFdCh0LGUpe3JldHVyblwiRmVhdHVyZUNvbGxlY3Rpb25cIj09PXQudHlwZT9cIkZlYXR1cmVDb2xsZWN0aW9uXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PXQudHlwZT9cIkdlb21ldHJ5Q29sbGVjdGlvblwiOlwiRmVhdHVyZVwiPT09dC50eXBlJiZudWxsIT09dC5nZW9tZXRyeT90Lmdlb21ldHJ5LnR5cGU6dC50eXBlfWZ1bmN0aW9uIFN0KHQsZSxpKXtpZihudWxsIT09dClmb3IodmFyIG4scixhLG8scyxsLGgsdSxjPTAscD0wLGQ9dC50eXBlLGY9XCJGZWF0dXJlQ29sbGVjdGlvblwiPT09ZCxnPVwiRmVhdHVyZVwiPT09ZCxfPWY/dC5mZWF0dXJlcy5sZW5ndGg6MSxtPTA7bTxfO20rKyl7cz0odT0hIShoPWY/dC5mZWF0dXJlc1ttXS5nZW9tZXRyeTpnP3QuZ2VvbWV0cnk6dCkmJlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT1oLnR5cGUpP2guZ2VvbWV0cmllcy5sZW5ndGg6MTtmb3IodmFyIHk9MDt5PHM7eSsrKXt2YXIgdj0wLEw9MDtpZihudWxsIT09KG89dT9oLmdlb21ldHJpZXNbeV06aCkpe2w9by5jb29yZGluYXRlczt2YXIgYj1vLnR5cGU7c3dpdGNoKGM9IWl8fFwiUG9seWdvblwiIT09YiYmXCJNdWx0aVBvbHlnb25cIiE9PWI/MDoxLGIpe2Nhc2UgbnVsbDpicmVhaztjYXNlXCJQb2ludFwiOmlmKCExPT09ZShsLHAsbSx2LEwpKXJldHVybiExO3ArKyx2Kys7YnJlYWs7Y2FzZVwiTGluZVN0cmluZ1wiOmNhc2VcIk11bHRpUG9pbnRcIjpmb3Iobj0wO248bC5sZW5ndGg7bisrKXtpZighMT09PWUobFtuXSxwLG0sdixMKSlyZXR1cm4hMTtwKyssXCJNdWx0aVBvaW50XCI9PT1iJiZ2Kyt9XCJMaW5lU3RyaW5nXCI9PT1iJiZ2Kys7YnJlYWs7Y2FzZVwiUG9seWdvblwiOmNhc2VcIk11bHRpTGluZVN0cmluZ1wiOmZvcihuPTA7bjxsLmxlbmd0aDtuKyspe2ZvcihyPTA7cjxsW25dLmxlbmd0aC1jO3IrKyl7aWYoITE9PT1lKGxbbl1bcl0scCxtLHYsTCkpcmV0dXJuITE7cCsrfVwiTXVsdGlMaW5lU3RyaW5nXCI9PT1iJiZ2KyssXCJQb2x5Z29uXCI9PT1iJiZMKyt9XCJQb2x5Z29uXCI9PT1iJiZ2Kys7YnJlYWs7Y2FzZVwiTXVsdGlQb2x5Z29uXCI6Zm9yKG49MDtuPGwubGVuZ3RoO24rKyl7Zm9yKEw9MCxyPTA7cjxsW25dLmxlbmd0aDtyKyspe2ZvcihhPTA7YTxsW25dW3JdLmxlbmd0aC1jO2ErKyl7aWYoITE9PT1lKGxbbl1bcl1bYV0scCxtLHYsTCkpcmV0dXJuITE7cCsrfUwrK312Kyt9YnJlYWs7Y2FzZVwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6Zm9yKG49MDtuPG8uZ2VvbWV0cmllcy5sZW5ndGg7bisrKWlmKCExPT09U3Qoby5nZW9tZXRyaWVzW25dLGUsaSkpcmV0dXJuITE7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb21ldHJ5IFR5cGVcIil9fX19fWZ1bmN0aW9uIE90KHQsZSl7aWYoXCJGZWF0dXJlXCI9PT10LnR5cGUpZSh0LDApO2Vsc2UgaWYoXCJGZWF0dXJlQ29sbGVjdGlvblwiPT09dC50eXBlKWZvcih2YXIgaT0wO2k8dC5mZWF0dXJlcy5sZW5ndGgmJiExIT09ZSh0LmZlYXR1cmVzW2ldLGkpO2krKyk7fWZ1bmN0aW9uIER0KHQsZSl7dmFyIGksbixyLGEsbyxzLGwsaCx1LGMscD0wLGQ9XCJGZWF0dXJlQ29sbGVjdGlvblwiPT09dC50eXBlLGY9XCJGZWF0dXJlXCI9PT10LnR5cGUsZz1kP3QuZmVhdHVyZXMubGVuZ3RoOjE7Zm9yKGk9MDtpPGc7aSsrKXtmb3Iocz1kP3QuZmVhdHVyZXNbaV0uZ2VvbWV0cnk6Zj90Lmdlb21ldHJ5OnQsaD1kP3QuZmVhdHVyZXNbaV0ucHJvcGVydGllczpmP3QucHJvcGVydGllczp7fSx1PWQ/dC5mZWF0dXJlc1tpXS5iYm94OmY/dC5iYm94OnVuZGVmaW5lZCxjPWQ/dC5mZWF0dXJlc1tpXS5pZDpmP3QuaWQ6dW5kZWZpbmVkLG89KGw9ISFzJiZcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09cy50eXBlKT9zLmdlb21ldHJpZXMubGVuZ3RoOjEscj0wO3I8bztyKyspaWYobnVsbCE9PShhPWw/cy5nZW9tZXRyaWVzW3JdOnMpKXN3aXRjaChhLnR5cGUpe2Nhc2VcIlBvaW50XCI6Y2FzZVwiTGluZVN0cmluZ1wiOmNhc2VcIk11bHRpUG9pbnRcIjpjYXNlXCJQb2x5Z29uXCI6Y2FzZVwiTXVsdGlMaW5lU3RyaW5nXCI6Y2FzZVwiTXVsdGlQb2x5Z29uXCI6aWYoITE9PT1lKGEscCxoLHUsYykpcmV0dXJuITE7YnJlYWs7Y2FzZVwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6Zm9yKG49MDtuPGEuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWlmKCExPT09ZShhLmdlb21ldHJpZXNbbl0scCxoLHUsYykpcmV0dXJuITE7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb21ldHJ5IFR5cGVcIil9ZWxzZSBpZighMT09PWUobnVsbCxwLGgsdSxjKSlyZXR1cm4hMTtwKyt9fWZ1bmN0aW9uIFJ0KHQsZSl7RHQodCwoZnVuY3Rpb24odCxpLG4scixhKXt2YXIgbyxzPW51bGw9PT10P251bGw6dC50eXBlO3N3aXRjaChzKXtjYXNlIG51bGw6Y2FzZVwiUG9pbnRcIjpjYXNlXCJMaW5lU3RyaW5nXCI6Y2FzZVwiUG9seWdvblwiOnJldHVybiExIT09ZShsdCh0LG4se2Jib3g6cixpZDphfSksaSwwKSYmdm9pZCAwfXN3aXRjaChzKXtjYXNlXCJNdWx0aVBvaW50XCI6bz1cIlBvaW50XCI7YnJlYWs7Y2FzZVwiTXVsdGlMaW5lU3RyaW5nXCI6bz1cIkxpbmVTdHJpbmdcIjticmVhaztjYXNlXCJNdWx0aVBvbHlnb25cIjpvPVwiUG9seWdvblwifWZvcih2YXIgbD0wO2w8dC5jb29yZGluYXRlcy5sZW5ndGg7bCsrKXt2YXIgaD10LmNvb3JkaW5hdGVzW2xdO2lmKCExPT09ZShsdCh7dHlwZTpvLGNvb3JkaW5hdGVzOmh9LG4pLGksbCkpcmV0dXJuITF9fSkpfWF0LkxpbmU9YXQuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX21hcD10LHRoaXMuX3NoYXBlPVwiTGluZVwiLHRoaXMudG9vbGJhckJ1dHRvbk5hbWU9XCJkcmF3UG9seWxpbmVcIix0aGlzLl9kb2VzU2VsZkludGVyc2VjdD0hMX0sZW5hYmxlOmZ1bmN0aW9uKHQpe0wuVXRpbC5zZXRPcHRpb25zKHRoaXMsdCksdGhpcy5fZW5hYmxlZD0hMCx0aGlzLl9sYXllckdyb3VwPW5ldyBMLkxheWVyR3JvdXAsdGhpcy5fbGF5ZXJHcm91cC5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5fbGF5ZXJHcm91cC5hZGRUbyh0aGlzLl9tYXApLHRoaXMuX2xheWVyPUwucG9seWxpbmUoW10sdGhpcy5vcHRpb25zLnRlbXBsaW5lU3R5bGUpLHRoaXMuX3NldFBhbmUodGhpcy5fbGF5ZXIsXCJsYXllclBhbmVcIiksdGhpcy5fbGF5ZXIuX3BtVGVtcExheWVyPSEwLHRoaXMuX2xheWVyR3JvdXAuYWRkTGF5ZXIodGhpcy5fbGF5ZXIpLHRoaXMuX2hpbnRsaW5lPUwucG9seWxpbmUoW10sdGhpcy5vcHRpb25zLmhpbnRsaW5lU3R5bGUpLHRoaXMuX3NldFBhbmUodGhpcy5faGludGxpbmUsXCJsYXllclBhbmVcIiksdGhpcy5faGludGxpbmUuX3BtVGVtcExheWVyPSEwLHRoaXMuX2xheWVyR3JvdXAuYWRkTGF5ZXIodGhpcy5faGludGxpbmUpLHRoaXMuX2hpbnRNYXJrZXI9TC5tYXJrZXIodGhpcy5fbWFwLmdldENlbnRlcigpLHtpbnRlcmFjdGl2ZTohMSx6SW5kZXhPZmZzZXQ6MTAwLGljb246TC5kaXZJY29uKHtjbGFzc05hbWU6XCJtYXJrZXItaWNvbiBjdXJzb3ItbWFya2VyXCJ9KX0pLHRoaXMuX3NldFBhbmUodGhpcy5faGludE1hcmtlcixcInZlcnRleFBhbmVcIiksdGhpcy5faGludE1hcmtlci5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5fbGF5ZXJHcm91cC5hZGRMYXllcih0aGlzLl9oaW50TWFya2VyKSx0aGlzLm9wdGlvbnMuY3Vyc29yTWFya2VyJiZMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faGludE1hcmtlci5faWNvbixcInZpc2libGVcIiksdGhpcy5vcHRpb25zLnRvb2x0aXBzJiZ0aGlzLl9oaW50TWFya2VyLmJpbmRUb29sdGlwKEkoXCJ0b29sdGlwcy5maXJzdFZlcnRleFwiKSx7cGVybWFuZW50OiEwLG9mZnNldDpMLnBvaW50KDAsMTApLGRpcmVjdGlvbjpcImJvdHRvbVwiLG9wYWNpdHk6Ljh9KS5vcGVuVG9vbHRpcCgpLHRoaXMuX21hcC5fY29udGFpbmVyLnN0eWxlLmN1cnNvcj1cImNyb3NzaGFpclwiLHRoaXMuX21hcC5vbihcImNsaWNrXCIsdGhpcy5fY3JlYXRlVmVydGV4LHRoaXMpLHRoaXMub3B0aW9ucy5maW5pc2hPbiYmXCJzbmFwXCIhPT10aGlzLm9wdGlvbnMuZmluaXNoT24mJnRoaXMuX21hcC5vbih0aGlzLm9wdGlvbnMuZmluaXNoT24sdGhpcy5fZmluaXNoU2hhcGUsdGhpcyksXCJkYmxjbGlja1wiPT09dGhpcy5vcHRpb25zLmZpbmlzaE9uJiYodGhpcy50ZW1wTWFwRG91YmxlQ2xpY2tab29tU3RhdGU9dGhpcy5fbWFwLmRvdWJsZUNsaWNrWm9vbS5fZW5hYmxlZCx0aGlzLnRlbXBNYXBEb3VibGVDbGlja1pvb21TdGF0ZSYmdGhpcy5fbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCkpLHRoaXMuX21hcC5vbihcIm1vdXNlbW92ZVwiLHRoaXMuX3N5bmNIaW50TWFya2VyLHRoaXMpLHRoaXMuX2hpbnRNYXJrZXIub24oXCJtb3ZlXCIsdGhpcy5fc3luY0hpbnRMaW5lLHRoaXMpLHRoaXMuX21hcC5wbS5Ub29sYmFyLnRvZ2dsZUJ1dHRvbih0aGlzLnRvb2xiYXJCdXR0b25OYW1lLCEwKSx0aGlzLl9vdGhlclNuYXBMYXllcnM9W10sdGhpcy5fZmlyZURyYXdTdGFydCgpLHRoaXMuX3NldEdsb2JhbERyYXdNb2RlKCl9LGRpc2FibGU6ZnVuY3Rpb24oKXt0aGlzLl9lbmFibGVkJiYodGhpcy5fZW5hYmxlZD0hMSx0aGlzLl9tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3I9XCJcIix0aGlzLl9tYXAub2ZmKFwiY2xpY2tcIix0aGlzLl9jcmVhdGVWZXJ0ZXgsdGhpcyksdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLHRoaXMuX3N5bmNIaW50TWFya2VyLHRoaXMpLHRoaXMub3B0aW9ucy5maW5pc2hPbiYmXCJzbmFwXCIhPT10aGlzLm9wdGlvbnMuZmluaXNoT24mJnRoaXMuX21hcC5vZmYodGhpcy5vcHRpb25zLmZpbmlzaE9uLHRoaXMuX2ZpbmlzaFNoYXBlLHRoaXMpLHRoaXMudGVtcE1hcERvdWJsZUNsaWNrWm9vbVN0YXRlJiZ0aGlzLl9tYXAuZG91YmxlQ2xpY2tab29tLmVuYWJsZSgpLHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllckdyb3VwKSx0aGlzLl9tYXAucG0uVG9vbGJhci50b2dnbGVCdXR0b24odGhpcy50b29sYmFyQnV0dG9uTmFtZSwhMSksdGhpcy5vcHRpb25zLnNuYXBwYWJsZSYmdGhpcy5fY2xlYW51cFNuYXBwaW5nKCksdGhpcy5fZmlyZURyYXdFbmQoKSx0aGlzLl9zZXRHbG9iYWxEcmF3TW9kZSgpKX0sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkfSx0b2dnbGU6ZnVuY3Rpb24odCl7dGhpcy5lbmFibGVkKCk/dGhpcy5kaXNhYmxlKCk6dGhpcy5lbmFibGUodCl9LF9zeW5jSGludExpbmU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9sYXllci5nZXRMYXRMbmdzKCk7aWYodC5sZW5ndGg+MCl7dmFyIGU9dFt0Lmxlbmd0aC0xXTt0aGlzLl9oaW50bGluZS5zZXRMYXRMbmdzKFtlLHRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCldKX19LF9zeW5jSGludE1hcmtlcjpmdW5jdGlvbih0KXtpZih0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyh0LmxhdGxuZyksdGhpcy5vcHRpb25zLnNuYXBwYWJsZSl7dmFyIGU9dDtlLnRhcmdldD10aGlzLl9oaW50TWFya2VyLHRoaXMuX2hhbmRsZVNuYXBwaW5nKGUpfXRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb258fHRoaXMuX2hhbmRsZVNlbGZJbnRlcnNlY3Rpb24oITAsdC5sYXRsbmcpO3ZhciBpPXRoaXMuX2xheWVyLl9kZWZhdWx0U2hhcGUoKS5zbGljZSgpO2kucHVzaCh0aGlzLl9oaW50TWFya2VyLmdldExhdExuZygpKSx0aGlzLl9jaGFuZ2UoaSl9LGhhc1NlbGZJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gbXQodGhpcy5fbGF5ZXIudG9HZW9KU09OKDE1KSkuZmVhdHVyZXMubGVuZ3RoPjB9LF9oYW5kbGVTZWxmSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSl7dmFyIGk9TC5wb2x5bGluZSh0aGlzLl9sYXllci5nZXRMYXRMbmdzKCkpO3QmJihlfHwoZT10aGlzLl9oaW50TWFya2VyLmdldExhdExuZygpKSxpLmFkZExhdExuZyhlKSk7dmFyIG49bXQoaS50b0dlb0pTT04oMTUpKTt0aGlzLl9kb2VzU2VsZkludGVyc2VjdD1uLmZlYXR1cmVzLmxlbmd0aD4wLHRoaXMuX2RvZXNTZWxmSW50ZXJzZWN0P3RoaXMuX2hpbnRsaW5lLnNldFN0eWxlKHtjb2xvcjpcIiNmMDAwMDBmZlwifSk6dGhpcy5faGludGxpbmUuaXNFbXB0eSgpfHx0aGlzLl9oaW50bGluZS5zZXRTdHlsZSh0aGlzLm9wdGlvbnMuaGludGxpbmVTdHlsZSl9LF9jcmVhdGVWZXJ0ZXg6ZnVuY3Rpb24odCl7aWYodGhpcy5vcHRpb25zLmFsbG93U2VsZkludGVyc2VjdGlvbnx8KHRoaXMuX2hhbmRsZVNlbGZJbnRlcnNlY3Rpb24oITAsdC5sYXRsbmcpLCF0aGlzLl9kb2VzU2VsZkludGVyc2VjdCkpe3RoaXMuX2hpbnRNYXJrZXIuX3NuYXBwZWR8fHRoaXMuX2hpbnRNYXJrZXIuc2V0TGF0TG5nKHQubGF0bG5nKTt2YXIgZT10aGlzLl9oaW50TWFya2VyLmdldExhdExuZygpO2lmKGUuZXF1YWxzKHRoaXMuX2xheWVyLmdldExhdExuZ3MoKVswXSkpdGhpcy5fZmluaXNoU2hhcGUodCk7ZWxzZXt0aGlzLl9sYXllci5fbGF0bG5nSW5mbz10aGlzLl9sYXllci5fbGF0bG5nSW5mb3x8W10sdGhpcy5fbGF5ZXIuX2xhdGxuZ0luZm8ucHVzaCh7bGF0bG5nOmUsc25hcEluZm86dGhpcy5faGludE1hcmtlci5fc25hcEluZm99KSx0aGlzLl9sYXllci5hZGRMYXRMbmcoZSk7dmFyIGk9dGhpcy5fY3JlYXRlTWFya2VyKGUpO3RoaXMuX3NldFRvb2x0aXBUZXh0KCksdGhpcy5faGludGxpbmUuc2V0TGF0TG5ncyhbZSxlXSksdGhpcy5fZmlyZVZlcnRleEFkZGVkKGksdW5kZWZpbmVkLGUsXCJEcmF3XCIpLHRoaXMuX2NoYW5nZSh0aGlzLl9sYXllci5nZXRMYXRMbmdzKCkpLFwic25hcFwiPT09dGhpcy5vcHRpb25zLmZpbmlzaE9uJiZ0aGlzLl9oaW50TWFya2VyLl9zbmFwcGVkJiZ0aGlzLl9maW5pc2hTaGFwZSh0KX19fSxfcmVtb3ZlTGFzdFZlcnRleDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2xheWVyLmdldExhdExuZ3MoKSxlPXQucG9wKCk7aWYodC5sZW5ndGg8MSl0aGlzLmRpc2FibGUoKTtlbHNle3ZhciBpPXRoaXMuX2xheWVyR3JvdXAuZ2V0TGF5ZXJzKCkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEwuTWFya2VyfSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIUwuRG9tVXRpbC5oYXNDbGFzcyh0Ll9pY29uLFwiY3Vyc29yLW1hcmtlclwiKX0pKS5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXRMYXRMbmcoKT09PWV9KSksbj10aGlzLl9sYXllckdyb3VwLmdldExheWVycygpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBMLk1hcmtlcn0pKSxyPUwuUE0uVXRpbHMuZmluZERlZXBNYXJrZXJJbmRleChuLGkpLmluZGV4UGF0aDt0aGlzLl9sYXllckdyb3VwLnJlbW92ZUxheWVyKGkpLHRoaXMuX2xheWVyLnNldExhdExuZ3ModCksdGhpcy5fc3luY0hpbnRMaW5lKCksdGhpcy5fc2V0VG9vbHRpcFRleHQoKSx0aGlzLl9maXJlVmVydGV4UmVtb3ZlZChpLHIsXCJEcmF3XCIpLHRoaXMuX2NoYW5nZSh0aGlzLl9sYXllci5nZXRMYXRMbmdzKCkpfX0sX2ZpbmlzaFNoYXBlOmZ1bmN0aW9uKCl7aWYoKHRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb258fCh0aGlzLl9oYW5kbGVTZWxmSW50ZXJzZWN0aW9uKCExKSwhdGhpcy5fZG9lc1NlbGZJbnRlcnNlY3QpKSYmKCF0aGlzLm9wdGlvbnMucmVxdWlyZVNuYXBUb0ZpbmlzaHx8dGhpcy5faGludE1hcmtlci5fc25hcHBlZHx8dGhpcy5faXNGaXJzdExheWVyKCkpKXt2YXIgdD10aGlzLl9sYXllci5nZXRMYXRMbmdzKCk7aWYoISh0Lmxlbmd0aDw9MSkpe3ZhciBlPUwucG9seWxpbmUodCx0aGlzLm9wdGlvbnMucGF0aE9wdGlvbnMpO3RoaXMuX3NldFBhbmUoZSxcImxheWVyUGFuZVwiKSx0aGlzLl9maW5pc2hMYXllcihlKSxlLmFkZFRvKHRoaXMuX21hcC5wbS5fZ2V0Q29udGFpbmluZ0xheWVyKCkpLHRoaXMuX2ZpcmVDcmVhdGUoZSksdGhpcy5vcHRpb25zLnNuYXBwYWJsZSYmdGhpcy5fY2xlYW51cFNuYXBwaW5nKCksdGhpcy5kaXNhYmxlKCksdGhpcy5vcHRpb25zLmNvbnRpbnVlRHJhd2luZyYmdGhpcy5lbmFibGUoKX19fSxfY3JlYXRlTWFya2VyOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBMLk1hcmtlcih0LHtkcmFnZ2FibGU6ITEsaWNvbjpMLmRpdkljb24oe2NsYXNzTmFtZTpcIm1hcmtlci1pY29uXCJ9KX0pO3JldHVybiB0aGlzLl9zZXRQYW5lKGUsXCJ2ZXJ0ZXhQYW5lXCIpLGUuX3BtVGVtcExheWVyPSEwLHRoaXMuX2xheWVyR3JvdXAuYWRkTGF5ZXIoZSksZS5vbihcImNsaWNrXCIsdGhpcy5fZmluaXNoU2hhcGUsdGhpcyksZX0sX3NldFRvb2x0aXBUZXh0OmZ1bmN0aW9uKCl7dmFyIHQ9XCJcIjt0PUkodGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpLmZsYXQoKS5sZW5ndGg8PTE/XCJ0b29sdGlwcy5jb250aW51ZUxpbmVcIjpcInRvb2x0aXBzLmZpbmlzaExpbmVcIiksdGhpcy5faGludE1hcmtlci5zZXRUb29sdGlwQ29udGVudCh0KX0sX2NoYW5nZTpmdW5jdGlvbih0KXt0aGlzLl9maXJlQ2hhbmdlKHQsXCJEcmF3XCIpfX0pLGF0LlBvbHlnb249YXQuTGluZS5leHRlbmQoe2luaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fbWFwPXQsdGhpcy5fc2hhcGU9XCJQb2x5Z29uXCIsdGhpcy50b29sYmFyQnV0dG9uTmFtZT1cImRyYXdQb2x5Z29uXCJ9LF9jcmVhdGVNYXJrZXI6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEwuTWFya2VyKHQse2RyYWdnYWJsZTohMSxpY29uOkwuZGl2SWNvbih7Y2xhc3NOYW1lOlwibWFya2VyLWljb25cIn0pfSk7cmV0dXJuIHRoaXMuX3NldFBhbmUoZSxcInZlcnRleFBhbmVcIiksZS5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5fbGF5ZXJHcm91cC5hZGRMYXllcihlKSwxPT09dGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpLmZsYXQoKS5sZW5ndGg/KGUub24oXCJjbGlja1wiLHRoaXMuX2ZpbmlzaFNoYXBlLHRoaXMpLHRoaXMuX3RlbXBTbmFwTGF5ZXJJbmRleD10aGlzLl9vdGhlclNuYXBMYXllcnMucHVzaChlKS0xLHRoaXMub3B0aW9ucy5zbmFwcGFibGUmJnRoaXMuX2NsZWFudXBTbmFwcGluZygpKTplLm9uKFwiY2xpY2tcIiwoZnVuY3Rpb24oKXtyZXR1cm4gMX0pKSxlfSxfc2V0VG9vbHRpcFRleHQ6ZnVuY3Rpb24oKXt2YXIgdD1cIlwiO3Q9SSh0aGlzLl9sYXllci5nZXRMYXRMbmdzKCkuZmxhdCgpLmxlbmd0aDw9Mj9cInRvb2x0aXBzLmNvbnRpbnVlTGluZVwiOlwidG9vbHRpcHMuZmluaXNoUG9seVwiKSx0aGlzLl9oaW50TWFya2VyLnNldFRvb2x0aXBDb250ZW50KHQpfSxfZmluaXNoU2hhcGU6ZnVuY3Rpb24oKXtpZigodGhpcy5vcHRpb25zLmFsbG93U2VsZkludGVyc2VjdGlvbnx8KHRoaXMuX2hhbmRsZVNlbGZJbnRlcnNlY3Rpb24oITAsdGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpWzBdKSwhdGhpcy5fZG9lc1NlbGZJbnRlcnNlY3QpKSYmKCF0aGlzLm9wdGlvbnMucmVxdWlyZVNuYXBUb0ZpbmlzaHx8dGhpcy5faGludE1hcmtlci5fc25hcHBlZHx8dGhpcy5faXNGaXJzdExheWVyKCkpKXt2YXIgdD10aGlzLl9sYXllci5nZXRMYXRMbmdzKCk7aWYoISh0Lmxlbmd0aDw9Mikpe3ZhciBlPUwucG9seWdvbih0LHRoaXMub3B0aW9ucy5wYXRoT3B0aW9ucyk7dGhpcy5fc2V0UGFuZShlLFwibGF5ZXJQYW5lXCIpLHRoaXMuX2ZpbmlzaExheWVyKGUpLGUuYWRkVG8odGhpcy5fbWFwLnBtLl9nZXRDb250YWluaW5nTGF5ZXIoKSksdGhpcy5fZmlyZUNyZWF0ZShlKSx0aGlzLl9jbGVhbnVwU25hcHBpbmcoKSx0aGlzLl9vdGhlclNuYXBMYXllcnMuc3BsaWNlKHRoaXMuX3RlbXBTbmFwTGF5ZXJJbmRleCwxKSxkZWxldGUgdGhpcy5fdGVtcFNuYXBMYXllckluZGV4LHRoaXMuZGlzYWJsZSgpLHRoaXMub3B0aW9ucy5jb250aW51ZURyYXdpbmcmJnRoaXMuZW5hYmxlKCl9fX19KSxhdC5SZWN0YW5nbGU9YXQuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX21hcD10LHRoaXMuX3NoYXBlPVwiUmVjdGFuZ2xlXCIsdGhpcy50b29sYmFyQnV0dG9uTmFtZT1cImRyYXdSZWN0YW5nbGVcIn0sZW5hYmxlOmZ1bmN0aW9uKHQpe2lmKEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsdCksdGhpcy5fZW5hYmxlZD0hMCx0aGlzLl9sYXllckdyb3VwPW5ldyBMLkxheWVyR3JvdXAsdGhpcy5fbGF5ZXJHcm91cC5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5fbGF5ZXJHcm91cC5hZGRUbyh0aGlzLl9tYXApLHRoaXMuX2xheWVyPUwucmVjdGFuZ2xlKFtbMCwwXSxbMCwwXV0sdGhpcy5vcHRpb25zLnBhdGhPcHRpb25zKSx0aGlzLl9zZXRQYW5lKHRoaXMuX2xheWVyLFwibGF5ZXJQYW5lXCIpLHRoaXMuX2xheWVyLl9wbVRlbXBMYXllcj0hMCx0aGlzLl9zdGFydE1hcmtlcj1MLm1hcmtlcihbMCwwXSx7aWNvbjpMLmRpdkljb24oe2NsYXNzTmFtZTpcIm1hcmtlci1pY29uIHJlY3Qtc3RhcnQtbWFya2VyXCJ9KSxkcmFnZ2FibGU6ITEsekluZGV4T2Zmc2V0Oi0xMDAsb3BhY2l0eTp0aGlzLm9wdGlvbnMuY3Vyc29yTWFya2VyPzE6MH0pLHRoaXMuX3NldFBhbmUodGhpcy5fc3RhcnRNYXJrZXIsXCJ2ZXJ0ZXhQYW5lXCIpLHRoaXMuX3N0YXJ0TWFya2VyLl9wbVRlbXBMYXllcj0hMCx0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX3N0YXJ0TWFya2VyKSx0aGlzLl9oaW50TWFya2VyPUwubWFya2VyKFswLDBdLHt6SW5kZXhPZmZzZXQ6MTUwLGljb246TC5kaXZJY29uKHtjbGFzc05hbWU6XCJtYXJrZXItaWNvbiBjdXJzb3ItbWFya2VyXCJ9KX0pLHRoaXMuX3NldFBhbmUodGhpcy5faGludE1hcmtlcixcInZlcnRleFBhbmVcIiksdGhpcy5faGludE1hcmtlci5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5fbGF5ZXJHcm91cC5hZGRMYXllcih0aGlzLl9oaW50TWFya2VyKSx0aGlzLm9wdGlvbnMudG9vbHRpcHMmJnRoaXMuX2hpbnRNYXJrZXIuYmluZFRvb2x0aXAoSShcInRvb2x0aXBzLmZpcnN0VmVydGV4XCIpLHtwZXJtYW5lbnQ6ITAsb2Zmc2V0OkwucG9pbnQoMCwxMCksZGlyZWN0aW9uOlwiYm90dG9tXCIsb3BhY2l0eTouOH0pLm9wZW5Ub29sdGlwKCksdGhpcy5vcHRpb25zLmN1cnNvck1hcmtlcil7TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2hpbnRNYXJrZXIuX2ljb24sXCJ2aXNpYmxlXCIpLHRoaXMuX3N0eWxlTWFya2Vycz1bXTtmb3IodmFyIGU9MDtlPDI7ZSs9MSl7dmFyIGk9TC5tYXJrZXIoWzAsMF0se2ljb246TC5kaXZJY29uKHtjbGFzc05hbWU6XCJtYXJrZXItaWNvbiByZWN0LXN0eWxlLW1hcmtlclwifSksZHJhZ2dhYmxlOiExLHpJbmRleE9mZnNldDoxMDB9KTt0aGlzLl9zZXRQYW5lKGksXCJ2ZXJ0ZXhQYW5lXCIpLGkuX3BtVGVtcExheWVyPSEwLHRoaXMuX2xheWVyR3JvdXAuYWRkTGF5ZXIoaSksdGhpcy5fc3R5bGVNYXJrZXJzLnB1c2goaSl9fXRoaXMuX21hcC5fY29udGFpbmVyLnN0eWxlLmN1cnNvcj1cImNyb3NzaGFpclwiLHRoaXMuX21hcC5vbihcImNsaWNrXCIsdGhpcy5fcGxhY2VTdGFydGluZ01hcmtlcnMsdGhpcyksdGhpcy5fbWFwLm9uKFwibW91c2Vtb3ZlXCIsdGhpcy5fc3luY0hpbnRNYXJrZXIsdGhpcyksdGhpcy5fbWFwLnBtLlRvb2xiYXIudG9nZ2xlQnV0dG9uKHRoaXMudG9vbGJhckJ1dHRvbk5hbWUsITApLHRoaXMuX290aGVyU25hcExheWVycz1bXSx0aGlzLl9maXJlRHJhd1N0YXJ0KCksdGhpcy5fc2V0R2xvYmFsRHJhd01vZGUoKX0sZGlzYWJsZTpmdW5jdGlvbigpe3RoaXMuX2VuYWJsZWQmJih0aGlzLl9lbmFibGVkPSExLHRoaXMuX21hcC5fY29udGFpbmVyLnN0eWxlLmN1cnNvcj1cIlwiLHRoaXMuX21hcC5vZmYoXCJjbGlja1wiLHRoaXMuX2ZpbmlzaFNoYXBlLHRoaXMpLHRoaXMuX21hcC5vZmYoXCJjbGlja1wiLHRoaXMuX3BsYWNlU3RhcnRpbmdNYXJrZXJzLHRoaXMpLHRoaXMuX21hcC5vZmYoXCJtb3VzZW1vdmVcIix0aGlzLl9zeW5jSGludE1hcmtlcix0aGlzKSx0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJHcm91cCksdGhpcy5fbWFwLnBtLlRvb2xiYXIudG9nZ2xlQnV0dG9uKHRoaXMudG9vbGJhckJ1dHRvbk5hbWUsITEpLHRoaXMub3B0aW9ucy5zbmFwcGFibGUmJnRoaXMuX2NsZWFudXBTbmFwcGluZygpLHRoaXMuX2ZpcmVEcmF3RW5kKCksdGhpcy5fc2V0R2xvYmFsRHJhd01vZGUoKSl9LGVuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZW5hYmxlZH0sdG9nZ2xlOmZ1bmN0aW9uKHQpe3RoaXMuZW5hYmxlZCgpP3RoaXMuZGlzYWJsZSgpOnRoaXMuZW5hYmxlKHQpfSxfcGxhY2VTdGFydGluZ01hcmtlcnM6ZnVuY3Rpb24odCl7dGhpcy5faGludE1hcmtlci5fc25hcHBlZHx8dGhpcy5faGludE1hcmtlci5zZXRMYXRMbmcodC5sYXRsbmcpO3ZhciBlPXRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCk7TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3N0YXJ0TWFya2VyLl9pY29uLFwidmlzaWJsZVwiKSx0aGlzLl9zdGFydE1hcmtlci5zZXRMYXRMbmcoZSksdGhpcy5vcHRpb25zLmN1cnNvck1hcmtlciYmdGhpcy5fc3R5bGVNYXJrZXJzJiZ0aGlzLl9zdHlsZU1hcmtlcnMuZm9yRWFjaCgoZnVuY3Rpb24odCl7TC5Eb21VdGlsLmFkZENsYXNzKHQuX2ljb24sXCJ2aXNpYmxlXCIpLHQuc2V0TGF0TG5nKGUpfSkpLHRoaXMuX21hcC5vZmYoXCJjbGlja1wiLHRoaXMuX3BsYWNlU3RhcnRpbmdNYXJrZXJzLHRoaXMpLHRoaXMuX21hcC5vbihcImNsaWNrXCIsdGhpcy5fZmluaXNoU2hhcGUsdGhpcyksdGhpcy5faGludE1hcmtlci5zZXRUb29sdGlwQ29udGVudChJKFwidG9vbHRpcHMuZmluaXNoUmVjdFwiKSksdGhpcy5fc2V0UmVjdGFuZ2xlT3JpZ2luKCl9LF9zZXRSZWN0YW5nbGVPcmlnaW46ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9zdGFydE1hcmtlci5nZXRMYXRMbmcoKTt0JiYodGhpcy5fbGF5ZXJHcm91cC5hZGRMYXllcih0aGlzLl9sYXllciksdGhpcy5fbGF5ZXIuc2V0TGF0TG5ncyhbdCx0XSksdGhpcy5faGludE1hcmtlci5vbihcIm1vdmVcIix0aGlzLl9zeW5jUmVjdGFuZ2xlU2l6ZSx0aGlzKSl9LF9zeW5jSGludE1hcmtlcjpmdW5jdGlvbih0KXtpZih0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyh0LmxhdGxuZyksdGhpcy5vcHRpb25zLnNuYXBwYWJsZSl7dmFyIGU9dDtlLnRhcmdldD10aGlzLl9oaW50TWFya2VyLHRoaXMuX2hhbmRsZVNuYXBwaW5nKGUpfXZhciBpPXRoaXMuX2xheWVyR3JvdXAmJnRoaXMuX2xheWVyR3JvdXAuaGFzTGF5ZXIodGhpcy5fbGF5ZXIpP3RoaXMuX2xheWVyLmdldExhdExuZ3MoKTpbdGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKV07dGhpcy5fZmlyZUNoYW5nZShpLFwiRHJhd1wiKX0sX3N5bmNSZWN0YW5nbGVTaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPUYodGhpcy5fc3RhcnRNYXJrZXIuZ2V0TGF0TG5nKCksdGhpcy5fbWFwKSxpPUYodGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKSx0aGlzLl9tYXApLG49TC5QTS5VdGlscy5fZ2V0Um90YXRlZFJlY3RhbmdsZShlLGksdGhpcy5vcHRpb25zLnJlY3RhbmdsZUFuZ2xlfHwwLHRoaXMuX21hcCk7aWYodGhpcy5fbGF5ZXIuc2V0TGF0TG5ncyhuKSx0aGlzLm9wdGlvbnMuY3Vyc29yTWFya2VyJiZ0aGlzLl9zdHlsZU1hcmtlcnMpe3ZhciByPVtdO24uZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5lcXVhbHMoZSwxZS04KXx8dC5lcXVhbHMoaSwxZS04KXx8ci5wdXNoKHQpfSkpLHIuZm9yRWFjaCgoZnVuY3Rpb24oZSxpKXt0cnl7dC5fc3R5bGVNYXJrZXJzW2ldLnNldExhdExuZyhlKX1jYXRjaChuKXt9fSkpfX0sX2ZpbmRDb3JuZXJzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbGF5ZXIuZ2V0Qm91bmRzKCk7cmV0dXJuW3QuZ2V0Tm9ydGhXZXN0KCksdC5nZXROb3J0aEVhc3QoKSx0LmdldFNvdXRoRWFzdCgpLHQuZ2V0U291dGhXZXN0KCldfSxfZmluaXNoU2hhcGU6ZnVuY3Rpb24odCl7dGhpcy5faGludE1hcmtlci5fc25hcHBlZHx8dGhpcy5faGludE1hcmtlci5zZXRMYXRMbmcodC5sYXRsbmcpO3ZhciBlPXRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCksaT10aGlzLl9zdGFydE1hcmtlci5nZXRMYXRMbmcoKTtpZighdGhpcy5vcHRpb25zLnJlcXVpcmVTbmFwVG9GaW5pc2h8fHRoaXMuX2hpbnRNYXJrZXIuX3NuYXBwZWR8fHRoaXMuX2lzRmlyc3RMYXllcigpKXt2YXIgbj1MLnJlY3RhbmdsZShbaSxlXSx0aGlzLm9wdGlvbnMucGF0aE9wdGlvbnMpO2lmKHRoaXMub3B0aW9ucy5yZWN0YW5nbGVBbmdsZSl7dmFyIHI9TC5QTS5VdGlscy5fZ2V0Um90YXRlZFJlY3RhbmdsZShpLGUsdGhpcy5vcHRpb25zLnJlY3RhbmdsZUFuZ2xlfHwwLHRoaXMuX21hcCk7bi5zZXRMYXRMbmdzKHIpLG4ucG0mJm4ucG0uX3NldEFuZ2xlKHRoaXMub3B0aW9ucy5yZWN0YW5nbGVBbmdsZXx8MCl9dGhpcy5fc2V0UGFuZShuLFwibGF5ZXJQYW5lXCIpLHRoaXMuX2ZpbmlzaExheWVyKG4pLG4uYWRkVG8odGhpcy5fbWFwLnBtLl9nZXRDb250YWluaW5nTGF5ZXIoKSksdGhpcy5fZmlyZUNyZWF0ZShuKSx0aGlzLmRpc2FibGUoKSx0aGlzLm9wdGlvbnMuY29udGludWVEcmF3aW5nJiZ0aGlzLmVuYWJsZSgpfX19KSxhdC5DaXJjbGU9YXQuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX21hcD10LHRoaXMuX3NoYXBlPVwiQ2lyY2xlXCIsdGhpcy50b29sYmFyQnV0dG9uTmFtZT1cImRyYXdDaXJjbGVcIn0sZW5hYmxlOmZ1bmN0aW9uKHQpe0wuVXRpbC5zZXRPcHRpb25zKHRoaXMsdCksdGhpcy5vcHRpb25zLnJhZGl1cz0wLHRoaXMuX2VuYWJsZWQ9ITAsdGhpcy5fbGF5ZXJHcm91cD1uZXcgTC5MYXllckdyb3VwLHRoaXMuX2xheWVyR3JvdXAuX3BtVGVtcExheWVyPSEwLHRoaXMuX2xheWVyR3JvdXAuYWRkVG8odGhpcy5fbWFwKSx0aGlzLl9sYXllcj1MLmNpcmNsZShbMCwwXSxMdChMdCh7fSx0aGlzLm9wdGlvbnMudGVtcGxpbmVTdHlsZSkse30se3JhZGl1czowfSkpLHRoaXMuX3NldFBhbmUodGhpcy5fbGF5ZXIsXCJsYXllclBhbmVcIiksdGhpcy5fbGF5ZXIuX3BtVGVtcExheWVyPSEwLHRoaXMuX2NlbnRlck1hcmtlcj1MLm1hcmtlcihbMCwwXSx7aWNvbjpMLmRpdkljb24oe2NsYXNzTmFtZTpcIm1hcmtlci1pY29uXCJ9KSxkcmFnZ2FibGU6ITEsekluZGV4T2Zmc2V0OjEwMH0pLHRoaXMuX3NldFBhbmUodGhpcy5fY2VudGVyTWFya2VyLFwidmVydGV4UGFuZVwiKSx0aGlzLl9jZW50ZXJNYXJrZXIuX3BtVGVtcExheWVyPSEwLHRoaXMuX2hpbnRNYXJrZXI9TC5tYXJrZXIoWzAsMF0se3pJbmRleE9mZnNldDoxMTAsaWNvbjpMLmRpdkljb24oe2NsYXNzTmFtZTpcIm1hcmtlci1pY29uIGN1cnNvci1tYXJrZXJcIn0pfSksdGhpcy5fc2V0UGFuZSh0aGlzLl9oaW50TWFya2VyLFwidmVydGV4UGFuZVwiKSx0aGlzLl9oaW50TWFya2VyLl9wbVRlbXBMYXllcj0hMCx0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX2hpbnRNYXJrZXIpLHRoaXMub3B0aW9ucy5jdXJzb3JNYXJrZXImJkwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9oaW50TWFya2VyLl9pY29uLFwidmlzaWJsZVwiKSx0aGlzLm9wdGlvbnMudG9vbHRpcHMmJnRoaXMuX2hpbnRNYXJrZXIuYmluZFRvb2x0aXAoSShcInRvb2x0aXBzLnN0YXJ0Q2lyY2xlXCIpLHtwZXJtYW5lbnQ6ITAsb2Zmc2V0OkwucG9pbnQoMCwxMCksZGlyZWN0aW9uOlwiYm90dG9tXCIsb3BhY2l0eTouOH0pLm9wZW5Ub29sdGlwKCksdGhpcy5faGludGxpbmU9TC5wb2x5bGluZShbXSx0aGlzLm9wdGlvbnMuaGludGxpbmVTdHlsZSksdGhpcy5fc2V0UGFuZSh0aGlzLl9oaW50bGluZSxcImxheWVyUGFuZVwiKSx0aGlzLl9oaW50bGluZS5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5fbGF5ZXJHcm91cC5hZGRMYXllcih0aGlzLl9oaW50bGluZSksdGhpcy5fbWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yPVwiY3Jvc3NoYWlyXCIsdGhpcy5fbWFwLm9uKFwiY2xpY2tcIix0aGlzLl9wbGFjZUNlbnRlck1hcmtlcix0aGlzKSx0aGlzLl9tYXAub24oXCJtb3VzZW1vdmVcIix0aGlzLl9zeW5jSGludE1hcmtlcix0aGlzKSx0aGlzLl9tYXAucG0uVG9vbGJhci50b2dnbGVCdXR0b24odGhpcy50b29sYmFyQnV0dG9uTmFtZSwhMCksdGhpcy5fb3RoZXJTbmFwTGF5ZXJzPVtdLHRoaXMuX2ZpcmVEcmF3U3RhcnQoKSx0aGlzLl9zZXRHbG9iYWxEcmF3TW9kZSgpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7dGhpcy5fZW5hYmxlZCYmKHRoaXMuX2VuYWJsZWQ9ITEsdGhpcy5fbWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yPVwiXCIsdGhpcy5fbWFwLm9mZihcImNsaWNrXCIsdGhpcy5fZmluaXNoU2hhcGUsdGhpcyksdGhpcy5fbWFwLm9mZihcImNsaWNrXCIsdGhpcy5fcGxhY2VDZW50ZXJNYXJrZXIsdGhpcyksdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLHRoaXMuX3N5bmNIaW50TWFya2VyLHRoaXMpLHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllckdyb3VwKSx0aGlzLl9tYXAucG0uVG9vbGJhci50b2dnbGVCdXR0b24odGhpcy50b29sYmFyQnV0dG9uTmFtZSwhMSksdGhpcy5vcHRpb25zLnNuYXBwYWJsZSYmdGhpcy5fY2xlYW51cFNuYXBwaW5nKCksdGhpcy5fZmlyZURyYXdFbmQoKSx0aGlzLl9zZXRHbG9iYWxEcmF3TW9kZSgpKX0sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkfSx0b2dnbGU6ZnVuY3Rpb24odCl7dGhpcy5lbmFibGVkKCk/dGhpcy5kaXNhYmxlKCk6dGhpcy5lbmFibGUodCl9LF9zeW5jSGludExpbmU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9jZW50ZXJNYXJrZXIuZ2V0TGF0TG5nKCksZT10aGlzLl9nZXROZXdEZXN0aW5hdGlvbk9mSGludE1hcmtlcigpO3RoaXMuX2hpbnRsaW5lLnNldExhdExuZ3MoW3QsZV0pfSxfc3luY0NpcmNsZVJhZGl1czpmdW5jdGlvbigpe3ZhciB0LGU9dGhpcy5fY2VudGVyTWFya2VyLmdldExhdExuZygpLGk9dGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKTt0PXRoaXMuX21hcC5vcHRpb25zLmNycz09PUwuQ1JTLlNpbXBsZT90aGlzLl9tYXAuZGlzdGFuY2UoZSxpKTplLmRpc3RhbmNlVG8oaSksdGhpcy5vcHRpb25zLm1pblJhZGl1c0NpcmNsZSYmdDx0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlP3RoaXMuX2xheWVyLnNldFJhZGl1cyh0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlKTp0aGlzLm9wdGlvbnMubWF4UmFkaXVzQ2lyY2xlJiZ0PnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGU/dGhpcy5fbGF5ZXIuc2V0UmFkaXVzKHRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGUpOnRoaXMuX2xheWVyLnNldFJhZGl1cyh0KX0sX3N5bmNIaW50TWFya2VyOmZ1bmN0aW9uKHQpe2lmKHRoaXMuX2hpbnRNYXJrZXIuc2V0TGF0TG5nKHQubGF0bG5nKSx0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyh0aGlzLl9nZXROZXdEZXN0aW5hdGlvbk9mSGludE1hcmtlcigpKSx0aGlzLm9wdGlvbnMuc25hcHBhYmxlKXt2YXIgZT10O2UudGFyZ2V0PXRoaXMuX2hpbnRNYXJrZXIsdGhpcy5faGFuZGxlU25hcHBpbmcoZSl9dGhpcy5faGFuZGxlSGludE1hcmtlclNuYXBwaW5nKCk7dmFyIGk9dGhpcy5fbGF5ZXJHcm91cCYmdGhpcy5fbGF5ZXJHcm91cC5oYXNMYXllcih0aGlzLl9jZW50ZXJNYXJrZXIpP3RoaXMuX2NlbnRlck1hcmtlci5nZXRMYXRMbmcoKTp0aGlzLl9oaW50TWFya2VyLmdldExhdExuZygpO3RoaXMuX2ZpcmVDaGFuZ2UoaSxcIkRyYXdcIil9LF9wbGFjZUNlbnRlck1hcmtlcjpmdW5jdGlvbih0KXt0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX2xheWVyKSx0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX2NlbnRlck1hcmtlciksdGhpcy5faGludE1hcmtlci5fc25hcHBlZHx8dGhpcy5faGludE1hcmtlci5zZXRMYXRMbmcodC5sYXRsbmcpO3ZhciBlPXRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCk7dGhpcy5fbGF5ZXJHcm91cC5hZGRMYXllcih0aGlzLl9sYXllciksdGhpcy5fY2VudGVyTWFya2VyLnNldExhdExuZyhlKSx0aGlzLl9tYXAub2ZmKFwiY2xpY2tcIix0aGlzLl9wbGFjZUNlbnRlck1hcmtlcix0aGlzKSx0aGlzLl9tYXAub24oXCJjbGlja1wiLHRoaXMuX2ZpbmlzaFNoYXBlLHRoaXMpLHRoaXMuX3BsYWNlQ2lyY2xlQ2VudGVyKCl9LF9wbGFjZUNpcmNsZUNlbnRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NlbnRlck1hcmtlci5nZXRMYXRMbmcoKTt0JiYodGhpcy5fbGF5ZXIuc2V0TGF0TG5nKHQpLHRoaXMuX2hpbnRNYXJrZXIub24oXCJtb3ZlXCIsdGhpcy5fc3luY0hpbnRMaW5lLHRoaXMpLHRoaXMuX2hpbnRNYXJrZXIub24oXCJtb3ZlXCIsdGhpcy5fc3luY0NpcmNsZVJhZGl1cyx0aGlzKSx0aGlzLl9oaW50TWFya2VyLnNldFRvb2x0aXBDb250ZW50KEkoXCJ0b29sdGlwcy5maW5pc2hDaXJjbGVcIikpLHRoaXMuX2ZpcmVDZW50ZXJQbGFjZWQoKSx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldExhdExuZygpLFwiRHJhd1wiKSl9LF9maW5pc2hTaGFwZTpmdW5jdGlvbih0KXtpZighdGhpcy5vcHRpb25zLnJlcXVpcmVTbmFwVG9GaW5pc2h8fHRoaXMuX2hpbnRNYXJrZXIuX3NuYXBwZWR8fHRoaXMuX2lzRmlyc3RMYXllcigpKXt0aGlzLl9oaW50TWFya2VyLl9zbmFwcGVkfHx0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyh0LmxhdGxuZyk7dmFyIGUsaT10aGlzLl9jZW50ZXJNYXJrZXIuZ2V0TGF0TG5nKCksbj10aGlzLl9oaW50TWFya2VyLmdldExhdExuZygpO2U9dGhpcy5fbWFwLm9wdGlvbnMuY3JzPT09TC5DUlMuU2ltcGxlP3RoaXMuX21hcC5kaXN0YW5jZShpLG4pOmkuZGlzdGFuY2VUbyhuKSx0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlJiZlPHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGU/ZT10aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlOnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGUmJmU+dGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZSYmKGU9dGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZSk7dmFyIHI9THQoTHQoe30sdGhpcy5vcHRpb25zLnBhdGhPcHRpb25zKSx7fSx7cmFkaXVzOmV9KSxhPUwuY2lyY2xlKGkscik7dGhpcy5fc2V0UGFuZShhLFwibGF5ZXJQYW5lXCIpLHRoaXMuX2ZpbmlzaExheWVyKGEpLGEuYWRkVG8odGhpcy5fbWFwLnBtLl9nZXRDb250YWluaW5nTGF5ZXIoKSksYS5wbSYmYS5wbS5fdXBkYXRlSGlkZGVuUG9seUNpcmNsZSgpLHRoaXMuX2ZpcmVDcmVhdGUoYSksdGhpcy5kaXNhYmxlKCksdGhpcy5vcHRpb25zLmNvbnRpbnVlRHJhd2luZyYmdGhpcy5lbmFibGUoKX19LF9nZXROZXdEZXN0aW5hdGlvbk9mSGludE1hcmtlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NlbnRlck1hcmtlci5nZXRMYXRMbmcoKSxlPXRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCksaT10LmRpc3RhbmNlVG8oZSk7cmV0dXJuIHQuZXF1YWxzKEwubGF0TG5nKFswLDBdKSl8fCh0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlJiZpPHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGU/ZT16KHRoaXMuX21hcCx0LGUsdGhpcy5vcHRpb25zLm1pblJhZGl1c0NpcmNsZSk6dGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZSYmaT50aGlzLm9wdGlvbnMubWF4UmFkaXVzQ2lyY2xlJiYoZT16KHRoaXMuX21hcCx0LGUsdGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZSkpKSxlfSxfaGFuZGxlSGludE1hcmtlclNuYXBwaW5nOmZ1bmN0aW9uKCl7aWYodGhpcy5faGludE1hcmtlci5fc25hcHBlZCl7dmFyIHQ9dGhpcy5fY2VudGVyTWFya2VyLmdldExhdExuZygpLGU9dGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKSxpPXQuZGlzdGFuY2VUbyhlKTt0LmVxdWFscyhMLmxhdExuZyhbMCwwXSkpfHwodGhpcy5vcHRpb25zLm1pblJhZGl1c0NpcmNsZSYmaTx0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlfHx0aGlzLm9wdGlvbnMubWF4UmFkaXVzQ2lyY2xlJiZpPnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGUpJiZ0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyh0aGlzLl9oaW50TWFya2VyLl9vcmdMYXRMbmcpfXRoaXMuX2hpbnRNYXJrZXIuc2V0TGF0TG5nKHRoaXMuX2dldE5ld0Rlc3RpbmF0aW9uT2ZIaW50TWFya2VyKCkpfX0pLGF0LkNpcmNsZU1hcmtlcj1hdC5NYXJrZXIuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX21hcD10LHRoaXMuX3NoYXBlPVwiQ2lyY2xlTWFya2VyXCIsdGhpcy50b29sYmFyQnV0dG9uTmFtZT1cImRyYXdDaXJjbGVNYXJrZXJcIix0aGlzLl9sYXllcklzRHJhZ2dpbmc9ITF9LGVuYWJsZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsdCksdGhpcy5fZW5hYmxlZD0hMCx0aGlzLl9tYXAucG0uVG9vbGJhci50b2dnbGVCdXR0b24odGhpcy50b29sYmFyQnV0dG9uTmFtZSwhMCksdGhpcy5vcHRpb25zLmVkaXRhYmxlKXt2YXIgaT17fTtMLnNldE9wdGlvbnMoaSx0aGlzLm9wdGlvbnMudGVtcGxpbmVTdHlsZSksaS5yYWRpdXM9MCx0aGlzLl9sYXllckdyb3VwPW5ldyBMLkxheWVyR3JvdXAsdGhpcy5fbGF5ZXJHcm91cC5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5fbGF5ZXJHcm91cC5hZGRUbyh0aGlzLl9tYXApLHRoaXMuX2xheWVyPUwuY2lyY2xlTWFya2VyKFswLDBdLGkpLHRoaXMuX3NldFBhbmUodGhpcy5fbGF5ZXIsXCJsYXllclBhbmVcIiksdGhpcy5fbGF5ZXIuX3BtVGVtcExheWVyPSEwLHRoaXMuX2NlbnRlck1hcmtlcj1MLm1hcmtlcihbMCwwXSx7aWNvbjpMLmRpdkljb24oe2NsYXNzTmFtZTpcIm1hcmtlci1pY29uXCJ9KSxkcmFnZ2FibGU6ITEsekluZGV4T2Zmc2V0OjEwMH0pLHRoaXMuX3NldFBhbmUodGhpcy5fY2VudGVyTWFya2VyLFwidmVydGV4UGFuZVwiKSx0aGlzLl9jZW50ZXJNYXJrZXIuX3BtVGVtcExheWVyPSEwLHRoaXMuX2hpbnRNYXJrZXI9TC5tYXJrZXIoWzAsMF0se3pJbmRleE9mZnNldDoxMTAsaWNvbjpMLmRpdkljb24oe2NsYXNzTmFtZTpcIm1hcmtlci1pY29uIGN1cnNvci1tYXJrZXJcIn0pfSksdGhpcy5fc2V0UGFuZSh0aGlzLl9oaW50TWFya2VyLFwidmVydGV4UGFuZVwiKSx0aGlzLl9oaW50TWFya2VyLl9wbVRlbXBMYXllcj0hMCx0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX2hpbnRNYXJrZXIpLHRoaXMub3B0aW9ucy5jdXJzb3JNYXJrZXImJkwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9oaW50TWFya2VyLl9pY29uLFwidmlzaWJsZVwiKSx0aGlzLm9wdGlvbnMudG9vbHRpcHMmJnRoaXMuX2hpbnRNYXJrZXIuYmluZFRvb2x0aXAoSShcInRvb2x0aXBzLnN0YXJ0Q2lyY2xlXCIpLHtwZXJtYW5lbnQ6ITAsb2Zmc2V0OkwucG9pbnQoMCwxMCksZGlyZWN0aW9uOlwiYm90dG9tXCIsb3BhY2l0eTouOH0pLm9wZW5Ub29sdGlwKCksdGhpcy5faGludGxpbmU9TC5wb2x5bGluZShbXSx0aGlzLm9wdGlvbnMuaGludGxpbmVTdHlsZSksdGhpcy5fc2V0UGFuZSh0aGlzLl9oaW50bGluZSxcImxheWVyUGFuZVwiKSx0aGlzLl9oaW50bGluZS5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5fbGF5ZXJHcm91cC5hZGRMYXllcih0aGlzLl9oaW50bGluZSksdGhpcy5fbWFwLm9uKFwiY2xpY2tcIix0aGlzLl9wbGFjZUNlbnRlck1hcmtlcix0aGlzKSx0aGlzLl9tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3I9XCJjcm9zc2hhaXJcIn1lbHNlIHRoaXMuX21hcC5vbihcImNsaWNrXCIsdGhpcy5fY3JlYXRlTWFya2VyLHRoaXMpLHRoaXMuX2hpbnRNYXJrZXI9TC5jaXJjbGVNYXJrZXIoWzAsMF0sdGhpcy5vcHRpb25zLnRlbXBsaW5lU3R5bGUpLHRoaXMuX3NldFBhbmUodGhpcy5faGludE1hcmtlcixcImxheWVyUGFuZVwiKSx0aGlzLl9oaW50TWFya2VyLl9wbVRlbXBMYXllcj0hMCx0aGlzLl9oaW50TWFya2VyLmFkZFRvKHRoaXMuX21hcCksdGhpcy5fbGF5ZXI9dGhpcy5faGludE1hcmtlcix0aGlzLm9wdGlvbnMudG9vbHRpcHMmJnRoaXMuX2hpbnRNYXJrZXIuYmluZFRvb2x0aXAoSShcInRvb2x0aXBzLnBsYWNlQ2lyY2xlTWFya2VyXCIpLHtwZXJtYW5lbnQ6ITAsb2Zmc2V0OkwucG9pbnQoMCwxMCksZGlyZWN0aW9uOlwiYm90dG9tXCIsb3BhY2l0eTouOH0pLm9wZW5Ub29sdGlwKCk7dGhpcy5fbWFwLm9uKFwibW91c2Vtb3ZlXCIsdGhpcy5fc3luY0hpbnRNYXJrZXIsdGhpcyksIXRoaXMub3B0aW9ucy5lZGl0YWJsZSYmdGhpcy5vcHRpb25zLm1hcmtlckVkaXRhYmxlJiZ0aGlzLl9tYXAuZWFjaExheWVyKChmdW5jdGlvbih0KXtlLmlzUmVsZXZhbnRNYXJrZXIodCkmJnQucG0uZW5hYmxlKCl9KSksdGhpcy5fbGF5ZXIuYnJpbmdUb0JhY2soKSx0aGlzLl9maXJlRHJhd1N0YXJ0KCksdGhpcy5fc2V0R2xvYmFsRHJhd01vZGUoKX0sZGlzYWJsZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5fZW5hYmxlZCYmKHRoaXMuX2VuYWJsZWQ9ITEsdGhpcy5vcHRpb25zLmVkaXRhYmxlPyh0aGlzLl9tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3I9XCJcIix0aGlzLl9tYXAub2ZmKFwiY2xpY2tcIix0aGlzLl9maW5pc2hTaGFwZSx0aGlzKSx0aGlzLl9tYXAub2ZmKFwiY2xpY2tcIix0aGlzLl9wbGFjZUNlbnRlck1hcmtlcix0aGlzKSx0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJHcm91cCkpOih0aGlzLl9tYXAub2ZmKFwiY2xpY2tcIix0aGlzLl9jcmVhdGVNYXJrZXIsdGhpcyksdGhpcy5fbWFwLmVhY2hMYXllcigoZnVuY3Rpb24oZSl7dC5pc1JlbGV2YW50TWFya2VyKGUpJiZlLnBtLmRpc2FibGUoKX0pKSx0aGlzLl9oaW50TWFya2VyLnJlbW92ZSgpKSx0aGlzLl9tYXAub2ZmKFwibW91c2Vtb3ZlXCIsdGhpcy5fc3luY0hpbnRNYXJrZXIsdGhpcyksdGhpcy5fbWFwLnBtLlRvb2xiYXIudG9nZ2xlQnV0dG9uKHRoaXMudG9vbGJhckJ1dHRvbk5hbWUsITEpLHRoaXMub3B0aW9ucy5zbmFwcGFibGUmJnRoaXMuX2NsZWFudXBTbmFwcGluZygpLHRoaXMuX2ZpcmVEcmF3RW5kKCksdGhpcy5fc2V0R2xvYmFsRHJhd01vZGUoKSl9LF9wbGFjZUNlbnRlck1hcmtlcjpmdW5jdGlvbih0KXt0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX2xheWVyKSx0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX2NlbnRlck1hcmtlciksdGhpcy5faGludE1hcmtlci5fc25hcHBlZHx8dGhpcy5faGludE1hcmtlci5zZXRMYXRMbmcodC5sYXRsbmcpO3ZhciBlPXRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCk7dGhpcy5fbGF5ZXJHcm91cC5hZGRMYXllcih0aGlzLl9sYXllciksdGhpcy5fY2VudGVyTWFya2VyLnNldExhdExuZyhlKSx0aGlzLl9tYXAub2ZmKFwiY2xpY2tcIix0aGlzLl9wbGFjZUNlbnRlck1hcmtlcix0aGlzKSx0aGlzLl9tYXAub24oXCJjbGlja1wiLHRoaXMuX2ZpbmlzaFNoYXBlLHRoaXMpLHRoaXMuX3BsYWNlQ2lyY2xlQ2VudGVyKCl9LF9wbGFjZUNpcmNsZUNlbnRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NlbnRlck1hcmtlci5nZXRMYXRMbmcoKTt0JiYodGhpcy5fbGF5ZXIuc2V0TGF0TG5nKHQpLHRoaXMuX2hpbnRNYXJrZXIub24oXCJtb3ZlXCIsdGhpcy5fc3luY0hpbnRMaW5lLHRoaXMpLHRoaXMuX2hpbnRNYXJrZXIub24oXCJtb3ZlXCIsdGhpcy5fc3luY0NpcmNsZVJhZGl1cyx0aGlzKSx0aGlzLl9oaW50TWFya2VyLnNldFRvb2x0aXBDb250ZW50KEkoXCJ0b29sdGlwcy5maW5pc2hDaXJjbGVcIikpLHRoaXMuX2ZpcmVDZW50ZXJQbGFjZWQoKSx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldExhdExuZygpLFwiRHJhd1wiKSl9LF9zeW5jSGludExpbmU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9jZW50ZXJNYXJrZXIuZ2V0TGF0TG5nKCksZT10aGlzLl9nZXROZXdEZXN0aW5hdGlvbk9mSGludE1hcmtlcigpO3RoaXMuX2hpbnRsaW5lLnNldExhdExuZ3MoW3QsZV0pfSxfc3luY0NpcmNsZVJhZGl1czpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NlbnRlck1hcmtlci5nZXRMYXRMbmcoKSxlPXRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCksaT10aGlzLl9tYXAucHJvamVjdCh0KS5kaXN0YW5jZVRvKHRoaXMuX21hcC5wcm9qZWN0KGUpKTt0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlTWFya2VyJiZpPHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGVNYXJrZXI/dGhpcy5fbGF5ZXIuc2V0UmFkaXVzKHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGVNYXJrZXIpOnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGVNYXJrZXImJmk+dGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZU1hcmtlcj90aGlzLl9sYXllci5zZXRSYWRpdXModGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZU1hcmtlcik6dGhpcy5fbGF5ZXIuc2V0UmFkaXVzKGkpfSxfc3luY0hpbnRNYXJrZXI6ZnVuY3Rpb24odCl7aWYodGhpcy5faGludE1hcmtlci5zZXRMYXRMbmcodC5sYXRsbmcpLHRoaXMuX2hpbnRNYXJrZXIuc2V0TGF0TG5nKHRoaXMuX2dldE5ld0Rlc3RpbmF0aW9uT2ZIaW50TWFya2VyKCkpLHRoaXMub3B0aW9ucy5zbmFwcGFibGUpe3ZhciBlPXQ7ZS50YXJnZXQ9dGhpcy5faGludE1hcmtlcix0aGlzLl9oYW5kbGVTbmFwcGluZyhlKX10aGlzLl9oYW5kbGVIaW50TWFya2VyU25hcHBpbmcoKTt2YXIgaT10aGlzLl9sYXllckdyb3VwJiZ0aGlzLl9sYXllckdyb3VwLmhhc0xheWVyKHRoaXMuX2NlbnRlck1hcmtlcik/dGhpcy5fY2VudGVyTWFya2VyLmdldExhdExuZygpOnRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCk7dGhpcy5fZmlyZUNoYW5nZShpLFwiRHJhd1wiKX0saXNSZWxldmFudE1hcmtlcjpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyJiYhKHQgaW5zdGFuY2VvZiBMLkNpcmNsZSkmJnQucG0mJiF0Ll9wbVRlbXBMYXllcn0sX2NyZWF0ZU1hcmtlcjpmdW5jdGlvbih0KXtpZigoIXRoaXMub3B0aW9ucy5yZXF1aXJlU25hcFRvRmluaXNofHx0aGlzLl9oaW50TWFya2VyLl9zbmFwcGVkfHx0aGlzLl9pc0ZpcnN0TGF5ZXIoKSkmJnQubGF0bG5nJiYhdGhpcy5fbGF5ZXJJc0RyYWdnaW5nKXt0aGlzLl9oaW50TWFya2VyLl9zbmFwcGVkfHx0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyh0LmxhdGxuZyk7dmFyIGU9dGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKSxpPUwuY2lyY2xlTWFya2VyKGUsdGhpcy5vcHRpb25zLnBhdGhPcHRpb25zKTt0aGlzLl9zZXRQYW5lKGksXCJsYXllclBhbmVcIiksdGhpcy5fZmluaXNoTGF5ZXIoaSksaS5hZGRUbyh0aGlzLl9tYXAucG0uX2dldENvbnRhaW5pbmdMYXllcigpKSxpLnBtJiZ0aGlzLm9wdGlvbnMubWFya2VyRWRpdGFibGUmJmkucG0uZW5hYmxlKCksdGhpcy5fZmlyZUNyZWF0ZShpKSx0aGlzLl9jbGVhbnVwU25hcHBpbmcoKSx0aGlzLm9wdGlvbnMuY29udGludWVEcmF3aW5nfHx0aGlzLmRpc2FibGUoKX19LF9maW5pc2hTaGFwZTpmdW5jdGlvbih0KXtpZighdGhpcy5vcHRpb25zLnJlcXVpcmVTbmFwVG9GaW5pc2h8fHRoaXMuX2hpbnRNYXJrZXIuX3NuYXBwZWR8fHRoaXMuX2lzRmlyc3RMYXllcigpKXt0aGlzLl9oaW50TWFya2VyLl9zbmFwcGVkfHx0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyh0LmxhdGxuZyk7dmFyIGU9dGhpcy5fY2VudGVyTWFya2VyLmdldExhdExuZygpLGk9dGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKSxuPXRoaXMuX21hcC5wcm9qZWN0KGUpLmRpc3RhbmNlVG8odGhpcy5fbWFwLnByb2plY3QoaSkpO3RoaXMub3B0aW9ucy5lZGl0YWJsZSYmKHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGVNYXJrZXImJm48dGhpcy5vcHRpb25zLm1pblJhZGl1c0NpcmNsZU1hcmtlcj9uPXRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGVNYXJrZXI6dGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZU1hcmtlciYmbj50aGlzLm9wdGlvbnMubWF4UmFkaXVzQ2lyY2xlTWFya2VyJiYobj10aGlzLm9wdGlvbnMubWF4UmFkaXVzQ2lyY2xlTWFya2VyKSk7dmFyIHI9TXQoTXQoe30sdGhpcy5vcHRpb25zLnBhdGhPcHRpb25zKSx7fSx7cmFkaXVzOm59KSxhPUwuY2lyY2xlTWFya2VyKGUscik7dGhpcy5fc2V0UGFuZShhLFwibGF5ZXJQYW5lXCIpLHRoaXMuX2ZpbmlzaExheWVyKGEpLGEuYWRkVG8odGhpcy5fbWFwLnBtLl9nZXRDb250YWluaW5nTGF5ZXIoKSksYS5wbSYmYS5wbS5fdXBkYXRlSGlkZGVuUG9seUNpcmNsZSgpLHRoaXMuX2ZpcmVDcmVhdGUoYSksdGhpcy5kaXNhYmxlKCksdGhpcy5vcHRpb25zLmNvbnRpbnVlRHJhd2luZyYmdGhpcy5lbmFibGUoKX19LF9nZXROZXdEZXN0aW5hdGlvbk9mSGludE1hcmtlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCk7aWYodGhpcy5vcHRpb25zLmVkaXRhYmxlKXt2YXIgZT10aGlzLl9jZW50ZXJNYXJrZXIuZ2V0TGF0TG5nKCk7aWYoZS5lcXVhbHMoTC5sYXRMbmcoWzAsMF0pKSlyZXR1cm4gdDt2YXIgaT10aGlzLl9tYXAucHJvamVjdChlKS5kaXN0YW5jZVRvKHRoaXMuX21hcC5wcm9qZWN0KHQpKTt0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlTWFya2VyJiZpPHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGVNYXJrZXI/dD16KHRoaXMuX21hcCxlLHQsdGhpcy5fcHhSYWRpdXNUb01ldGVyKHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGVNYXJrZXIpKTp0aGlzLm9wdGlvbnMubWF4UmFkaXVzQ2lyY2xlTWFya2VyJiZpPnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGVNYXJrZXImJih0PXoodGhpcy5fbWFwLGUsdCx0aGlzLl9weFJhZGl1c1RvTWV0ZXIodGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZU1hcmtlcikpKX1yZXR1cm4gdH0sX2hhbmRsZUhpbnRNYXJrZXJTbmFwcGluZzpmdW5jdGlvbigpe2lmKHRoaXMub3B0aW9ucy5lZGl0YWJsZSl7aWYodGhpcy5faGludE1hcmtlci5fc25hcHBlZCl7dmFyIHQ9dGhpcy5fY2VudGVyTWFya2VyLmdldExhdExuZygpLGU9dGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKSxpPXRoaXMuX21hcC5wcm9qZWN0KHQpLmRpc3RhbmNlVG8odGhpcy5fbWFwLnByb2plY3QoZSkpOyh0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlTWFya2VyJiZpPHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGVNYXJrZXJ8fHRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGVNYXJrZXImJmk+dGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZU1hcmtlcikmJnRoaXMuX2hpbnRNYXJrZXIuc2V0TGF0TG5nKHRoaXMuX2hpbnRNYXJrZXIuX29yZ0xhdExuZyl9dGhpcy5faGludE1hcmtlci5zZXRMYXRMbmcodGhpcy5fZ2V0TmV3RGVzdGluYXRpb25PZkhpbnRNYXJrZXIoKSl9fSxfcHhSYWRpdXNUb01ldGVyOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2NlbnRlck1hcmtlci5nZXRMYXRMbmcoKSxpPXRoaXMuX21hcC5wcm9qZWN0KGUpLG49TC5wb2ludChpLngrdCxpLnkpO3JldHVybiB0aGlzLl9tYXAudW5wcm9qZWN0KG4pLmRpc3RhbmNlVG8oZSl9fSk7Y29uc3QgQnQ9ZnVuY3Rpb24odCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyByZXF1aXJlZFwiKTt2YXIgZT1bXTtyZXR1cm4gUnQodCwoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSl7dmFyIGk9W10sbj10Lmdlb21ldHJ5O2lmKG51bGwhPT1uKXtzd2l0Y2gobi50eXBlKXtjYXNlXCJQb2x5Z29uXCI6aT1DdChuKTticmVhaztjYXNlXCJMaW5lU3RyaW5nXCI6aT1bQ3QobildfWkuZm9yRWFjaCgoZnVuY3Rpb24oaSl7dmFyIG49ZnVuY3Rpb24odCxlKXt2YXIgaT1bXTtyZXR1cm4gdC5yZWR1Y2UoKGZ1bmN0aW9uKHQsbil7dmFyIHIsYSxvLHMsbCxoLHU9dXQoW3Qsbl0sZSk7cmV0dXJuIHUuYmJveD0oYT1uLG89KHI9dClbMF0scz1yWzFdLGw9YVswXSxoPWFbMV0sW288bD9vOmwsczxoP3M6aCxvPmw/bzpsLHM+aD9zOmhdKSxpLnB1c2godSksbn0pKSxpfShpLHQucHJvcGVydGllcyk7bi5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmlkPWUubGVuZ3RoLGUucHVzaCh0KX0pKX0pKX19KHQsZSl9KSksY3QoZSl9O3ZhciBUdD1pKDE3ODcpO2Z1bmN0aW9uIEl0KHQsZSl7dmFyIGk9Q3QodCksbj1DdChlKTtpZigyIT09aS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiPGludGVyc2VjdHM+IGxpbmUxIG11c3Qgb25seSBjb250YWluIDIgY29vcmRpbmF0ZXNcIik7aWYoMiE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIjxpbnRlcnNlY3RzPiBsaW5lMiBtdXN0IG9ubHkgY29udGFpbiAyIGNvb3JkaW5hdGVzXCIpO3ZhciByPWlbMF1bMF0sYT1pWzBdWzFdLG89aVsxXVswXSxzPWlbMV1bMV0sbD1uWzBdWzBdLGg9blswXVsxXSx1PW5bMV1bMF0sYz1uWzFdWzFdLHA9KGMtaCkqKG8tciktKHUtbCkqKHMtYSksZD0odS1sKSooYS1oKS0oYy1oKSooci1sKSxmPShvLXIpKihhLWgpLShzLWEpKihyLWwpO2lmKDA9PT1wKXJldHVybiBudWxsO3ZhciBnPWQvcCxfPWYvcDtyZXR1cm4gZz49MCYmZzw9MSYmXz49MCYmXzw9MT9odChbcitnKihvLXIpLGErZyoocy1hKV0pOm51bGx9Y29uc3QganQ9ZnVuY3Rpb24odCxlKXt2YXIgaT17fSxuPVtdO2lmKFwiTGluZVN0cmluZ1wiPT09dC50eXBlJiYodD1sdCh0KSksXCJMaW5lU3RyaW5nXCI9PT1lLnR5cGUmJihlPWx0KGUpKSxcIkZlYXR1cmVcIj09PXQudHlwZSYmXCJGZWF0dXJlXCI9PT1lLnR5cGUmJm51bGwhPT10Lmdlb21ldHJ5JiZudWxsIT09ZS5nZW9tZXRyeSYmXCJMaW5lU3RyaW5nXCI9PT10Lmdlb21ldHJ5LnR5cGUmJlwiTGluZVN0cmluZ1wiPT09ZS5nZW9tZXRyeS50eXBlJiYyPT09dC5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGgmJjI9PT1lLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCl7dmFyIHI9SXQodCxlKTtyZXR1cm4gciYmbi5wdXNoKHIpLGN0KG4pfXZhciBhPVR0KCk7cmV0dXJuIGEubG9hZChCdChlKSksT3QoQnQodCksKGZ1bmN0aW9uKHQpe090KGEuc2VhcmNoKHQpLChmdW5jdGlvbihlKXt2YXIgcj1JdCh0LGUpO2lmKHIpe3ZhciBhPUN0KHIpLmpvaW4oXCIsXCIpO2lbYV18fChpW2FdPSEwLG4ucHVzaChyKSl9fSkpfSkpLGN0KG4pfTtjb25zdCBBdD1mdW5jdGlvbih0LGUsaSl7dm9pZCAwPT09aSYmKGk9e30pO3ZhciBuPXd0KHQpLHI9d3QoZSksYT1ndChyWzFdLW5bMV0pLG89Z3QoclswXS1uWzBdKSxzPWd0KG5bMV0pLGw9Z3QoclsxXSksaD1NYXRoLnBvdyhNYXRoLnNpbihhLzIpLDIpK01hdGgucG93KE1hdGguc2luKG8vMiksMikqTWF0aC5jb3MocykqTWF0aC5jb3MobCk7cmV0dXJuIHB0KDIqTWF0aC5hdGFuMihNYXRoLnNxcnQoaCksTWF0aC5zcXJ0KDEtaCkpLGkudW5pdHMpfTtjb25zdCBHdD1mdW5jdGlvbih0KXt2YXIgZT10WzBdLGk9dFsxXSxuPXRbMl0scj10WzNdO2lmKEF0KHQuc2xpY2UoMCwyKSxbbixpXSk+PUF0KHQuc2xpY2UoMCwyKSxbZSxyXSkpe3ZhciBhPShpK3IpLzI7cmV0dXJuW2UsYS0obi1lKS8yLG4sYSsobi1lKS8yXX12YXIgbz0oZStuKS8yO3JldHVybltvLShyLWkpLzIsaSxvKyhyLWkpLzIscl19O2Z1bmN0aW9uIE50KHQpe3ZhciBlPVtJbmZpbml0eSxJbmZpbml0eSwtSW5maW5pdHksLUluZmluaXR5XTtyZXR1cm4gU3QodCwoZnVuY3Rpb24odCl7ZVswXT50WzBdJiYoZVswXT10WzBdKSxlWzFdPnRbMV0mJihlWzFdPXRbMV0pLGVbMl08dFswXSYmKGVbMl09dFswXSksZVszXTx0WzFdJiYoZVszXT10WzFdKX0pKSxlfU50W1wiZGVmYXVsdFwiXT1OdDtjb25zdCB6dD1OdDtjb25zdCBVdD1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgaT1lLnByZWNpc2lvbixuPWUuY29vcmRpbmF0ZXMscj1lLm11dGF0ZTtpZihpPWk9PT11bmRlZmluZWR8fG51bGw9PT1pfHxpc05hTihpKT82Omksbj1uPT09dW5kZWZpbmVkfHxudWxsPT09bnx8aXNOYU4obik/MzpuLCF0KXRocm93IG5ldyBFcnJvcihcIjxnZW9qc29uPiBpcyByZXF1aXJlZFwiKTtpZihcIm51bWJlclwiIT10eXBlb2YgaSl0aHJvdyBuZXcgRXJyb3IoXCI8cHJlY2lzaW9uPiBtdXN0IGJlIGEgbnVtYmVyXCIpO2lmKFwibnVtYmVyXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcIjxjb29yZGluYXRlcz4gbXVzdCBiZSBhIG51bWJlclwiKTshMSE9PXImJnIhPT11bmRlZmluZWR8fCh0PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpKTt2YXIgYT1NYXRoLnBvdygxMCxpKTtyZXR1cm4gU3QodCwoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxpKXt0Lmxlbmd0aD5pJiZ0LnNwbGljZShpLHQubGVuZ3RoKTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl0W25dPU1hdGgucm91bmQodFtuXSplKS9lfSh0LGEsbil9KSksdH07ZnVuY3Rpb24gRnQodCxlLGkpe2lmKHZvaWQgMD09PWkmJihpPXt9KSwhMD09PWkuZmluYWwpcmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIGk9RnQoZSx0KTtyZXR1cm4gaT0oaSsxODApJTM2MH0odCxlKTt2YXIgbj13dCh0KSxyPXd0KGUpLGE9Z3QoblswXSksbz1ndChyWzBdKSxzPWd0KG5bMV0pLGw9Z3QoclsxXSksaD1NYXRoLnNpbihvLWEpKk1hdGguY29zKGwpLHU9TWF0aC5jb3MocykqTWF0aC5zaW4obCktTWF0aC5zaW4ocykqTWF0aC5jb3MobCkqTWF0aC5jb3Moby1hKTtyZXR1cm4gZnQoTWF0aC5hdGFuMihoLHUpKX1mdW5jdGlvbiBWdCh0LGUsaSxuKXt2b2lkIDA9PT1uJiYobj17fSk7dmFyIHI9d3QodCksYT1ndChyWzBdKSxvPWd0KHJbMV0pLHM9Z3QoaSksbD1kdChlLG4udW5pdHMpLGg9TWF0aC5hc2luKE1hdGguc2luKG8pKk1hdGguY29zKGwpK01hdGguY29zKG8pKk1hdGguc2luKGwpKk1hdGguY29zKHMpKTtyZXR1cm4gaHQoW2Z0KGErTWF0aC5hdGFuMihNYXRoLnNpbihzKSpNYXRoLnNpbihsKSpNYXRoLmNvcyhvKSxNYXRoLmNvcyhsKS1NYXRoLnNpbihvKSpNYXRoLnNpbihoKSkpLGZ0KGgpXSxuLnByb3BlcnRpZXMpfWNvbnN0IEt0PWZ1bmN0aW9uKHQsZSxpKXt2b2lkIDA9PT1pJiYoaT17fSk7dmFyIG49aHQoW0luZmluaXR5LEluZmluaXR5XSx7ZGlzdDpJbmZpbml0eX0pLHI9MDtyZXR1cm4gUnQodCwoZnVuY3Rpb24odCl7Zm9yKHZhciBhPUN0KHQpLG89MDtvPGEubGVuZ3RoLTE7bysrKXt2YXIgcz1odChhW29dKTtzLnByb3BlcnRpZXMuZGlzdD1BdChlLHMsaSk7dmFyIGw9aHQoYVtvKzFdKTtsLnByb3BlcnRpZXMuZGlzdD1BdChlLGwsaSk7dmFyIGg9QXQocyxsLGkpLHU9TWF0aC5tYXgocy5wcm9wZXJ0aWVzLmRpc3QsbC5wcm9wZXJ0aWVzLmRpc3QpLGM9RnQocyxsKSxwPVZ0KGUsdSxjKzkwLGkpLGQ9VnQoZSx1LGMtOTAsaSksZj1qdCh1dChbcC5nZW9tZXRyeS5jb29yZGluYXRlcyxkLmdlb21ldHJ5LmNvb3JkaW5hdGVzXSksdXQoW3MuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsbC5nZW9tZXRyeS5jb29yZGluYXRlc10pKSxnPW51bGw7Zi5mZWF0dXJlcy5sZW5ndGg+MCYmKChnPWYuZmVhdHVyZXNbMF0pLnByb3BlcnRpZXMuZGlzdD1BdChlLGcsaSksZy5wcm9wZXJ0aWVzLmxvY2F0aW9uPXIrQXQocyxnLGkpKSxzLnByb3BlcnRpZXMuZGlzdDxuLnByb3BlcnRpZXMuZGlzdCYmKChuPXMpLnByb3BlcnRpZXMuaW5kZXg9byxuLnByb3BlcnRpZXMubG9jYXRpb249ciksbC5wcm9wZXJ0aWVzLmRpc3Q8bi5wcm9wZXJ0aWVzLmRpc3QmJigobj1sKS5wcm9wZXJ0aWVzLmluZGV4PW8rMSxuLnByb3BlcnRpZXMubG9jYXRpb249citoKSxnJiZnLnByb3BlcnRpZXMuZGlzdDxuLnByb3BlcnRpZXMuZGlzdCYmKChuPWcpLnByb3BlcnRpZXMuaW5kZXg9bykscis9aH19KSksbn07ZnVuY3Rpb24gSHQodCxlKXt2YXIgaT1bXSxuPVR0KCk7cmV0dXJuIFJ0KGUsKGZ1bmN0aW9uKGUpe2lmKGkuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXt0LmlkPWV9KSksaS5sZW5ndGgpe3ZhciByPW4uc2VhcmNoKGUpO2lmKHIuZmVhdHVyZXMubGVuZ3RoKXt2YXIgYT1KdChlLHIpO2k9aS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkIT09YS5pZH0pKSxuLnJlbW92ZShhKSxPdChxdChhLGUpLChmdW5jdGlvbih0KXtpLnB1c2godCksbi5pbnNlcnQodCl9KSl9fWVsc2UoaT1xdCh0LGUpLmZlYXR1cmVzKS5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmJib3h8fCh0LmJib3g9R3QoenQodCkpKX0pKSxuLmxvYWQoY3QoaSkpfSkpLGN0KGkpfWZ1bmN0aW9uIHF0KHQsZSl7dmFyIGk9W10sbj1DdCh0KVswXSxyPUN0KHQpW3QuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoLTFdO2lmKFl0KG4sd3QoZSkpfHxZdChyLHd0KGUpKSlyZXR1cm4gY3QoW3RdKTt2YXIgYT1UdCgpLG89QnQodCk7YS5sb2FkKG8pO3ZhciBzPWEuc2VhcmNoKGUpO2lmKCFzLmZlYXR1cmVzLmxlbmd0aClyZXR1cm4gY3QoW3RdKTt2YXIgbD1KdChlLHMpLGg9ZnVuY3Rpb24odCxlLGkpe3ZhciBuPWk7cmV0dXJuIE90KHQsKGZ1bmN0aW9uKHQscil7bj0wPT09ciYmaT09PXVuZGVmaW5lZD90OmUobix0LHIpfSkpLG59KG8sKGZ1bmN0aW9uKHQsbixyKXt2YXIgYT1DdChuKVsxXSxvPXd0KGUpO3JldHVybiByPT09bC5pZD8odC5wdXNoKG8pLGkucHVzaCh1dCh0KSksWXQobyxhKT9bb106W28sYV0pOih0LnB1c2goYSksdCl9KSxbbl0pO3JldHVybiBoLmxlbmd0aD4xJiZpLnB1c2godXQoaCkpLGN0KGkpfWZ1bmN0aW9uIEp0KHQsZSl7aWYoIWUuZmVhdHVyZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImxpbmVzIG11c3QgY29udGFpbiBmZWF0dXJlc1wiKTtpZigxPT09ZS5mZWF0dXJlcy5sZW5ndGgpcmV0dXJuIGUuZmVhdHVyZXNbMF07dmFyIGksbj1JbmZpbml0eTtyZXR1cm4gT3QoZSwoZnVuY3Rpb24oZSl7dmFyIHI9S3QoZSx0KS5wcm9wZXJ0aWVzLmRpc3Q7cjxuJiYoaT1lLG49cil9KSksaX1mdW5jdGlvbiBZdCh0LGUpe3JldHVybiB0WzBdPT09ZVswXSYmdFsxXT09PWVbMV19Y29uc3QgWHQ9ZnVuY3Rpb24odCxlKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJsaW5lIGlzIHJlcXVpcmVkXCIpO2lmKCFlKXRocm93IG5ldyBFcnJvcihcInNwbGl0dGVyIGlzIHJlcXVpcmVkXCIpO3ZhciBpPUV0KHQpLG49RXQoZSk7aWYoXCJMaW5lU3RyaW5nXCIhPT1pKXRocm93IG5ldyBFcnJvcihcImxpbmUgbXVzdCBiZSBMaW5lU3RyaW5nXCIpO2lmKFwiRmVhdHVyZUNvbGxlY3Rpb25cIj09PW4pdGhyb3cgbmV3IEVycm9yKFwic3BsaXR0ZXIgY2Fubm90IGJlIGEgRmVhdHVyZUNvbGxlY3Rpb25cIik7aWYoXCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PW4pdGhyb3cgbmV3IEVycm9yKFwic3BsaXR0ZXIgY2Fubm90IGJlIGEgR2VvbWV0cnlDb2xsZWN0aW9uXCIpO3ZhciByPVV0KGUse3ByZWNpc2lvbjo3fSk7c3dpdGNoKG4pe2Nhc2VcIlBvaW50XCI6cmV0dXJuIHF0KHQscik7Y2FzZVwiTXVsdGlQb2ludFwiOnJldHVybiBIdCh0LHIpO2Nhc2VcIkxpbmVTdHJpbmdcIjpjYXNlXCJNdWx0aUxpbmVTdHJpbmdcIjpjYXNlXCJQb2x5Z29uXCI6Y2FzZVwiTXVsdGlQb2x5Z29uXCI6cmV0dXJuIEh0KHQsanQodCxyKSl9fTtmdW5jdGlvbiBadCh0LGUsaSl7aWYodm9pZCAwPT09aSYmKGk9e30pLCF0KXRocm93IG5ldyBFcnJvcihcInBvaW50IGlzIHJlcXVpcmVkXCIpO2lmKCFlKXRocm93IG5ldyBFcnJvcihcInBvbHlnb24gaXMgcmVxdWlyZWRcIik7dmFyIG49d3QodCkscj1QdChlKSxhPXIudHlwZSxvPWUuYmJveCxzPXIuY29vcmRpbmF0ZXM7aWYobyYmITE9PT1mdW5jdGlvbih0LGUpe3JldHVybiBlWzBdPD10WzBdJiZlWzFdPD10WzFdJiZlWzJdPj10WzBdJiZlWzNdPj10WzFdfShuLG8pKXJldHVybiExO1wiUG9seWdvblwiPT09YSYmKHM9W3NdKTtmb3IodmFyIGw9ITEsaD0wO2g8cy5sZW5ndGgmJiFsO2grKylpZigkdChuLHNbaF1bMF0saS5pZ25vcmVCb3VuZGFyeSkpe2Zvcih2YXIgdT0hMSxjPTE7YzxzW2hdLmxlbmd0aCYmIXU7KSR0KG4sc1toXVtjXSwhaS5pZ25vcmVCb3VuZGFyeSkmJih1PSEwKSxjKys7dXx8KGw9ITApfXJldHVybiBsfWZ1bmN0aW9uICR0KHQsZSxpKXt2YXIgbj0hMTtlWzBdWzBdPT09ZVtlLmxlbmd0aC0xXVswXSYmZVswXVsxXT09PWVbZS5sZW5ndGgtMV1bMV0mJihlPWUuc2xpY2UoMCxlLmxlbmd0aC0xKSk7Zm9yKHZhciByPTAsYT1lLmxlbmd0aC0xO3I8ZS5sZW5ndGg7YT1yKyspe3ZhciBvPWVbcl1bMF0scz1lW3JdWzFdLGw9ZVthXVswXSxoPWVbYV1bMV07aWYodFsxXSooby1sKStzKihsLXRbMF0pK2gqKHRbMF0tbyk9PTAmJihvLXRbMF0pKihsLXRbMF0pPD0wJiYocy10WzFdKSooaC10WzFdKTw9MClyZXR1cm4haTtzPnRbMV0hPWg+dFsxXSYmdFswXTwobC1vKSoodFsxXS1zKS8oaC1zKStvJiYobj0hbil9cmV0dXJuIG59ZnVuY3Rpb24gV3QodCxlLGksbixyKXt2YXIgYT1pWzBdLG89aVsxXSxzPXRbMF0sbD10WzFdLGg9ZVswXSx1PWVbMV0sYz1oLXMscD11LWwsZD0oaVswXS1zKSpwLShpWzFdLWwpKmM7aWYobnVsbCE9PXIpe2lmKE1hdGguYWJzKGQpPnIpcmV0dXJuITF9ZWxzZSBpZigwIT09ZClyZXR1cm4hMTtyZXR1cm4gbj9cInN0YXJ0XCI9PT1uP01hdGguYWJzKGMpPj1NYXRoLmFicyhwKT9jPjA/czxhJiZhPD1oOmg8PWEmJmE8czpwPjA/bDxvJiZvPD11OnU8PW8mJm88bDpcImVuZFwiPT09bj9NYXRoLmFicyhjKT49TWF0aC5hYnMocCk/Yz4wP3M8PWEmJmE8aDpoPGEmJmE8PXM6cD4wP2w8PW8mJm88dTp1PG8mJm88PWw6XCJib3RoXCI9PT1uJiYoTWF0aC5hYnMoYyk+PU1hdGguYWJzKHApP2M+MD9zPGEmJmE8aDpoPGEmJmE8czpwPjA/bDxvJiZvPHU6dTxvJiZvPGwpOk1hdGguYWJzKGMpPj1NYXRoLmFicyhwKT9jPjA/czw9YSYmYTw9aDpoPD1hJiZhPD1zOnA+MD9sPD1vJiZvPD11OnU8PW8mJm88PWx9Y29uc3QgUXQ9ZnVuY3Rpb24odCxlLGkpe3ZvaWQgMD09PWkmJihpPXt9KTtmb3IodmFyIG49d3QodCkscj1DdChlKSxhPTA7YTxyLmxlbmd0aC0xO2ErKyl7dmFyIG89ITE7aWYoaS5pZ25vcmVFbmRWZXJ0aWNlcyYmKDA9PT1hJiYobz1cInN0YXJ0XCIpLGE9PT1yLmxlbmd0aC0yJiYobz1cImVuZFwiKSwwPT09YSYmYSsxPT09ci5sZW5ndGgtMSYmKG89XCJib3RoXCIpKSxXdChyW2FdLHJbYSsxXSxuLG8sXCJ1bmRlZmluZWRcIj09dHlwZW9mIGkuZXBzaWxvbj9udWxsOmkuZXBzaWxvbikpcmV0dXJuITB9cmV0dXJuITF9O2Z1bmN0aW9uIHRlKHQsZSl7dmFyIGk9UHQodCksbj1QdChlKSxyPWkudHlwZSxhPW4udHlwZSxvPWkuY29vcmRpbmF0ZXMscz1uLmNvb3JkaW5hdGVzO3N3aXRjaChyKXtjYXNlXCJQb2ludFwiOmlmKFwiUG9pbnRcIj09PWEpcmV0dXJuIGllKG8scyk7dGhyb3cgbmV3IEVycm9yKFwiZmVhdHVyZTIgXCIrYStcIiBnZW9tZXRyeSBub3Qgc3VwcG9ydGVkXCIpO2Nhc2VcIk11bHRpUG9pbnRcIjpzd2l0Y2goYSl7Y2FzZVwiUG9pbnRcIjpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgaSxuPSExO2ZvcihpPTA7aTx0LmNvb3JkaW5hdGVzLmxlbmd0aDtpKyspaWYoaWUodC5jb29yZGluYXRlc1tpXSxlLmNvb3JkaW5hdGVzKSl7bj0hMDticmVha31yZXR1cm4gbn0oaSxuKTtjYXNlXCJNdWx0aVBvaW50XCI6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPTAsbj1lLmNvb3JkaW5hdGVzO2k8bi5sZW5ndGg7aSsrKXtmb3IodmFyIHI9bltpXSxhPSExLG89MCxzPXQuY29vcmRpbmF0ZXM7bzxzLmxlbmd0aDtvKyspe2lmKGllKHIsc1tvXSkpe2E9ITA7YnJlYWt9fWlmKCFhKXJldHVybiExfXJldHVybiEwfShpLG4pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiZmVhdHVyZTIgXCIrYStcIiBnZW9tZXRyeSBub3Qgc3VwcG9ydGVkXCIpfWNhc2VcIkxpbmVTdHJpbmdcIjpzd2l0Y2goYSl7Y2FzZVwiUG9pbnRcIjpyZXR1cm4gUXQobixpLHtpZ25vcmVFbmRWZXJ0aWNlczohMH0pO2Nhc2VcIkxpbmVTdHJpbmdcIjpyZXR1cm4gZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9ITEsbj0wLHI9ZS5jb29yZGluYXRlcztuPHIubGVuZ3RoO24rKyl7dmFyIGE9cltuXTtpZihRdCh7dHlwZTpcIlBvaW50XCIsY29vcmRpbmF0ZXM6YX0sdCx7aWdub3JlRW5kVmVydGljZXM6ITB9KSYmKGk9ITApLCFRdCh7dHlwZTpcIlBvaW50XCIsY29vcmRpbmF0ZXM6YX0sdCx7aWdub3JlRW5kVmVydGljZXM6ITF9KSlyZXR1cm4hMX1yZXR1cm4gaX0oaSxuKTtjYXNlXCJNdWx0aVBvaW50XCI6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPSExLG49MCxyPWUuY29vcmRpbmF0ZXM7bjxyLmxlbmd0aDtuKyspe3ZhciBhPXJbbl07aWYoUXQoYSx0LHtpZ25vcmVFbmRWZXJ0aWNlczohMH0pJiYoaT0hMCksIVF0KGEsdCkpcmV0dXJuITF9aWYoaSlyZXR1cm4hMDtyZXR1cm4hMX0oaSxuKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcImZlYXR1cmUyIFwiK2ErXCIgZ2VvbWV0cnkgbm90IHN1cHBvcnRlZFwiKX1jYXNlXCJQb2x5Z29uXCI6c3dpdGNoKGEpe2Nhc2VcIlBvaW50XCI6cmV0dXJuIFp0KG4saSx7aWdub3JlQm91bmRhcnk6ITB9KTtjYXNlXCJMaW5lU3RyaW5nXCI6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIGk9ITEsbj0wLHI9enQodCksYT16dChlKTtpZighZWUocixhKSlyZXR1cm4hMTtmb3IoO248ZS5jb29yZGluYXRlcy5sZW5ndGgtMTtuKyspe2lmKFp0KHt0eXBlOlwiUG9pbnRcIixjb29yZGluYXRlczpuZShlLmNvb3JkaW5hdGVzW25dLGUuY29vcmRpbmF0ZXNbbisxXSl9LHQse2lnbm9yZUJvdW5kYXJ5OiEwfSkpe2k9ITA7YnJlYWt9fXJldHVybiBpfShpLG4pO2Nhc2VcIlBvbHlnb25cIjpyZXR1cm4gZnVuY3Rpb24odCxlKXtpZihcIkZlYXR1cmVcIj09PXQudHlwZSYmbnVsbD09PXQuZ2VvbWV0cnkpcmV0dXJuITE7aWYoXCJGZWF0dXJlXCI9PT1lLnR5cGUmJm51bGw9PT1lLmdlb21ldHJ5KXJldHVybiExO3ZhciBpPXp0KHQpLG49enQoZSk7aWYoIWVlKGksbikpcmV0dXJuITE7Zm9yKHZhciByPVB0KGUpLmNvb3JkaW5hdGVzLGE9MCxvPXI7YTxvLmxlbmd0aDthKyspZm9yKHZhciBzPTAsbD1vW2FdO3M8bC5sZW5ndGg7cysrKXtpZighWnQobFtzXSx0KSlyZXR1cm4hMX1yZXR1cm4hMH0oaSxuKTtjYXNlXCJNdWx0aVBvaW50XCI6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPTAsbj1lLmNvb3JkaW5hdGVzO2k8bi5sZW5ndGg7aSsrKXtpZighWnQobltpXSx0LHtpZ25vcmVCb3VuZGFyeTohMH0pKXJldHVybiExfXJldHVybiEwfShpLG4pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiZmVhdHVyZTIgXCIrYStcIiBnZW9tZXRyeSBub3Qgc3VwcG9ydGVkXCIpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiZmVhdHVyZTEgXCIrcitcIiBnZW9tZXRyeSBub3Qgc3VwcG9ydGVkXCIpfX1mdW5jdGlvbiBlZSh0LGUpe3JldHVybiEodFswXT5lWzBdKSYmKCEodFsyXTxlWzJdKSYmKCEodFsxXT5lWzFdKSYmISh0WzNdPGVbM10pKSl9ZnVuY3Rpb24gaWUodCxlKXtyZXR1cm4gdFswXT09PWVbMF0mJnRbMV09PT1lWzFdfWZ1bmN0aW9uIG5lKHQsZSl7cmV0dXJuWyh0WzBdK2VbMF0pLzIsKHRbMV0rZVsxXSkvMl19dmFyIHJlPWkoMjY3NiksYWU9aS5uKHJlKTtmdW5jdGlvbiBvZSh0KXt2YXIgZT17dHlwZTpcIkZlYXR1cmVcIn07cmV0dXJuIGUuZ2VvbWV0cnk9dCxlfWZ1bmN0aW9uIHNlKHQpe3JldHVyblwiRmVhdHVyZVwiPT09dC50eXBlP3QuZ2VvbWV0cnk6dH1mdW5jdGlvbiBsZSh0KXtyZXR1cm4gdC5nZW9tZXRyeS5jb29yZGluYXRlc31mdW5jdGlvbiBoZSh0KXtyZXR1cm4gb2Uoe3R5cGU6XCJQb2x5Z29uXCIsY29vcmRpbmF0ZXM6dH0pfWZ1bmN0aW9uIHVlKHQpe3JldHVybiBvZSh7dHlwZTpcIk11bHRpUG9seWdvblwiLGNvb3JkaW5hdGVzOnR9KX1mdW5jdGlvbiBjZSh0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT8xK2NlKHRbMF0pOi0xfWZ1bmN0aW9uIHBlKHQpe3QgaW5zdGFuY2VvZiBMLlBvbHlsaW5lJiYodD10LnRvR2VvSlNPTigxNSkpO3ZhciBlPWxlKHQpLGk9Y2UoZSksbj1bXTtyZXR1cm4gaT4xP2UuZm9yRWFjaCgoZnVuY3Rpb24odCl7bi5wdXNoKGZ1bmN0aW9uKHQpe3JldHVybiBvZSh7dHlwZTpcIkxpbmVTdHJpbmdcIixjb29yZGluYXRlczp0fSl9KHQpKX0pKTpuLnB1c2godCksbn1mdW5jdGlvbiBkZSh0KXt2YXIgZT1bXTtyZXR1cm4gdC5lYWNoTGF5ZXIoKGZ1bmN0aW9uKHQpe2UucHVzaChsZSh0LnRvR2VvSlNPTigxNSkpKX0pKSxmdW5jdGlvbih0KXtyZXR1cm4gb2Uoe3R5cGU6XCJNdWx0aUxpbmVTdHJpbmdcIixjb29yZGluYXRlczp0fSl9KGUpfWZ1bmN0aW9uIGZlKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHR9KHQpfHxmdW5jdGlvbih0LGUpe3ZhciBpPW51bGw9PXQ/bnVsbDpcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZ0W1N5bWJvbC5pdGVyYXRvcl18fHRbXCJAQGl0ZXJhdG9yXCJdO2lmKG51bGw9PWkpcmV0dXJuO3ZhciBuLHIsYT1bXSxvPSEwLHM9ITE7dHJ5e2ZvcihpPWkuY2FsbCh0KTshKG89KG49aS5uZXh0KCkpLmRvbmUpJiYoYS5wdXNoKG4udmFsdWUpLCFlfHxhLmxlbmd0aCE9PWUpO289ITApO31jYXRjaChsKXtzPSEwLHI9bH1maW5hbGx5e3RyeXtvfHxudWxsPT1pW1wicmV0dXJuXCJdfHxpW1wicmV0dXJuXCJdKCl9ZmluYWxseXtpZihzKXRocm93IHJ9fXJldHVybiBhfSh0LGUpfHxmdW5jdGlvbih0LGUpe2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gZ2UodCxlKTt2YXIgaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwtMSk7XCJPYmplY3RcIj09PWkmJnQuY29uc3RydWN0b3ImJihpPXQuY29uc3RydWN0b3IubmFtZSk7aWYoXCJNYXBcIj09PWl8fFwiU2V0XCI9PT1pKXJldHVybiBBcnJheS5mcm9tKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1pfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChpKSlyZXR1cm4gZ2UodCxlKX0odCxlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfWZ1bmN0aW9uIGdlKHQsZSl7KG51bGw9PWV8fGU+dC5sZW5ndGgpJiYoZT10Lmxlbmd0aCk7Zm9yKHZhciBpPTAsbj1uZXcgQXJyYXkoZSk7aTxlO2krKyluW2ldPXRbaV07cmV0dXJuIG59ZnVuY3Rpb24gX2UodCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIG1lKHQpfSh0KXx8ZnVuY3Rpb24odCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmbnVsbCE9dFtTeW1ib2wuaXRlcmF0b3JdfHxudWxsIT10W1wiQEBpdGVyYXRvclwiXSlyZXR1cm4gQXJyYXkuZnJvbSh0KX0odCl8fGZ1bmN0aW9uKHQsZSl7aWYoIXQpcmV0dXJuO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiBtZSh0LGUpO3ZhciBpPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KS5zbGljZSg4LC0xKTtcIk9iamVjdFwiPT09aSYmdC5jb25zdHJ1Y3RvciYmKGk9dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09aXx8XCJTZXRcIj09PWkpcmV0dXJuIEFycmF5LmZyb20odCk7aWYoXCJBcmd1bWVudHNcIj09PWl8fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KGkpKXJldHVybiBtZSh0LGUpfSh0KXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBtZSh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgaT0wLG49bmV3IEFycmF5KGUpO2k8ZTtpKyspbltpXT10W2ldO3JldHVybiBufWF0LkN1dD1hdC5Qb2x5Z29uLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9tYXA9dCx0aGlzLl9zaGFwZT1cIkN1dFwiLHRoaXMudG9vbGJhckJ1dHRvbk5hbWU9XCJjdXRQb2x5Z29uXCJ9LF9maW5pc2hTaGFwZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYodGhpcy5fZWRpdGVkTGF5ZXJzPVtdLHRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb258fCh0aGlzLl9oYW5kbGVTZWxmSW50ZXJzZWN0aW9uKCEwLHRoaXMuX2xheWVyLmdldExhdExuZ3MoKVswXSksIXRoaXMuX2RvZXNTZWxmSW50ZXJzZWN0KSl7dmFyIGU9dGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpLGk9TC5wb2x5Z29uKGUsdGhpcy5vcHRpb25zLnBhdGhPcHRpb25zKTtpLl9sYXRsbmdJbmZvcz10aGlzLl9sYXllci5fbGF0bG5nSW5mbyx0aGlzLmN1dChpKSx0aGlzLl9jbGVhbnVwU25hcHBpbmcoKSx0aGlzLl9vdGhlclNuYXBMYXllcnMuc3BsaWNlKHRoaXMuX3RlbXBTbmFwTGF5ZXJJbmRleCwxKSxkZWxldGUgdGhpcy5fdGVtcFNuYXBMYXllckluZGV4LHRoaXMuX2VkaXRlZExheWVycy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgaT1lLmxheWVyLG49ZS5vcmlnaW5hbExheWVyO3QuX2ZpcmVDdXQobixpLG4pLHQuX2ZpcmVDdXQodC5fbWFwLGksbiksbi5wbS5fZmlyZUVkaXQoKX0pKSx0aGlzLl9lZGl0ZWRMYXllcnM9W10sdGhpcy5kaXNhYmxlKCksdGhpcy5vcHRpb25zLmNvbnRpbnVlRHJhd2luZyYmdGhpcy5lbmFibGUoKX19LGN1dDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9dGhpcy5fbWFwLl9sYXllcnMsbj10Ll9sYXRsbmdJbmZvc3x8W107T2JqZWN0LmtleXMoaSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gaVt0XX0pKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnBtfSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIXQuX3BtVGVtcExheWVyfSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIUwuUE0ub3B0SW4mJiF0Lm9wdGlvbnMucG1JZ25vcmV8fEwuUE0ub3B0SW4mJiExPT09dC5vcHRpb25zLnBtSWdub3JlfSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBMLlBvbHlsaW5lfSkpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT10fSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQucG0ub3B0aW9ucy5hbGxvd0N1dHRpbmd9KSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hKGUub3B0aW9ucy5sYXllcnNUb0N1dCYmTC5VdGlsLmlzQXJyYXkoZS5vcHRpb25zLmxheWVyc1RvQ3V0KSYmZS5vcHRpb25zLmxheWVyc1RvQ3V0Lmxlbmd0aD4wKXx8ZS5vcHRpb25zLmxheWVyc1RvQ3V0LmluZGV4T2YodCk+LTF9KSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hZS5fbGF5ZXJHcm91cC5oYXNMYXllcih0KX0pKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3RyeXt2YXIgaT0hIWp0KHQudG9HZW9KU09OKDE1KSxlLnRvR2VvSlNPTigxNSkpLmZlYXR1cmVzLmxlbmd0aD4wO3JldHVybiBpfHxlIGluc3RhbmNlb2YgTC5Qb2x5bGluZSYmIShlIGluc3RhbmNlb2YgTC5Qb2x5Z29uKT9pOihuPXQudG9HZW9KU09OKDE1KSxyPWUudG9HZW9KU09OKDE1KSxhPXNlKG4pLG89c2UociksISgwPT09KHM9YWUoKS5pbnRlcnNlY3Rpb24oYS5jb29yZGluYXRlcyxvLmNvb3JkaW5hdGVzKSkubGVuZ3RofHwhKDE9PT1zLmxlbmd0aD9oZShzWzBdKTp1ZShzKSkpKX1jYXRjaChsKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEwuUG9seWdvbiYmY29uc29sZS5lcnJvcihcIllvdSBjYW4ndCBjdXQgcG9seWdvbnMgd2l0aCBzZWxmLWludGVyc2VjdGlvbnNcIiksITF9dmFyIG4scixhLG8sc30pKS5mb3JFYWNoKChmdW5jdGlvbihpKXt2YXIgcjtpZihpIGluc3RhbmNlb2YgTC5Qb2x5Z29uKXt2YXIgYT0ocj1MLnBvbHlnb24oaS5nZXRMYXRMbmdzKCkpKS5nZXRMYXRMbmdzKCk7bi5mb3JFYWNoKChmdW5jdGlvbih0KXtpZih0JiZ0LnNuYXBJbmZvKXt2YXIgaT10LmxhdGxuZyxuPWUuX2NhbGNDbG9zZXN0TGF5ZXIoaSxbcl0pO2lmKG4mJm4uc2VnbWVudCYmbi5kaXN0YW5jZTxlLm9wdGlvbnMuc25hcERpc3RhbmNlKXt2YXIgbz1uLnNlZ21lbnQ7aWYobyYmMj09PW8ubGVuZ3RoKXt2YXIgcz1MLlBNLlV0aWxzLl9nZXRJbmRleEZyb21TZWdtZW50KGEsbyksbD1zLmluZGV4UGF0aCxoPXMucGFyZW50UGF0aCx1PXMubmV3SW5kZXg7KGwubGVuZ3RoPjE/UigpKGEsaCk6YSkuc3BsaWNlKHUsMCxpKX19fX0pKX1lbHNlIHI9aTt2YXIgbz1lLl9jdXRMYXllcih0LHIpLHM9TC5nZW9KU09OKG8saS5vcHRpb25zKTtpZigxPT09cy5nZXRMYXllcnMoKS5sZW5ndGgpe3ZhciBsPXMuZ2V0TGF5ZXJzKCk7cz1mZShsLDEpWzBdfWUuX3NldFBhbmUocyxcImxheWVyUGFuZVwiKTt2YXIgaD1zLmFkZFRvKGUuX21hcC5wbS5fZ2V0Q29udGFpbmluZ0xheWVyKCkpO2lmKGgucG0uZW5hYmxlKGkucG0ub3B0aW9ucyksaC5wbS5kaXNhYmxlKCksaS5fcG1UZW1wTGF5ZXI9ITAsdC5fcG1UZW1wTGF5ZXI9ITAsaS5yZW1vdmUoKSxpLnJlbW92ZUZyb20oZS5fbWFwLnBtLl9nZXRDb250YWluaW5nTGF5ZXIoKSksdC5yZW1vdmUoKSx0LnJlbW92ZUZyb20oZS5fbWFwLnBtLl9nZXRDb250YWluaW5nTGF5ZXIoKSksaC5nZXRMYXllcnMmJjA9PT1oLmdldExheWVycygpLmxlbmd0aCYmZS5fbWFwLnBtLnJlbW92ZUxheWVyKHt0YXJnZXQ6aH0pLGggaW5zdGFuY2VvZiBMLkxheWVyR3JvdXA/KGguZWFjaExheWVyKChmdW5jdGlvbih0KXtlLl9hZGREcmF3bkxheWVyUHJvcCh0KX0pKSxlLl9hZGREcmF3bkxheWVyUHJvcChoKSk6ZS5fYWRkRHJhd25MYXllclByb3AoaCksZS5vcHRpb25zLmxheWVyc1RvQ3V0JiZMLlV0aWwuaXNBcnJheShlLm9wdGlvbnMubGF5ZXJzVG9DdXQpJiZlLm9wdGlvbnMubGF5ZXJzVG9DdXQubGVuZ3RoPjApe3ZhciB1PWUub3B0aW9ucy5sYXllcnNUb0N1dC5pbmRleE9mKGkpO3U+LTEmJmUub3B0aW9ucy5sYXllcnNUb0N1dC5zcGxpY2UodSwxKX1lLl9lZGl0ZWRMYXllcnMucHVzaCh7bGF5ZXI6aCxvcmlnaW5hbExheWVyOml9KX0pKX0sX2N1dExheWVyOmZ1bmN0aW9uKHQsZSl7dmFyIGksbixyLGEsbyxzLGw9TC5nZW9KU09OKCk7aWYoZSBpbnN0YW5jZW9mIEwuUG9seWdvbiluPWUudG9HZW9KU09OKDE1KSxyPXQudG9HZW9KU09OKDE1KSxhPXNlKG4pLG89c2UociksaT0wPT09KHM9YWUoKS5kaWZmZXJlbmNlKGEuY29vcmRpbmF0ZXMsby5jb29yZGluYXRlcykpLmxlbmd0aD9udWxsOjE9PT1zLmxlbmd0aD9oZShzWzBdKTp1ZShzKTtlbHNle3ZhciBoPXBlKGUpO2guZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIGk9WHQoZSx0LnRvR2VvSlNPTigxNSkpOyhpJiZpLmZlYXR1cmVzLmxlbmd0aD4wP0wuZ2VvSlNPTihpKTpMLmdlb0pTT04oZSkpLmdldExheWVycygpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3RlKHQudG9HZW9KU09OKDE1KSxlLnRvR2VvSlNPTigxNSkpfHxlLmFkZFRvKGwpfSkpfSkpLGk9aC5sZW5ndGg+MT9kZShsKTpsLnRvR2VvSlNPTigxNSl9cmV0dXJuIGl9LF9jaGFuZ2U6TC5VdGlsLmZhbHNlRm59KSxhdC5UZXh0PWF0LmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9tYXA9dCx0aGlzLl9zaGFwZT1cIlRleHRcIix0aGlzLnRvb2xiYXJCdXR0b25OYW1lPVwiZHJhd1RleHRcIn0sZW5hYmxlOmZ1bmN0aW9uKHQpe0wuVXRpbC5zZXRPcHRpb25zKHRoaXMsdCksdGhpcy5fZW5hYmxlZD0hMCx0aGlzLl9tYXAub24oXCJjbGlja1wiLHRoaXMuX2NyZWF0ZU1hcmtlcix0aGlzKSx0aGlzLl9tYXAucG0uVG9vbGJhci50b2dnbGVCdXR0b24odGhpcy50b29sYmFyQnV0dG9uTmFtZSwhMCksdGhpcy5faGludE1hcmtlcj1MLm1hcmtlcih0aGlzLl9tYXAuZ2V0Q2VudGVyKCkse2ludGVyYWN0aXZlOiExLHpJbmRleE9mZnNldDoxMDAsaWNvbjpMLmRpdkljb24oe2NsYXNzTmFtZTpcIm1hcmtlci1pY29uIGN1cnNvci1tYXJrZXJcIn0pfSksdGhpcy5fc2V0UGFuZSh0aGlzLl9oaW50TWFya2VyLFwidmVydGV4UGFuZVwiKSx0aGlzLl9oaW50TWFya2VyLl9wbVRlbXBMYXllcj0hMCx0aGlzLl9oaW50TWFya2VyLmFkZFRvKHRoaXMuX21hcCksdGhpcy5vcHRpb25zLmN1cnNvck1hcmtlciYmTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2hpbnRNYXJrZXIuX2ljb24sXCJ2aXNpYmxlXCIpLHRoaXMub3B0aW9ucy50b29sdGlwcyYmdGhpcy5faGludE1hcmtlci5iaW5kVG9vbHRpcChJKFwidG9vbHRpcHMucGxhY2VUZXh0XCIpLHtwZXJtYW5lbnQ6ITAsb2Zmc2V0OkwucG9pbnQoMCwxMCksZGlyZWN0aW9uOlwiYm90dG9tXCIsb3BhY2l0eTouOH0pLm9wZW5Ub29sdGlwKCksdGhpcy5fbGF5ZXI9dGhpcy5faGludE1hcmtlcix0aGlzLl9tYXAub24oXCJtb3VzZW1vdmVcIix0aGlzLl9zeW5jSGludE1hcmtlcix0aGlzKSx0aGlzLl9maXJlRHJhd1N0YXJ0KCksdGhpcy5fc2V0R2xvYmFsRHJhd01vZGUoKX0sZGlzYWJsZTpmdW5jdGlvbigpe3RoaXMuX2VuYWJsZWQmJih0aGlzLl9lbmFibGVkPSExLHRoaXMuX21hcC5vZmYoXCJjbGlja1wiLHRoaXMuX2NyZWF0ZU1hcmtlcix0aGlzKSx0aGlzLl9oaW50TWFya2VyLnJlbW92ZSgpLHRoaXMuX21hcC5vZmYoXCJtb3VzZW1vdmVcIix0aGlzLl9zeW5jSGludE1hcmtlcix0aGlzKSx0aGlzLl9tYXAucG0uVG9vbGJhci50b2dnbGVCdXR0b24odGhpcy50b29sYmFyQnV0dG9uTmFtZSwhMSksdGhpcy5vcHRpb25zLnNuYXBwYWJsZSYmdGhpcy5fY2xlYW51cFNuYXBwaW5nKCksdGhpcy5fZmlyZURyYXdFbmQoKSx0aGlzLl9zZXRHbG9iYWxEcmF3TW9kZSgpKX0sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkfSx0b2dnbGU6ZnVuY3Rpb24odCl7dGhpcy5lbmFibGVkKCk/dGhpcy5kaXNhYmxlKCk6dGhpcy5lbmFibGUodCl9LF9zeW5jSGludE1hcmtlcjpmdW5jdGlvbih0KXtpZih0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyh0LmxhdGxuZyksdGhpcy5vcHRpb25zLnNuYXBwYWJsZSl7dmFyIGU9dDtlLnRhcmdldD10aGlzLl9oaW50TWFya2VyLHRoaXMuX2hhbmRsZVNuYXBwaW5nKGUpfX0sX2NyZWF0ZU1hcmtlcjpmdW5jdGlvbih0KXt2YXIgZTtpZih0LmxhdGxuZyYmKCF0aGlzLm9wdGlvbnMucmVxdWlyZVNuYXBUb0ZpbmlzaHx8dGhpcy5faGludE1hcmtlci5fc25hcHBlZHx8dGhpcy5faXNGaXJzdExheWVyKCkpKXt0aGlzLl9oaW50TWFya2VyLl9zbmFwcGVkfHx0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyh0LmxhdGxuZyk7dmFyIGk9dGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKTtpZih0aGlzLnRleHRBcmVhPXRoaXMuX2NyZWF0ZVRleHRBcmVhKCksbnVsbCE9PShlPXRoaXMub3B0aW9ucy50ZXh0T3B0aW9ucykmJnZvaWQgMCE9PWUmJmUuY2xhc3NOYW1lKXt2YXIgbixyPXRoaXMub3B0aW9ucy50ZXh0T3B0aW9ucy5jbGFzc05hbWUuc3BsaXQoXCIgXCIpOyhuPXRoaXMudGV4dEFyZWEuY2xhc3NMaXN0KS5hZGQuYXBwbHkobixfZShyKSl9dmFyIGE9dGhpcy5fY3JlYXRlVGV4dEljb24odGhpcy50ZXh0QXJlYSksbz1uZXcgTC5NYXJrZXIoaSx7dGV4dE1hcmtlcjohMCxfdGV4dE1hcmtlck92ZXJQTTohMCxpY29uOmF9KTtpZih0aGlzLl9zZXRQYW5lKG8sXCJtYXJrZXJQYW5lXCIpLHRoaXMuX2ZpbmlzaExheWVyKG8pLG8ucG18fChvLm9wdGlvbnMuZHJhZ2dhYmxlPSExKSxvLmFkZFRvKHRoaXMuX21hcC5wbS5fZ2V0Q29udGFpbmluZ0xheWVyKCkpLG8ucG0pe3ZhciBzLGwsaCx1LGM7by5wbS50ZXh0QXJlYT10aGlzLnRleHRBcmVhLEwuc2V0T3B0aW9ucyhvLnBtLHtyZW1vdmVJZkVtcHR5Om51bGw9PT0ocz1udWxsPT09KGw9dGhpcy5vcHRpb25zLnRleHRPcHRpb25zKXx8dm9pZCAwPT09bD92b2lkIDA6bC5yZW1vdmVJZkVtcHR5KXx8dm9pZCAwPT09c3x8c30pO3ZhciBwPW51bGw9PT0oaD1udWxsPT09KHU9dGhpcy5vcHRpb25zLnRleHRPcHRpb25zKXx8dm9pZCAwPT09dT92b2lkIDA6dS5mb2N1c0FmdGVyRHJhdyl8fHZvaWQgMD09PWh8fGg7by5wbS5fY3JlYXRlVGV4dE1hcmtlcihwKSxudWxsIT09KGM9dGhpcy5vcHRpb25zLnRleHRPcHRpb25zKSYmdm9pZCAwIT09YyYmYy50ZXh0JiZvLnBtLnNldFRleHQodGhpcy5vcHRpb25zLnRleHRPcHRpb25zLnRleHQpfXRoaXMuX2ZpcmVDcmVhdGUobyksdGhpcy5fY2xlYW51cFNuYXBwaW5nKCksdGhpcy5kaXNhYmxlKCksdGhpcy5vcHRpb25zLmNvbnRpbnVlRHJhd2luZyYmdGhpcy5lbmFibGUoKX19LF9jcmVhdGVUZXh0QXJlYTpmdW5jdGlvbigpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtyZXR1cm4gdC5hdXRvZm9jdXM9ITAsdC5yZWFkT25seT0hMCx0LmNsYXNzTGlzdC5hZGQoXCJwbS10ZXh0YXJlYVwiLFwicG0tZGlzYWJsZWRcIiksdH0sX2NyZWF0ZVRleHRJY29uOmZ1bmN0aW9uKHQpe3JldHVybiBMLmRpdkljb24oe2NsYXNzTmFtZTpcInBtLXRleHQtbWFya2VyXCIsaHRtbDp0fSl9fSk7Y29uc3QgeWU9e2VuYWJsZUxheWVyRHJhZzpmdW5jdGlvbigpe2lmKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUmJnRoaXMuX2xheWVyLl9tYXApe3RoaXMuZGlzYWJsZSgpLHRoaXMuX2xheWVyRHJhZ0VuYWJsZWQ9ITAsdGhpcy5fbWFwfHwodGhpcy5fbWFwPXRoaXMuX2xheWVyLl9tYXApLCh0aGlzLl9sYXllciBpbnN0YW5jZW9mIEwuTWFya2VyfHx0aGlzLl9sYXllciBpbnN0YW5jZW9mIEwuSW1hZ2VPdmVybGF5KSYmTC5Eb21FdmVudC5vbih0aGlzLl9nZXRET01FbGVtKCksXCJkcmFnc3RhcnRcIix0aGlzLl9zdG9wRE9NSW1hZ2VEcmFnKSx0aGlzLl9sYXllci5kcmFnZ2luZyYmdGhpcy5fbGF5ZXIuZHJhZ2dpbmcuZGlzYWJsZSgpLHRoaXMuX3RlbXBEcmFnQ29vcmQ9bnVsbCxWKHRoaXMuX2xheWVyKWluc3RhbmNlb2YgTC5DYW52YXM/KHRoaXMuX2xheWVyLm9uKFwibW91c2VvdXRcIix0aGlzLnJlbW92ZURyYWdnaW5nQ2xhc3MsdGhpcyksdGhpcy5fbGF5ZXIub24oXCJtb3VzZW92ZXJcIix0aGlzLmFkZERyYWdnaW5nQ2xhc3MsdGhpcykpOnRoaXMuYWRkRHJhZ2dpbmdDbGFzcygpLHRoaXMuX29yaWdpbmFsTWFwRHJhZ1N0YXRlPXRoaXMuX2xheWVyLl9tYXAuZHJhZ2dpbmcuX2VuYWJsZWQsdGhpcy5fc2FmZVRvQ2FjaGVEcmFnU3RhdGU9ITA7dmFyIHQ9dGhpcy5fZ2V0RE9NRWxlbSgpO3QmJihWKHRoaXMuX2xheWVyKWluc3RhbmNlb2YgTC5DYW52YXM/KHRoaXMuX2xheWVyLm9uKFwidG91Y2hzdGFydCBtb3VzZWRvd25cIix0aGlzLl9kcmFnTWl4aW5Pbk1vdXNlRG93bix0aGlzKSx0aGlzLl9tYXAucG0uX2FkZFRvdWNoRXZlbnRzKHQpKTpMLkRvbUV2ZW50Lm9uKHQsXCJ0b3VjaHN0YXJ0IG1vdXNlZG93blwiLHRoaXMuX3NpbXVsYXRlTW91c2VEb3duRXZlbnQsdGhpcykpLHRoaXMuX2ZpcmVEcmFnRW5hYmxlKCl9fSxkaXNhYmxlTGF5ZXJEcmFnOmZ1bmN0aW9uKCl7dGhpcy5fbGF5ZXJEcmFnRW5hYmxlZD0hMSxWKHRoaXMuX2xheWVyKWluc3RhbmNlb2YgTC5DYW52YXM/KHRoaXMuX2xheWVyLm9mZihcIm1vdXNlb3V0XCIsdGhpcy5yZW1vdmVEcmFnZ2luZ0NsYXNzLHRoaXMpLHRoaXMuX2xheWVyLm9mZihcIm1vdXNlb3ZlclwiLHRoaXMuYWRkRHJhZ2dpbmdDbGFzcyx0aGlzKSk6dGhpcy5yZW1vdmVEcmFnZ2luZ0NsYXNzKCksdGhpcy5fb3JpZ2luYWxNYXBEcmFnU3RhdGUmJnRoaXMuX2RyYWdnaW5nJiZ0aGlzLl9tYXAuZHJhZ2dpbmcuZW5hYmxlKCksdGhpcy5fc2FmZVRvQ2FjaGVEcmFnU3RhdGU9ITEsdGhpcy5fbGF5ZXIuZHJhZ2dpbmcmJnRoaXMuX2xheWVyLmRyYWdnaW5nLmRpc2FibGUoKTt2YXIgdD10aGlzLl9nZXRET01FbGVtKCk7dCYmKFYodGhpcy5fbGF5ZXIpaW5zdGFuY2VvZiBMLkNhbnZhcz8odGhpcy5fbGF5ZXIub2ZmKFwidG91Y2hzdGFydCBtb3VzZWRvd25cIix0aGlzLl9kcmFnTWl4aW5Pbk1vdXNlRG93bix0aGlzKSx0aGlzLl9tYXAucG0uX3JlbW92ZVRvdWNoRXZlbnRzKHQpKTpMLkRvbUV2ZW50Lm9mZih0LFwidG91Y2hzdGFydCBtb3VzZWRvd25cIix0aGlzLl9zaW11bGF0ZU1vdXNlRG93bkV2ZW50LHRoaXMpKSx0aGlzLl9sYXllckRyYWdnZWQmJnRoaXMuX2ZpcmVVcGRhdGUoKSx0aGlzLl9sYXllckRyYWdnZWQ9ITEsdGhpcy5fZmlyZURyYWdEaXNhYmxlKCl9LGRyYWdnaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RyYWdnaW5nfSxsYXllckRyYWdFbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLl9sYXllckRyYWdFbmFibGVkfSxfc2ltdWxhdGVNb3VzZURvd25FdmVudDpmdW5jdGlvbih0KXt2YXIgZT17b3JpZ2luYWxFdmVudDp0LHRhcmdldDp0aGlzLl9sYXllcn0saT10LnRvdWNoZXM/dC50b3VjaGVzWzBdOnQ7cmV0dXJuIGUuY29udGFpbmVyUG9pbnQ9dGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGkpLGUubGF0bG5nPXRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKGUuY29udGFpbmVyUG9pbnQpLHRoaXMuX2RyYWdNaXhpbk9uTW91c2VEb3duKGUpLCExfSxfc2ltdWxhdGVNb3VzZU1vdmVFdmVudDpmdW5jdGlvbih0KXt2YXIgZT17b3JpZ2luYWxFdmVudDp0LHRhcmdldDp0aGlzLl9sYXllcn0saT10LnRvdWNoZXM/dC50b3VjaGVzWzBdOnQ7cmV0dXJuIGUuY29udGFpbmVyUG9pbnQ9dGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGkpLGUubGF0bG5nPXRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKGUuY29udGFpbmVyUG9pbnQpLHRoaXMuX2RyYWdNaXhpbk9uTW91c2VNb3ZlKGUpLCExfSxfc2ltdWxhdGVNb3VzZVVwRXZlbnQ6ZnVuY3Rpb24odCl7dmFyIGU9e29yaWdpbmFsRXZlbnQ6dCx0YXJnZXQ6dGhpcy5fbGF5ZXJ9O3JldHVybi0xPT09dC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSYmKGUuY29udGFpbmVyUG9pbnQ9dGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KHQpLGUubGF0bG5nPXRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKGUuY29udGFpbmVyUG9pbnQpKSx0aGlzLl9kcmFnTWl4aW5Pbk1vdXNlVXAoZSksITF9LF9kcmFnTWl4aW5Pbk1vdXNlRG93bjpmdW5jdGlvbih0KXtpZighKHQub3JpZ2luYWxFdmVudC5idXR0b24+MCkpe3RoaXMuX292ZXJ3cml0ZUV2ZW50SWZJdENvbWVzRnJvbU1hcmtlcih0KTt2YXIgZT10Ll9mcm9tTGF5ZXJTeW5jLGk9dGhpcy5fc3luY0xheWVycyhcIl9kcmFnTWl4aW5Pbk1vdXNlRG93blwiLHQpO3RoaXMuX2xheWVyIGluc3RhbmNlb2YgTC5NYXJrZXImJighdGhpcy5vcHRpb25zLnNuYXBwYWJsZXx8ZXx8aT90aGlzLl9kaXNhYmxlU25hcHBpbmcoKTp0aGlzLl9pbml0U25hcHBhYmxlTWFya2VycygpKSx0aGlzLl9sYXllciBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyJiYhKHRoaXMuX2xheWVyIGluc3RhbmNlb2YgTC5DaXJjbGUpJiYoIXRoaXMub3B0aW9ucy5zbmFwcGFibGV8fGV8fGk/dGhpcy5fbGF5ZXIucG0ub3B0aW9ucy5lZGl0YWJsZT90aGlzLl9sYXllci5wbS5fZGlzYWJsZVNuYXBwaW5nKCk6dGhpcy5fbGF5ZXIucG0uX2Rpc2FibGVTbmFwcGluZ0RyYWcoKTp0aGlzLl9sYXllci5wbS5vcHRpb25zLmVkaXRhYmxlfHx0aGlzLl9pbml0U25hcHBhYmxlTWFya2Vyc0RyYWcoKSksdGhpcy5fc2FmZVRvQ2FjaGVEcmFnU3RhdGUmJih0aGlzLl9vcmlnaW5hbE1hcERyYWdTdGF0ZT10aGlzLl9sYXllci5fbWFwLmRyYWdnaW5nLl9lbmFibGVkLHRoaXMuX3NhZmVUb0NhY2hlRHJhZ1N0YXRlPSExKSx0aGlzLl90ZW1wRHJhZ0Nvb3JkPXQubGF0bG5nLEwuRG9tRXZlbnQub24odGhpcy5fbWFwLmdldENvbnRhaW5lcigpLFwidG91Y2hlbmQgbW91c2V1cFwiLHRoaXMuX3NpbXVsYXRlTW91c2VVcEV2ZW50LHRoaXMpLEwuRG9tRXZlbnQub24odGhpcy5fbWFwLmdldENvbnRhaW5lcigpLFwidG91Y2htb3ZlIG1vdXNlbW92ZVwiLHRoaXMuX3NpbXVsYXRlTW91c2VNb3ZlRXZlbnQsdGhpcyl9fSxfZHJhZ01peGluT25Nb3VzZU1vdmU6ZnVuY3Rpb24odCl7dGhpcy5fb3ZlcndyaXRlRXZlbnRJZkl0Q29tZXNGcm9tTWFya2VyKHQpO3ZhciBlPXRoaXMuX2dldERPTUVsZW0oKTt0aGlzLl9zeW5jTGF5ZXJzKFwiX2RyYWdNaXhpbk9uTW91c2VNb3ZlXCIsdCksdGhpcy5fZHJhZ2dpbmd8fCh0aGlzLl9kcmFnZ2luZz0hMCxMLkRvbVV0aWwuYWRkQ2xhc3MoZSxcImxlYWZsZXQtcG0tZHJhZ2dpbmdcIiksdGhpcy5fbGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcnx8dGhpcy5fbGF5ZXIuYnJpbmdUb0Zyb250KCksdGhpcy5fb3JpZ2luYWxNYXBEcmFnU3RhdGUmJnRoaXMuX21hcC5kcmFnZ2luZy5kaXNhYmxlKCksdGhpcy5fZmlyZURyYWdTdGFydCgpKSx0aGlzLl90ZW1wRHJhZ0Nvb3JkfHwodGhpcy5fdGVtcERyYWdDb29yZD10LmxhdGxuZyksdGhpcy5fb25MYXllckRyYWcodCksdGhpcy5fbGF5ZXIgaW5zdGFuY2VvZiBMLkNpcmNsZU1hcmtlciYmdGhpcy5fbGF5ZXIucG0uX3VwZGF0ZUhpZGRlblBvbHlDaXJjbGUoKX0sX2RyYWdNaXhpbk9uTW91c2VVcDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9dGhpcy5fZ2V0RE9NRWxlbSgpO3JldHVybiB0aGlzLl9zeW5jTGF5ZXJzKFwiX2RyYWdNaXhpbk9uTW91c2VVcFwiLHQpLHRoaXMuX29yaWdpbmFsTWFwRHJhZ1N0YXRlJiZ0aGlzLl9tYXAuZHJhZ2dpbmcuZW5hYmxlKCksdGhpcy5fc2FmZVRvQ2FjaGVEcmFnU3RhdGU9ITAsTC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLmdldENvbnRhaW5lcigpLFwidG91Y2htb3ZlIG1vdXNlbW92ZVwiLHRoaXMuX3NpbXVsYXRlTW91c2VNb3ZlRXZlbnQsdGhpcyksTC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLmdldENvbnRhaW5lcigpLFwidG91Y2hlbmQgbW91c2V1cFwiLHRoaXMuX3NpbXVsYXRlTW91c2VVcEV2ZW50LHRoaXMpLCEhdGhpcy5fZHJhZ2dpbmcmJih0aGlzLl9sYXllciBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyJiZ0aGlzLl9sYXllci5wbS5fdXBkYXRlSGlkZGVuUG9seUNpcmNsZSgpLHRoaXMuX2xheWVyRHJhZ2dlZD0hMCx3aW5kb3cuc2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLl9kcmFnZ2luZz0hMSxpJiZMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoaSxcImxlYWZsZXQtcG0tZHJhZ2dpbmdcIiksZS5fZmlyZURyYWdFbmQoKSxlLl9maXJlRWRpdCgpfSksMTApLCEwKX0sX29uTGF5ZXJEcmFnOmZ1bmN0aW9uKHQpe3ZhciBlPXQubGF0bG5nLGk9ZS5sYXQtdGhpcy5fdGVtcERyYWdDb29yZC5sYXQsbj1lLmxuZy10aGlzLl90ZW1wRHJhZ0Nvb3JkLmxuZyxyPWZ1bmN0aW9uIHUodCl7cmV0dXJuIHQubWFwKChmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB1KHQpO3ZhciBlPXtsYXQ6dC5sYXQraSxsbmc6dC5sbmcrbn07cmV0dXJuKHQuYWx0fHwwPT09dC5hbHQpJiYoZS5hbHQ9dC5hbHQpLGV9KSl9O2lmKHRoaXMuX2xheWVyIGluc3RhbmNlb2YgTC5DaXJjbGV8fHRoaXMuX2xheWVyIGluc3RhbmNlb2YgTC5DaXJjbGVNYXJrZXImJnRoaXMuX2xheWVyLm9wdGlvbnMuZWRpdGFibGUpe3ZhciBhPXIoW3RoaXMuX2xheWVyLmdldExhdExuZygpXSk7dGhpcy5fbGF5ZXIuc2V0TGF0TG5nKGFbMF0pLHRoaXMuX2ZpcmVDaGFuZ2UodGhpcy5fbGF5ZXIuZ2V0TGF0TG5nKCksXCJFZGl0XCIpfWVsc2UgaWYodGhpcy5fbGF5ZXIgaW5zdGFuY2VvZiBMLkNpcmNsZU1hcmtlcnx8dGhpcy5fbGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcil7dmFyIG89dGhpcy5fbGF5ZXIuZ2V0TGF0TG5nKCk7dGhpcy5fbGF5ZXIuX3NuYXBwZWQmJihvPXRoaXMuX2xheWVyLl9vcmdMYXRMbmcpO3ZhciBzPXIoW29dKTt0aGlzLl9sYXllci5zZXRMYXRMbmcoc1swXSksdGhpcy5fZmlyZUNoYW5nZSh0aGlzLl9sYXllci5nZXRMYXRMbmcoKSxcIkVkaXRcIil9ZWxzZSBpZih0aGlzLl9sYXllciBpbnN0YW5jZW9mIEwuSW1hZ2VPdmVybGF5KXt2YXIgbD1yKFt0aGlzLl9sYXllci5nZXRCb3VuZHMoKS5nZXROb3J0aFdlc3QoKSx0aGlzLl9sYXllci5nZXRCb3VuZHMoKS5nZXRTb3V0aEVhc3QoKV0pO3RoaXMuX2xheWVyLnNldEJvdW5kcyhsKSx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldEJvdW5kcygpLFwiRWRpdFwiKX1lbHNle3ZhciBoPXIodGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpKTt0aGlzLl9sYXllci5zZXRMYXRMbmdzKGgpLHRoaXMuX2ZpcmVDaGFuZ2UodGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpLFwiRWRpdFwiKX10aGlzLl90ZW1wRHJhZ0Nvb3JkPWUsdC5sYXllcj10aGlzLl9sYXllcix0aGlzLl9maXJlRHJhZyh0KX0sYWRkRHJhZ2dpbmdDbGFzczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2dldERPTUVsZW0oKTt0JiZMLkRvbVV0aWwuYWRkQ2xhc3ModCxcImxlYWZsZXQtcG0tZHJhZ2dhYmxlXCIpfSxyZW1vdmVEcmFnZ2luZ0NsYXNzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0RE9NRWxlbSgpO3QmJkwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0LFwibGVhZmxldC1wbS1kcmFnZ2FibGVcIil9LF9nZXRET01FbGVtOmZ1bmN0aW9uKCl7dmFyIHQ9bnVsbDtyZXR1cm4gdGhpcy5fbGF5ZXIuX3BhdGg/dD10aGlzLl9sYXllci5fcGF0aDp0aGlzLl9sYXllci5fcmVuZGVyZXImJnRoaXMuX2xheWVyLl9yZW5kZXJlci5fY29udGFpbmVyP3Q9dGhpcy5fbGF5ZXIuX3JlbmRlcmVyLl9jb250YWluZXI6dGhpcy5fbGF5ZXIuX2ltYWdlP3Q9dGhpcy5fbGF5ZXIuX2ltYWdlOnRoaXMuX2xheWVyLl9pY29uJiYodD10aGlzLl9sYXllci5faWNvbiksdH0sX292ZXJ3cml0ZUV2ZW50SWZJdENvbWVzRnJvbU1hcmtlcjpmdW5jdGlvbih0KXt0LnRhcmdldC5nZXRMYXRMbmcmJighdC50YXJnZXQuX3JhZGl1c3x8dC50YXJnZXQuX3JhZGl1czw9MTApJiYodC5jb250YWluZXJQb2ludD10aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodC5vcmlnaW5hbEV2ZW50KSx0LmxhdGxuZz10aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0LmNvbnRhaW5lclBvaW50KSl9LF9zeW5jTGF5ZXJzOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcztpZih0aGlzLmVuYWJsZWQoKSlyZXR1cm4hMTtpZighZS5fZnJvbUxheWVyU3luYyYmdGhpcy5fbGF5ZXI9PT1lLnRhcmdldCYmdGhpcy5vcHRpb25zLnN5bmNMYXllcnNPbkRyYWcpe2UuX2Zyb21MYXllclN5bmM9ITA7dmFyIG49W107aWYoTC5VdGlsLmlzQXJyYXkodGhpcy5vcHRpb25zLnN5bmNMYXllcnNPbkRyYWcpKW49dGhpcy5vcHRpb25zLnN5bmNMYXllcnNPbkRyYWcsdGhpcy5vcHRpb25zLnN5bmNMYXllcnNPbkRyYWcuZm9yRWFjaCgoZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCYmKG49bi5jb25jYXQodC5wbS5nZXRMYXllcnMoITApKSl9KSk7ZWxzZSBpZighMD09PXRoaXMub3B0aW9ucy5zeW5jTGF5ZXJzT25EcmFnJiZ0aGlzLl9wYXJlbnRMYXllckdyb3VwKWZvcih2YXIgciBpbiB0aGlzLl9wYXJlbnRMYXllckdyb3VwKXt2YXIgYT10aGlzLl9wYXJlbnRMYXllckdyb3VwW3JdO2EucG0mJihuPWEucG0uZ2V0TGF5ZXJzKCEwKSl9cmV0dXJuIEwuVXRpbC5pc0FycmF5KG4pJiZuLmxlbmd0aD4wJiYobj1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuISF0LnBtfSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuISF0LnBtLm9wdGlvbnMuZHJhZ2dhYmxlfSkpKS5mb3JFYWNoKChmdW5jdGlvbihuKXtuIT09aS5fbGF5ZXImJm4ucG1bdF0mJihuLl9zbmFwcGVkPSExLG4ucG1bdF0oZSkpfSkpLG4ubGVuZ3RoPjB9cmV0dXJuITF9LF9zdG9wRE9NSW1hZ2VEcmFnOmZ1bmN0aW9uKHQpe3JldHVybiB0LnByZXZlbnREZWZhdWx0KCksITF9fTtmdW5jdGlvbiB2ZSh0LGUsaSl7dmFyIG49aS5nZXRNYXhab29tKCk7aWYobj09PUluZmluaXR5JiYobj1pLmdldFpvb20oKSksTC5VdGlsLmlzQXJyYXkodCkpe3ZhciByPVtdO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3IucHVzaCh2ZSh0LGUsaSkpfSkpLHJ9cmV0dXJuIHQgaW5zdGFuY2VvZiBMLkxhdExuZz9mdW5jdGlvbih0LGUsaSxuKXtyZXR1cm4gaS51bnByb2plY3QoZS50cmFuc2Zvcm0oaS5wcm9qZWN0KHQsbikpLG4pfSh0LGUsaSxuKTpudWxsfWZ1bmN0aW9uIExlKHQsZSl7ZSBpbnN0YW5jZW9mIEwuTGF5ZXImJihlPWUuZ2V0TGF0TG5nKCkpO3ZhciBpPXQuZ2V0TWF4Wm9vbSgpO3JldHVybiBpPT09SW5maW5pdHkmJihpPXQuZ2V0Wm9vbSgpKSx0LnByb2plY3QoZSxpKX1mdW5jdGlvbiBiZSh0LGUpe3ZhciBpPXQuZ2V0TWF4Wm9vbSgpO3JldHVybiBpPT09SW5maW5pdHkmJihpPXQuZ2V0Wm9vbSgpKSx0LnVucHJvamVjdChlLGkpfXZhciBrZT17X29uUm90YXRlU3RhcnQ6ZnVuY3Rpb24odCl7dGhpcy5fcHJldmVudFJlbmRlcmluZ01hcmtlcnMoITApLHRoaXMuX3JvdGF0aW9uT3JpZ2luTGF0TG5nPXRoaXMuX2dldFJvdGF0aW9uQ2VudGVyKCkuY2xvbmUoKSx0aGlzLl9yb3RhdGlvbk9yaWdpblBvaW50PUxlKHRoaXMuX21hcCx0aGlzLl9yb3RhdGlvbk9yaWdpbkxhdExuZyksdGhpcy5fcm90YXRpb25TdGFydFBvaW50PUxlKHRoaXMuX21hcCx0LnRhcmdldC5nZXRMYXRMbmcoKSksdGhpcy5faW5pdGlhbFJvdGF0ZUxhdExuZz1VKHRoaXMuX2xheWVyKSx0aGlzLl9zdGFydEFuZ2xlPXRoaXMuZ2V0QW5nbGUoKTt2YXIgZT1VKHRoaXMuX3JvdGF0aW9uTGF5ZXIsdGhpcy5fcm90YXRpb25MYXllci5wbS5fcm90YXRlT3JnTGF0TG5nKTt0aGlzLl9maXJlUm90YXRpb25TdGFydCh0aGlzLl9yb3RhdGlvbkxheWVyLGUpLHRoaXMuX2ZpcmVSb3RhdGlvblN0YXJ0KHRoaXMuX21hcCxlKX0sX29uUm90YXRlOmZ1bmN0aW9uKHQpe3ZhciBlPUxlKHRoaXMuX21hcCx0LnRhcmdldC5nZXRMYXRMbmcoKSksaT10aGlzLl9yb3RhdGlvblN0YXJ0UG9pbnQsbj10aGlzLl9yb3RhdGlvbk9yaWdpblBvaW50LHI9TWF0aC5hdGFuMihlLnktbi55LGUueC1uLngpLU1hdGguYXRhbjIoaS55LW4ueSxpLngtbi54KTt0aGlzLl9sYXllci5zZXRMYXRMbmdzKHRoaXMuX3JvdGF0ZUxheWVyKHIsdGhpcy5faW5pdGlhbFJvdGF0ZUxhdExuZyx0aGlzLl9yb3RhdGlvbk9yaWdpbkxhdExuZyxMLlBNLk1hdHJpeC5pbml0KCksdGhpcy5fbWFwKSk7dmFyIGE9dGhpczshZnVuY3Rpb24gaCh0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06W10saT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06LTE7aWYoaT4tMSYmZS5wdXNoKGkpLEwuVXRpbC5pc0FycmF5KHRbMF0pKXQuZm9yRWFjaCgoZnVuY3Rpb24odCxpKXtyZXR1cm4gaCh0LGUuc2xpY2UoKSxpKX0pKTtlbHNle3ZhciBuPVIoKShhLl9tYXJrZXJzLGUpO3QuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtuW2VdLnNldExhdExuZyh0KX0pKX19KHRoaXMuX2xheWVyLmdldExhdExuZ3MoKSk7dmFyIG89VSh0aGlzLl9yb3RhdGlvbkxheWVyKTt0aGlzLl9yb3RhdGlvbkxheWVyLnNldExhdExuZ3ModGhpcy5fcm90YXRlTGF5ZXIocix0aGlzLl9yb3RhdGlvbkxheWVyLnBtLl9yb3RhdGVPcmdMYXRMbmcsdGhpcy5fcm90YXRpb25PcmlnaW5MYXRMbmcsTC5QTS5NYXRyaXguaW5pdCgpLHRoaXMuX21hcCkpO3ZhciBzPTE4MCpyL01hdGguUEksbD0ocz1zPDA/cyszNjA6cykrdGhpcy5fc3RhcnRBbmdsZTt0aGlzLl9zZXRBbmdsZShsKSx0aGlzLl9yb3RhdGlvbkxheWVyLnBtLl9zZXRBbmdsZShsKSx0aGlzLl9maXJlUm90YXRpb24odGhpcy5fcm90YXRpb25MYXllcixzLG8pLHRoaXMuX2ZpcmVSb3RhdGlvbih0aGlzLl9tYXAscyxvKSx0aGlzLl9yb3RhdGlvbkxheWVyLnBtLl9maXJlQ2hhbmdlKHRoaXMuX3JvdGF0aW9uTGF5ZXIuZ2V0TGF0TG5ncygpLFwiUm90YXRpb25cIil9LF9vblJvdGF0ZUVuZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3N0YXJ0QW5nbGU7ZGVsZXRlIHRoaXMuX3JvdGF0aW9uT3JpZ2luTGF0TG5nLGRlbGV0ZSB0aGlzLl9yb3RhdGlvbk9yaWdpblBvaW50LGRlbGV0ZSB0aGlzLl9yb3RhdGlvblN0YXJ0UG9pbnQsZGVsZXRlIHRoaXMuX2luaXRpYWxSb3RhdGVMYXRMbmcsZGVsZXRlIHRoaXMuX3N0YXJ0QW5nbGU7dmFyIGU9VSh0aGlzLl9yb3RhdGlvbkxheWVyLHRoaXMuX3JvdGF0aW9uTGF5ZXIucG0uX3JvdGF0ZU9yZ0xhdExuZyk7dGhpcy5fcm90YXRpb25MYXllci5wbS5fcm90YXRlT3JnTGF0TG5nPVUodGhpcy5fcm90YXRpb25MYXllciksdGhpcy5fZmlyZVJvdGF0aW9uRW5kKHRoaXMuX3JvdGF0aW9uTGF5ZXIsdCxlKSx0aGlzLl9maXJlUm90YXRpb25FbmQodGhpcy5fbWFwLHQsZSksdGhpcy5fcm90YXRpb25MYXllci5wbS5fZmlyZUVkaXQodGhpcy5fcm90YXRpb25MYXllcixcIlJvdGF0aW9uXCIpLHRoaXMuX3ByZXZlbnRSZW5kZXJpbmdNYXJrZXJzKCExKSx0aGlzLl9sYXllclJvdGF0ZWQ9ITB9LF9yb3RhdGVMYXllcjpmdW5jdGlvbih0LGUsaSxuLHIpe3ZhciBhPUxlKHIsaSk7cmV0dXJuIHRoaXMuX21hdHJpeD1uLmNsb25lKCkucm90YXRlKHQsYSkuZmxpcCgpLHZlKGUsdGhpcy5fbWF0cml4LHIpfSxfc2V0QW5nbGU6ZnVuY3Rpb24odCl7dD10PDA/dCszNjA6dCx0aGlzLl9hbmdsZT10JTM2MH0sX2dldFJvdGF0aW9uQ2VudGVyOmZ1bmN0aW9uKCl7dmFyIHQ9TC5wb2x5Z29uKHRoaXMuX2xheWVyLmdldExhdExuZ3MoKSx7c3Ryb2tlOiExLGZpbGw6ITEscG1JZ25vcmU6ITB9KS5hZGRUbyh0aGlzLl9sYXllci5fbWFwKSxlPXQuZ2V0Q2VudGVyKCk7cmV0dXJuIHQucmVtb3ZlRnJvbSh0aGlzLl9sYXllci5fbWFwKSxlfSxlbmFibGVSb3RhdGU6ZnVuY3Rpb24oKXtpZih0aGlzLm9wdGlvbnMuYWxsb3dSb3RhdGlvbil7dGhpcy5fcm90YXRlUG9seT1MLnBvbHlnb24odGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpLHtmaWxsOiExLHN0cm9rZTohMSxwbUlnbm9yZTohMSxzbmFwSWdub3JlOiEwfSkuYWRkVG8odGhpcy5fbGF5ZXIuX21hcCksdGhpcy5fcm90YXRlUG9seS5wbS5fc2V0QW5nbGUodGhpcy5nZXRBbmdsZSgpKSx0aGlzLl9yb3RhdGVQb2x5LnBtLnNldE9wdGlvbnModGhpcy5fbGF5ZXIuX21hcC5wbS5nZXRHbG9iYWxPcHRpb25zKCkpLHRoaXMuX3JvdGF0ZVBvbHkucG0uc2V0T3B0aW9ucyh7cm90YXRlOiEwLHNuYXBwYWJsZTohMSxoaWRlTWlkZGxlTWFya2VyczohMH0pLHRoaXMuX3JvdGF0ZVBvbHkucG0uX3JvdGF0aW9uTGF5ZXI9dGhpcy5fbGF5ZXIsdGhpcy5fcm90YXRlUG9seS5wbS5lbmFibGUoKSx0aGlzLl9yb3RhdGVPcmdMYXRMbmc9VSh0aGlzLl9sYXllciksdGhpcy5fcm90YXRlRW5hYmxlZD0hMCx0aGlzLl9sYXllci5vbihcInJlbW92ZVwiLHRoaXMuZGlzYWJsZVJvdGF0ZSx0aGlzKSx0aGlzLl9maXJlUm90YXRpb25FbmFibGUodGhpcy5fbGF5ZXIpLHRoaXMuX2ZpcmVSb3RhdGlvbkVuYWJsZSh0aGlzLl9sYXllci5fbWFwKX1lbHNlIHRoaXMuZGlzYWJsZVJvdGF0ZSgpfSxkaXNhYmxlUm90YXRlOmZ1bmN0aW9uKCl7dGhpcy5yb3RhdGVFbmFibGVkKCkmJih0aGlzLl9yb3RhdGVQb2x5LnBtLl9sYXllclJvdGF0ZWQmJnRoaXMuX2ZpcmVVcGRhdGUoKSx0aGlzLl9yb3RhdGVQb2x5LnBtLl9sYXllclJvdGF0ZWQ9ITEsdGhpcy5fcm90YXRlUG9seS5wbS5kaXNhYmxlKCksdGhpcy5fcm90YXRlUG9seS5yZW1vdmUoKSx0aGlzLl9yb3RhdGVQb2x5LnBtLnNldE9wdGlvbnMoe3JvdGF0ZTohMX0pLHRoaXMuX3JvdGF0ZVBvbHk9dW5kZWZpbmVkLHRoaXMuX3JvdGF0ZU9yZ0xhdExuZz11bmRlZmluZWQsdGhpcy5fbGF5ZXIub2ZmKFwicmVtb3ZlXCIsdGhpcy5kaXNhYmxlUm90YXRlLHRoaXMpLHRoaXMuX3JvdGF0ZUVuYWJsZWQ9ITEsdGhpcy5fZmlyZVJvdGF0aW9uRGlzYWJsZSh0aGlzLl9sYXllciksdGhpcy5fZmlyZVJvdGF0aW9uRGlzYWJsZSh0aGlzLl9sYXllci5fbWFwKSl9LHJvdGF0ZUVuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcm90YXRlRW5hYmxlZH0scm90YXRlTGF5ZXI6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRBbmdsZSgpLGk9dGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpLG49dCooTWF0aC5QSS8xODApO3RoaXMuX2xheWVyLnNldExhdExuZ3ModGhpcy5fcm90YXRlTGF5ZXIobix0aGlzLl9sYXllci5nZXRMYXRMbmdzKCksdGhpcy5fZ2V0Um90YXRpb25DZW50ZXIoKSxMLlBNLk1hdHJpeC5pbml0KCksdGhpcy5fbGF5ZXIuX21hcCkpLHRoaXMuX3JvdGF0ZU9yZ0xhdExuZz1MLnBvbHlnb24odGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpKS5nZXRMYXRMbmdzKCksdGhpcy5fc2V0QW5nbGUodGhpcy5nZXRBbmdsZSgpK3QpLHRoaXMucm90YXRlRW5hYmxlZCgpJiZ0aGlzLl9yb3RhdGVQb2x5JiZ0aGlzLl9yb3RhdGVQb2x5LnBtLmVuYWJsZWQoKSYmKHRoaXMuX3JvdGF0ZVBvbHkuc2V0TGF0TG5ncyh0aGlzLl9yb3RhdGVMYXllcihuLHRoaXMuX3JvdGF0ZVBvbHkuZ2V0TGF0TG5ncygpLHRoaXMuX2dldFJvdGF0aW9uQ2VudGVyKCksTC5QTS5NYXRyaXguaW5pdCgpLHRoaXMuX3JvdGF0ZVBvbHkuX21hcCkpLHRoaXMuX3JvdGF0ZVBvbHkucG0uX2luaXRNYXJrZXJzKCkpO3ZhciByPXRoaXMuZ2V0QW5nbGUoKS1lO3I9cjwwP3IrMzYwOnIsdGhpcy5fc3RhcnRBbmdsZT1lLHRoaXMuX2ZpcmVSb3RhdGlvbih0aGlzLl9sYXllcixyLGksdGhpcy5fbGF5ZXIpLHRoaXMuX2ZpcmVSb3RhdGlvbih0aGlzLl9tYXAscixpLHRoaXMuX2xheWVyKSxkZWxldGUgdGhpcy5fc3RhcnRBbmdsZSx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldExhdExuZ3MoKSxcIlJvdGF0aW9uXCIpfSxyb3RhdGVMYXllclRvQW5nbGU6ZnVuY3Rpb24odCl7dmFyIGU9dC10aGlzLmdldEFuZ2xlKCk7dGhpcy5yb3RhdGVMYXllcihlKX0sZ2V0QW5nbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYW5nbGV8fDB9fTtjb25zdCBNZT1rZTtjb25zdCB4ZT1MLkNsYXNzLmV4dGVuZCh7aW5jbHVkZXM6W3llLHJ0LE1lLFNdLG9wdGlvbnM6e3NuYXBwYWJsZTohMCxzbmFwRGlzdGFuY2U6MjAsYWxsb3dTZWxmSW50ZXJzZWN0aW9uOiEwLGFsbG93U2VsZkludGVyc2VjdGlvbkVkaXQ6ITEscHJldmVudE1hcmtlclJlbW92YWw6ITEscmVtb3ZlTGF5ZXJCZWxvd01pblZlcnRleENvdW50OiEwLGxpbWl0TWFya2Vyc1RvQ291bnQ6LTEsaGlkZU1pZGRsZU1hcmtlcnM6ITEsc25hcFNlZ21lbnQ6ITAsc3luY0xheWVyc09uRHJhZzohMSxkcmFnZ2FibGU6ITAsYWxsb3dFZGl0aW5nOiEwLGFsbG93UmVtb3ZhbDohMCxhbGxvd0N1dHRpbmc6ITAsYWxsb3dSb3RhdGlvbjohMCxhZGRWZXJ0ZXhPbjpcImNsaWNrXCIscmVtb3ZlVmVydGV4T246XCJjb250ZXh0bWVudVwiLHJlbW92ZVZlcnRleFZhbGlkYXRpb246dW5kZWZpbmVkLGFkZFZlcnRleFZhbGlkYXRpb246dW5kZWZpbmVkLG1vdmVWZXJ0ZXhWYWxpZGF0aW9uOnVuZGVmaW5lZH0sc2V0T3B0aW9uczpmdW5jdGlvbih0KXtMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLHQpfSxnZXRPcHRpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9uc30sYXBwbHlPcHRpb25zOmZ1bmN0aW9uKCl7fSxpc1BvbHlnb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGF5ZXIgaW5zdGFuY2VvZiBMLlBvbHlnb259LGdldFNoYXBlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NoYXBlfSxfc2V0UGFuZTpmdW5jdGlvbih0LGUpe1wibGF5ZXJQYW5lXCI9PT1lP3Qub3B0aW9ucy5wYW5lPXRoaXMuX21hcC5wbS5nbG9iYWxPcHRpb25zLnBhbmVzJiZ0aGlzLl9tYXAucG0uZ2xvYmFsT3B0aW9ucy5wYW5lcy5sYXllclBhbmV8fFwib3ZlcmxheVBhbmVcIjpcInZlcnRleFBhbmVcIj09PWU/dC5vcHRpb25zLnBhbmU9dGhpcy5fbWFwLnBtLmdsb2JhbE9wdGlvbnMucGFuZXMmJnRoaXMuX21hcC5wbS5nbG9iYWxPcHRpb25zLnBhbmVzLnZlcnRleFBhbmV8fFwibWFya2VyUGFuZVwiOlwibWFya2VyUGFuZVwiPT09ZSYmKHQub3B0aW9ucy5wYW5lPXRoaXMuX21hcC5wbS5nbG9iYWxPcHRpb25zLnBhbmVzJiZ0aGlzLl9tYXAucG0uZ2xvYmFsT3B0aW9ucy5wYW5lcy5tYXJrZXJQYW5lfHxcIm1hcmtlclBhbmVcIil9LHJlbW92ZTpmdW5jdGlvbigpeyh0aGlzLl9tYXB8fHRoaXMuX2xheWVyLl9tYXApLnBtLnJlbW92ZUxheWVyKHt0YXJnZXQ6dGhpcy5fbGF5ZXJ9KX0sX3ZlcnRleFZhbGlkYXRpb246ZnVuY3Rpb24odCxlKXt2YXIgaT1lLnRhcmdldCxuPXtsYXllcjp0aGlzLl9sYXllcixtYXJrZXI6aSxldmVudDplfSxyPVwiXCI7cmV0dXJuXCJtb3ZlXCI9PT10P3I9XCJtb3ZlVmVydGV4VmFsaWRhdGlvblwiOlwiYWRkXCI9PT10P3I9XCJhZGRWZXJ0ZXhWYWxpZGF0aW9uXCI6XCJyZW1vdmVcIj09PXQmJihyPVwicmVtb3ZlVmVydGV4VmFsaWRhdGlvblwiKSx0aGlzLm9wdGlvbnNbcl0mJlwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9uc1tyXSYmIXRoaXMub3B0aW9uc1tyXShuKT8oXCJtb3ZlXCI9PT10JiYoaS5fY2FuY2VsRHJhZ0V2ZW50Q2hhaW49aS5nZXRMYXRMbmcoKSksITEpOihpLl9jYW5jZWxEcmFnRXZlbnRDaGFpbj1udWxsLCEwKX0sX3ZlcnRleFZhbGlkYXRpb25EcmFnOmZ1bmN0aW9uKHQpe3JldHVybiF0Ll9jYW5jZWxEcmFnRXZlbnRDaGFpbnx8KHQuX2xhdGxuZz10Ll9jYW5jZWxEcmFnRXZlbnRDaGFpbix0LnVwZGF0ZSgpLCExKX0sX3ZlcnRleFZhbGlkYXRpb25EcmFnRW5kOmZ1bmN0aW9uKHQpe3JldHVybiF0Ll9jYW5jZWxEcmFnRXZlbnRDaGFpbnx8KHQuX2NhbmNlbERyYWdFdmVudENoYWluPW51bGwsITEpfX0pO2Z1bmN0aW9uIHdlKHQpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiBDZSh0KX0odCl8fGZ1bmN0aW9uKHQpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJm51bGwhPXRbU3ltYm9sLml0ZXJhdG9yXXx8bnVsbCE9dFtcIkBAaXRlcmF0b3JcIl0pcmV0dXJuIEFycmF5LmZyb20odCl9KHQpfHxmdW5jdGlvbih0LGUpe2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gQ2UodCxlKTt2YXIgaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwtMSk7XCJPYmplY3RcIj09PWkmJnQuY29uc3RydWN0b3ImJihpPXQuY29uc3RydWN0b3IubmFtZSk7aWYoXCJNYXBcIj09PWl8fFwiU2V0XCI9PT1pKXJldHVybiBBcnJheS5mcm9tKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1pfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChpKSlyZXR1cm4gQ2UodCxlKX0odCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24gQ2UodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIGk9MCxuPW5ldyBBcnJheShlKTtpPGU7aSsrKW5baV09dFtpXTtyZXR1cm4gbn14ZS5MYXllckdyb3VwPUwuQ2xhc3MuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy5fbGF5ZXJHcm91cD10LHRoaXMuX2xheWVycz10aGlzLmdldExheWVycygpLHRoaXMuX2dldE1hcCgpLHRoaXMuX2xheWVycy5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gZS5faW5pdExheWVyKHQpfSkpO3RoaXMuX2xheWVyR3JvdXAub24oXCJsYXllcmFkZFwiLEwuVXRpbC50aHJvdHRsZSgoZnVuY3Rpb24odCl7aWYoIXQubGF5ZXIuX3BtVGVtcExheWVyKXtlLl9sYXllcnM9ZS5nZXRMYXllcnMoKTt2YXIgaT1lLl9sYXllcnMuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hdC5wbS5fcGFyZW50TGF5ZXJHcm91cHx8IShlLl9sYXllckdyb3VwLl9sZWFmbGV0X2lkIGluIHQucG0uX3BhcmVudExheWVyR3JvdXApfSkpO2kuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZS5faW5pdExheWVyKHQpfSkpLGkubGVuZ3RoPjAmJmUuX2dldE1hcCgpJiZlLl9nZXRNYXAoKS5wbS5nbG9iYWxFZGl0TW9kZUVuYWJsZWQoKSYmZS5lbmFibGVkKCkmJmUuZW5hYmxlKGUuZ2V0T3B0aW9ucygpKX19KSwxMDAsdGhpcyksdGhpcyksdGhpcy5fbGF5ZXJHcm91cC5vbihcImxheWVycmVtb3ZlXCIsKGZ1bmN0aW9uKHQpe2UuX3JlbW92ZUxheWVyRnJvbUdyb3VwKHQudGFyZ2V0KX0pLHRoaXMpO3RoaXMuX2xheWVyR3JvdXAub24oXCJsYXllcnJlbW92ZVwiLEwuVXRpbC50aHJvdHRsZSgoZnVuY3Rpb24odCl7dC50YXJnZXQuX3BtVGVtcExheWVyfHwoZS5fbGF5ZXJzPWUuZ2V0TGF5ZXJzKCkpfSksMTAwLHRoaXMpLHRoaXMpfSxlbmFibGU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOltdOzA9PT1lLmxlbmd0aCYmKHRoaXMuX2xheWVycz10aGlzLmdldExheWVycygpKSx0aGlzLl9vcHRpb25zPXQsdGhpcy5fbGF5ZXJzLmZvckVhY2goKGZ1bmN0aW9uKGkpe2kgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXA/LTE9PT1lLmluZGV4T2YoaS5fbGVhZmxldF9pZCkmJihlLnB1c2goaS5fbGVhZmxldF9pZCksaS5wbS5lbmFibGUodCxlKSk6aS5wbS5lbmFibGUodCl9KSl9LGRpc2FibGU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06W107MD09PXQubGVuZ3RoJiYodGhpcy5fbGF5ZXJzPXRoaXMuZ2V0TGF5ZXJzKCkpLHRoaXMuX2xheWVycy5mb3JFYWNoKChmdW5jdGlvbihlKXtlIGluc3RhbmNlb2YgTC5MYXllckdyb3VwPy0xPT09dC5pbmRleE9mKGUuX2xlYWZsZXRfaWQpJiYodC5wdXNoKGUuX2xlYWZsZXRfaWQpLGUucG0uZGlzYWJsZSh0KSk6ZS5wbS5kaXNhYmxlKCl9KSl9LGVuYWJsZWQ6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06W107MD09PXQubGVuZ3RoJiYodGhpcy5fbGF5ZXJzPXRoaXMuZ2V0TGF5ZXJzKCkpO3ZhciBlPXRoaXMuX2xheWVycy5maW5kKChmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cD8tMT09PXQuaW5kZXhPZihlLl9sZWFmbGV0X2lkKSYmKHQucHVzaChlLl9sZWFmbGV0X2lkKSxlLnBtLmVuYWJsZWQodCkpOmUucG0uZW5hYmxlZCgpfSkpO3JldHVybiEhZX0sdG9nZ2xlRWRpdDpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06W107MD09PWUubGVuZ3RoJiYodGhpcy5fbGF5ZXJzPXRoaXMuZ2V0TGF5ZXJzKCkpLHRoaXMuX29wdGlvbnM9dCx0aGlzLl9sYXllcnMuZm9yRWFjaCgoZnVuY3Rpb24oaSl7aSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cD8tMT09PWUuaW5kZXhPZihpLl9sZWFmbGV0X2lkKSYmKGUucHVzaChpLl9sZWFmbGV0X2lkKSxpLnBtLnRvZ2dsZUVkaXQodCxlKSk6aS5wbS50b2dnbGVFZGl0KHQpfSkpfSxfaW5pdExheWVyOmZ1bmN0aW9uKHQpe3ZhciBlPUwuVXRpbC5zdGFtcCh0aGlzLl9sYXllckdyb3VwKTt0LnBtLl9wYXJlbnRMYXllckdyb3VwfHwodC5wbS5fcGFyZW50TGF5ZXJHcm91cD17fSksdC5wbS5fcGFyZW50TGF5ZXJHcm91cFtlXT10aGlzLl9sYXllckdyb3VwfSxfcmVtb3ZlTGF5ZXJGcm9tR3JvdXA6ZnVuY3Rpb24odCl7aWYodC5wbSYmdC5wbS5fbGF5ZXJHcm91cCl7dmFyIGU9TC5VdGlsLnN0YW1wKHRoaXMuX2xheWVyR3JvdXApO2RlbGV0ZSB0LnBtLl9sYXllckdyb3VwW2VdfX0sZHJhZ2dpbmc6ZnVuY3Rpb24oKXtpZih0aGlzLl9sYXllcnM9dGhpcy5nZXRMYXllcnMoKSx0aGlzLl9sYXllcnMpe3ZhciB0PXRoaXMuX2xheWVycy5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC5wbS5kcmFnZ2luZygpfSkpO3JldHVybiEhdH1yZXR1cm4hMX0sZ2V0T3B0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnN9LF9nZXRNYXA6ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gdGhpcy5fbWFwfHwobnVsbD09PSh0PXRoaXMuX2xheWVycy5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4hIXQuX21hcH0pKSl8fHZvaWQgMD09PXQ/dm9pZCAwOnQuX21hcCl8fG51bGx9LGdldExheWVyczpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkJiZhcmd1bWVudHNbMF0sZT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dW5kZWZpbmVkKXx8YXJndW1lbnRzWzFdLGk9IShhcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZCl8fGFyZ3VtZW50c1syXSxuPWFyZ3VtZW50cy5sZW5ndGg+MyYmYXJndW1lbnRzWzNdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1szXTpbXSxyPVtdO3JldHVybiB0P3RoaXMuX2xheWVyR3JvdXAuZ2V0TGF5ZXJzKCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7ci5wdXNoKHQpLHQgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXAmJi0xPT09bi5pbmRleE9mKHQuX2xlYWZsZXRfaWQpJiYobi5wdXNoKHQuX2xlYWZsZXRfaWQpLHI9ci5jb25jYXQodC5wbS5nZXRMYXllcnMoITAsITAsITAsbikpKX0pKTpyPXRoaXMuX2xheWVyR3JvdXAuZ2V0TGF5ZXJzKCksaSYmKHI9ci5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiEodCBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCl9KSkpLGUmJihyPShyPShyPXIuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hIXQucG19KSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIXQuX3BtVGVtcExheWVyfSkpKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiFMLlBNLm9wdEluJiYhdC5vcHRpb25zLnBtSWdub3JlfHxMLlBNLm9wdEluJiYhMT09PXQub3B0aW9ucy5wbUlnbm9yZX0pKSkscn0sc2V0T3B0aW9uczpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06W107MD09PWUubGVuZ3RoJiYodGhpcy5fbGF5ZXJzPXRoaXMuZ2V0TGF5ZXJzKCkpLHRoaXMub3B0aW9ucz10LHRoaXMuX2xheWVycy5mb3JFYWNoKChmdW5jdGlvbihpKXtpLnBtJiYoaSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cD8tMT09PWUuaW5kZXhPZihpLl9sZWFmbGV0X2lkKSYmKGUucHVzaChpLl9sZWFmbGV0X2lkKSxpLnBtLnNldE9wdGlvbnModCxlKSk6aS5wbS5zZXRPcHRpb25zKHQpKX0pKX19KSx4ZS5NYXJrZXI9eGUuZXh0ZW5kKHtfc2hhcGU6XCJNYXJrZXJcIixpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX2xheWVyPXQsdGhpcy5fZW5hYmxlZD0hMSx0aGlzLl9sYXllci5vbihcImRyYWdlbmRcIix0aGlzLl9vbkRyYWdFbmQsdGhpcyl9LGVuYWJsZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7ZHJhZ2dhYmxlOiEwfTtMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLHQpLHRoaXMub3B0aW9ucy5hbGxvd0VkaXRpbmcmJnRoaXMuX2xheWVyLl9tYXA/KHRoaXMuX21hcD10aGlzLl9sYXllci5fbWFwLHRoaXMuZW5hYmxlZCgpJiZ0aGlzLmRpc2FibGUoKSx0aGlzLmFwcGx5T3B0aW9ucygpLHRoaXMuX2xheWVyLm9uKFwicmVtb3ZlXCIsdGhpcy5kaXNhYmxlLHRoaXMpLHRoaXMuX2VuYWJsZWQ9ITAsdGhpcy5fZmlyZUVuYWJsZSgpKTp0aGlzLmRpc2FibGUoKX0sZGlzYWJsZTpmdW5jdGlvbigpe3RoaXMuZW5hYmxlZCgpJiYodGhpcy5kaXNhYmxlTGF5ZXJEcmFnKCksdGhpcy5fbGF5ZXIub2ZmKFwicmVtb3ZlXCIsdGhpcy5kaXNhYmxlLHRoaXMpLHRoaXMuX2xheWVyLm9mZihcImNvbnRleHRtZW51XCIsdGhpcy5fcmVtb3ZlTWFya2VyLHRoaXMpLHRoaXMuX2xheWVyRWRpdGVkJiZ0aGlzLl9maXJlVXBkYXRlKCksdGhpcy5fbGF5ZXJFZGl0ZWQ9ITEsdGhpcy5fZmlyZURpc2FibGUoKSx0aGlzLl9lbmFibGVkPSExKX0sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkfSx0b2dnbGVFZGl0OmZ1bmN0aW9uKHQpe3RoaXMuZW5hYmxlZCgpP3RoaXMuZGlzYWJsZSgpOnRoaXMuZW5hYmxlKHQpfSxhcHBseU9wdGlvbnM6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuc25hcHBhYmxlP3RoaXMuX2luaXRTbmFwcGFibGVNYXJrZXJzKCk6dGhpcy5fZGlzYWJsZVNuYXBwaW5nKCksdGhpcy5vcHRpb25zLmRyYWdnYWJsZT90aGlzLmVuYWJsZUxheWVyRHJhZygpOnRoaXMuZGlzYWJsZUxheWVyRHJhZygpLHRoaXMub3B0aW9ucy5wcmV2ZW50TWFya2VyUmVtb3ZhbHx8dGhpcy5fbGF5ZXIub24oXCJjb250ZXh0bWVudVwiLHRoaXMuX3JlbW92ZU1hcmtlcix0aGlzKX0sX3JlbW92ZU1hcmtlcjpmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldDtlLnJlbW92ZSgpLHRoaXMuX2ZpcmVSZW1vdmUoZSksdGhpcy5fZmlyZVJlbW92ZSh0aGlzLl9tYXAsZSl9LF9vbkRyYWdFbmQ6ZnVuY3Rpb24oKXt0aGlzLl9maXJlRWRpdCgpLHRoaXMuX2xheWVyRWRpdGVkPSEwfSxfaW5pdFNuYXBwYWJsZU1hcmtlcnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9sYXllcjt0aGlzLm9wdGlvbnMuc25hcERpc3RhbmNlPXRoaXMub3B0aW9ucy5zbmFwRGlzdGFuY2V8fDMwLHRoaXMub3B0aW9ucy5zbmFwU2VnbWVudD10aGlzLm9wdGlvbnMuc25hcFNlZ21lbnQ9PT11bmRlZmluZWR8fHRoaXMub3B0aW9ucy5zbmFwU2VnbWVudCx0Lm9mZihcInBtOmRyYWdcIix0aGlzLl9oYW5kbGVTbmFwcGluZyx0aGlzKSx0Lm9uKFwicG06ZHJhZ1wiLHRoaXMuX2hhbmRsZVNuYXBwaW5nLHRoaXMpLHQub2ZmKFwicG06ZHJhZ2VuZFwiLHRoaXMuX2NsZWFudXBTbmFwcGluZyx0aGlzKSx0Lm9uKFwicG06ZHJhZ2VuZFwiLHRoaXMuX2NsZWFudXBTbmFwcGluZyx0aGlzKSx0Lm9mZihcInBtOmRyYWdzdGFydFwiLHRoaXMuX3Vuc25hcCx0aGlzKSx0Lm9uKFwicG06ZHJhZ3N0YXJ0XCIsdGhpcy5fdW5zbmFwLHRoaXMpfSxfZGlzYWJsZVNuYXBwaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbGF5ZXI7dC5vZmYoXCJwbTpkcmFnXCIsdGhpcy5faGFuZGxlU25hcHBpbmcsdGhpcyksdC5vZmYoXCJwbTpkcmFnZW5kXCIsdGhpcy5fY2xlYW51cFNuYXBwaW5nLHRoaXMpLHQub2ZmKFwicG06ZHJhZ3N0YXJ0XCIsdGhpcy5fdW5zbmFwLHRoaXMpfX0pO2NvbnN0IFBlPXtmaWx0ZXJNYXJrZXJHcm91cDpmdW5jdGlvbigpe3RoaXMubWFya2VyQ2FjaGU9W10sdGhpcy5jcmVhdGVDYWNoZSgpLHRoaXMuX2xheWVyLm9uKFwicG06ZWRpdFwiLHRoaXMuY3JlYXRlQ2FjaGUsdGhpcyksdGhpcy5hcHBseUxpbWl0RmlsdGVycyh7fSksdGhpcy5fbGF5ZXIub24oXCJwbTpkaXNhYmxlXCIsdGhpcy5fcmVtb3ZlTWFya2VyTGltaXRFdmVudHMsdGhpcyksdGhpcy5vcHRpb25zLmxpbWl0TWFya2Vyc1RvQ291bnQ+LTEmJih0aGlzLl9sYXllci5vbihcInBtOnZlcnRleHJlbW92ZWRcIix0aGlzLl9pbml0TWFya2Vycyx0aGlzKSx0aGlzLl9tYXAub24oXCJtb3VzZW1vdmVcIix0aGlzLmFwcGx5TGltaXRGaWx0ZXJzLHRoaXMpKX0sX3JlbW92ZU1hcmtlckxpbWl0RXZlbnRzOmZ1bmN0aW9uKCl7dGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLHRoaXMuYXBwbHlMaW1pdEZpbHRlcnMsdGhpcyksdGhpcy5fbGF5ZXIub2ZmKFwicG06ZWRpdFwiLHRoaXMuY3JlYXRlQ2FjaGUsdGhpcyksdGhpcy5fbGF5ZXIub2ZmKFwicG06ZGlzYWJsZVwiLHRoaXMuX3JlbW92ZU1hcmtlckxpbWl0RXZlbnRzLHRoaXMpLHRoaXMuX2xheWVyLm9mZihcInBtOnZlcnRleHJlbW92ZWRcIix0aGlzLl9pbml0TWFya2Vycyx0aGlzKX0sY3JlYXRlQ2FjaGU6ZnVuY3Rpb24oKXt2YXIgdD1bXS5jb25jYXQod2UodGhpcy5fbWFya2VyR3JvdXAuZ2V0TGF5ZXJzKCkpLHdlKHRoaXMubWFya2VyQ2FjaGUpKTt0aGlzLm1hcmtlckNhY2hlPXQuZmlsdGVyKChmdW5jdGlvbih0LGUsaSl7cmV0dXJuIGkuaW5kZXhPZih0KT09PWV9KSl9LHJlbmRlckxpbWl0czpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMubWFya2VyQ2FjaGUuZm9yRWFjaCgoZnVuY3Rpb24oaSl7dC5pbmNsdWRlcyhpKT9lLl9tYXJrZXJHcm91cC5hZGRMYXllcihpKTplLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihpKX0pKX0sYXBwbHlMaW1pdEZpbHRlcnM6ZnVuY3Rpb24odCl7dmFyIGU9dC5sYXRsbmcsaT12b2lkIDA9PT1lP3tsYXQ6MCxsbmc6MH06ZTtpZighdGhpcy5fcHJldmVudFJlbmRlck1hcmtlcnMpe3ZhciBuPXdlKHRoaXMuX2ZpbHRlckNsb3Nlc3RNYXJrZXJzKGkpKTt0aGlzLnJlbmRlckxpbWl0cyhuKX19LF9maWx0ZXJDbG9zZXN0TWFya2VyczpmdW5jdGlvbih0KXt2YXIgZT13ZSh0aGlzLm1hcmtlckNhY2hlKSxpPXRoaXMub3B0aW9ucy5saW1pdE1hcmtlcnNUb0NvdW50O3JldHVybiBlLnNvcnQoKGZ1bmN0aW9uKGUsaSl7cmV0dXJuIGUuX2xhdGxuZy5kaXN0YW5jZVRvKHQpLWkuX2xhdGxuZy5kaXN0YW5jZVRvKHQpfSkpLGUuZmlsdGVyKChmdW5jdGlvbih0LGUpe3JldHVybiEoaT4tMSl8fGU8aX0pKX0sX3ByZXZlbnRSZW5kZXJNYXJrZXJzOiExLF9wcmV2ZW50UmVuZGVyaW5nTWFya2VyczpmdW5jdGlvbih0KXt0aGlzLl9wcmV2ZW50UmVuZGVyTWFya2Vycz0hIXR9fTtmdW5jdGlvbiBFZSh0LGUpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0fSh0KXx8ZnVuY3Rpb24odCxlKXt2YXIgaT1udWxsPT10P251bGw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmdFtTeW1ib2wuaXRlcmF0b3JdfHx0W1wiQEBpdGVyYXRvclwiXTtpZihudWxsPT1pKXJldHVybjt2YXIgbixyLGE9W10sbz0hMCxzPSExO3RyeXtmb3IoaT1pLmNhbGwodCk7IShvPShuPWkubmV4dCgpKS5kb25lKSYmKGEucHVzaChuLnZhbHVlKSwhZXx8YS5sZW5ndGghPT1lKTtvPSEwKTt9Y2F0Y2gobCl7cz0hMCxyPWx9ZmluYWxseXt0cnl7b3x8bnVsbD09aVtcInJldHVyblwiXXx8aVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYocyl0aHJvdyByfX1yZXR1cm4gYX0odCxlKXx8ZnVuY3Rpb24odCxlKXtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIFNlKHQsZSk7dmFyIGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLnNsaWNlKDgsLTEpO1wiT2JqZWN0XCI9PT1pJiZ0LmNvbnN0cnVjdG9yJiYoaT10LmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1pfHxcIlNldFwiPT09aSlyZXR1cm4gQXJyYXkuZnJvbSh0KTtpZihcIkFyZ3VtZW50c1wiPT09aXx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QoaSkpcmV0dXJuIFNlKHQsZSl9KHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBTZSh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgaT0wLG49bmV3IEFycmF5KGUpO2k8ZTtpKyspbltpXT10W2ldO3JldHVybiBufWZ1bmN0aW9uIE9lKHQpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiBEZSh0KX0odCl8fGZ1bmN0aW9uKHQpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJm51bGwhPXRbU3ltYm9sLml0ZXJhdG9yXXx8bnVsbCE9dFtcIkBAaXRlcmF0b3JcIl0pcmV0dXJuIEFycmF5LmZyb20odCl9KHQpfHxmdW5jdGlvbih0LGUpe2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gRGUodCxlKTt2YXIgaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwtMSk7XCJPYmplY3RcIj09PWkmJnQuY29uc3RydWN0b3ImJihpPXQuY29uc3RydWN0b3IubmFtZSk7aWYoXCJNYXBcIj09PWl8fFwiU2V0XCI9PT1pKXJldHVybiBBcnJheS5mcm9tKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1pfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChpKSlyZXR1cm4gRGUodCxlKX0odCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24gRGUodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIGk9MCxuPW5ldyBBcnJheShlKTtpPGU7aSsrKW5baV09dFtpXTtyZXR1cm4gbn14ZS5MaW5lPXhlLmV4dGVuZCh7aW5jbHVkZXM6W1BlXSxfc2hhcGU6XCJMaW5lXCIsaW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9sYXllcj10LHRoaXMuX2VuYWJsZWQ9ITF9LGVuYWJsZTpmdW5jdGlvbih0KXtMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLHQpLHRoaXMuX21hcD10aGlzLl9sYXllci5fbWFwLHRoaXMuX21hcCYmKHRoaXMub3B0aW9ucy5hbGxvd0VkaXRpbmc/KHRoaXMuZW5hYmxlZCgpJiZ0aGlzLmRpc2FibGUoKSx0aGlzLl9lbmFibGVkPSEwLHRoaXMuX2luaXRNYXJrZXJzKCksdGhpcy5hcHBseU9wdGlvbnMoKSx0aGlzLl9sYXllci5vbihcInJlbW92ZVwiLHRoaXMuZGlzYWJsZSx0aGlzKSx0aGlzLm9wdGlvbnMuYWxsb3dTZWxmSW50ZXJzZWN0aW9ufHx0aGlzLl9sYXllci5vbihcInBtOnZlcnRleHJlbW92ZWRcIix0aGlzLl9oYW5kbGVTZWxmSW50ZXJzZWN0aW9uT25WZXJ0ZXhSZW1vdmFsLHRoaXMpLHRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb24/dGhpcy5jYWNoZWRDb2xvcj11bmRlZmluZWQ6KFwiI2YwMDAwMGZmXCIhPT10aGlzLl9sYXllci5vcHRpb25zLmNvbG9yPyh0aGlzLmNhY2hlZENvbG9yPXRoaXMuX2xheWVyLm9wdGlvbnMuY29sb3IsdGhpcy5pc1JlZD0hMSk6dGhpcy5pc1JlZD0hMCx0aGlzLl9oYW5kbGVMYXllclN0eWxlKCkpLHRoaXMuX2ZpcmVFbmFibGUoKSk6dGhpcy5kaXNhYmxlKCkpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7aWYodGhpcy5lbmFibGVkKCkmJiF0aGlzLl9kcmFnZ2luZyl7dGhpcy5fZW5hYmxlZD0hMSx0aGlzLl9tYXJrZXJHcm91cC5jbGVhckxheWVycygpLHRoaXMuX21hcmtlckdyb3VwLnJlbW92ZUZyb20odGhpcy5fbWFwKSx0aGlzLl9sYXllci5vZmYoXCJyZW1vdmVcIix0aGlzLmRpc2FibGUsdGhpcyksdGhpcy5vcHRpb25zLmFsbG93U2VsZkludGVyc2VjdGlvbnx8dGhpcy5fbGF5ZXIub2ZmKFwicG06dmVydGV4cmVtb3ZlZFwiLHRoaXMuX2hhbmRsZVNlbGZJbnRlcnNlY3Rpb25PblZlcnRleFJlbW92YWwsdGhpcyk7dmFyIHQ9dGhpcy5fbGF5ZXIuX3BhdGg/dGhpcy5fbGF5ZXIuX3BhdGg6dGhpcy5fbGF5ZXIuX3JlbmRlcmVyLl9jb250YWluZXI7TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHQsXCJsZWFmbGV0LXBtLWRyYWdnYWJsZVwiKSx0aGlzLmhhc1NlbGZJbnRlcnNlY3Rpb24oKSYmTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHQsXCJsZWFmbGV0LXBtLWludmFsaWRcIiksdGhpcy5fbGF5ZXJFZGl0ZWQmJnRoaXMuX2ZpcmVVcGRhdGUoKSx0aGlzLl9sYXllckVkaXRlZD0hMSx0aGlzLl9maXJlRGlzYWJsZSgpfX0sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkfSx0b2dnbGVFZGl0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVuYWJsZWQoKT90aGlzLmRpc2FibGUoKTp0aGlzLmVuYWJsZSh0KSx0aGlzLmVuYWJsZWQoKX0sYXBwbHlPcHRpb25zOmZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLnNuYXBwYWJsZT90aGlzLl9pbml0U25hcHBhYmxlTWFya2VycygpOnRoaXMuX2Rpc2FibGVTbmFwcGluZygpfSxfaW5pdE1hcmtlcnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5fbWFwLGk9dGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpO3RoaXMuX21hcmtlckdyb3VwJiZ0aGlzLl9tYXJrZXJHcm91cC5jbGVhckxheWVycygpLHRoaXMuX21hcmtlckdyb3VwPW5ldyBMLkxheWVyR3JvdXAsdGhpcy5fbWFya2VyR3JvdXAuX3BtVGVtcExheWVyPSEwO3RoaXMuX21hcmtlcnM9ZnVuY3Rpb24gbihlKXtpZihBcnJheS5pc0FycmF5KGVbMF0pKXJldHVybiBlLm1hcChuLHQpO3ZhciBpPWUubWFwKHQuX2NyZWF0ZU1hcmtlcix0KTtyZXR1cm4hMCE9PXQub3B0aW9ucy5oaWRlTWlkZGxlTWFya2VycyYmZS5tYXAoKGZ1bmN0aW9uKG4scil7dmFyIGE9dC5pc1BvbHlnb24oKT8ocisxKSVlLmxlbmd0aDpyKzE7cmV0dXJuIHQuX2NyZWF0ZU1pZGRsZU1hcmtlcihpW3JdLGlbYV0pfSkpLGl9KGkpLHRoaXMuZmlsdGVyTWFya2VyR3JvdXAoKSxlLmFkZExheWVyKHRoaXMuX21hcmtlckdyb3VwKX0sX2NyZWF0ZU1hcmtlcjpmdW5jdGlvbih0KXt2YXIgZT1uZXcgTC5NYXJrZXIodCx7ZHJhZ2dhYmxlOiEwLGljb246TC5kaXZJY29uKHtjbGFzc05hbWU6XCJtYXJrZXItaWNvblwifSl9KTtyZXR1cm4gdGhpcy5fc2V0UGFuZShlLFwidmVydGV4UGFuZVwiKSxlLl9wbVRlbXBMYXllcj0hMCx0aGlzLm9wdGlvbnMucm90YXRlPyhlLm9uKFwiZHJhZ3N0YXJ0XCIsdGhpcy5fb25Sb3RhdGVTdGFydCx0aGlzKSxlLm9uKFwiZHJhZ1wiLHRoaXMuX29uUm90YXRlLHRoaXMpLGUub24oXCJkcmFnZW5kXCIsdGhpcy5fb25Sb3RhdGVFbmQsdGhpcykpOihlLm9uKFwiY2xpY2tcIix0aGlzLl9vblZlcnRleENsaWNrLHRoaXMpLGUub24oXCJkcmFnc3RhcnRcIix0aGlzLl9vbk1hcmtlckRyYWdTdGFydCx0aGlzKSxlLm9uKFwibW92ZVwiLHRoaXMuX29uTWFya2VyRHJhZyx0aGlzKSxlLm9uKFwiZHJhZ2VuZFwiLHRoaXMuX29uTWFya2VyRHJhZ0VuZCx0aGlzKSx0aGlzLm9wdGlvbnMucHJldmVudE1hcmtlclJlbW92YWx8fGUub24odGhpcy5vcHRpb25zLnJlbW92ZVZlcnRleE9uLHRoaXMuX3JlbW92ZU1hcmtlcix0aGlzKSksdGhpcy5fbWFya2VyR3JvdXAuYWRkTGF5ZXIoZSksZX0sX2NyZWF0ZU1pZGRsZU1hcmtlcjpmdW5jdGlvbih0LGUpe2lmKCF0fHwhZSlyZXR1cm4hMTt2YXIgaT1MLlBNLlV0aWxzLmNhbGNNaWRkbGVMYXRMbmcodGhpcy5fbWFwLHQuZ2V0TGF0TG5nKCksZS5nZXRMYXRMbmcoKSksbj10aGlzLl9jcmVhdGVNYXJrZXIoaSkscj1MLmRpdkljb24oe2NsYXNzTmFtZTpcIm1hcmtlci1pY29uIG1hcmtlci1pY29uLW1pZGRsZVwifSk7cmV0dXJuIG4uc2V0SWNvbihyKSxuLmxlZnRNPXQsbi5yaWdodE09ZSx0Ll9taWRkbGVNYXJrZXJOZXh0PW4sZS5fbWlkZGxlTWFya2VyUHJldj1uLG4ub24odGhpcy5vcHRpb25zLmFkZFZlcnRleE9uLHRoaXMuX29uTWlkZGxlTWFya2VyQ2xpY2ssdGhpcyksbi5vbihcIm1vdmVzdGFydFwiLHRoaXMuX29uTWlkZGxlTWFya2VyTW92ZVN0YXJ0LHRoaXMpLG59LF9vbk1pZGRsZU1hcmtlckNsaWNrOmZ1bmN0aW9uKHQpe3ZhciBlPXQudGFyZ2V0O2lmKHRoaXMuX3ZlcnRleFZhbGlkYXRpb24oXCJhZGRcIix0KSl7dmFyIGk9TC5kaXZJY29uKHtjbGFzc05hbWU6XCJtYXJrZXItaWNvblwifSk7ZS5zZXRJY29uKGkpLHRoaXMuX2FkZE1hcmtlcihlLGUubGVmdE0sZS5yaWdodE0pfX0sX29uTWlkZGxlTWFya2VyTW92ZVN0YXJ0OmZ1bmN0aW9uKHQpe3ZhciBlPXQudGFyZ2V0O2Uub24oXCJtb3ZlZW5kXCIsdGhpcy5fb25NaWRkbGVNYXJrZXJNb3ZlRW5kLHRoaXMpLHRoaXMuX3ZlcnRleFZhbGlkYXRpb24oXCJhZGRcIix0KT8oZS5fZHJhZ2dpbmc9ITAsdGhpcy5fYWRkTWFya2VyKGUsZS5sZWZ0TSxlLnJpZ2h0TSkpOmUub24oXCJtb3ZlXCIsdGhpcy5fb25NaWRkbGVNYXJrZXJNb3ZlUHJldmVudCx0aGlzKX0sX29uTWlkZGxlTWFya2VyTW92ZVByZXZlbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC50YXJnZXQ7dGhpcy5fdmVydGV4VmFsaWRhdGlvbkRyYWcoZSl9LF9vbk1pZGRsZU1hcmtlck1vdmVFbmQ6ZnVuY3Rpb24odCl7dmFyIGU9dC50YXJnZXQ7aWYoZS5vZmYoXCJtb3ZlXCIsdGhpcy5fb25NaWRkbGVNYXJrZXJNb3ZlUHJldmVudCx0aGlzKSxlLm9mZihcIm1vdmVlbmRcIix0aGlzLl9vbk1pZGRsZU1hcmtlck1vdmVFbmQsdGhpcyksdGhpcy5fdmVydGV4VmFsaWRhdGlvbkRyYWdFbmQoZSkpe3ZhciBpPUwuZGl2SWNvbih7Y2xhc3NOYW1lOlwibWFya2VyLWljb25cIn0pO2Uuc2V0SWNvbihpKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe2RlbGV0ZSBlLl9kcmFnZ2luZ30pLDEwMCl9fSxfYWRkTWFya2VyOmZ1bmN0aW9uKHQsZSxpKXt0Lm9mZihcIm1vdmVzdGFydFwiLHRoaXMuX29uTWlkZGxlTWFya2VyTW92ZVN0YXJ0LHRoaXMpLHQub2ZmKHRoaXMub3B0aW9ucy5hZGRWZXJ0ZXhPbix0aGlzLl9vbk1pZGRsZU1hcmtlckNsaWNrLHRoaXMpO3ZhciBuPXQuZ2V0TGF0TG5nKCkscj10aGlzLl9sYXllci5fbGF0bG5ncztkZWxldGUgdC5sZWZ0TSxkZWxldGUgdC5yaWdodE07dmFyIGE9TC5QTS5VdGlscy5maW5kRGVlcE1hcmtlckluZGV4KHRoaXMuX21hcmtlcnMsZSksbz1hLmluZGV4UGF0aCxzPWEuaW5kZXgsbD1hLnBhcmVudFBhdGgsaD1vLmxlbmd0aD4xP1IoKShyLGwpOnIsdT1vLmxlbmd0aD4xP1IoKSh0aGlzLl9tYXJrZXJzLGwpOnRoaXMuX21hcmtlcnM7aC5zcGxpY2UocysxLDAsbiksdS5zcGxpY2UocysxLDAsdCksdGhpcy5fbGF5ZXIuc2V0TGF0TG5ncyhyKSwhMCE9PXRoaXMub3B0aW9ucy5oaWRlTWlkZGxlTWFya2VycyYmKHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcihlLHQpLHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcih0LGkpKSx0aGlzLl9maXJlRWRpdCgpLHRoaXMuX2xheWVyRWRpdGVkPSEwLHRoaXMuX2ZpcmVDaGFuZ2UodGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpLFwiRWRpdFwiKSx0aGlzLl9maXJlVmVydGV4QWRkZWQodCxMLlBNLlV0aWxzLmZpbmREZWVwTWFya2VySW5kZXgodGhpcy5fbWFya2Vycyx0KS5pbmRleFBhdGgsbiksdGhpcy5vcHRpb25zLnNuYXBwYWJsZSYmdGhpcy5faW5pdFNuYXBwYWJsZU1hcmtlcnMoKX0saGFzU2VsZkludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiBtdCh0aGlzLl9sYXllci50b0dlb0pTT04oMTUpKS5mZWF0dXJlcy5sZW5ndGg+MH0sX2hhbmRsZVNlbGZJbnRlcnNlY3Rpb25PblZlcnRleFJlbW92YWw6ZnVuY3Rpb24oKXt0aGlzLl9oYW5kbGVMYXllclN0eWxlKCEwKSx0aGlzLmhhc1NlbGZJbnRlcnNlY3Rpb24oKSYmKHRoaXMuX2xheWVyLnNldExhdExuZ3ModGhpcy5fY29vcmRzQmVmb3JlRWRpdCksdGhpcy5fY29vcmRzQmVmb3JlRWRpdD1udWxsLHRoaXMuX2luaXRNYXJrZXJzKCkpfSxfaGFuZGxlTGF5ZXJTdHlsZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9sYXllcjtpZih0aGlzLmhhc1NlbGZJbnRlcnNlY3Rpb24oKSl7aWYoIXRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb24mJnRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb25FZGl0JiZ0aGlzLl91cGRhdGVEaXNhYmxlZE1hcmtlclN0eWxlKHRoaXMuX21hcmtlcnMsITApLHRoaXMuaXNSZWQpcmV0dXJuO3Q/dGhpcy5fZmxhc2hMYXllcigpOihlLnNldFN0eWxlKHtjb2xvcjpcIiNmMDAwMDBmZlwifSksdGhpcy5pc1JlZD0hMCksdGhpcy5fZmlyZUludGVyc2VjdChtdCh0aGlzLl9sYXllci50b0dlb0pTT04oMTUpKSl9ZWxzZSBlLnNldFN0eWxlKHtjb2xvcjp0aGlzLmNhY2hlZENvbG9yfSksdGhpcy5pc1JlZD0hMSwhdGhpcy5vcHRpb25zLmFsbG93U2VsZkludGVyc2VjdGlvbiYmdGhpcy5vcHRpb25zLmFsbG93U2VsZkludGVyc2VjdGlvbkVkaXQmJnRoaXMuX3VwZGF0ZURpc2FibGVkTWFya2VyU3R5bGUodGhpcy5fbWFya2VycywhMSl9LF9mbGFzaExheWVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmNhY2hlZENvbG9yfHwodGhpcy5jYWNoZWRDb2xvcj10aGlzLl9sYXllci5vcHRpb25zLmNvbG9yKSx0aGlzLl9sYXllci5zZXRTdHlsZSh7Y29sb3I6XCIjZjAwMDAwZmZcIn0pLHRoaXMuaXNSZWQ9ITAsd2luZG93LnNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dC5fbGF5ZXIuc2V0U3R5bGUoe2NvbG9yOnQuY2FjaGVkQ29sb3J9KSx0LmlzUmVkPSExfSksMjAwKX0sX3VwZGF0ZURpc2FibGVkTWFya2VyU3R5bGU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7QXJyYXkuaXNBcnJheSh0KT9pLl91cGRhdGVEaXNhYmxlZE1hcmtlclN0eWxlKHQsZSk6dC5faWNvbiYmKGUmJiFpLl9jaGVja01hcmtlckFsbG93ZWRUb0RyYWcodCk/TC5Eb21VdGlsLmFkZENsYXNzKHQuX2ljb24sXCJ2ZXJ0ZXhtYXJrZXItZGlzYWJsZWRcIik6TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHQuX2ljb24sXCJ2ZXJ0ZXhtYXJrZXItZGlzYWJsZWRcIikpfSkpfSxfcmVtb3ZlTWFya2VyOmZ1bmN0aW9uKHQpe3ZhciBlPXQudGFyZ2V0O2lmKHRoaXMuX3ZlcnRleFZhbGlkYXRpb24oXCJyZW1vdmVcIix0KSl7aWYoIXRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb24pe3ZhciBpPXRoaXMuX2xheWVyLmdldExhdExuZ3MoKTt0aGlzLl9jb29yZHNCZWZvcmVFZGl0PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaSkpfXZhciBuPXRoaXMuX2xheWVyLmdldExhdExuZ3MoKSxyPUwuUE0uVXRpbHMuZmluZERlZXBNYXJrZXJJbmRleCh0aGlzLl9tYXJrZXJzLGUpLGE9ci5pbmRleFBhdGgsbz1yLmluZGV4LHM9ci5wYXJlbnRQYXRoO2lmKGEpe3ZhciBsPWEubGVuZ3RoPjE/UigpKG4scyk6bixoPWEubGVuZ3RoPjE/UigpKHRoaXMuX21hcmtlcnMscyk6dGhpcy5fbWFya2VycztpZih0aGlzLm9wdGlvbnMucmVtb3ZlTGF5ZXJCZWxvd01pblZlcnRleENvdW50fHwhKGwubGVuZ3RoPD0yfHx0aGlzLmlzUG9seWdvbigpJiZsLmxlbmd0aDw9Mykpe2wuc3BsaWNlKG8sMSksdGhpcy5fbGF5ZXIuc2V0TGF0TG5ncyhuKSx0aGlzLmlzUG9seWdvbigpJiZsLmxlbmd0aDw9MiYmbC5zcGxpY2UoMCxsLmxlbmd0aCk7dmFyIHU9ITE7aWYobC5sZW5ndGg8PTEmJihsLnNwbGljZSgwLGwubGVuZ3RoKSx0aGlzLl9sYXllci5zZXRMYXRMbmdzKG4pLHRoaXMuZGlzYWJsZSgpLHRoaXMuZW5hYmxlKHRoaXMub3B0aW9ucyksdT0hMCksaihuKSYmdGhpcy5fbGF5ZXIucmVtb3ZlKCksbj1BKG4pLHRoaXMuX2xheWVyLnNldExhdExuZ3MobiksdGhpcy5fbWFya2Vycz1BKHRoaXMuX21hcmtlcnMpLCF1JiYoaD1hLmxlbmd0aD4xP1IoKSh0aGlzLl9tYXJrZXJzLHMpOnRoaXMuX21hcmtlcnMsZS5fbWlkZGxlTWFya2VyUHJldiYmdGhpcy5fbWFya2VyR3JvdXAucmVtb3ZlTGF5ZXIoZS5fbWlkZGxlTWFya2VyUHJldiksZS5fbWlkZGxlTWFya2VyTmV4dCYmdGhpcy5fbWFya2VyR3JvdXAucmVtb3ZlTGF5ZXIoZS5fbWlkZGxlTWFya2VyTmV4dCksdGhpcy5fbWFya2VyR3JvdXAucmVtb3ZlTGF5ZXIoZSksaCkpe3ZhciBjLHA7aWYodGhpcy5pc1BvbHlnb24oKT8oYz0obysxKSVoLmxlbmd0aCxwPShvKyhoLmxlbmd0aC0xKSklaC5sZW5ndGgpOihwPW8tMTwwP3VuZGVmaW5lZDpvLTEsYz1vKzE+PWgubGVuZ3RoP3VuZGVmaW5lZDpvKzEpLGMhPT1wKXt2YXIgZD1oW3BdLGY9aFtjXTshMCE9PXRoaXMub3B0aW9ucy5oaWRlTWlkZGxlTWFya2VycyYmdGhpcy5fY3JlYXRlTWlkZGxlTWFya2VyKGQsZil9aC5zcGxpY2UobywxKX10aGlzLl9maXJlRWRpdCgpLHRoaXMuX2xheWVyRWRpdGVkPSEwLHRoaXMuX2ZpcmVWZXJ0ZXhSZW1vdmVkKGUsYSksdGhpcy5fZmlyZUNoYW5nZSh0aGlzLl9sYXllci5nZXRMYXRMbmdzKCksXCJFZGl0XCIpfWVsc2UgdGhpcy5fZmxhc2hMYXllcigpfX19LHVwZGF0ZVBvbHlnb25Db29yZHNGcm9tTWFya2VyRHJhZzpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9sYXllci5nZXRMYXRMbmdzKCksaT10LmdldExhdExuZygpLG49TC5QTS5VdGlscy5maW5kRGVlcE1hcmtlckluZGV4KHRoaXMuX21hcmtlcnMsdCkscj1uLmluZGV4UGF0aCxhPW4uaW5kZXgsbz1uLnBhcmVudFBhdGg7KHIubGVuZ3RoPjE/UigpKGUsbyk6ZSkuc3BsaWNlKGEsMSxpKSx0aGlzLl9sYXllci5zZXRMYXRMbmdzKGUpfSxfZ2V0TmVpZ2hib3JNYXJrZXJzOmZ1bmN0aW9uKHQpe3ZhciBlPUwuUE0uVXRpbHMuZmluZERlZXBNYXJrZXJJbmRleCh0aGlzLl9tYXJrZXJzLHQpLGk9ZS5pbmRleFBhdGgsbj1lLmluZGV4LHI9ZS5wYXJlbnRQYXRoLGE9aS5sZW5ndGg+MT9SKCkodGhpcy5fbWFya2VycyxyKTp0aGlzLl9tYXJrZXJzLG89KG4rMSklYS5sZW5ndGg7cmV0dXJue3ByZXZNYXJrZXI6YVsobisoYS5sZW5ndGgtMSkpJWEubGVuZ3RoXSxuZXh0TWFya2VyOmFbb119fSxfY2hlY2tNYXJrZXJBbGxvd2VkVG9EcmFnOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2dldE5laWdoYm9yTWFya2Vycyh0KSxpPWUucHJldk1hcmtlcixuPWUubmV4dE1hcmtlcixyPUwucG9seWxpbmUoW2kuZ2V0TGF0TG5nKCksdC5nZXRMYXRMbmcoKV0pLGE9TC5wb2x5bGluZShbdC5nZXRMYXRMbmcoKSxuLmdldExhdExuZygpXSksbz1qdCh0aGlzLl9sYXllci50b0dlb0pTT04oMTUpLHIudG9HZW9KU09OKDE1KSkuZmVhdHVyZXMubGVuZ3RoLHM9anQodGhpcy5fbGF5ZXIudG9HZW9KU09OKDE1KSxhLnRvR2VvSlNPTigxNSkpLmZlYXR1cmVzLmxlbmd0aDtyZXR1cm4gdC5nZXRMYXRMbmcoKT09PXRoaXMuX21hcmtlcnNbMF1bMF0uZ2V0TGF0TG5nKCk/cys9MTp0LmdldExhdExuZygpPT09dGhpcy5fbWFya2Vyc1swXVt0aGlzLl9tYXJrZXJzWzBdLmxlbmd0aC0xXS5nZXRMYXRMbmcoKSYmKG8rPTEpLCEobzw9MiYmczw9Mil9LF9vbk1hcmtlckRyYWdTdGFydDpmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldDtpZih0aGlzLmNhY2hlZENvbG9yfHwodGhpcy5jYWNoZWRDb2xvcj10aGlzLl9sYXllci5vcHRpb25zLmNvbG9yKSx0aGlzLl92ZXJ0ZXhWYWxpZGF0aW9uKFwibW92ZVwiLHQpKXt2YXIgaT1MLlBNLlV0aWxzLmZpbmREZWVwTWFya2VySW5kZXgodGhpcy5fbWFya2VycyxlKS5pbmRleFBhdGg7dGhpcy5fZmlyZU1hcmtlckRyYWdTdGFydCh0LGkpLHRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb258fCh0aGlzLl9jb29yZHNCZWZvcmVFZGl0PXRoaXMuX2xheWVyLmdldExhdExuZ3MoKSksIXRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb24mJnRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb25FZGl0JiZ0aGlzLmhhc1NlbGZJbnRlcnNlY3Rpb24oKT90aGlzLl9tYXJrZXJBbGxvd2VkVG9EcmFnPXRoaXMuX2NoZWNrTWFya2VyQWxsb3dlZFRvRHJhZyhlKTp0aGlzLl9tYXJrZXJBbGxvd2VkVG9EcmFnPW51bGx9fSxfb25NYXJrZXJEcmFnOmZ1bmN0aW9uKHQpe3ZhciBlPXQudGFyZ2V0O2lmKHRoaXMuX3ZlcnRleFZhbGlkYXRpb25EcmFnKGUpKXt2YXIgaT1MLlBNLlV0aWxzLmZpbmREZWVwTWFya2VySW5kZXgodGhpcy5fbWFya2VycyxlKSxuPWkuaW5kZXhQYXRoLHI9aS5pbmRleCxhPWkucGFyZW50UGF0aDtpZihuKXtpZighdGhpcy5vcHRpb25zLmFsbG93U2VsZkludGVyc2VjdGlvbiYmdGhpcy5vcHRpb25zLmFsbG93U2VsZkludGVyc2VjdGlvbkVkaXQmJnRoaXMuaGFzU2VsZkludGVyc2VjdGlvbigpJiYhMT09PXRoaXMuX21hcmtlckFsbG93ZWRUb0RyYWcpcmV0dXJuIHRoaXMuX2xheWVyLnNldExhdExuZ3ModGhpcy5fY29vcmRzQmVmb3JlRWRpdCksdGhpcy5faW5pdE1hcmtlcnMoKSx2b2lkIHRoaXMuX2hhbmRsZUxheWVyU3R5bGUoKTt0aGlzLnVwZGF0ZVBvbHlnb25Db29yZHNGcm9tTWFya2VyRHJhZyhlKTt2YXIgbz1uLmxlbmd0aD4xP1IoKSh0aGlzLl9tYXJrZXJzLGEpOnRoaXMuX21hcmtlcnMscz0ocisxKSVvLmxlbmd0aCxsPShyKyhvLmxlbmd0aC0xKSklby5sZW5ndGgsaD1lLmdldExhdExuZygpLHU9b1tsXS5nZXRMYXRMbmcoKSxjPW9bc10uZ2V0TGF0TG5nKCk7aWYoZS5fbWlkZGxlTWFya2VyTmV4dCl7dmFyIHA9TC5QTS5VdGlscy5jYWxjTWlkZGxlTGF0TG5nKHRoaXMuX21hcCxoLGMpO2UuX21pZGRsZU1hcmtlck5leHQuc2V0TGF0TG5nKHApfWlmKGUuX21pZGRsZU1hcmtlclByZXYpe3ZhciBkPUwuUE0uVXRpbHMuY2FsY01pZGRsZUxhdExuZyh0aGlzLl9tYXAsaCx1KTtlLl9taWRkbGVNYXJrZXJQcmV2LnNldExhdExuZyhkKX10aGlzLm9wdGlvbnMuYWxsb3dTZWxmSW50ZXJzZWN0aW9ufHx0aGlzLl9oYW5kbGVMYXllclN0eWxlKCksdGhpcy5fZmlyZU1hcmtlckRyYWcodCxuKSx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldExhdExuZ3MoKSxcIkVkaXRcIil9fX0sX29uTWFya2VyRHJhZ0VuZDpmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldDtpZih0aGlzLl92ZXJ0ZXhWYWxpZGF0aW9uRHJhZ0VuZChlKSl7dmFyIGk9TC5QTS5VdGlscy5maW5kRGVlcE1hcmtlckluZGV4KHRoaXMuX21hcmtlcnMsZSkuaW5kZXhQYXRoLG49dGhpcy5oYXNTZWxmSW50ZXJzZWN0aW9uKCk7biYmdGhpcy5vcHRpb25zLmFsbG93U2VsZkludGVyc2VjdGlvbkVkaXQmJnRoaXMuX21hcmtlckFsbG93ZWRUb0RyYWcmJihuPSExKTt2YXIgcj0hdGhpcy5vcHRpb25zLmFsbG93U2VsZkludGVyc2VjdGlvbiYmbjtpZih0aGlzLl9maXJlTWFya2VyRHJhZ0VuZCh0LGkscikscilyZXR1cm4gdGhpcy5fbGF5ZXIuc2V0TGF0TG5ncyh0aGlzLl9jb29yZHNCZWZvcmVFZGl0KSx0aGlzLl9jb29yZHNCZWZvcmVFZGl0PW51bGwsdGhpcy5faW5pdE1hcmtlcnMoKSx0aGlzLm9wdGlvbnMuc25hcHBhYmxlJiZ0aGlzLl9pbml0U25hcHBhYmxlTWFya2VycygpLHRoaXMuX2hhbmRsZUxheWVyU3R5bGUoKSx2b2lkIHRoaXMuX2ZpcmVMYXllclJlc2V0KHQsaSk7IXRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb24mJnRoaXMub3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb25FZGl0JiZ0aGlzLl9oYW5kbGVMYXllclN0eWxlKCksdGhpcy5fZmlyZUVkaXQoKSx0aGlzLl9sYXllckVkaXRlZD0hMCx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldExhdExuZ3MoKSxcIkVkaXRcIil9fSxfb25WZXJ0ZXhDbGljazpmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldDtpZighZS5fZHJhZ2dpbmcpe3ZhciBpPUwuUE0uVXRpbHMuZmluZERlZXBNYXJrZXJJbmRleCh0aGlzLl9tYXJrZXJzLGUpLmluZGV4UGF0aDt0aGlzLl9maXJlVmVydGV4Q2xpY2sodCxpKX19fSkseGUuUG9seWdvbj14ZS5MaW5lLmV4dGVuZCh7X3NoYXBlOlwiUG9seWdvblwiLF9jaGVja01hcmtlckFsbG93ZWRUb0RyYWc6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fZ2V0TmVpZ2hib3JNYXJrZXJzKHQpLGk9ZS5wcmV2TWFya2VyLG49ZS5uZXh0TWFya2VyLHI9TC5wb2x5bGluZShbaS5nZXRMYXRMbmcoKSx0LmdldExhdExuZygpXSksYT1MLnBvbHlsaW5lKFt0LmdldExhdExuZygpLG4uZ2V0TGF0TG5nKCldKSxvPWp0KHRoaXMuX2xheWVyLnRvR2VvSlNPTigxNSksci50b0dlb0pTT04oMTUpKS5mZWF0dXJlcy5sZW5ndGgscz1qdCh0aGlzLl9sYXllci50b0dlb0pTT04oMTUpLGEudG9HZW9KU09OKDE1KSkuZmVhdHVyZXMubGVuZ3RoO3JldHVybiEobzw9MiYmczw9Mil9fSkseGUuUmVjdGFuZ2xlPXhlLlBvbHlnb24uZXh0ZW5kKHtfc2hhcGU6XCJSZWN0YW5nbGVcIixfaW5pdE1hcmtlcnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5fbWFwLGk9dGhpcy5fZmluZENvcm5lcnMoKTt0aGlzLl9tYXJrZXJHcm91cCYmdGhpcy5fbWFya2VyR3JvdXAuY2xlYXJMYXllcnMoKSx0aGlzLl9tYXJrZXJHcm91cD1uZXcgTC5MYXllckdyb3VwLHRoaXMuX21hcmtlckdyb3VwLl9wbVRlbXBMYXllcj0hMCxlLmFkZExheWVyKHRoaXMuX21hcmtlckdyb3VwKSx0aGlzLl9tYXJrZXJzPVtdLHRoaXMuX21hcmtlcnNbMF09aS5tYXAodGhpcy5fY3JlYXRlTWFya2VyLHRoaXMpO3ZhciBuPUVlKHRoaXMuX21hcmtlcnMsMSk7dGhpcy5fY29ybmVyTWFya2Vycz1uWzBdLHRoaXMuX2xheWVyLmdldExhdExuZ3MoKVswXS5mb3JFYWNoKChmdW5jdGlvbihlLGkpe3ZhciBuPXQuX2Nvcm5lck1hcmtlcnMuZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuX2luZGV4PT09aX0pKTtuJiZuLnNldExhdExuZyhlKX0pKX0sYXBwbHlPcHRpb25zOmZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLnNuYXBwYWJsZT90aGlzLl9pbml0U25hcHBhYmxlTWFya2VycygpOnRoaXMuX2Rpc2FibGVTbmFwcGluZygpLHRoaXMuX2FkZE1hcmtlckV2ZW50cygpfSxfY3JlYXRlTWFya2VyOmZ1bmN0aW9uKHQsZSl7dmFyIGk9bmV3IEwuTWFya2VyKHQse2RyYWdnYWJsZTohMCxpY29uOkwuZGl2SWNvbih7Y2xhc3NOYW1lOlwibWFya2VyLWljb25cIn0pfSk7cmV0dXJuIHRoaXMuX3NldFBhbmUoaSxcInZlcnRleFBhbmVcIiksaS5fb3JpZ0xhdExuZz10LGkuX2luZGV4PWUsaS5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5fbWFya2VyR3JvdXAuYWRkTGF5ZXIoaSksaX0sX2FkZE1hcmtlckV2ZW50czpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5fbWFya2Vyc1swXS5mb3JFYWNoKChmdW5jdGlvbihlKXtlLm9uKFwiZHJhZ3N0YXJ0XCIsdC5fb25NYXJrZXJEcmFnU3RhcnQsdCksZS5vbihcImRyYWdcIix0Ll9vbk1hcmtlckRyYWcsdCksZS5vbihcImRyYWdlbmRcIix0Ll9vbk1hcmtlckRyYWdFbmQsdCksdC5vcHRpb25zLnByZXZlbnRNYXJrZXJSZW1vdmFsfHxlLm9uKFwiY29udGV4dG1lbnVcIix0Ll9yZW1vdmVNYXJrZXIsdCl9KSl9LF9yZW1vdmVNYXJrZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sX29uTWFya2VyRHJhZ1N0YXJ0OmZ1bmN0aW9uKHQpe2lmKHRoaXMuX3ZlcnRleFZhbGlkYXRpb24oXCJtb3ZlXCIsdCkpe3ZhciBlPXQudGFyZ2V0LGk9dGhpcy5fY29ybmVyTWFya2VycztlLl9vcHBvc2l0ZUNvcm5lckxhdExuZz1pLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVybiB0Ll9pbmRleD09PShlLl9pbmRleCsyKSU0fSkpLmdldExhdExuZygpLGUuX3NuYXBwZWQ9ITEsdGhpcy5fZmlyZU1hcmtlckRyYWdTdGFydCh0KX19LF9vbk1hcmtlckRyYWc6ZnVuY3Rpb24odCl7dmFyIGU9dC50YXJnZXQ7dGhpcy5fdmVydGV4VmFsaWRhdGlvbkRyYWcoZSkmJmUuX2luZGV4IT09dW5kZWZpbmVkJiYodGhpcy5fYWRqdXN0UmVjdGFuZ2xlRm9yTWFya2VyTW92ZShlKSx0aGlzLl9maXJlTWFya2VyRHJhZyh0KSx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldExhdExuZ3MoKSxcIkVkaXRcIikpfSxfb25NYXJrZXJEcmFnRW5kOmZ1bmN0aW9uKHQpe3ZhciBlPXQudGFyZ2V0O3RoaXMuX3ZlcnRleFZhbGlkYXRpb25EcmFnRW5kKGUpJiYodGhpcy5fY29ybmVyTWFya2Vycy5mb3JFYWNoKChmdW5jdGlvbih0KXtkZWxldGUgdC5fb3Bwb3NpdGVDb3JuZXJMYXRMbmd9KSksdGhpcy5fZmlyZU1hcmtlckRyYWdFbmQodCksdGhpcy5fZmlyZUVkaXQoKSx0aGlzLl9sYXllckVkaXRlZD0hMCx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldExhdExuZ3MoKSxcIkVkaXRcIikpfSxfYWRqdXN0UmVjdGFuZ2xlRm9yTWFya2VyTW92ZTpmdW5jdGlvbih0KXtMLmV4dGVuZCh0Ll9vcmlnTGF0TG5nLHQuX2xhdGxuZyk7dmFyIGU9TC5QTS5VdGlscy5fZ2V0Um90YXRlZFJlY3RhbmdsZSh0LmdldExhdExuZygpLHQuX29wcG9zaXRlQ29ybmVyTGF0TG5nLHRoaXMuX2FuZ2xlfHwwLHRoaXMuX21hcCk7dGhpcy5fbGF5ZXIuc2V0TGF0TG5ncyhlKSx0aGlzLl9hZGp1c3RBbGxNYXJrZXJzKCksdGhpcy5fbGF5ZXIucmVkcmF3KCl9LF9hZGp1c3RBbGxNYXJrZXJzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMuX2xheWVyLmdldExhdExuZ3MoKVswXTtlJiY0IT09ZS5sZW5ndGgmJmUubGVuZ3RoPjA/KGUuZm9yRWFjaCgoZnVuY3Rpb24oZSxpKXt0Ll9jb3JuZXJNYXJrZXJzW2ldLnNldExhdExuZyhlKX0pKSx0aGlzLl9jb3JuZXJNYXJrZXJzLnNsaWNlKGUubGVuZ3RoKS5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnNldExhdExuZyhlWzBdKX0pKSk6ZSYmZS5sZW5ndGg/dGhpcy5fY29ybmVyTWFya2Vycy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnNldExhdExuZyhlW3QuX2luZGV4XSl9KSk6Y29uc29sZS5lcnJvcihcIlRoZSBsYXllciBoYXMgbm8gTGF0TG5nc1wiKX0sX2ZpbmRDb3JuZXJzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpWzBdO3JldHVybiBMLlBNLlV0aWxzLl9nZXRSb3RhdGVkUmVjdGFuZ2xlKHRbMF0sdFsyXSx0aGlzLl9hbmdsZXx8MCx0aGlzLl9tYXApfX0pLHhlLkNpcmNsZT14ZS5leHRlbmQoe19zaGFwZTpcIkNpcmNsZVwiLGluaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fbGF5ZXI9dCx0aGlzLl9lbmFibGVkPSExLHRoaXMuX3VwZGF0ZUhpZGRlblBvbHlDaXJjbGUoKX0sZW5hYmxlOmZ1bmN0aW9uKHQpe0wuVXRpbC5zZXRPcHRpb25zKHRoaXMsdCksdGhpcy5fbWFwPXRoaXMuX2xheWVyLl9tYXAsdGhpcy5vcHRpb25zLmFsbG93RWRpdGluZz8odGhpcy5lbmFibGVkKCl8fHRoaXMuZGlzYWJsZSgpLHRoaXMuX2VuYWJsZWQ9ITAsdGhpcy5faW5pdE1hcmtlcnMoKSx0aGlzLmFwcGx5T3B0aW9ucygpLHRoaXMuX2xheWVyLm9uKFwicmVtb3ZlXCIsdGhpcy5kaXNhYmxlLHRoaXMpLHRoaXMuX3VwZGF0ZUhpZGRlblBvbHlDaXJjbGUoKSx0aGlzLl9maXJlRW5hYmxlKCkpOnRoaXMuZGlzYWJsZSgpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7aWYodGhpcy5lbmFibGVkKCkmJiF0aGlzLl9kcmFnZ2luZyl7dGhpcy5fY2VudGVyTWFya2VyLm9mZihcImRyYWdzdGFydFwiLHRoaXMuX29uQ2lyY2xlRHJhZ1N0YXJ0LHRoaXMpLHRoaXMuX2NlbnRlck1hcmtlci5vZmYoXCJkcmFnXCIsdGhpcy5fb25DaXJjbGVEcmFnLHRoaXMpLHRoaXMuX2NlbnRlck1hcmtlci5vZmYoXCJkcmFnZW5kXCIsdGhpcy5fb25DaXJjbGVEcmFnRW5kLHRoaXMpLHRoaXMuX291dGVyTWFya2VyLm9mZihcImRyYWdcIix0aGlzLl9oYW5kbGVPdXRlck1hcmtlclNuYXBwaW5nLHRoaXMpLHRoaXMuX2xheWVyLm9mZihcInJlbW92ZVwiLHRoaXMuZGlzYWJsZSx0aGlzKSx0aGlzLl9lbmFibGVkPSExLHRoaXMuX2hlbHBlckxheWVycy5jbGVhckxheWVycygpO3ZhciB0PXRoaXMuX2xheWVyLl9wYXRoP3RoaXMuX2xheWVyLl9wYXRoOnRoaXMuX2xheWVyLl9yZW5kZXJlci5fY29udGFpbmVyO0wuRG9tVXRpbC5yZW1vdmVDbGFzcyh0LFwibGVhZmxldC1wbS1kcmFnZ2FibGVcIiksdGhpcy5fbGF5ZXJFZGl0ZWQmJnRoaXMuX2ZpcmVVcGRhdGUoKSx0aGlzLl9sYXllckVkaXRlZD0hMSx0aGlzLl9maXJlRGlzYWJsZSgpfX0sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkfSx0b2dnbGVFZGl0OmZ1bmN0aW9uKHQpe3RoaXMuZW5hYmxlZCgpP3RoaXMuZGlzYWJsZSgpOnRoaXMuZW5hYmxlKHQpfSxfaW5pdE1hcmtlcnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXA7dGhpcy5faGVscGVyTGF5ZXJzJiZ0aGlzLl9oZWxwZXJMYXllcnMuY2xlYXJMYXllcnMoKSx0aGlzLl9oZWxwZXJMYXllcnM9bmV3IEwuTGF5ZXJHcm91cCx0aGlzLl9oZWxwZXJMYXllcnMuX3BtVGVtcExheWVyPSEwLHRoaXMuX2hlbHBlckxheWVycy5hZGRUbyh0KTt2YXIgZT10aGlzLl9sYXllci5nZXRMYXRMbmcoKSxpPXRoaXMuX2xheWVyLl9yYWRpdXMsbj10aGlzLl9nZXRMYXRMbmdPbkNpcmNsZShlLGkpO3RoaXMuX2NlbnRlck1hcmtlcj10aGlzLl9jcmVhdGVDZW50ZXJNYXJrZXIoZSksdGhpcy5fb3V0ZXJNYXJrZXI9dGhpcy5fY3JlYXRlT3V0ZXJNYXJrZXIobiksdGhpcy5fbWFya2Vycz1bdGhpcy5fY2VudGVyTWFya2VyLHRoaXMuX291dGVyTWFya2VyXSx0aGlzLl9jcmVhdGVIaW50TGluZSh0aGlzLl9jZW50ZXJNYXJrZXIsdGhpcy5fb3V0ZXJNYXJrZXIpfSxhcHBseU9wdGlvbnM6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuc25hcHBhYmxlPyh0aGlzLl9pbml0U25hcHBhYmxlTWFya2VycygpLHRoaXMuX291dGVyTWFya2VyLm9uKFwiZHJhZ1wiLHRoaXMuX2hhbmRsZU91dGVyTWFya2VyU25hcHBpbmcsdGhpcyksdGhpcy5fb3V0ZXJNYXJrZXIub24oXCJtb3ZlXCIsdGhpcy5fc3luY0hpbnRMaW5lLHRoaXMpLHRoaXMuX291dGVyTWFya2VyLm9uKFwibW92ZVwiLHRoaXMuX3N5bmNDaXJjbGVSYWRpdXMsdGhpcyksdGhpcy5fY2VudGVyTWFya2VyLm9uKFwibW92ZVwiLHRoaXMuX21vdmVDaXJjbGUsdGhpcykpOnRoaXMuX2Rpc2FibGVTbmFwcGluZygpfSxfY3JlYXRlSGludExpbmU6ZnVuY3Rpb24odCxlKXt2YXIgaT10LmdldExhdExuZygpLG49ZS5nZXRMYXRMbmcoKTt0aGlzLl9oaW50bGluZT1MLnBvbHlsaW5lKFtpLG5dLHRoaXMub3B0aW9ucy5oaW50bGluZVN0eWxlKSx0aGlzLl9zZXRQYW5lKHRoaXMuX2hpbnRsaW5lLFwibGF5ZXJQYW5lXCIpLHRoaXMuX2hpbnRsaW5lLl9wbVRlbXBMYXllcj0hMCx0aGlzLl9oZWxwZXJMYXllcnMuYWRkTGF5ZXIodGhpcy5faGludGxpbmUpfSxfY3JlYXRlQ2VudGVyTWFya2VyOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2NyZWF0ZU1hcmtlcih0KTtyZXR1cm4gTC5Eb21VdGlsLmFkZENsYXNzKGUuX2ljb24sXCJsZWFmbGV0LXBtLWRyYWdnYWJsZVwiKSxlLm9uKFwiZHJhZ1wiLHRoaXMuX21vdmVDaXJjbGUsdGhpcyksZS5vbihcImRyYWdzdGFydFwiLHRoaXMuX29uQ2lyY2xlRHJhZ1N0YXJ0LHRoaXMpLGUub24oXCJkcmFnXCIsdGhpcy5fb25DaXJjbGVEcmFnLHRoaXMpLGUub24oXCJkcmFnZW5kXCIsdGhpcy5fb25DaXJjbGVEcmFnRW5kLHRoaXMpLGV9LF9jcmVhdGVPdXRlck1hcmtlcjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9jcmVhdGVNYXJrZXIodCk7cmV0dXJuIGUub24oXCJkcmFnXCIsdGhpcy5fcmVzaXplQ2lyY2xlLHRoaXMpLGV9LF9jcmVhdGVNYXJrZXI6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEwuTWFya2VyKHQse2RyYWdnYWJsZTohMCxpY29uOkwuZGl2SWNvbih7Y2xhc3NOYW1lOlwibWFya2VyLWljb25cIn0pfSk7cmV0dXJuIHRoaXMuX3NldFBhbmUoZSxcInZlcnRleFBhbmVcIiksZS5fb3JpZ0xhdExuZz10LGUuX3BtVGVtcExheWVyPSEwLGUub24oXCJkcmFnc3RhcnRcIix0aGlzLl9vbk1hcmtlckRyYWdTdGFydCx0aGlzKSxlLm9uKFwiZHJhZ1wiLHRoaXMuX29uTWFya2VyRHJhZyx0aGlzKSxlLm9uKFwiZHJhZ2VuZFwiLHRoaXMuX29uTWFya2VyRHJhZ0VuZCx0aGlzKSx0aGlzLl9oZWxwZXJMYXllcnMuYWRkTGF5ZXIoZSksZX0sX3Jlc2l6ZUNpcmNsZTpmdW5jdGlvbigpe3RoaXMuX291dGVyTWFya2VyLnNldExhdExuZyh0aGlzLl9nZXROZXdEZXN0aW5hdGlvbk9mT3V0ZXJNYXJrZXIoKSksdGhpcy5fc3luY0hpbnRMaW5lKCksdGhpcy5fc3luY0NpcmNsZVJhZGl1cygpfSxfbW92ZUNpcmNsZTpmdW5jdGlvbih0KXtpZighdC50YXJnZXQuX2NhbmNlbERyYWdFdmVudENoYWluKXt2YXIgZT10LmxhdGxuZzt0aGlzLl9sYXllci5zZXRMYXRMbmcoZSk7dmFyIGk9dGhpcy5fbGF5ZXIuX3JhZGl1cyxuPXRoaXMuX2dldExhdExuZ09uQ2lyY2xlKGUsaSk7dGhpcy5fb3V0ZXJNYXJrZXIuX2xhdGxuZz1uLHRoaXMuX291dGVyTWFya2VyLnVwZGF0ZSgpLHRoaXMuX3N5bmNIaW50TGluZSgpLHRoaXMuX3VwZGF0ZUhpZGRlblBvbHlDaXJjbGUoKSx0aGlzLl9maXJlQ2VudGVyUGxhY2VkKFwiRWRpdFwiKSx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldExhdExuZygpLFwiRWRpdFwiKX19LF9zeW5jQ2lyY2xlUmFkaXVzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fY2VudGVyTWFya2VyLmdldExhdExuZygpLGU9dGhpcy5fb3V0ZXJNYXJrZXIuZ2V0TGF0TG5nKCksaT10aGlzLl9tYXAuZGlzdGFuY2UodCxlKTt0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlJiZpPHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGU/dGhpcy5fbGF5ZXIuc2V0UmFkaXVzKHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGUpOnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGUmJmk+dGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZT90aGlzLl9sYXllci5zZXRSYWRpdXModGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZSk6dGhpcy5fbGF5ZXIuc2V0UmFkaXVzKGkpLHRoaXMuX3VwZGF0ZUhpZGRlblBvbHlDaXJjbGUoKSx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldExhdExuZygpLFwiRWRpdFwiKX0sX3N5bmNIaW50TGluZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NlbnRlck1hcmtlci5nZXRMYXRMbmcoKSxlPXRoaXMuX291dGVyTWFya2VyLmdldExhdExuZygpO3RoaXMuX2hpbnRsaW5lLnNldExhdExuZ3MoW3QsZV0pfSxfZGlzYWJsZVNuYXBwaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLl9tYXJrZXJzLmZvckVhY2goKGZ1bmN0aW9uKGUpe2Uub2ZmKFwibW92ZVwiLHQuX3N5bmNIaW50TGluZSx0KSxlLm9mZihcIm1vdmVcIix0Ll9zeW5jQ2lyY2xlUmFkaXVzLHQpLGUub2ZmKFwiZHJhZ1wiLHQuX2hhbmRsZVNuYXBwaW5nLHQpLGUub2ZmKFwiZHJhZ2VuZFwiLHQuX2NsZWFudXBTbmFwcGluZyx0KX0pKSx0aGlzLl9sYXllci5vZmYoXCJwbTpkcmFnc3RhcnRcIix0aGlzLl91bnNuYXAsdGhpcyl9LF9vbk1hcmtlckRyYWdTdGFydDpmdW5jdGlvbih0KXt0aGlzLl92ZXJ0ZXhWYWxpZGF0aW9uKFwibW92ZVwiLHQpJiZ0aGlzLl9maXJlTWFya2VyRHJhZ1N0YXJ0KHQpfSxfb25NYXJrZXJEcmFnOmZ1bmN0aW9uKHQpe3ZhciBlPXQudGFyZ2V0O3RoaXMuX3ZlcnRleFZhbGlkYXRpb25EcmFnKGUpJiZ0aGlzLl9maXJlTWFya2VyRHJhZyh0KX0sX29uTWFya2VyRHJhZ0VuZDpmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldDt0aGlzLl92ZXJ0ZXhWYWxpZGF0aW9uRHJhZ0VuZChlKSYmKHRoaXMuX2ZpcmVFZGl0KCksdGhpcy5fbGF5ZXJFZGl0ZWQ9ITAsdGhpcy5fZmlyZU1hcmtlckRyYWdFbmQodCkpfSxfb25DaXJjbGVEcmFnU3RhcnQ6ZnVuY3Rpb24odCl7dGhpcy5fdmVydGV4VmFsaWRhdGlvbkRyYWcodC50YXJnZXQpPyhkZWxldGUgdGhpcy5fdmVydGV4VmFsaWRhdGlvblJlc2V0LHRoaXMuX2ZpcmVEcmFnU3RhcnQoKSk6dGhpcy5fdmVydGV4VmFsaWRhdGlvblJlc2V0PSEwfSxfb25DaXJjbGVEcmFnOmZ1bmN0aW9uKHQpe3RoaXMuX3ZlcnRleFZhbGlkYXRpb25SZXNldHx8dGhpcy5fZmlyZURyYWcodCl9LF9vbkNpcmNsZURyYWdFbmQ6ZnVuY3Rpb24oKXt0aGlzLl92ZXJ0ZXhWYWxpZGF0aW9uUmVzZXQ/ZGVsZXRlIHRoaXMuX3ZlcnRleFZhbGlkYXRpb25SZXNldDp0aGlzLl9maXJlRHJhZ0VuZCgpfSxfdXBkYXRlSGlkZGVuUG9seUNpcmNsZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcCYmdGhpcy5fbWFwLnBtLl9pc0NSU1NpbXBsZSgpO3RoaXMuX2hpZGRlblBvbHlDaXJjbGU/dGhpcy5faGlkZGVuUG9seUNpcmNsZS5zZXRMYXRMbmdzKEwuUE0uVXRpbHMuY2lyY2xlVG9Qb2x5Z29uKHRoaXMuX2xheWVyLDIwMCwhdCkuZ2V0TGF0TG5ncygpKTp0aGlzLl9oaWRkZW5Qb2x5Q2lyY2xlPUwuUE0uVXRpbHMuY2lyY2xlVG9Qb2x5Z29uKHRoaXMuX2xheWVyLDIwMCwhdCksdGhpcy5faGlkZGVuUG9seUNpcmNsZS5fcGFyZW50Q29weXx8KHRoaXMuX2hpZGRlblBvbHlDaXJjbGUuX3BhcmVudENvcHk9dGhpcy5fbGF5ZXIpfSxfZ2V0TGF0TG5nT25DaXJjbGU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLl9tYXAucHJvamVjdCh0KSxuPUwucG9pbnQoaS54K2UsaS55KTtyZXR1cm4gdGhpcy5fbWFwLnVucHJvamVjdChuKX0sX2dldE5ld0Rlc3RpbmF0aW9uT2ZPdXRlck1hcmtlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NlbnRlck1hcmtlci5nZXRMYXRMbmcoKSxlPXRoaXMuX291dGVyTWFya2VyLmdldExhdExuZygpLGk9dGhpcy5fbWFwLmRpc3RhbmNlKHQsZSk7cmV0dXJuIHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGUmJmk8dGhpcy5vcHRpb25zLm1pblJhZGl1c0NpcmNsZT9lPXoodGhpcy5fbWFwLHQsZSx0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlKTp0aGlzLm9wdGlvbnMubWF4UmFkaXVzQ2lyY2xlJiZpPnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGUmJihlPXoodGhpcy5fbWFwLHQsZSx0aGlzLm9wdGlvbnMubWF4UmFkaXVzQ2lyY2xlKSksZX0sX2hhbmRsZU91dGVyTWFya2VyU25hcHBpbmc6ZnVuY3Rpb24oKXtpZih0aGlzLl9vdXRlck1hcmtlci5fc25hcHBlZCl7dmFyIHQ9dGhpcy5fY2VudGVyTWFya2VyLmdldExhdExuZygpLGU9dGhpcy5fb3V0ZXJNYXJrZXIuZ2V0TGF0TG5nKCksaT10aGlzLl9tYXAuZGlzdGFuY2UodCxlKTsodGhpcy5vcHRpb25zLm1pblJhZGl1c0NpcmNsZSYmaTx0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlfHx0aGlzLm9wdGlvbnMubWF4UmFkaXVzQ2lyY2xlJiZpPnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGUpJiZ0aGlzLl9vdXRlck1hcmtlci5zZXRMYXRMbmcodGhpcy5fb3V0ZXJNYXJrZXIuX29yZ0xhdExuZyl9dGhpcy5fb3V0ZXJNYXJrZXIuc2V0TGF0TG5nKHRoaXMuX2dldE5ld0Rlc3RpbmF0aW9uT2ZPdXRlck1hcmtlcigpKX19KSx4ZS5DaXJjbGVNYXJrZXI9eGUuZXh0ZW5kKHtfc2hhcGU6XCJDaXJjbGVNYXJrZXJcIixpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX2xheWVyPXQsdGhpcy5fZW5hYmxlZD0hMSx0aGlzLl91cGRhdGVIaWRkZW5Qb2x5Q2lyY2xlKCl9LGVuYWJsZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7ZHJhZ2dhYmxlOiEwLHNuYXBwYWJsZTohMH07TC5VdGlsLnNldE9wdGlvbnModGhpcyx0KSx0aGlzLm9wdGlvbnMuYWxsb3dFZGl0aW5nJiZ0aGlzLl9sYXllci5fbWFwPyh0aGlzLl9tYXA9dGhpcy5fbGF5ZXIuX21hcCx0aGlzLmVuYWJsZWQoKSYmdGhpcy5kaXNhYmxlKCksdGhpcy5hcHBseU9wdGlvbnMoKSx0aGlzLl9sYXllci5vbihcInJlbW92ZVwiLHRoaXMuZGlzYWJsZSx0aGlzKSx0aGlzLl9lbmFibGVkPSEwLHRoaXMuX2xheWVyLm9uKFwicG06ZHJhZ3N0YXJ0XCIsdGhpcy5fb25EcmFnU3RhcnQsdGhpcyksdGhpcy5fbGF5ZXIub24oXCJwbTpkcmFnXCIsdGhpcy5fb25NYXJrZXJEcmFnLHRoaXMpLHRoaXMuX2xheWVyLm9uKFwicG06ZHJhZ2VuZFwiLHRoaXMuX29uTWFya2VyRHJhZ0VuZCx0aGlzKSx0aGlzLl91cGRhdGVIaWRkZW5Qb2x5Q2lyY2xlKCksdGhpcy5fZmlyZUVuYWJsZSgpKTp0aGlzLmRpc2FibGUoKX0sZGlzYWJsZTpmdW5jdGlvbigpe3RoaXMuX2RyYWdnaW5nfHwodGhpcy5faGVscGVyTGF5ZXJzJiZ0aGlzLl9oZWxwZXJMYXllcnMuY2xlYXJMYXllcnMoKSx0aGlzLl9tYXB8fCh0aGlzLl9tYXA9dGhpcy5fbGF5ZXIuX21hcCksdGhpcy5fbWFwfHwodGhpcy5vcHRpb25zLmVkaXRhYmxlPyh0aGlzLl9tYXAub2ZmKFwibW92ZVwiLHRoaXMuX3N5bmNNYXJrZXJzLHRoaXMpLHRoaXMuX291dGVyTWFya2VyJiZ0aGlzLl9vdXRlck1hcmtlci5vbihcImRyYWdcIix0aGlzLl9oYW5kbGVPdXRlck1hcmtlclNuYXBwaW5nLHRoaXMpKTp0aGlzLl9tYXAub2ZmKFwibW92ZVwiLHRoaXMuX3VwZGF0ZUhpZGRlblBvbHlDaXJjbGUsdGhpcykpLHRoaXMuZGlzYWJsZUxheWVyRHJhZygpLHRoaXMuX2xheWVyLm9mZihcImNvbnRleHRtZW51XCIsdGhpcy5fcmVtb3ZlTWFya2VyLHRoaXMpLHRoaXMuX2xheWVyLm9mZihcInJlbW92ZVwiLHRoaXMuZGlzYWJsZSx0aGlzKSx0aGlzLmVuYWJsZWQoKSYmKHRoaXMuX2xheWVyRWRpdGVkJiZ0aGlzLl9maXJlVXBkYXRlKCksdGhpcy5fbGF5ZXJFZGl0ZWQ9ITEsdGhpcy5fZmlyZURpc2FibGUoKSksdGhpcy5fZW5hYmxlZD0hMSl9LGVuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZW5hYmxlZH0sdG9nZ2xlRWRpdDpmdW5jdGlvbih0KXt0aGlzLmVuYWJsZWQoKT90aGlzLmRpc2FibGUoKTp0aGlzLmVuYWJsZSh0KX0sYXBwbHlPcHRpb25zOmZ1bmN0aW9uKCl7IXRoaXMub3B0aW9ucy5lZGl0YWJsZSYmdGhpcy5vcHRpb25zLmRyYWdnYWJsZT90aGlzLmVuYWJsZUxheWVyRHJhZygpOnRoaXMuZGlzYWJsZUxheWVyRHJhZygpLHRoaXMub3B0aW9ucy5lZGl0YWJsZT8odGhpcy5faW5pdE1hcmtlcnMoKSx0aGlzLl9tYXAub24oXCJtb3ZlXCIsdGhpcy5fc3luY01hcmtlcnMsdGhpcykpOnRoaXMuX21hcC5vbihcIm1vdmVcIix0aGlzLl91cGRhdGVIaWRkZW5Qb2x5Q2lyY2xlLHRoaXMpLHRoaXMub3B0aW9ucy5zbmFwcGFibGU/dGhpcy5vcHRpb25zLmVkaXRhYmxlPyh0aGlzLl9pbml0U25hcHBhYmxlTWFya2VycygpLHRoaXMuX2NlbnRlck1hcmtlci5vbihcImRyYWdcIix0aGlzLl9tb3ZlQ2lyY2xlLHRoaXMpLHRoaXMub3B0aW9ucy5lZGl0YWJsZSYmdGhpcy5fb3V0ZXJNYXJrZXIub24oXCJkcmFnXCIsdGhpcy5faGFuZGxlT3V0ZXJNYXJrZXJTbmFwcGluZyx0aGlzKSx0aGlzLl9vdXRlck1hcmtlci5vbihcIm1vdmVcIix0aGlzLl9zeW5jSGludExpbmUsdGhpcyksdGhpcy5fb3V0ZXJNYXJrZXIub24oXCJtb3ZlXCIsdGhpcy5fc3luY0NpcmNsZVJhZGl1cyx0aGlzKSk6dGhpcy5faW5pdFNuYXBwYWJsZU1hcmtlcnNEcmFnKCk6dGhpcy5vcHRpb25zLmVkaXRhYmxlP3RoaXMuX2Rpc2FibGVTbmFwcGluZygpOnRoaXMuX2Rpc2FibGVTbmFwcGluZ0RyYWcoKSx0aGlzLm9wdGlvbnMucHJldmVudE1hcmtlclJlbW92YWx8fHRoaXMuX2xheWVyLm9uKFwiY29udGV4dG1lbnVcIix0aGlzLl9yZW1vdmVNYXJrZXIsdGhpcyl9LF9pbml0TWFya2VyczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcDt0aGlzLl9oZWxwZXJMYXllcnMmJnRoaXMuX2hlbHBlckxheWVycy5jbGVhckxheWVycygpLHRoaXMuX2hlbHBlckxheWVycz1uZXcgTC5MYXllckdyb3VwLHRoaXMuX2hlbHBlckxheWVycy5fcG1UZW1wTGF5ZXI9ITAsdGhpcy5faGVscGVyTGF5ZXJzLmFkZFRvKHQpO3ZhciBlPXRoaXMuX2xheWVyLmdldExhdExuZygpLGk9dGhpcy5fbGF5ZXIuX3JhZGl1cyxuPXRoaXMuX2dldExhdExuZ09uQ2lyY2xlKGUsaSk7dGhpcy5fY2VudGVyTWFya2VyPXRoaXMuX2NyZWF0ZUNlbnRlck1hcmtlcihlKSx0aGlzLl9vdXRlck1hcmtlcj10aGlzLl9jcmVhdGVPdXRlck1hcmtlcihuKSx0aGlzLl9tYXJrZXJzPVt0aGlzLl9jZW50ZXJNYXJrZXIsdGhpcy5fb3V0ZXJNYXJrZXJdLHRoaXMuX2NyZWF0ZUhpbnRMaW5lKHRoaXMuX2NlbnRlck1hcmtlcix0aGlzLl9vdXRlck1hcmtlcil9LF9nZXRMYXRMbmdPbkNpcmNsZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuX21hcC5wcm9qZWN0KHQpLG49TC5wb2ludChpLngrZSxpLnkpO3JldHVybiB0aGlzLl9tYXAudW5wcm9qZWN0KG4pfSxfY3JlYXRlSGludExpbmU6ZnVuY3Rpb24odCxlKXt2YXIgaT10LmdldExhdExuZygpLG49ZS5nZXRMYXRMbmcoKTt0aGlzLl9oaW50bGluZT1MLnBvbHlsaW5lKFtpLG5dLHRoaXMub3B0aW9ucy5oaW50bGluZVN0eWxlKSx0aGlzLl9zZXRQYW5lKHRoaXMuX2hpbnRsaW5lLFwibGF5ZXJQYW5lXCIpLHRoaXMuX2hpbnRsaW5lLl9wbVRlbXBMYXllcj0hMCx0aGlzLl9oZWxwZXJMYXllcnMuYWRkTGF5ZXIodGhpcy5faGludGxpbmUpfSxfY3JlYXRlQ2VudGVyTWFya2VyOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2NyZWF0ZU1hcmtlcih0KTtyZXR1cm4gdGhpcy5vcHRpb25zLmRyYWdnYWJsZT9MLkRvbVV0aWwuYWRkQ2xhc3MoZS5faWNvbixcImxlYWZsZXQtcG0tZHJhZ2dhYmxlXCIpOmUuZHJhZ2dpbmcuZGlzYWJsZSgpLGV9LF9jcmVhdGVPdXRlck1hcmtlcjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9jcmVhdGVNYXJrZXIodCk7cmV0dXJuIGUub24oXCJkcmFnXCIsdGhpcy5fcmVzaXplQ2lyY2xlLHRoaXMpLGV9LF9jcmVhdGVNYXJrZXI6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEwuTWFya2VyKHQse2RyYWdnYWJsZTohMCxpY29uOkwuZGl2SWNvbih7Y2xhc3NOYW1lOlwibWFya2VyLWljb25cIn0pfSk7cmV0dXJuIHRoaXMuX3NldFBhbmUoZSxcInZlcnRleFBhbmVcIiksZS5fb3JpZ0xhdExuZz10LGUuX3BtVGVtcExheWVyPSEwLGUub24oXCJkcmFnc3RhcnRcIix0aGlzLl9vbk1hcmtlckRyYWdTdGFydCx0aGlzKSxlLm9uKFwiZHJhZ1wiLHRoaXMuX29uTWFya2VyRHJhZyx0aGlzKSxlLm9uKFwiZHJhZ2VuZFwiLHRoaXMuX29uTWFya2VyRHJhZ0VuZCx0aGlzKSx0aGlzLl9oZWxwZXJMYXllcnMuYWRkTGF5ZXIoZSksZX0sX21vdmVDaXJjbGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9jZW50ZXJNYXJrZXIuZ2V0TGF0TG5nKCk7dGhpcy5fbGF5ZXIuc2V0TGF0TG5nKHQpO3ZhciBlPXRoaXMuX2xheWVyLl9yYWRpdXMsaT10aGlzLl9nZXRMYXRMbmdPbkNpcmNsZSh0LGUpO3RoaXMuX291dGVyTWFya2VyLl9sYXRsbmc9aSx0aGlzLl9vdXRlck1hcmtlci51cGRhdGUoKSx0aGlzLl9zeW5jSGludExpbmUoKSx0aGlzLl91cGRhdGVIaWRkZW5Qb2x5Q2lyY2xlKCksdGhpcy5fZmlyZUNlbnRlclBsYWNlZChcIkVkaXRcIiksdGhpcy5fZmlyZUNoYW5nZSh0aGlzLl9sYXllci5nZXRMYXRMbmcoKSxcIkVkaXRcIil9LF9zeW5jTWFya2VyczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2xheWVyLmdldExhdExuZygpLGU9dGhpcy5fbGF5ZXIuX3JhZGl1cyxpPXRoaXMuX2dldExhdExuZ09uQ2lyY2xlKHQsZSk7dGhpcy5fb3V0ZXJNYXJrZXIuc2V0TGF0TG5nKGkpLHRoaXMuX2NlbnRlck1hcmtlci5zZXRMYXRMbmcodCksdGhpcy5fc3luY0hpbnRMaW5lKCksdGhpcy5fdXBkYXRlSGlkZGVuUG9seUNpcmNsZSgpfSxfcmVzaXplQ2lyY2xlOmZ1bmN0aW9uKCl7dGhpcy5fb3V0ZXJNYXJrZXIuc2V0TGF0TG5nKHRoaXMuX2dldE5ld0Rlc3RpbmF0aW9uT2ZPdXRlck1hcmtlcigpKSx0aGlzLl9zeW5jSGludExpbmUoKSx0aGlzLl9zeW5jQ2lyY2xlUmFkaXVzKCl9LF9zeW5jQ2lyY2xlUmFkaXVzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fY2VudGVyTWFya2VyLmdldExhdExuZygpLGU9dGhpcy5fb3V0ZXJNYXJrZXIuZ2V0TGF0TG5nKCksaT10aGlzLl9tYXAucHJvamVjdCh0KS5kaXN0YW5jZVRvKHRoaXMuX21hcC5wcm9qZWN0KGUpKTt0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlTWFya2VyJiZpPHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGVNYXJrZXI/dGhpcy5fbGF5ZXIuc2V0UmFkaXVzKHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGVNYXJrZXIpOnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGVNYXJrZXImJmk+dGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZU1hcmtlcj90aGlzLl9sYXllci5zZXRSYWRpdXModGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZU1hcmtlcik6dGhpcy5fbGF5ZXIuc2V0UmFkaXVzKGkpLHRoaXMuX3VwZGF0ZUhpZGRlblBvbHlDaXJjbGUoKSx0aGlzLl9maXJlQ2hhbmdlKHRoaXMuX2xheWVyLmdldExhdExuZygpLFwiRWRpdFwiKX0sX3N5bmNIaW50TGluZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NlbnRlck1hcmtlci5nZXRMYXRMbmcoKSxlPXRoaXMuX291dGVyTWFya2VyLmdldExhdExuZygpO3RoaXMuX2hpbnRsaW5lLnNldExhdExuZ3MoW3QsZV0pfSxfcmVtb3ZlTWFya2VyOmZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLmVkaXRhYmxlJiZ0aGlzLmRpc2FibGUoKSx0aGlzLl9sYXllci5yZW1vdmUoKSx0aGlzLl9maXJlUmVtb3ZlKHRoaXMuX2xheWVyKSx0aGlzLl9maXJlUmVtb3ZlKHRoaXMuX21hcCx0aGlzLl9sYXllcil9LF9vbkRyYWdTdGFydDpmdW5jdGlvbigpe3RoaXMuX21hcC5wbS5EcmF3LkNpcmNsZU1hcmtlci5fbGF5ZXJJc0RyYWdnaW5nPSEwfSxfb25NYXJrZXJEcmFnU3RhcnQ6ZnVuY3Rpb24odCl7dGhpcy5fdmVydGV4VmFsaWRhdGlvbihcIm1vdmVcIix0KSYmdGhpcy5fZmlyZU1hcmtlckRyYWdTdGFydCh0KX0sX29uTWFya2VyRHJhZzpmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldDtlIGluc3RhbmNlb2YgTC5NYXJrZXImJiF0aGlzLl92ZXJ0ZXhWYWxpZGF0aW9uRHJhZyhlKXx8dGhpcy5fZmlyZU1hcmtlckRyYWcodCl9LF9vbk1hcmtlckRyYWdFbmQ6ZnVuY3Rpb24odCl7dGhpcy5fbWFwLnBtLkRyYXcuQ2lyY2xlTWFya2VyLl9sYXllcklzRHJhZ2dpbmc9ITE7dmFyIGU9dC50YXJnZXQ7dGhpcy5fdmVydGV4VmFsaWRhdGlvbkRyYWdFbmQoZSkmJih0aGlzLm9wdGlvbnMuZWRpdGFibGUmJih0aGlzLl9maXJlRWRpdCgpLHRoaXMuX2xheWVyRWRpdGVkPSEwKSx0aGlzLl9maXJlTWFya2VyRHJhZ0VuZCh0KSl9LF9pbml0U25hcHBhYmxlTWFya2Vyc0RyYWc6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9sYXllcjt0aGlzLm9wdGlvbnMuc25hcERpc3RhbmNlPXRoaXMub3B0aW9ucy5zbmFwRGlzdGFuY2V8fDMwLHRoaXMub3B0aW9ucy5zbmFwU2VnbWVudD10aGlzLm9wdGlvbnMuc25hcFNlZ21lbnQ9PT11bmRlZmluZWR8fHRoaXMub3B0aW9ucy5zbmFwU2VnbWVudCx0Lm9mZihcInBtOmRyYWdcIix0aGlzLl9oYW5kbGVTbmFwcGluZyx0aGlzKSx0Lm9uKFwicG06ZHJhZ1wiLHRoaXMuX2hhbmRsZVNuYXBwaW5nLHRoaXMpLHQub2ZmKFwicG06ZHJhZ2VuZFwiLHRoaXMuX2NsZWFudXBTbmFwcGluZyx0aGlzKSx0Lm9uKFwicG06ZHJhZ2VuZFwiLHRoaXMuX2NsZWFudXBTbmFwcGluZyx0aGlzKSx0Lm9mZihcInBtOmRyYWdzdGFydFwiLHRoaXMuX3Vuc25hcCx0aGlzKSx0Lm9uKFwicG06ZHJhZ3N0YXJ0XCIsdGhpcy5fdW5zbmFwLHRoaXMpfSxfZGlzYWJsZVNuYXBwaW5nRHJhZzpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2xheWVyO3Qub2ZmKFwicG06ZHJhZ1wiLHRoaXMuX2hhbmRsZVNuYXBwaW5nLHRoaXMpLHQub2ZmKFwicG06ZHJhZ2VuZFwiLHRoaXMuX2NsZWFudXBTbmFwcGluZyx0aGlzKSx0Lm9mZihcInBtOmRyYWdzdGFydFwiLHRoaXMuX3Vuc25hcCx0aGlzKX0sX3VwZGF0ZUhpZGRlblBvbHlDaXJjbGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9sYXllci5fbWFwfHx0aGlzLl9tYXA7aWYodCl7dmFyIGU9TC5QTS5VdGlscy5weFJhZGl1c1RvTWV0ZXJSYWRpdXModGhpcy5fbGF5ZXIuZ2V0UmFkaXVzKCksdCx0aGlzLl9sYXllci5nZXRMYXRMbmcoKSksaT1MLmNpcmNsZSh0aGlzLl9sYXllci5nZXRMYXRMbmcoKSx0aGlzLl9sYXllci5vcHRpb25zKTtpLnNldFJhZGl1cyhlKTt2YXIgbj10JiZ0LnBtLl9pc0NSU1NpbXBsZSgpO3RoaXMuX2hpZGRlblBvbHlDaXJjbGU/dGhpcy5faGlkZGVuUG9seUNpcmNsZS5zZXRMYXRMbmdzKEwuUE0uVXRpbHMuY2lyY2xlVG9Qb2x5Z29uKGksMjAwLCFuKS5nZXRMYXRMbmdzKCkpOnRoaXMuX2hpZGRlblBvbHlDaXJjbGU9TC5QTS5VdGlscy5jaXJjbGVUb1BvbHlnb24oaSwyMDAsIW4pLHRoaXMuX2hpZGRlblBvbHlDaXJjbGUuX3BhcmVudENvcHl8fCh0aGlzLl9oaWRkZW5Qb2x5Q2lyY2xlLl9wYXJlbnRDb3B5PXRoaXMuX2xheWVyKX19LF9nZXROZXdEZXN0aW5hdGlvbk9mT3V0ZXJNYXJrZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9jZW50ZXJNYXJrZXIuZ2V0TGF0TG5nKCksZT10aGlzLl9vdXRlck1hcmtlci5nZXRMYXRMbmcoKSxpPXRoaXMuX21hcC5wcm9qZWN0KHQpLmRpc3RhbmNlVG8odGhpcy5fbWFwLnByb2plY3QoZSkpO3JldHVybiB0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlTWFya2VyJiZpPHRoaXMub3B0aW9ucy5taW5SYWRpdXNDaXJjbGVNYXJrZXI/ZT16KHRoaXMuX21hcCx0LGUsTC5QTS5VdGlscy5weFJhZGl1c1RvTWV0ZXJSYWRpdXModGhpcy5vcHRpb25zLm1pblJhZGl1c0NpcmNsZU1hcmtlcix0aGlzLl9tYXAsdCkpOnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGVNYXJrZXImJmk+dGhpcy5vcHRpb25zLm1heFJhZGl1c0NpcmNsZU1hcmtlciYmKGU9eih0aGlzLl9tYXAsdCxlLEwuUE0uVXRpbHMucHhSYWRpdXNUb01ldGVyUmFkaXVzKHRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGVNYXJrZXIsdGhpcy5fbWFwLHQpKSksZX0sX2hhbmRsZU91dGVyTWFya2VyU25hcHBpbmc6ZnVuY3Rpb24oKXtpZih0aGlzLl9vdXRlck1hcmtlci5fc25hcHBlZCl7dmFyIHQ9dGhpcy5fY2VudGVyTWFya2VyLmdldExhdExuZygpLGU9dGhpcy5fb3V0ZXJNYXJrZXIuZ2V0TGF0TG5nKCksaT10aGlzLl9tYXAucHJvamVjdCh0KS5kaXN0YW5jZVRvKHRoaXMuX21hcC5wcm9qZWN0KGUpKTsodGhpcy5vcHRpb25zLm1pblJhZGl1c0NpcmNsZU1hcmtlciYmaTx0aGlzLm9wdGlvbnMubWluUmFkaXVzQ2lyY2xlTWFya2VyfHx0aGlzLm9wdGlvbnMubWF4UmFkaXVzQ2lyY2xlTWFya2VyJiZpPnRoaXMub3B0aW9ucy5tYXhSYWRpdXNDaXJjbGVNYXJrZXIpJiZ0aGlzLl9vdXRlck1hcmtlci5zZXRMYXRMbmcodGhpcy5fb3V0ZXJNYXJrZXIuX29yZ0xhdExuZyl9dGhpcy5fb3V0ZXJNYXJrZXIuc2V0TGF0TG5nKHRoaXMuX2dldE5ld0Rlc3RpbmF0aW9uT2ZPdXRlck1hcmtlcigpKX19KSx4ZS5JbWFnZU92ZXJsYXk9eGUuZXh0ZW5kKHtfc2hhcGU6XCJJbWFnZU92ZXJsYXlcIixpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX2xheWVyPXQsdGhpcy5fZW5hYmxlZD0hMX0sdG9nZ2xlRWRpdDpmdW5jdGlvbih0KXt0aGlzLmVuYWJsZWQoKT90aGlzLmRpc2FibGUoKTp0aGlzLmVuYWJsZSh0KX0sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkfSxlbmFibGU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e2RyYWdnYWJsZTohMCxzbmFwcGFibGU6ITB9O0wuVXRpbC5zZXRPcHRpb25zKHRoaXMsdCksdGhpcy5fbWFwPXRoaXMuX2xheWVyLl9tYXAsdGhpcy5fbWFwJiYodGhpcy5vcHRpb25zLmFsbG93RWRpdGluZz8odGhpcy5lbmFibGVkKCl8fHRoaXMuZGlzYWJsZSgpLHRoaXMuZW5hYmxlTGF5ZXJEcmFnKCksdGhpcy5fbGF5ZXIub24oXCJyZW1vdmVcIix0aGlzLmRpc2FibGUsdGhpcyksdGhpcy5fZW5hYmxlZD0hMCx0aGlzLl9vdGhlclNuYXBMYXllcnM9dGhpcy5fZmluZENvcm5lcnMoKSx0aGlzLl9maXJlRW5hYmxlKCkpOnRoaXMuZGlzYWJsZSgpKX0sZGlzYWJsZTpmdW5jdGlvbigpe3RoaXMuX2RyYWdnaW5nfHwodGhpcy5fbWFwfHwodGhpcy5fbWFwPXRoaXMuX2xheWVyLl9tYXApLHRoaXMuZGlzYWJsZUxheWVyRHJhZygpLHRoaXMuX2xheWVyLm9mZihcInJlbW92ZVwiLHRoaXMuZGlzYWJsZSx0aGlzKSx0aGlzLmVuYWJsZWQoKXx8KHRoaXMuX2xheWVyRWRpdGVkJiZ0aGlzLl9maXJlVXBkYXRlKCksdGhpcy5fbGF5ZXJFZGl0ZWQ9ITEsdGhpcy5fZmlyZURpc2FibGUoKSksdGhpcy5fZW5hYmxlZD0hMSl9LF9maW5kQ29ybmVyczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2xheWVyLmdldEJvdW5kcygpO3JldHVyblt0LmdldE5vcnRoV2VzdCgpLHQuZ2V0Tm9ydGhFYXN0KCksdC5nZXRTb3V0aEVhc3QoKSx0LmdldFNvdXRoV2VzdCgpXX19KSx4ZS5UZXh0PXhlLmV4dGVuZCh7X3NoYXBlOlwiVGV4dFwiLGluaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fbGF5ZXI9dCx0aGlzLl9lbmFibGVkPSExfSxlbmFibGU6ZnVuY3Rpb24odCl7TC5VdGlsLnNldE9wdGlvbnModGhpcyx0KSx0aGlzLnRleHRBcmVhJiYodGhpcy5vcHRpb25zLmFsbG93RWRpdGluZyYmdGhpcy5fbGF5ZXIuX21hcD8odGhpcy5fbWFwPXRoaXMuX2xheWVyLl9tYXAsdGhpcy5lbmFibGVkKCkmJnRoaXMuZGlzYWJsZSgpLHRoaXMuYXBwbHlPcHRpb25zKCksdGhpcy5fZm9jdXNDaGFuZ2UoKSx0aGlzLnRleHRBcmVhLnJlYWRPbmx5PSExLHRoaXMudGV4dEFyZWEuY2xhc3NMaXN0LnJlbW92ZShcInBtLWRpc2FibGVkXCIpLHRoaXMuX2xheWVyLm9uKFwicmVtb3ZlXCIsdGhpcy5kaXNhYmxlLHRoaXMpLEwuRG9tRXZlbnQub24odGhpcy50ZXh0QXJlYSxcImlucHV0XCIsdGhpcy5fYXV0b1Jlc2l6ZSx0aGlzKSxMLkRvbUV2ZW50Lm9uKHRoaXMudGV4dEFyZWEsXCJmb2N1c1wiLHRoaXMuX2ZvY3VzQ2hhbmdlLHRoaXMpLEwuRG9tRXZlbnQub24odGhpcy50ZXh0QXJlYSxcImJsdXJcIix0aGlzLl9mb2N1c0NoYW5nZSx0aGlzKSx0aGlzLl9sYXllci5vbihcImRibGNsaWNrXCIsTC5Eb21FdmVudC5zdG9wKSxMLkRvbUV2ZW50Lm9mZih0aGlzLnRleHRBcmVhLFwibW91c2Vkb3duXCIsdGhpcy5fcHJldmVudFRleHRTZWxlY3Rpb24pLHRoaXMuX2VuYWJsZWQ9ITAsdGhpcy5fZmlyZUVuYWJsZSgpKTp0aGlzLmRpc2FibGUoKSl9LGRpc2FibGU6ZnVuY3Rpb24oKXtpZih0aGlzLmVuYWJsZWQoKSl7dGhpcy5fbGF5ZXIub2ZmKFwicmVtb3ZlXCIsdGhpcy5kaXNhYmxlLHRoaXMpLEwuRG9tRXZlbnQub2ZmKHRoaXMudGV4dEFyZWEsXCJpbnB1dFwiLHRoaXMuX2F1dG9SZXNpemUsdGhpcyksTC5Eb21FdmVudC5vZmYodGhpcy50ZXh0QXJlYSxcImZvY3VzXCIsdGhpcy5fZm9jdXNDaGFuZ2UsdGhpcyksTC5Eb21FdmVudC5vZmYodGhpcy50ZXh0QXJlYSxcImJsdXJcIix0aGlzLl9mb2N1c0NoYW5nZSx0aGlzKSxMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCxcImNsaWNrXCIsdGhpcy5fZG9jdW1lbnRDbGljayx0aGlzKSx0aGlzLl9mb2N1c0NoYW5nZSgpLHRoaXMudGV4dEFyZWEucmVhZE9ubHk9ITAsdGhpcy50ZXh0QXJlYS5jbGFzc0xpc3QuYWRkKFwicG0tZGlzYWJsZWRcIik7dmFyIHQ9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDt0aGlzLnRleHRBcmVhLmZvY3VzKCksdGhpcy50ZXh0QXJlYS5zZWxlY3Rpb25TdGFydD0wLHRoaXMudGV4dEFyZWEuc2VsZWN0aW9uRW5kPTAsTC5Eb21FdmVudC5vbih0aGlzLnRleHRBcmVhLFwibW91c2Vkb3duXCIsdGhpcy5fcHJldmVudFRleHRTZWxlY3Rpb24pLHQuZm9jdXMoKSx0aGlzLl9kaXNhYmxlT25CbHVyQWN0aXZlPSExLHRoaXMuX2xheWVyRWRpdGVkJiZ0aGlzLl9maXJlVXBkYXRlKCksdGhpcy5fbGF5ZXJFZGl0ZWQ9ITEsdGhpcy5fZmlyZURpc2FibGUoKSx0aGlzLl9lbmFibGVkPSExfX0sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkfSx0b2dnbGVFZGl0OmZ1bmN0aW9uKHQpe3RoaXMuZW5hYmxlZCgpP3RoaXMuZGlzYWJsZSgpOnRoaXMuZW5hYmxlKHQpfSxhcHBseU9wdGlvbnM6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuc25hcHBhYmxlP3RoaXMuX2luaXRTbmFwcGFibGVNYXJrZXJzKCk6dGhpcy5fZGlzYWJsZVNuYXBwaW5nKCl9LF9pbml0U25hcHBhYmxlTWFya2VyczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2xheWVyO3RoaXMub3B0aW9ucy5zbmFwRGlzdGFuY2U9dGhpcy5vcHRpb25zLnNuYXBEaXN0YW5jZXx8MzAsdGhpcy5vcHRpb25zLnNuYXBTZWdtZW50PXRoaXMub3B0aW9ucy5zbmFwU2VnbWVudD09PXVuZGVmaW5lZHx8dGhpcy5vcHRpb25zLnNuYXBTZWdtZW50LHQub2ZmKFwicG06ZHJhZ1wiLHRoaXMuX2hhbmRsZVNuYXBwaW5nLHRoaXMpLHQub24oXCJwbTpkcmFnXCIsdGhpcy5faGFuZGxlU25hcHBpbmcsdGhpcyksdC5vZmYoXCJwbTpkcmFnZW5kXCIsdGhpcy5fY2xlYW51cFNuYXBwaW5nLHRoaXMpLHQub24oXCJwbTpkcmFnZW5kXCIsdGhpcy5fY2xlYW51cFNuYXBwaW5nLHRoaXMpLHQub2ZmKFwicG06ZHJhZ3N0YXJ0XCIsdGhpcy5fdW5zbmFwLHRoaXMpLHQub24oXCJwbTpkcmFnc3RhcnRcIix0aGlzLl91bnNuYXAsdGhpcyl9LF9kaXNhYmxlU25hcHBpbmc6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9sYXllcjt0Lm9mZihcInBtOmRyYWdcIix0aGlzLl9oYW5kbGVTbmFwcGluZyx0aGlzKSx0Lm9mZihcInBtOmRyYWdlbmRcIix0aGlzLl9jbGVhbnVwU25hcHBpbmcsdGhpcyksdC5vZmYoXCJwbTpkcmFnc3RhcnRcIix0aGlzLl91bnNuYXAsdGhpcyl9LF9hdXRvUmVzaXplOmZ1bmN0aW9uKCl7dGhpcy50ZXh0QXJlYS5zdHlsZS5oZWlnaHQ9XCIxcHhcIix0aGlzLnRleHRBcmVhLnN0eWxlLndpZHRoPVwiMXB4XCI7dmFyIHQ9dGhpcy50ZXh0QXJlYS5zY3JvbGxIZWlnaHQ+MjE/dGhpcy50ZXh0QXJlYS5zY3JvbGxIZWlnaHQ6MjEsZT10aGlzLnRleHRBcmVhLnNjcm9sbFdpZHRoPjE2P3RoaXMudGV4dEFyZWEuc2Nyb2xsV2lkdGg6MTY7dGhpcy50ZXh0QXJlYS5zdHlsZS5oZWlnaHQ9XCJcIi5jb25jYXQodCxcInB4XCIpLHRoaXMudGV4dEFyZWEuc3R5bGUud2lkdGg9XCJcIi5jb25jYXQoZSxcInB4XCIpLHRoaXMuX2ZpcmVUZXh0Q2hhbmdlKHRoaXMuZ2V0VGV4dCgpKX0sX2Rpc2FibGVPbkJsdXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuX2Rpc2FibGVPbkJsdXJBY3RpdmU9ITAsc2V0VGltZW91dCgoZnVuY3Rpb24oKXt0LmVuYWJsZWQoKSYmTC5Eb21FdmVudC5vbihkb2N1bWVudCxcImNsaWNrXCIsdC5fZG9jdW1lbnRDbGljayx0KX0pLDEwMCl9LF9kb2N1bWVudENsaWNrOmZ1bmN0aW9uKHQpe3QudGFyZ2V0IT09dGhpcy50ZXh0QXJlYSYmKHRoaXMuZGlzYWJsZSgpLCF0aGlzLmdldFRleHQoKSYmdGhpcy5vcHRpb25zLnJlbW92ZUlmRW1wdHkmJnRoaXMucmVtb3ZlKCkpfSxfZm9jdXNDaGFuZ2U6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e307dGhpcy5faGFzRm9jdXM9XCJmb2N1c1wiPT09dC50eXBlLHRoaXMuX2hhc0ZvY3VzP3RoaXMuX2FwcGx5Rm9jdXMoKTp0aGlzLl9yZW1vdmVGb2N1cygpfSxfYXBwbHlGb2N1czpmdW5jdGlvbigpe3RoaXMudGV4dEFyZWEuY2xhc3NMaXN0LmFkZChcInBtLWhhc2ZvY3VzXCIpLHRoaXMuX21hcC5kcmFnZ2luZyYmKHRoaXMuX3NhZmVUb0NhY2hlRHJhZ1N0YXRlJiYodGhpcy5fb3JpZ2luYWxNYXBEcmFnU3RhdGU9dGhpcy5fbWFwLmRyYWdnaW5nLl9lbmFibGVkLHRoaXMuX3NhZmVUb0NhY2hlRHJhZ1N0YXRlPSExKSx0aGlzLl9tYXAuZHJhZ2dpbmcuZGlzYWJsZSgpKX0sX3JlbW92ZUZvY3VzOmZ1bmN0aW9uKCl7dGhpcy5fbWFwLmRyYWdnaW5nJiYodGhpcy5fb3JpZ2luYWxNYXBEcmFnU3RhdGUmJnRoaXMuX21hcC5kcmFnZ2luZy5lbmFibGUoKSx0aGlzLl9zYWZlVG9DYWNoZURyYWdTdGF0ZT0hMCksdGhpcy50ZXh0QXJlYS5jbGFzc0xpc3QucmVtb3ZlKFwicG0taGFzZm9jdXNcIil9LGZvY3VzOmZ1bmN0aW9uKCl7aWYoIXRoaXMuZW5hYmxlZCgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJMYXllciBpcyBub3QgZW5hYmxlZFwiKTt0aGlzLnRleHRBcmVhLmZvY3VzKCl9LGJsdXI6ZnVuY3Rpb24oKXtpZighdGhpcy5lbmFibGVkKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkxheWVyIGlzIG5vdCBlbmFibGVkXCIpO3RoaXMudGV4dEFyZWEuYmx1cigpLHRoaXMuX2Rpc2FibGVPbkJsdXJBY3RpdmUmJnRoaXMuZGlzYWJsZSgpfSxoYXNGb2N1czpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9oYXNGb2N1c30sZ2V0RWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRleHRBcmVhfSxzZXRUZXh0OmZ1bmN0aW9uKHQpe3RoaXMudGV4dEFyZWEudmFsdWU9dCx0aGlzLl9hdXRvUmVzaXplKCl9LGdldFRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0QXJlYS52YWx1ZX0sX2luaXRUZXh0TWFya2VyOmZ1bmN0aW9uKCl7aWYodGhpcy50ZXh0QXJlYT1MLlBNLkRyYXcuVGV4dC5wcm90b3R5cGUuX2NyZWF0ZVRleHRBcmVhLmNhbGwodGhpcyksdGhpcy5vcHRpb25zLmNsYXNzTmFtZSl7dmFyIHQsZT10aGlzLm9wdGlvbnMuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKTsodD10aGlzLnRleHRBcmVhLmNsYXNzTGlzdCkuYWRkLmFwcGx5KHQsT2UoZSkpfXZhciBpPUwuUE0uRHJhdy5UZXh0LnByb3RvdHlwZS5fY3JlYXRlVGV4dEljb24uY2FsbCh0aGlzLHRoaXMudGV4dEFyZWEpO3RoaXMuX2xheWVyLnNldEljb24oaSksdGhpcy5fbGF5ZXIub25jZShcImFkZFwiLHRoaXMuX2NyZWF0ZVRleHRNYXJrZXIsdGhpcyl9LF9jcmVhdGVUZXh0TWFya2VyOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQmJmFyZ3VtZW50c1swXTt0aGlzLl9sYXllci5nZXRFbGVtZW50KCkudGFiSW5kZXg9LTEsdGhpcy50ZXh0QXJlYS53cmFwPVwib2ZmXCIsdGhpcy50ZXh0QXJlYS5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLHRoaXMudGV4dEFyZWEuc3R5bGUuaGVpZ2h0PUwuRG9tVXRpbC5nZXRTdHlsZSh0aGlzLnRleHRBcmVhLFwiZm9udC1zaXplXCIpLHRoaXMudGV4dEFyZWEuc3R5bGUud2lkdGg9XCIxcHhcIix0aGlzLl9sYXllci5vcHRpb25zLnRleHQmJnRoaXMuc2V0VGV4dCh0aGlzLl9sYXllci5vcHRpb25zLnRleHQpLHRoaXMuX2F1dG9SZXNpemUoKSx0JiYodGhpcy5lbmFibGUoKSx0aGlzLmZvY3VzKCksdGhpcy5fZGlzYWJsZU9uQmx1cigpKX0sX3ByZXZlbnRUZXh0U2VsZWN0aW9uOmZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKX19KTt2YXIgUmU9ZnVuY3Rpb24odCxlLGksbixyLGEpe3RoaXMuX21hdHJpeD1bdCxlLGksbixyLGFdfTtSZS5pbml0PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBMLlBNLk1hdHJpeCgxLDAsMCwxLDAsMCl9LFJlLnByb3RvdHlwZT17dHJhbnNmb3JtOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl90cmFuc2Zvcm0odC5jbG9uZSgpKX0sX3RyYW5zZm9ybTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9tYXRyaXgsaT10Lngsbj10Lnk7cmV0dXJuIHQueD1lWzBdKmkrZVsxXSpuK2VbNF0sdC55PWVbMl0qaStlWzNdKm4rZVs1XSx0fSx1bnRyYW5zZm9ybTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9tYXRyaXg7cmV0dXJuIG5ldyBMLlBvaW50KCh0LngvZVswXS1lWzRdKS9lWzBdLCh0LnkvZVsyXS1lWzVdKS9lWzJdKX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXRyaXg7cmV0dXJuIG5ldyBMLlBNLk1hdHJpeCh0WzBdLHRbMV0sdFsyXSx0WzNdLHRbNF0sdFs1XSl9LHRyYW5zbGF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdD09PXVuZGVmaW5lZD9uZXcgTC5Qb2ludCh0aGlzLl9tYXRyaXhbNF0sdGhpcy5fbWF0cml4WzVdKTooXCJudW1iZXJcIj09dHlwZW9mIHQ/KGU9dCxpPXQpOihlPXQueCxpPXQueSksdGhpcy5fYWRkKDEsMCwwLDEsZSxpKSk7dmFyIGUsaX0sc2NhbGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PXVuZGVmaW5lZD9uZXcgTC5Qb2ludCh0aGlzLl9tYXRyaXhbMF0sdGhpcy5fbWF0cml4WzNdKTooZT1lfHxMLnBvaW50KDAsMCksXCJudW1iZXJcIj09dHlwZW9mIHQ/KGk9dCxuPXQpOihpPXQueCxuPXQueSksdGhpcy5fYWRkKGksMCwwLG4sZS54LGUueSkuX2FkZCgxLDAsMCwxLC1lLngsLWUueSkpO3ZhciBpLG59LHJvdGF0ZTpmdW5jdGlvbih0LGUpe3ZhciBpPU1hdGguY29zKHQpLG49TWF0aC5zaW4odCk7cmV0dXJuIGU9ZXx8bmV3IEwuUG9pbnQoMCwwKSx0aGlzLl9hZGQoaSxuLC1uLGksZS54LGUueSkuX2FkZCgxLDAsMCwxLC1lLngsLWUueSl9LGZsaXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4WzFdKj0tMSx0aGlzLl9tYXRyaXhbMl0qPS0xLHRoaXN9LF9hZGQ6ZnVuY3Rpb24odCxlLGksbixyLGEpe3ZhciBvLHM9W1tdLFtdLFtdXSxsPXRoaXMuX21hdHJpeCxoPVtbbFswXSxsWzJdLGxbNF1dLFtsWzFdLGxbM10sbFs1XV0sWzAsMCwxXV0sdT1bW3QsaSxyXSxbZSxuLGFdLFswLDAsMV1dO3QmJnQgaW5zdGFuY2VvZiBMLlBNLk1hdHJpeCYmKHU9W1sobD10Ll9tYXRyaXgpWzBdLGxbMl0sbFs0XV0sW2xbMV0sbFszXSxsWzVdXSxbMCwwLDFdXSk7Zm9yKHZhciBjPTA7YzwzO2MrPTEpZm9yKHZhciBwPTA7cDwzO3ArPTEpe289MDtmb3IodmFyIGQ9MDtkPDM7ZCs9MSlvKz1oW2NdW2RdKnVbZF1bcF07c1tjXVtwXT1vfXJldHVybiB0aGlzLl9tYXRyaXg9W3NbMF1bMF0sc1sxXVswXSxzWzBdWzFdLHNbMV1bMV0sc1swXVsyXSxzWzFdWzJdXSx0aGlzfX07Y29uc3QgQmU9UmU7dmFyIFRlPXtjYWxjTWlkZGxlTGF0TG5nOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbj10LnByb2plY3QoZSkscj10LnByb2plY3QoaSk7cmV0dXJuIHQudW5wcm9qZWN0KG4uX2FkZChyKS5fZGl2aWRlQnkoMikpfSxmaW5kTGF5ZXJzOmZ1bmN0aW9uKHQpe3ZhciBlPVtdO3JldHVybiB0LmVhY2hMYXllcigoZnVuY3Rpb24odCl7KHQgaW5zdGFuY2VvZiBMLlBvbHlsaW5lfHx0IGluc3RhbmNlb2YgTC5NYXJrZXJ8fHQgaW5zdGFuY2VvZiBMLkNpcmNsZXx8dCBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyfHx0IGluc3RhbmNlb2YgTC5JbWFnZU92ZXJsYXkpJiZlLnB1c2godCl9KSksZT0oZT0oZT1lLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuISF0LnBtfSkpKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiF0Ll9wbVRlbXBMYXllcn0pKSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hTC5QTS5vcHRJbiYmIXQub3B0aW9ucy5wbUlnbm9yZXx8TC5QTS5vcHRJbiYmITE9PT10Lm9wdGlvbnMucG1JZ25vcmV9KSl9LGNpcmNsZVRvUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOjYwLGk9IShhcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZCl8fGFyZ3VtZW50c1syXSxuPXQuZ2V0TGF0TG5nKCkscj10LmdldFJhZGl1cygpLGE9TihuLHIsZSwwLGkpLG89W10scz0wO3M8YS5sZW5ndGg7cys9MSl7dmFyIGw9W2Fbc10ubGF0LGFbc10ubG5nXTtvLnB1c2gobCl9cmV0dXJuIEwucG9seWdvbihvLHQub3B0aW9ucyl9LGRpc2FibGVQb3B1cDpmdW5jdGlvbih0KXt0LmdldFBvcHVwKCkmJih0Ll90ZW1wUG9wdXBDb3B5PXQuZ2V0UG9wdXAoKSx0LnVuYmluZFBvcHVwKCkpfSxlbmFibGVQb3B1cDpmdW5jdGlvbih0KXt0Ll90ZW1wUG9wdXBDb3B5JiYodC5iaW5kUG9wdXAodC5fdGVtcFBvcHVwQ29weSksZGVsZXRlIHQuX3RlbXBQb3B1cENvcHkpfSxfZmlyZUV2ZW50OmZ1bmN0aW9uKHQsZSxpKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZCYmYXJndW1lbnRzWzNdO3QuZmlyZShlLGksbik7dmFyIHI9dGhpcy5nZXRBbGxQYXJlbnRHcm91cHModCksYT1yLmdyb3VwczthLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QuZmlyZShlLGksbil9KSl9LGdldEFsbFBhcmVudEdyb3VwczpmdW5jdGlvbih0KXt2YXIgZT1bXSxpPVtdO3JldHVybiF0Ll9wbUxhc3RHcm91cEZldGNofHwhdC5fcG1MYXN0R3JvdXBGZXRjaC50aW1lfHwobmV3IERhdGUpLmdldFRpbWUoKS10Ll9wbUxhc3RHcm91cEZldGNoLnRpbWU+MWUzPyhmdW5jdGlvbiBuKHQpe2Zvcih2YXIgciBpbiB0Ll9ldmVudFBhcmVudHMpaWYoLTE9PT1lLmluZGV4T2Yocikpe2UucHVzaChyKTt2YXIgYT10Ll9ldmVudFBhcmVudHNbcl07aS5wdXNoKGEpLG4oYSl9fSh0KSx0Ll9wbUxhc3RHcm91cEZldGNoPXt0aW1lOihuZXcgRGF0ZSkuZ2V0VGltZSgpLGdyb3VwczppLGdyb3VwSWRzOmV9LHtncm91cElkczplLGdyb3VwczppfSk6e2dyb3Vwczp0Ll9wbUxhc3RHcm91cEZldGNoLmdyb3Vwcyxncm91cElkczp0Ll9wbUxhc3RHcm91cEZldGNoLmdyb3VwSWRzfX0sY3JlYXRlR2VvZGVzaWNQb2x5Z29uOk4sZ2V0VHJhbnNsYXRpb246SSxmaW5kRGVlcENvb3JkSW5kZXg6ZnVuY3Rpb24odCxlKXt2YXIgaTt0LnNvbWUoZnVuY3Rpb24gcih0KXtyZXR1cm4gZnVuY3Rpb24obixhKXt2YXIgbz10LmNvbmNhdChhKTtyZXR1cm4gbi5sYXQmJm4ubGF0PT09ZS5sYXQmJm4ubG5nPT09ZS5sbmc/KGk9bywhMCk6QXJyYXkuaXNBcnJheShuKSYmbi5zb21lKHIobykpfX0oW10pKTt2YXIgbj17fTtyZXR1cm4gaSYmKG49e2luZGV4UGF0aDppLGluZGV4OmlbaS5sZW5ndGgtMV0scGFyZW50UGF0aDppLnNsaWNlKDAsaS5sZW5ndGgtMSl9KSxufSxmaW5kRGVlcE1hcmtlckluZGV4OmZ1bmN0aW9uKHQsZSl7dmFyIGk7dC5zb21lKGZ1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKG4sYSl7dmFyIG89dC5jb25jYXQoYSk7cmV0dXJuIG4uX2xlYWZsZXRfaWQ9PT1lLl9sZWFmbGV0X2lkPyhpPW8sITApOkFycmF5LmlzQXJyYXkobikmJm4uc29tZShyKG8pKX19KFtdKSk7dmFyIG49e307cmV0dXJuIGkmJihuPXtpbmRleFBhdGg6aSxpbmRleDppW2kubGVuZ3RoLTFdLHBhcmVudFBhdGg6aS5zbGljZSgwLGkubGVuZ3RoLTEpfSksbn0sX2dldEluZGV4RnJvbVNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtpZihlJiYyPT09ZS5sZW5ndGgpe3ZhciBpPXRoaXMuZmluZERlZXBDb29yZEluZGV4KHQsZVswXSksbj10aGlzLmZpbmREZWVwQ29vcmRJbmRleCh0LGVbMV0pLHI9TWF0aC5tYXgoaS5pbmRleCxuLmluZGV4KTtyZXR1cm4gMCE9PWkuaW5kZXgmJjAhPT1uLmluZGV4fHwxPT09cnx8KHIrPTEpLHtpbmRleEE6aSxpbmRleEI6bixuZXdJbmRleDpyLGluZGV4UGF0aDppLmluZGV4UGF0aCxwYXJlbnRQYXRoOmkucGFyZW50UGF0aH19cmV0dXJuIG51bGx9LF9nZXRSb3RhdGVkUmVjdGFuZ2xlOmZ1bmN0aW9uKHQsZSxpLG4pe3ZhciByPUxlKG4sdCksYT1MZShuLGUpLG89aSpNYXRoLlBJLzE4MCxzPU1hdGguY29zKG8pLGw9TWF0aC5zaW4obyksaD0oYS54LXIueCkqcysoYS55LXIueSkqbCx1PShhLnktci55KSpzLShhLngtci54KSpsLGM9aCpzK3IueCxwPWgqbCtyLnksZD0tdSpsK3IueCxmPXUqcytyLnk7cmV0dXJuW2JlKG4sciksYmUobix7eDpjLHk6cH0pLGJlKG4sYSksYmUobix7eDpkLHk6Zn0pXX0scHhSYWRpdXNUb01ldGVyUmFkaXVzOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbj1lLnByb2plY3QoaSkscj1MLnBvaW50KG4ueCt0LG4ueSk7cmV0dXJuIGUuZGlzdGFuY2UoZS51bnByb2plY3QociksaSl9fTtjb25zdCBJZT1UZTtMLlBNPUwuUE18fHt2ZXJzaW9uOlwiMi4xMy4wXCIsTWFwOkssVG9vbGJhcjpRLERyYXc6YXQsRWRpdDp4ZSxVdGlsczpJZSxNYXRyaXg6QmUsYWN0aXZlTGFuZzpcImVuXCIsb3B0SW46ITEsaW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLmFkZEluaXRIb29rcyh0KX0sc2V0T3B0SW46ZnVuY3Rpb24odCl7dGhpcy5vcHRJbj0hIXR9LGFkZEluaXRIb29rczpmdW5jdGlvbigpe0wuTWFwLmFkZEluaXRIb29rKChmdW5jdGlvbigpe3RoaXMucG09dW5kZWZpbmVkLEwuUE0ub3B0SW4/ITE9PT10aGlzLm9wdGlvbnMucG1JZ25vcmUmJih0aGlzLnBtPW5ldyBMLlBNLk1hcCh0aGlzKSk6dGhpcy5vcHRpb25zLnBtSWdub3JlfHwodGhpcy5wbT1uZXcgTC5QTS5NYXAodGhpcykpfSkpLEwuTGF5ZXJHcm91cC5hZGRJbml0SG9vaygoZnVuY3Rpb24oKXt0aGlzLnBtPXVuZGVmaW5lZCxMLlBNLm9wdEluPyExPT09dGhpcy5vcHRpb25zLnBtSWdub3JlJiYodGhpcy5wbT1uZXcgTC5QTS5FZGl0LkxheWVyR3JvdXAodGhpcykpOnRoaXMub3B0aW9ucy5wbUlnbm9yZXx8KHRoaXMucG09bmV3IEwuUE0uRWRpdC5MYXllckdyb3VwKHRoaXMpKX0pKSxMLk1hcmtlci5hZGRJbml0SG9vaygoZnVuY3Rpb24oKXt0aGlzLnBtPXVuZGVmaW5lZCxMLlBNLm9wdEluPyExPT09dGhpcy5vcHRpb25zLnBtSWdub3JlJiYodGhpcy5vcHRpb25zLnRleHRNYXJrZXI/KHRoaXMucG09bmV3IEwuUE0uRWRpdC5UZXh0KHRoaXMpLHRoaXMub3B0aW9ucy5fdGV4dE1hcmtlck92ZXJQTXx8dGhpcy5wbS5faW5pdFRleHRNYXJrZXIoKSxkZWxldGUgdGhpcy5vcHRpb25zLl90ZXh0TWFya2VyT3ZlclBNKTp0aGlzLnBtPW5ldyBMLlBNLkVkaXQuTWFya2VyKHRoaXMpKTp0aGlzLm9wdGlvbnMucG1JZ25vcmV8fCh0aGlzLm9wdGlvbnMudGV4dE1hcmtlcj8odGhpcy5wbT1uZXcgTC5QTS5FZGl0LlRleHQodGhpcyksdGhpcy5vcHRpb25zLl90ZXh0TWFya2VyT3ZlclBNfHx0aGlzLnBtLl9pbml0VGV4dE1hcmtlcigpLGRlbGV0ZSB0aGlzLm9wdGlvbnMuX3RleHRNYXJrZXJPdmVyUE0pOnRoaXMucG09bmV3IEwuUE0uRWRpdC5NYXJrZXIodGhpcykpfSkpLEwuQ2lyY2xlTWFya2VyLmFkZEluaXRIb29rKChmdW5jdGlvbigpe3RoaXMucG09dW5kZWZpbmVkLEwuUE0ub3B0SW4/ITE9PT10aGlzLm9wdGlvbnMucG1JZ25vcmUmJih0aGlzLnBtPW5ldyBMLlBNLkVkaXQuQ2lyY2xlTWFya2VyKHRoaXMpKTp0aGlzLm9wdGlvbnMucG1JZ25vcmV8fCh0aGlzLnBtPW5ldyBMLlBNLkVkaXQuQ2lyY2xlTWFya2VyKHRoaXMpKX0pKSxMLlBvbHlsaW5lLmFkZEluaXRIb29rKChmdW5jdGlvbigpe3RoaXMucG09dW5kZWZpbmVkLEwuUE0ub3B0SW4/ITE9PT10aGlzLm9wdGlvbnMucG1JZ25vcmUmJih0aGlzLnBtPW5ldyBMLlBNLkVkaXQuTGluZSh0aGlzKSk6dGhpcy5vcHRpb25zLnBtSWdub3JlfHwodGhpcy5wbT1uZXcgTC5QTS5FZGl0LkxpbmUodGhpcykpfSkpLEwuUG9seWdvbi5hZGRJbml0SG9vaygoZnVuY3Rpb24oKXt0aGlzLnBtPXVuZGVmaW5lZCxMLlBNLm9wdEluPyExPT09dGhpcy5vcHRpb25zLnBtSWdub3JlJiYodGhpcy5wbT1uZXcgTC5QTS5FZGl0LlBvbHlnb24odGhpcykpOnRoaXMub3B0aW9ucy5wbUlnbm9yZXx8KHRoaXMucG09bmV3IEwuUE0uRWRpdC5Qb2x5Z29uKHRoaXMpKX0pKSxMLlJlY3RhbmdsZS5hZGRJbml0SG9vaygoZnVuY3Rpb24oKXt0aGlzLnBtPXVuZGVmaW5lZCxMLlBNLm9wdEluPyExPT09dGhpcy5vcHRpb25zLnBtSWdub3JlJiYodGhpcy5wbT1uZXcgTC5QTS5FZGl0LlJlY3RhbmdsZSh0aGlzKSk6dGhpcy5vcHRpb25zLnBtSWdub3JlfHwodGhpcy5wbT1uZXcgTC5QTS5FZGl0LlJlY3RhbmdsZSh0aGlzKSl9KSksTC5DaXJjbGUuYWRkSW5pdEhvb2soKGZ1bmN0aW9uKCl7dGhpcy5wbT11bmRlZmluZWQsTC5QTS5vcHRJbj8hMT09PXRoaXMub3B0aW9ucy5wbUlnbm9yZSYmKHRoaXMucG09bmV3IEwuUE0uRWRpdC5DaXJjbGUodGhpcykpOnRoaXMub3B0aW9ucy5wbUlnbm9yZXx8KHRoaXMucG09bmV3IEwuUE0uRWRpdC5DaXJjbGUodGhpcykpfSkpLEwuSW1hZ2VPdmVybGF5LmFkZEluaXRIb29rKChmdW5jdGlvbigpe3RoaXMucG09dW5kZWZpbmVkLEwuUE0ub3B0SW4/ITE9PT10aGlzLm9wdGlvbnMucG1JZ25vcmUmJih0aGlzLnBtPW5ldyBMLlBNLkVkaXQuSW1hZ2VPdmVybGF5KHRoaXMpKTp0aGlzLm9wdGlvbnMucG1JZ25vcmV8fCh0aGlzLnBtPW5ldyBMLlBNLkVkaXQuSW1hZ2VPdmVybGF5KHRoaXMpKX0pKX0scmVJbml0TGF5ZXI6ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0IGluc3RhbmNlb2YgTC5MYXllckdyb3VwJiZ0LmVhY2hMYXllcigoZnVuY3Rpb24odCl7ZS5yZUluaXRMYXllcih0KX0pKSx0LnBtfHxMLlBNLm9wdEluJiYhMSE9PXQub3B0aW9ucy5wbUlnbm9yZXx8dC5vcHRpb25zLnBtSWdub3JlfHwodCBpbnN0YW5jZW9mIEwuTWFwP3QucG09bmV3IEwuUE0uTWFwKHQpOnQgaW5zdGFuY2VvZiBMLk1hcmtlcj90LnBtPW5ldyBMLlBNLkVkaXQuTWFya2VyKHQpOnQgaW5zdGFuY2VvZiBMLkNpcmNsZT90LnBtPW5ldyBMLlBNLkVkaXQuQ2lyY2xlKHQpOnQgaW5zdGFuY2VvZiBMLkNpcmNsZU1hcmtlcj90LnBtPW5ldyBMLlBNLkVkaXQuQ2lyY2xlTWFya2VyKHQpOnQgaW5zdGFuY2VvZiBMLlJlY3RhbmdsZT90LnBtPW5ldyBMLlBNLkVkaXQuUmVjdGFuZ2xlKHQpOnQgaW5zdGFuY2VvZiBMLlBvbHlnb24/dC5wbT1uZXcgTC5QTS5FZGl0LlBvbHlnb24odCk6dCBpbnN0YW5jZW9mIEwuUG9seWxpbmU/dC5wbT1uZXcgTC5QTS5FZGl0LkxpbmUodCk6dCBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cD90LnBtPW5ldyBMLlBNLkVkaXQuTGF5ZXJHcm91cCh0KTp0IGluc3RhbmNlb2YgTC5JbWFnZU92ZXJsYXkmJih0LnBtPW5ldyBMLlBNLkVkaXQuSW1hZ2VPdmVybGF5KHQpKSl9fSxMLlBNLmluaXRpYWxpemUoKX0sNzEwNzooKT0+e0FycmF5LnByb3RvdHlwZS5maW5kSW5kZXg9QXJyYXkucHJvdG90eXBlLmZpbmRJbmRleHx8ZnVuY3Rpb24odCl7aWYobnVsbD09PXRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5LnByb3RvdHlwZS5maW5kSW5kZXggY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkXCIpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvblwiKTtmb3IodmFyIGU9T2JqZWN0KHRoaXMpLGk9ZS5sZW5ndGg+Pj4wLG49YXJndW1lbnRzWzFdLHI9MDtyPGk7cisrKWlmKHQuY2FsbChuLGVbcl0scixlKSlyZXR1cm4gcjtyZXR1cm4tMX0sQXJyYXkucHJvdG90eXBlLmZpbmQ9QXJyYXkucHJvdG90eXBlLmZpbmR8fGZ1bmN0aW9uKHQpe2lmKG51bGw9PT10aGlzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWRcIik7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO2Zvcih2YXIgZT1PYmplY3QodGhpcyksaT1lLmxlbmd0aD4+PjAsbj1hcmd1bWVudHNbMV0scj0wO3I8aTtyKyspe3ZhciBhPWVbcl07aWYodC5jYWxsKG4sYSxyLGUpKXJldHVybiBhfX0sXCJmdW5jdGlvblwiIT10eXBlb2YgT2JqZWN0LmFzc2lnbiYmKE9iamVjdC5hc3NpZ249ZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7aWYobnVsbD09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO3Q9T2JqZWN0KHQpO2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBpPWFyZ3VtZW50c1tlXTtpZihudWxsIT1pKWZvcih2YXIgbiBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLG4pJiYodFtuXT1pW25dKX1yZXR1cm4gdH0pLFtFbGVtZW50LnByb3RvdHlwZSxDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSxEb2N1bWVudFR5cGUucHJvdG90eXBlXS5mb3JFYWNoKChmdW5jdGlvbih0KXt0Lmhhc093blByb3BlcnR5KFwicmVtb3ZlXCIpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInJlbW92ZVwiLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKX19KX0pKSxBcnJheS5wcm90b3R5cGUuaW5jbHVkZXN8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsXCJpbmNsdWRlc1wiLHt2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKG51bGw9PXRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0aGlzXCIgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpO3ZhciBpPU9iamVjdCh0aGlzKSxuPWkubGVuZ3RoPj4+MDtpZigwPT09bilyZXR1cm4hMTt2YXIgcixhLG89MHxlLHM9TWF0aC5tYXgobz49MD9vOm4tTWF0aC5hYnMobyksMCk7Zm9yKDtzPG47KXtpZigocj1pW3NdKT09PShhPXQpfHxcIm51bWJlclwiPT10eXBlb2YgciYmXCJudW1iZXJcIj09dHlwZW9mIGEmJmlzTmFOKHIpJiZpc05hTihhKSlyZXR1cm4hMDtzKyt9cmV0dXJuITF9fSl9LDE3ODc6KHQsZSxpKT0+e3ZhciBuPWkoMjU4Mikscj1pKDQxMDIpLGE9aSgxNTQwKSxvPWkoOTcwNSkuWixzPWEuZmVhdHVyZUVhY2gsbD0oYS5jb29yZEVhY2gsci5wb2x5Z29uLHIuZmVhdHVyZUNvbGxlY3Rpb24pO2Z1bmN0aW9uIGgodCl7dmFyIGU9bmV3IG4odCk7cmV0dXJuIGUuaW5zZXJ0PWZ1bmN0aW9uKHQpe2lmKFwiRmVhdHVyZVwiIT09dC50eXBlKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmVhdHVyZVwiKTtyZXR1cm4gdC5iYm94PXQuYmJveD90LmJib3g6byh0KSxuLnByb3RvdHlwZS5pbnNlcnQuY2FsbCh0aGlzLHQpfSxlLmxvYWQ9ZnVuY3Rpb24odCl7dmFyIGU9W107cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dC5mb3JFYWNoKChmdW5jdGlvbih0KXtpZihcIkZlYXR1cmVcIiE9PXQudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZlYXR1cmVzXCIpO3QuYmJveD10LmJib3g/dC5iYm94Om8odCksZS5wdXNoKHQpfSkpOnModCwoZnVuY3Rpb24odCl7aWYoXCJGZWF0dXJlXCIhPT10LnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmZWF0dXJlc1wiKTt0LmJib3g9dC5iYm94P3QuYmJveDpvKHQpLGUucHVzaCh0KX0pKSxuLnByb3RvdHlwZS5sb2FkLmNhbGwodGhpcyxlKX0sZS5yZW1vdmU9ZnVuY3Rpb24odCxlKXtpZihcIkZlYXR1cmVcIiE9PXQudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZlYXR1cmVcIik7cmV0dXJuIHQuYmJveD10LmJib3g/dC5iYm94Om8odCksbi5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyx0LGUpfSxlLmNsZWFyPWZ1bmN0aW9uKCl7cmV0dXJuIG4ucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyl9LGUuc2VhcmNoPWZ1bmN0aW9uKHQpe3ZhciBlPW4ucHJvdG90eXBlLnNlYXJjaC5jYWxsKHRoaXMsdGhpcy50b0JCb3godCkpO3JldHVybiBsKGUpfSxlLmNvbGxpZGVzPWZ1bmN0aW9uKHQpe3JldHVybiBuLnByb3RvdHlwZS5jb2xsaWRlcy5jYWxsKHRoaXMsdGhpcy50b0JCb3godCkpfSxlLmFsbD1mdW5jdGlvbigpe3ZhciB0PW4ucHJvdG90eXBlLmFsbC5jYWxsKHRoaXMpO3JldHVybiBsKHQpfSxlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiBuLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKX0sZS5mcm9tSlNPTj1mdW5jdGlvbih0KXtyZXR1cm4gbi5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCh0aGlzLHQpfSxlLnRvQkJveD1mdW5jdGlvbih0KXt2YXIgZTtpZih0LmJib3gpZT10LmJib3g7ZWxzZSBpZihBcnJheS5pc0FycmF5KHQpJiY0PT09dC5sZW5ndGgpZT10O2Vsc2UgaWYoQXJyYXkuaXNBcnJheSh0KSYmNj09PXQubGVuZ3RoKWU9W3RbMF0sdFsxXSx0WzNdLHRbNF1dO2Vsc2UgaWYoXCJGZWF0dXJlXCI9PT10LnR5cGUpZT1vKHQpO2Vsc2V7aWYoXCJGZWF0dXJlQ29sbGVjdGlvblwiIT09dC50eXBlKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgZ2VvanNvblwiKTtlPW8odCl9cmV0dXJue21pblg6ZVswXSxtaW5ZOmVbMV0sbWF4WDplWzJdLG1heFk6ZVszXX19LGV9dC5leHBvcnRzPWgsdC5leHBvcnRzW1wiZGVmYXVsdFwiXT1ofSwxOTg5Oih0LGUsaSk9Pnt2YXIgbj1pKDE3ODkpLHI9aSg0MDEpLGE9aSg3NjY3KSxvPWkoMTMyNykscz1pKDE4NjYpO2Z1bmN0aW9uIGwodCl7dmFyIGU9LTEsaT1udWxsPT10PzA6dC5sZW5ndGg7Zm9yKHRoaXMuY2xlYXIoKTsrK2U8aTspe3ZhciBuPXRbZV07dGhpcy5zZXQoblswXSxuWzFdKX19bC5wcm90b3R5cGUuY2xlYXI9bixsLnByb3RvdHlwZVtcImRlbGV0ZVwiXT1yLGwucHJvdG90eXBlLmdldD1hLGwucHJvdG90eXBlLmhhcz1vLGwucHJvdG90eXBlLnNldD1zLHQuZXhwb3J0cz1sfSw4NDA3Oih0LGUsaSk9Pnt2YXIgbj1pKDcwNDApLHI9aSg0MTI1KSxhPWkoMjExNyksbz1pKDc1MTgpLHM9aSg0NzA1KTtmdW5jdGlvbiBsKHQpe3ZhciBlPS0xLGk9bnVsbD09dD8wOnQubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPGk7KXt2YXIgbj10W2VdO3RoaXMuc2V0KG5bMF0sblsxXSl9fWwucHJvdG90eXBlLmNsZWFyPW4sbC5wcm90b3R5cGVbXCJkZWxldGVcIl09cixsLnByb3RvdHlwZS5nZXQ9YSxsLnByb3RvdHlwZS5oYXM9byxsLnByb3RvdHlwZS5zZXQ9cyx0LmV4cG9ydHM9bH0sNzA3MToodCxlLGkpPT57dmFyIG49aSg4NTIpKGkoNTYzOSksXCJNYXBcIik7dC5leHBvcnRzPW59LDMzNjk6KHQsZSxpKT0+e3ZhciBuPWkoNDc4NSkscj1pKDEyODUpLGE9aSg2ZTMpLG89aSg5OTE2KSxzPWkoNTI2NSk7ZnVuY3Rpb24gbCh0KXt2YXIgZT0tMSxpPW51bGw9PXQ/MDp0Lmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTxpOyl7dmFyIG49dFtlXTt0aGlzLnNldChuWzBdLG5bMV0pfX1sLnByb3RvdHlwZS5jbGVhcj1uLGwucHJvdG90eXBlW1wiZGVsZXRlXCJdPXIsbC5wcm90b3R5cGUuZ2V0PWEsbC5wcm90b3R5cGUuaGFzPW8sbC5wcm90b3R5cGUuc2V0PXMsdC5leHBvcnRzPWx9LDYzODQ6KHQsZSxpKT0+e3ZhciBuPWkoODQwNykscj1pKDc0NjUpLGE9aSgzNzc5KSxvPWkoNzU5OSkscz1pKDQ3NTgpLGw9aSg0MzA5KTtmdW5jdGlvbiBoKHQpe3ZhciBlPXRoaXMuX19kYXRhX189bmV3IG4odCk7dGhpcy5zaXplPWUuc2l6ZX1oLnByb3RvdHlwZS5jbGVhcj1yLGgucHJvdG90eXBlW1wiZGVsZXRlXCJdPWEsaC5wcm90b3R5cGUuZ2V0PW8saC5wcm90b3R5cGUuaGFzPXMsaC5wcm90b3R5cGUuc2V0PWwsdC5leHBvcnRzPWh9LDI3MDU6KHQsZSxpKT0+e3ZhciBuPWkoNTYzOSkuU3ltYm9sO3QuZXhwb3J0cz1ufSwxMTQ5Oih0LGUsaSk9Pnt2YXIgbj1pKDU2MzkpLlVpbnQ4QXJyYXk7dC5leHBvcnRzPW59LDY4NzQ6dD0+e3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsaSl7c3dpdGNoKGkubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHQuY2FsbChlKTtjYXNlIDE6cmV0dXJuIHQuY2FsbChlLGlbMF0pO2Nhc2UgMjpyZXR1cm4gdC5jYWxsKGUsaVswXSxpWzFdKTtjYXNlIDM6cmV0dXJuIHQuY2FsbChlLGlbMF0saVsxXSxpWzJdKX1yZXR1cm4gdC5hcHBseShlLGkpfX0sNDYzNjoodCxlLGkpPT57dmFyIG49aSgyNTQ1KSxyPWkoNTY5NCksYT1pKDE0NjkpLG89aSg0MTQ0KSxzPWkoNTc3NiksbD1pKDY3MTkpLGg9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgaT1hKHQpLHU9IWkmJnIodCksYz0haSYmIXUmJm8odCkscD0haSYmIXUmJiFjJiZsKHQpLGQ9aXx8dXx8Y3x8cCxmPWQ/bih0Lmxlbmd0aCxTdHJpbmcpOltdLGc9Zi5sZW5ndGg7Zm9yKHZhciBfIGluIHQpIWUmJiFoLmNhbGwodCxfKXx8ZCYmKFwibGVuZ3RoXCI9PV98fGMmJihcIm9mZnNldFwiPT1ffHxcInBhcmVudFwiPT1fKXx8cCYmKFwiYnVmZmVyXCI9PV98fFwiYnl0ZUxlbmd0aFwiPT1ffHxcImJ5dGVPZmZzZXRcIj09Xyl8fHMoXyxnKSl8fGYucHVzaChfKTtyZXR1cm4gZn19LDk5MzI6dD0+e3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgaT0tMSxuPW51bGw9PXQ/MDp0Lmxlbmd0aCxyPUFycmF5KG4pOysraTxuOylyW2ldPWUodFtpXSxpLHQpO3JldHVybiByfX0sNjU1NjoodCxlLGkpPT57dmFyIG49aSg5NDY1KSxyPWkoNzgxMyk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxpKXsoaSE9PXVuZGVmaW5lZCYmIXIodFtlXSxpKXx8aT09PXVuZGVmaW5lZCYmIShlIGluIHQpKSYmbih0LGUsaSl9fSw0ODY1Oih0LGUsaSk9Pnt2YXIgbj1pKDk0NjUpLHI9aSg3ODEzKSxhPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxpKXt2YXIgbz10W2VdO2EuY2FsbCh0LGUpJiZyKG8saSkmJihpIT09dW5kZWZpbmVkfHxlIGluIHQpfHxuKHQsZSxpKX19LDg0NzA6KHQsZSxpKT0+e3ZhciBuPWkoNzgxMyk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPXQubGVuZ3RoO2ktLTspaWYobih0W2ldWzBdLGUpKXJldHVybiBpO3JldHVybi0xfX0sOTQ2NToodCxlLGkpPT57dmFyIG49aSg4Nzc3KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLGkpe1wiX19wcm90b19fXCI9PWUmJm4/bih0LGUse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOmksd3JpdGFibGU6ITB9KTp0W2VdPWl9fSwzMTE4Oih0LGUsaSk9Pnt2YXIgbj1pKDMyMTgpLHI9T2JqZWN0LmNyZWF0ZSxhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIW4oZSkpcmV0dXJue307aWYocilyZXR1cm4gcihlKTt0LnByb3RvdHlwZT1lO3ZhciBpPW5ldyB0O3JldHVybiB0LnByb3RvdHlwZT11bmRlZmluZWQsaX19KCk7dC5leHBvcnRzPWF9LDg0ODM6KHQsZSxpKT0+e3ZhciBuPWkoNTA2MykoKTt0LmV4cG9ydHM9bn0sNzc4NjoodCxlLGkpPT57dmFyIG49aSgxODExKSxyPWkoMzI3KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9MCxhPShlPW4oZSx0KSkubGVuZ3RoO251bGwhPXQmJmk8YTspdD10W3IoZVtpKytdKV07cmV0dXJuIGkmJmk9PWE/dDp1bmRlZmluZWR9fSw0MjM5Oih0LGUsaSk9Pnt2YXIgbj1pKDI3MDUpLHI9aSg5NjA3KSxhPWkoMjMzMyksbz1uP24udG9TdHJpbmdUYWc6dW5kZWZpbmVkO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dD90PT09dW5kZWZpbmVkP1wiW29iamVjdCBVbmRlZmluZWRdXCI6XCJbb2JqZWN0IE51bGxdXCI6byYmbyBpbiBPYmplY3QodCk/cih0KTphKHQpfX0sODU2NTp0PT57dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbnVsbCE9dCYmZS5jYWxsKHQsaSl9fSw5NDU0Oih0LGUsaSk9Pnt2YXIgbj1pKDQyMzkpLHI9aSg3MDA1KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCkmJlwiW29iamVjdCBBcmd1bWVudHNdXCI9PW4odCl9fSw4NDU4Oih0LGUsaSk9Pnt2YXIgbj1pKDM1NjApLHI9aSg1MzQ2KSxhPWkoMzIxOCksbz1pKDM0Nikscz0vXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvLGw9RnVuY3Rpb24ucHJvdG90eXBlLGg9T2JqZWN0LnByb3RvdHlwZSx1PWwudG9TdHJpbmcsYz1oLmhhc093blByb3BlcnR5LHA9UmVnRXhwKFwiXlwiK3UuY2FsbChjKS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcIlxcXFwkJlwiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLFwiJDEuKj9cIikrXCIkXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4hKCFhKHQpfHxyKHQpKSYmKG4odCk/cDpzKS50ZXN0KG8odCkpfX0sODc0OToodCxlLGkpPT57dmFyIG49aSg0MjM5KSxyPWkoMTc4MCksYT1pKDcwMDUpLG89e307b1tcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiXT1vW1wiW29iamVjdCBGbG9hdDY0QXJyYXldXCJdPW9bXCJbb2JqZWN0IEludDhBcnJheV1cIl09b1tcIltvYmplY3QgSW50MTZBcnJheV1cIl09b1tcIltvYmplY3QgSW50MzJBcnJheV1cIl09b1tcIltvYmplY3QgVWludDhBcnJheV1cIl09b1tcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCJdPW9bXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiXT1vW1wiW29iamVjdCBVaW50MzJBcnJheV1cIl09ITAsb1tcIltvYmplY3QgQXJndW1lbnRzXVwiXT1vW1wiW29iamVjdCBBcnJheV1cIl09b1tcIltvYmplY3QgQXJyYXlCdWZmZXJdXCJdPW9bXCJbb2JqZWN0IEJvb2xlYW5dXCJdPW9bXCJbb2JqZWN0IERhdGFWaWV3XVwiXT1vW1wiW29iamVjdCBEYXRlXVwiXT1vW1wiW29iamVjdCBFcnJvcl1cIl09b1tcIltvYmplY3QgRnVuY3Rpb25dXCJdPW9bXCJbb2JqZWN0IE1hcF1cIl09b1tcIltvYmplY3QgTnVtYmVyXVwiXT1vW1wiW29iamVjdCBPYmplY3RdXCJdPW9bXCJbb2JqZWN0IFJlZ0V4cF1cIl09b1tcIltvYmplY3QgU2V0XVwiXT1vW1wiW29iamVjdCBTdHJpbmddXCJdPW9bXCJbb2JqZWN0IFdlYWtNYXBdXCJdPSExLHQuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gYSh0KSYmcih0Lmxlbmd0aCkmJiEhb1tuKHQpXX19LDMxMzoodCxlLGkpPT57dmFyIG49aSgzMjE4KSxyPWkoNTcyNiksYT1pKDM0OTgpLG89T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoIW4odCkpcmV0dXJuIGEodCk7dmFyIGU9cih0KSxpPVtdO2Zvcih2YXIgcyBpbiB0KShcImNvbnN0cnVjdG9yXCIhPXN8fCFlJiZvLmNhbGwodCxzKSkmJmkucHVzaChzKTtyZXR1cm4gaX19LDI5ODA6KHQsZSxpKT0+e3ZhciBuPWkoNjM4NCkscj1pKDY1NTYpLGE9aSg4NDgzKSxvPWkoOTc4Mykscz1pKDMyMTgpLGw9aSgxNzA0KSxoPWkoNjM5MCk7dC5leHBvcnRzPWZ1bmN0aW9uIHUodCxlLGksYyxwKXt0IT09ZSYmYShlLChmdW5jdGlvbihhLGwpe2lmKHB8fChwPW5ldyBuKSxzKGEpKW8odCxlLGwsaSx1LGMscCk7ZWxzZXt2YXIgZD1jP2MoaCh0LGwpLGEsbCtcIlwiLHQsZSxwKTp1bmRlZmluZWQ7ZD09PXVuZGVmaW5lZCYmKGQ9YSkscih0LGwsZCl9fSksbCl9fSw5NzgzOih0LGUsaSk9Pnt2YXIgbj1pKDY1NTYpLHI9aSg0NjI2KSxhPWkoNzEzMyksbz1pKDI3OCkscz1pKDg1MTcpLGw9aSg1Njk0KSxoPWkoMTQ2OSksdT1pKDkyNDYpLGM9aSg0MTQ0KSxwPWkoMzU2MCksZD1pKDMyMTgpLGY9aSg4NjMwKSxnPWkoNjcxOSksXz1pKDYzOTApLG09aSg5ODgxKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLGkseSx2LEwsYil7dmFyIGs9Xyh0LGkpLE09XyhlLGkpLHg9Yi5nZXQoTSk7aWYoeCluKHQsaSx4KTtlbHNle3ZhciB3PUw/TChrLE0saStcIlwiLHQsZSxiKTp1bmRlZmluZWQsQz13PT09dW5kZWZpbmVkO2lmKEMpe3ZhciBQPWgoTSksRT0hUCYmYyhNKSxTPSFQJiYhRSYmZyhNKTt3PU0sUHx8RXx8Uz9oKGspP3c9azp1KGspP3c9byhrKTpFPyhDPSExLHc9cihNLCEwKSk6Uz8oQz0hMSx3PWEoTSwhMCkpOnc9W106ZihNKXx8bChNKT8odz1rLGwoayk/dz1tKGspOmQoaykmJiFwKGspfHwodz1zKE0pKSk6Qz0hMX1DJiYoYi5zZXQoTSx3KSx2KHcsTSx5LEwsYiksYltcImRlbGV0ZVwiXShNKSksbih0LGksdyl9fX0sNTk3NjoodCxlLGkpPT57dmFyIG49aSg2NTU3KSxyPWkoNTM1NyksYT1pKDYxKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYShyKHQsZSxuKSx0K1wiXCIpfX0sNjU2MDoodCxlLGkpPT57dmFyIG49aSg1NzAzKSxyPWkoODc3NyksYT1pKDY1NTcpLG89cj9mdW5jdGlvbih0LGUpe3JldHVybiByKHQsXCJ0b1N0cmluZ1wiLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMSx2YWx1ZTpuKGUpLHdyaXRhYmxlOiEwfSl9OmE7dC5leHBvcnRzPW99LDI1NDU6dD0+e3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgaT0tMSxuPUFycmF5KHQpOysraTx0OyluW2ldPWUoaSk7cmV0dXJuIG59fSw1MzE6KHQsZSxpKT0+e3ZhciBuPWkoMjcwNSkscj1pKDk5MzIpLGE9aSgxNDY5KSxvPWkoMzQ0OCkscz1uP24ucHJvdG90eXBlOnVuZGVmaW5lZCxsPXM/cy50b1N0cmluZzp1bmRlZmluZWQ7dC5leHBvcnRzPWZ1bmN0aW9uIGgodCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIHQ7aWYoYSh0KSlyZXR1cm4gcih0LGgpK1wiXCI7aWYobyh0KSlyZXR1cm4gbD9sLmNhbGwodCk6XCJcIjt2YXIgZT10K1wiXCI7cmV0dXJuXCIwXCI9PWUmJjEvdD09LUluZmluaXR5P1wiLTBcIjplfX0sMTcxNzp0PT57dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdChlKX19fSwxODExOih0LGUsaSk9Pnt2YXIgbj1pKDE0NjkpLHI9aSg1NDAzKSxhPWkoNTUxNCksbz1pKDk4MzMpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBuKHQpP3Q6cih0LGUpP1t0XTphKG8odCkpfX0sNDMxODoodCxlLGkpPT57dmFyIG49aSgxMTQ5KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHQuY29uc3RydWN0b3IodC5ieXRlTGVuZ3RoKTtyZXR1cm4gbmV3IG4oZSkuc2V0KG5ldyBuKHQpKSxlfX0sNDYyNjoodCxlLGkpPT57dD1pLm5tZCh0KTt2YXIgbj1pKDU2MzkpLHI9ZSYmIWUubm9kZVR5cGUmJmUsYT1yJiZ0JiYhdC5ub2RlVHlwZSYmdCxvPWEmJmEuZXhwb3J0cz09PXI/bi5CdWZmZXI6dW5kZWZpbmVkLHM9bz9vLmFsbG9jVW5zYWZlOnVuZGVmaW5lZDt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtpZihlKXJldHVybiB0LnNsaWNlKCk7dmFyIGk9dC5sZW5ndGgsbj1zP3MoaSk6bmV3IHQuY29uc3RydWN0b3IoaSk7cmV0dXJuIHQuY29weShuKSxufX0sNzEzMzoodCxlLGkpPT57dmFyIG49aSg0MzE4KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgaT1lP24odC5idWZmZXIpOnQuYnVmZmVyO3JldHVybiBuZXcgdC5jb25zdHJ1Y3RvcihpLHQuYnl0ZU9mZnNldCx0Lmxlbmd0aCl9fSwyNzg6dD0+e3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBpPS0xLG49dC5sZW5ndGg7Zm9yKGV8fChlPUFycmF5KG4pKTsrK2k8bjspZVtpXT10W2ldO3JldHVybiBlfX0sODM2MzoodCxlLGkpPT57dmFyIG49aSg0ODY1KSxyPWkoOTQ2NSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxpLGEpe3ZhciBvPSFpO2l8fChpPXt9KTtmb3IodmFyIHM9LTEsbD1lLmxlbmd0aDsrK3M8bDspe3ZhciBoPWVbc10sdT1hP2EoaVtoXSx0W2hdLGgsaSx0KTp1bmRlZmluZWQ7dT09PXVuZGVmaW5lZCYmKHU9dFtoXSksbz9yKGksaCx1KTpuKGksaCx1KX1yZXR1cm4gaX19LDQ0Mjk6KHQsZSxpKT0+e3ZhciBuPWkoNTYzOSlbXCJfX2NvcmUtanNfc2hhcmVkX19cIl07dC5leHBvcnRzPW59LDE0NjM6KHQsZSxpKT0+e3ZhciBuPWkoNTk3Nikscj1pKDY2MTIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbigoZnVuY3Rpb24oZSxpKXt2YXIgbj0tMSxhPWkubGVuZ3RoLG89YT4xP2lbYS0xXTp1bmRlZmluZWQscz1hPjI/aVsyXTp1bmRlZmluZWQ7Zm9yKG89dC5sZW5ndGg+MyYmXCJmdW5jdGlvblwiPT10eXBlb2Ygbz8oYS0tLG8pOnVuZGVmaW5lZCxzJiZyKGlbMF0saVsxXSxzKSYmKG89YTwzP3VuZGVmaW5lZDpvLGE9MSksZT1PYmplY3QoZSk7KytuPGE7KXt2YXIgbD1pW25dO2wmJnQoZSxsLG4sbyl9cmV0dXJuIGV9KSl9fSw1MDYzOnQ9Pnt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtmb3IodmFyIHI9LTEsYT1PYmplY3QoZSksbz1uKGUpLHM9by5sZW5ndGg7cy0tOyl7dmFyIGw9b1t0P3M6KytyXTtpZighMT09PWkoYVtsXSxsLGEpKWJyZWFrfXJldHVybiBlfX19LDg3Nzc6KHQsZSxpKT0+e3ZhciBuPWkoODUyKSxyPWZ1bmN0aW9uKCl7dHJ5e3ZhciB0PW4oT2JqZWN0LFwiZGVmaW5lUHJvcGVydHlcIik7cmV0dXJuIHQoe30sXCJcIix7fSksdH1jYXRjaChlKXt9fSgpO3QuZXhwb3J0cz1yfSwxOTU3Oih0LGUsaSk9Pnt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgaS5nJiZpLmcmJmkuZy5PYmplY3Q9PT1PYmplY3QmJmkuZzt0LmV4cG9ydHM9bn0sNTA1MDoodCxlLGkpPT57dmFyIG49aSg3MDE5KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgaT10Ll9fZGF0YV9fO3JldHVybiBuKGUpP2lbXCJzdHJpbmdcIj09dHlwZW9mIGU/XCJzdHJpbmdcIjpcImhhc2hcIl06aS5tYXB9fSw4NTI6KHQsZSxpKT0+e3ZhciBuPWkoODQ1OCkscj1pKDc4MDEpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBpPXIodCxlKTtyZXR1cm4gbihpKT9pOnVuZGVmaW5lZH19LDU5MjQ6KHQsZSxpKT0+e3ZhciBuPWkoNTU2OSkoT2JqZWN0LmdldFByb3RvdHlwZU9mLE9iamVjdCk7dC5leHBvcnRzPW59LDk2MDc6KHQsZSxpKT0+e3ZhciBuPWkoMjcwNSkscj1PYmplY3QucHJvdG90eXBlLGE9ci5oYXNPd25Qcm9wZXJ0eSxvPXIudG9TdHJpbmcscz1uP24udG9TdHJpbmdUYWc6dW5kZWZpbmVkO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1hLmNhbGwodCxzKSxpPXRbc107dHJ5e3Rbc109dW5kZWZpbmVkO3ZhciBuPSEwfWNhdGNoKGwpe312YXIgcj1vLmNhbGwodCk7cmV0dXJuIG4mJihlP3Rbc109aTpkZWxldGUgdFtzXSkscn19LDc4MDE6dD0+e3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT10P3VuZGVmaW5lZDp0W2VdfX0sMjIyOih0LGUsaSk9Pnt2YXIgbj1pKDE4MTEpLHI9aSg1Njk0KSxhPWkoMTQ2OSksbz1pKDU3NzYpLHM9aSgxNzgwKSxsPWkoMzI3KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLGkpe2Zvcih2YXIgaD0tMSx1PShlPW4oZSx0KSkubGVuZ3RoLGM9ITE7KytoPHU7KXt2YXIgcD1sKGVbaF0pO2lmKCEoYz1udWxsIT10JiZpKHQscCkpKWJyZWFrO3Q9dFtwXX1yZXR1cm4gY3x8KytoIT11P2M6ISEodT1udWxsPT10PzA6dC5sZW5ndGgpJiZzKHUpJiZvKHAsdSkmJihhKHQpfHxyKHQpKX19LDE3ODk6KHQsZSxpKT0+e3ZhciBuPWkoNDUzNik7dC5leHBvcnRzPWZ1bmN0aW9uKCl7dGhpcy5fX2RhdGFfXz1uP24obnVsbCk6e30sdGhpcy5zaXplPTB9fSw0MDE6dD0+e3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmhhcyh0KSYmZGVsZXRlIHRoaXMuX19kYXRhX19bdF07cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX19LDc2Njc6KHQsZSxpKT0+e3ZhciBuPWkoNDUzNikscj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9fZGF0YV9fO2lmKG4pe3ZhciBpPWVbdF07cmV0dXJuXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCI9PT1pP3VuZGVmaW5lZDppfXJldHVybiByLmNhbGwoZSx0KT9lW3RdOnVuZGVmaW5lZH19LDEzMjc6KHQsZSxpKT0+e3ZhciBuPWkoNDUzNikscj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9fZGF0YV9fO3JldHVybiBuP2VbdF0hPT11bmRlZmluZWQ6ci5jYWxsKGUsdCl9fSwxODY2Oih0LGUsaSk9Pnt2YXIgbj1pKDQ1MzYpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuX19kYXRhX187cmV0dXJuIHRoaXMuc2l6ZSs9dGhpcy5oYXModCk/MDoxLGlbdF09biYmZT09PXVuZGVmaW5lZD9cIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIjplLHRoaXN9fSw4NTE3Oih0LGUsaSk9Pnt2YXIgbj1pKDMxMTgpLHI9aSg1OTI0KSxhPWkoNTcyNik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIHQuY29uc3RydWN0b3J8fGEodCk/e306bihyKHQpKX19LDU3NzY6dD0+e3ZhciBlPS9eKD86MHxbMS05XVxcZCopJC87dC5leHBvcnRzPWZ1bmN0aW9uKHQsaSl7dmFyIG49dHlwZW9mIHQ7cmV0dXJuISEoaT1udWxsPT1pPzkwMDcxOTkyNTQ3NDA5OTE6aSkmJihcIm51bWJlclwiPT1ufHxcInN5bWJvbFwiIT1uJiZlLnRlc3QodCkpJiZ0Pi0xJiZ0JTE9PTAmJnQ8aX19LDY2MTI6KHQsZSxpKT0+e3ZhciBuPWkoNzgxMykscj1pKDg2MTIpLGE9aSg1Nzc2KSxvPWkoMzIxOCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxpKXtpZighbyhpKSlyZXR1cm4hMTt2YXIgcz10eXBlb2YgZTtyZXR1cm4hIShcIm51bWJlclwiPT1zP3IoaSkmJmEoZSxpLmxlbmd0aCk6XCJzdHJpbmdcIj09cyYmZSBpbiBpKSYmbihpW2VdLHQpfX0sNTQwMzoodCxlLGkpPT57dmFyIG49aSgxNDY5KSxyPWkoMzQ0OCksYT0vXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLG89L15cXHcqJC87dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7aWYobih0KSlyZXR1cm4hMTt2YXIgaT10eXBlb2YgdDtyZXR1cm4hKFwibnVtYmVyXCIhPWkmJlwic3ltYm9sXCIhPWkmJlwiYm9vbGVhblwiIT1pJiZudWxsIT10JiYhcih0KSl8fChvLnRlc3QodCl8fCFhLnRlc3QodCl8fG51bGwhPWUmJnQgaW4gT2JqZWN0KGUpKX19LDcwMTk6dD0+e3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT10eXBlb2YgdDtyZXR1cm5cInN0cmluZ1wiPT1lfHxcIm51bWJlclwiPT1lfHxcInN5bWJvbFwiPT1lfHxcImJvb2xlYW5cIj09ZT9cIl9fcHJvdG9fX1wiIT09dDpudWxsPT09dH19LDUzNDY6KHQsZSxpKT0+e3ZhciBuLHI9aSg0NDI5KSxhPShuPS9bXi5dKyQvLmV4ZWMociYmci5rZXlzJiZyLmtleXMuSUVfUFJPVE98fFwiXCIpKT9cIlN5bWJvbChzcmMpXzEuXCIrbjpcIlwiO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4hIWEmJmEgaW4gdH19LDU3MjY6dD0+e3ZhciBlPU9iamVjdC5wcm90b3R5cGU7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBpPXQmJnQuY29uc3RydWN0b3I7cmV0dXJuIHQ9PT0oXCJmdW5jdGlvblwiPT10eXBlb2YgaSYmaS5wcm90b3R5cGV8fGUpfX0sNzA0MDp0PT57dC5leHBvcnRzPWZ1bmN0aW9uKCl7dGhpcy5fX2RhdGFfXz1bXSx0aGlzLnNpemU9MH19LDQxMjU6KHQsZSxpKT0+e3ZhciBuPWkoODQ3MCkscj1BcnJheS5wcm90b3R5cGUuc3BsaWNlO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9fZGF0YV9fLGk9bihlLHQpO3JldHVybiEoaTwwKSYmKGk9PWUubGVuZ3RoLTE/ZS5wb3AoKTpyLmNhbGwoZSxpLDEpLC0tdGhpcy5zaXplLCEwKX19LDIxMTc6KHQsZSxpKT0+e3ZhciBuPWkoODQ3MCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX19kYXRhX18saT1uKGUsdCk7cmV0dXJuIGk8MD91bmRlZmluZWQ6ZVtpXVsxXX19LDc1MTg6KHQsZSxpKT0+e3ZhciBuPWkoODQ3MCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMuX19kYXRhX18sdCk+LTF9fSw0NzA1Oih0LGUsaSk9Pnt2YXIgbj1pKDg0NzApO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuX19kYXRhX18scj1uKGksdCk7cmV0dXJuIHI8MD8oKyt0aGlzLnNpemUsaS5wdXNoKFt0LGVdKSk6aVtyXVsxXT1lLHRoaXN9fSw0Nzg1Oih0LGUsaSk9Pnt2YXIgbj1pKDE5ODkpLHI9aSg4NDA3KSxhPWkoNzA3MSk7dC5leHBvcnRzPWZ1bmN0aW9uKCl7dGhpcy5zaXplPTAsdGhpcy5fX2RhdGFfXz17aGFzaDpuZXcgbixtYXA6bmV3KGF8fHIpLHN0cmluZzpuZXcgbn19fSwxMjg1Oih0LGUsaSk9Pnt2YXIgbj1pKDUwNTApO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1uKHRoaXMsdClbXCJkZWxldGVcIl0odCk7cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX19LDZlMzoodCxlLGkpPT57dmFyIG49aSg1MDUwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx0KS5nZXQodCl9fSw5OTE2Oih0LGUsaSk9Pnt2YXIgbj1pKDUwNTApO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHQpLmhhcyh0KX19LDUyNjU6KHQsZSxpKT0+e3ZhciBuPWkoNTA1MCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIGk9bih0aGlzLHQpLHI9aS5zaXplO3JldHVybiBpLnNldCh0LGUpLHRoaXMuc2l6ZSs9aS5zaXplPT1yPzA6MSx0aGlzfX0sNDUyMzoodCxlLGkpPT57dmFyIG49aSg4MzA2KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9bih0LChmdW5jdGlvbih0KXtyZXR1cm4gNTAwPT09aS5zaXplJiZpLmNsZWFyKCksdH0pKSxpPWUuY2FjaGU7cmV0dXJuIGV9fSw0NTM2Oih0LGUsaSk9Pnt2YXIgbj1pKDg1MikoT2JqZWN0LFwiY3JlYXRlXCIpO3QuZXhwb3J0cz1ufSwzNDk4OnQ9Pnt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9W107aWYobnVsbCE9dClmb3IodmFyIGkgaW4gT2JqZWN0KHQpKWUucHVzaChpKTtyZXR1cm4gZX19LDExNjc6KHQsZSxpKT0+e3Q9aS5ubWQodCk7dmFyIG49aSgxOTU3KSxyPWUmJiFlLm5vZGVUeXBlJiZlLGE9ciYmdCYmIXQubm9kZVR5cGUmJnQsbz1hJiZhLmV4cG9ydHM9PT1yJiZuLnByb2Nlc3Mscz1mdW5jdGlvbigpe3RyeXt2YXIgdD1hJiZhLnJlcXVpcmUmJmEucmVxdWlyZShcInV0aWxcIikudHlwZXM7cmV0dXJuIHR8fG8mJm8uYmluZGluZyYmby5iaW5kaW5nKFwidXRpbFwiKX1jYXRjaChlKXt9fSgpO3QuZXhwb3J0cz1zfSwyMzMzOnQ9Pnt2YXIgZT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gZS5jYWxsKHQpfX0sNTU2OTp0PT57dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKGkpe3JldHVybiB0KGUoaSkpfX19LDUzNTc6KHQsZSxpKT0+e3ZhciBuPWkoNjg3NCkscj1NYXRoLm1heDt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLGkpe3JldHVybiBlPXIoZT09PXVuZGVmaW5lZD90Lmxlbmd0aC0xOmUsMCksZnVuY3Rpb24oKXtmb3IodmFyIGE9YXJndW1lbnRzLG89LTEscz1yKGEubGVuZ3RoLWUsMCksbD1BcnJheShzKTsrK288czspbFtvXT1hW2Urb107bz0tMTtmb3IodmFyIGg9QXJyYXkoZSsxKTsrK288ZTspaFtvXT1hW29dO3JldHVybiBoW2VdPWkobCksbih0LHRoaXMsaCl9fX0sNTYzOToodCxlLGkpPT57dmFyIG49aSgxOTU3KSxyPVwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmJiZzZWxmLk9iamVjdD09PU9iamVjdCYmc2VsZixhPW58fHJ8fEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTt0LmV4cG9ydHM9YX0sNjM5MDp0PT57dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7aWYoKFwiY29uc3RydWN0b3JcIiE9PWV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRbZV0pJiZcIl9fcHJvdG9fX1wiIT1lKXJldHVybiB0W2VdfX0sNjE6KHQsZSxpKT0+e3ZhciBuPWkoNjU2MCkscj1pKDEyNzUpKG4pO3QuZXhwb3J0cz1yfSwxMjc1OnQ9Pnt2YXIgZT1EYXRlLm5vdzt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGk9MCxuPTA7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHI9ZSgpLGE9MTYtKHItbik7aWYobj1yLGE+MCl7aWYoKytpPj04MDApcmV0dXJuIGFyZ3VtZW50c1swXX1lbHNlIGk9MDtyZXR1cm4gdC5hcHBseSh1bmRlZmluZWQsYXJndW1lbnRzKX19fSw3NDY1Oih0LGUsaSk9Pnt2YXIgbj1pKDg0MDcpO3QuZXhwb3J0cz1mdW5jdGlvbigpe3RoaXMuX19kYXRhX189bmV3IG4sdGhpcy5zaXplPTB9fSwzNzc5OnQ9Pnt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fX2RhdGFfXyxpPWVbXCJkZWxldGVcIl0odCk7cmV0dXJuIHRoaXMuc2l6ZT1lLnNpemUsaX19LDc1OTk6dD0+e3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQodCl9fSw0NzU4OnQ9Pnt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHQpfX0sNDMwOToodCxlLGkpPT57dmFyIG49aSg4NDA3KSxyPWkoNzA3MSksYT1pKDMzNjkpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuX19kYXRhX187aWYoaSBpbnN0YW5jZW9mIG4pe3ZhciBvPWkuX19kYXRhX187aWYoIXJ8fG8ubGVuZ3RoPDE5OSlyZXR1cm4gby5wdXNoKFt0LGVdKSx0aGlzLnNpemU9KytpLnNpemUsdGhpcztpPXRoaXMuX19kYXRhX189bmV3IGEobyl9cmV0dXJuIGkuc2V0KHQsZSksdGhpcy5zaXplPWkuc2l6ZSx0aGlzfX0sNTUxNDoodCxlLGkpPT57dmFyIG49aSg0NTIzKSxyPS9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZyxhPS9cXFxcKFxcXFwpPy9nLG89bigoZnVuY3Rpb24odCl7dmFyIGU9W107cmV0dXJuIDQ2PT09dC5jaGFyQ29kZUF0KDApJiZlLnB1c2goXCJcIiksdC5yZXBsYWNlKHIsKGZ1bmN0aW9uKHQsaSxuLHIpe2UucHVzaChuP3IucmVwbGFjZShhLFwiJDFcIik6aXx8dCl9KSksZX0pKTt0LmV4cG9ydHM9b30sMzI3Oih0LGUsaSk9Pnt2YXIgbj1pKDM0NDgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdHx8bih0KSlyZXR1cm4gdDt2YXIgZT10K1wiXCI7cmV0dXJuXCIwXCI9PWUmJjEvdD09LUluZmluaXR5P1wiLTBcIjplfX0sMzQ2OnQ9Pnt2YXIgZT1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKG51bGwhPXQpe3RyeXtyZXR1cm4gZS5jYWxsKHQpfWNhdGNoKGkpe310cnl7cmV0dXJuIHQrXCJcIn1jYXRjaChpKXt9fXJldHVyblwiXCJ9fSw1NzAzOnQ9Pnt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHR9fX0sNzgxMzp0PT57dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PT1lfHx0IT10JiZlIT1lfX0sNzM2MToodCxlLGkpPT57dmFyIG49aSg3Nzg2KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLGkpe3ZhciByPW51bGw9PXQ/dW5kZWZpbmVkOm4odCxlKTtyZXR1cm4gcj09PXVuZGVmaW5lZD9pOnJ9fSw4NzIxOih0LGUsaSk9Pnt2YXIgbj1pKDg1NjUpLHI9aSgyMjIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsIT10JiZyKHQsZSxuKX19LDY1NTc6dD0+e3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdH19LDU2OTQ6KHQsZSxpKT0+e3ZhciBuPWkoOTQ1NCkscj1pKDcwMDUpLGE9T2JqZWN0LnByb3RvdHlwZSxvPWEuaGFzT3duUHJvcGVydHkscz1hLnByb3BlcnR5SXNFbnVtZXJhYmxlLGw9bihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpP246ZnVuY3Rpb24odCl7cmV0dXJuIHIodCkmJm8uY2FsbCh0LFwiY2FsbGVlXCIpJiYhcy5jYWxsKHQsXCJjYWxsZWVcIil9O3QuZXhwb3J0cz1sfSwxNDY5OnQ9Pnt2YXIgZT1BcnJheS5pc0FycmF5O3QuZXhwb3J0cz1lfSw4NjEyOih0LGUsaSk9Pnt2YXIgbj1pKDM1NjApLHI9aSgxNzgwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXQmJnIodC5sZW5ndGgpJiYhbih0KX19LDkyNDY6KHQsZSxpKT0+e3ZhciBuPWkoODYxMikscj1pKDcwMDUpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gcih0KSYmbih0KX19LDQxNDQ6KHQsZSxpKT0+e3Q9aS5ubWQodCk7dmFyIG49aSg1NjM5KSxyPWkoNTA2MiksYT1lJiYhZS5ub2RlVHlwZSYmZSxvPWEmJnQmJiF0Lm5vZGVUeXBlJiZ0LHM9byYmby5leHBvcnRzPT09YT9uLkJ1ZmZlcjp1bmRlZmluZWQsbD0ocz9zLmlzQnVmZmVyOnVuZGVmaW5lZCl8fHI7dC5leHBvcnRzPWx9LDM1NjA6KHQsZSxpKT0+e3ZhciBuPWkoNDIzOSkscj1pKDMyMTgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZighcih0KSlyZXR1cm4hMTt2YXIgZT1uKHQpO3JldHVyblwiW29iamVjdCBGdW5jdGlvbl1cIj09ZXx8XCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiPT1lfHxcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIj09ZXx8XCJbb2JqZWN0IFByb3h5XVwiPT1lfX0sMTc4MDp0PT57dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZ0Pi0xJiZ0JTE9PTAmJnQ8PTkwMDcxOTkyNTQ3NDA5OTF9fSwzMjE4OnQ9Pnt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9dHlwZW9mIHQ7cmV0dXJuIG51bGwhPXQmJihcIm9iamVjdFwiPT1lfHxcImZ1bmN0aW9uXCI9PWUpfX0sNzAwNTp0PT57dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10JiZcIm9iamVjdFwiPT10eXBlb2YgdH19LDg2MzA6KHQsZSxpKT0+e3ZhciBuPWkoNDIzOSkscj1pKDU5MjQpLGE9aSg3MDA1KSxvPUZ1bmN0aW9uLnByb3RvdHlwZSxzPU9iamVjdC5wcm90b3R5cGUsbD1vLnRvU3RyaW5nLGg9cy5oYXNPd25Qcm9wZXJ0eSx1PWwuY2FsbChPYmplY3QpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZighYSh0KXx8XCJbb2JqZWN0IE9iamVjdF1cIiE9bih0KSlyZXR1cm4hMTt2YXIgZT1yKHQpO2lmKG51bGw9PT1lKXJldHVybiEwO3ZhciBpPWguY2FsbChlLFwiY29uc3RydWN0b3JcIikmJmUuY29uc3RydWN0b3I7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgaSYmaSBpbnN0YW5jZW9mIGkmJmwuY2FsbChpKT09dX19LDM0NDg6KHQsZSxpKT0+e3ZhciBuPWkoNDIzOSkscj1pKDcwMDUpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdHx8cih0KSYmXCJbb2JqZWN0IFN5bWJvbF1cIj09bih0KX19LDY3MTk6KHQsZSxpKT0+e3ZhciBuPWkoODc0OSkscj1pKDE3MTcpLGE9aSgxMTY3KSxvPWEmJmEuaXNUeXBlZEFycmF5LHM9bz9yKG8pOm47dC5leHBvcnRzPXN9LDE3MDQ6KHQsZSxpKT0+e3ZhciBuPWkoNDYzNikscj1pKDMxMyksYT1pKDg2MTIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gYSh0KT9uKHQsITApOnIodCl9fSw4MzA2Oih0LGUsaSk9Pnt2YXIgbj1pKDMzNjkpO2Z1bmN0aW9uIHIodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHxudWxsIT1lJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCIpO3ZhciBpPWZ1bmN0aW9uKCl7dmFyIG49YXJndW1lbnRzLHI9ZT9lLmFwcGx5KHRoaXMsbik6blswXSxhPWkuY2FjaGU7aWYoYS5oYXMocikpcmV0dXJuIGEuZ2V0KHIpO3ZhciBvPXQuYXBwbHkodGhpcyxuKTtyZXR1cm4gaS5jYWNoZT1hLnNldChyLG8pfHxhLG99O3JldHVybiBpLmNhY2hlPW5ldyhyLkNhY2hlfHxuKSxpfXIuQ2FjaGU9bix0LmV4cG9ydHM9cn0sMjQ5MjoodCxlLGkpPT57dmFyIG49aSgyOTgwKSxyPWkoMTQ2MykoKGZ1bmN0aW9uKHQsZSxpKXtuKHQsZSxpKX0pKTt0LmV4cG9ydHM9cn0sNTA2Mjp0PT57dC5leHBvcnRzPWZ1bmN0aW9uKCl7cmV0dXJuITF9fSw5ODgxOih0LGUsaSk9Pnt2YXIgbj1pKDgzNjMpLHI9aSgxNzA0KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odCxyKHQpKX19LDk4MzM6KHQsZSxpKT0+e3ZhciBuPWkoNTMxKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXQ/XCJcIjpuKHQpfX0sMjY3NjpmdW5jdGlvbih0KXt0LmV4cG9ydHM9ZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBlKHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX1mdW5jdGlvbiBpKHQsaSxuKXtyZXR1cm4gaSYmZSh0LnByb3RvdHlwZSxpKSxuJiZlKHQsbiksdH12YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLm5leHQ9bnVsbCx0aGlzLmtleT10LHRoaXMuZGF0YT1lLHRoaXMubGVmdD1udWxsLHRoaXMucmlnaHQ9bnVsbH1yZXR1cm4gdH0oKTtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIHQ+ZT8xOnQ8ZT8tMTowfWZ1bmN0aW9uIGEodCxlLGkpe2Zvcih2YXIgcj1uZXcgbihudWxsLG51bGwpLGE9cixvPXI7Oyl7dmFyIHM9aSh0LGUua2V5KTtpZihzPDApe2lmKG51bGw9PT1lLmxlZnQpYnJlYWs7aWYoaSh0LGUubGVmdC5rZXkpPDApe3ZhciBsPWUubGVmdDtpZihlLmxlZnQ9bC5yaWdodCxsLnJpZ2h0PWUsbnVsbD09PShlPWwpLmxlZnQpYnJlYWt9by5sZWZ0PWUsbz1lLGU9ZS5sZWZ0fWVsc2V7aWYoIShzPjApKWJyZWFrO2lmKG51bGw9PT1lLnJpZ2h0KWJyZWFrO2lmKGkodCxlLnJpZ2h0LmtleSk+MCYmKGw9ZS5yaWdodCxlLnJpZ2h0PWwubGVmdCxsLmxlZnQ9ZSxudWxsPT09KGU9bCkucmlnaHQpKWJyZWFrO2EucmlnaHQ9ZSxhPWUsZT1lLnJpZ2h0fX1yZXR1cm4gYS5yaWdodD1lLmxlZnQsby5sZWZ0PWUucmlnaHQsZS5sZWZ0PXIucmlnaHQsZS5yaWdodD1yLmxlZnQsZX1mdW5jdGlvbiBvKHQsZSxpLHIpe3ZhciBvPW5ldyBuKHQsZSk7aWYobnVsbD09PWkpcmV0dXJuIG8ubGVmdD1vLnJpZ2h0PW51bGwsbzt2YXIgcz1yKHQsKGk9YSh0LGkscikpLmtleSk7cmV0dXJuIHM8MD8oby5sZWZ0PWkubGVmdCxvLnJpZ2h0PWksaS5sZWZ0PW51bGwpOnM+PTAmJihvLnJpZ2h0PWkucmlnaHQsby5sZWZ0PWksaS5yaWdodD1udWxsKSxvfWZ1bmN0aW9uIHModCxlLGkpe3ZhciBuPW51bGwscj1udWxsO2lmKGUpe3ZhciBvPWkoKGU9YSh0LGUsaSkpLmtleSx0KTswPT09bz8obj1lLmxlZnQscj1lLnJpZ2h0KTpvPDA/KHI9ZS5yaWdodCxlLnJpZ2h0PW51bGwsbj1lKToobj1lLmxlZnQsZS5sZWZ0PW51bGwscj1lKX1yZXR1cm57bGVmdDpuLHJpZ2h0OnJ9fWZ1bmN0aW9uIGwodCxlLGkpe3JldHVybiBudWxsPT09ZT90OihudWxsPT09dHx8KChlPWEodC5rZXksZSxpKSkubGVmdD10KSxlKX1mdW5jdGlvbiBoKHQsZSxpLG4scil7aWYodCl7bihlKyhpP1wi4pSU4pSA4pSAIFwiOlwi4pSc4pSA4pSAIFwiKStyKHQpK1wiXFxuXCIpO3ZhciBhPWUrKGk/XCIgICAgXCI6XCLilIIgICBcIik7dC5sZWZ0JiZoKHQubGVmdCxhLCExLG4sciksdC5yaWdodCYmaCh0LnJpZ2h0LGEsITAsbixyKX19dmFyIHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZvaWQgMD09PXQmJih0PXIpLHRoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9zaXplPTAsdGhpcy5fY29tcGFyYXRvcj10fXJldHVybiB0LnByb3RvdHlwZS5pbnNlcnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fc2l6ZSsrLHRoaXMuX3Jvb3Q9byh0LGUsdGhpcy5fcm9vdCx0aGlzLl9jb21wYXJhdG9yKX0sdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsZSl7dmFyIGk9bmV3IG4odCxlKTtudWxsPT09dGhpcy5fcm9vdCYmKGkubGVmdD1pLnJpZ2h0PW51bGwsdGhpcy5fc2l6ZSsrLHRoaXMuX3Jvb3Q9aSk7dmFyIHI9dGhpcy5fY29tcGFyYXRvcixvPWEodCx0aGlzLl9yb290LHIpLHM9cih0LG8ua2V5KTtyZXR1cm4gMD09PXM/dGhpcy5fcm9vdD1vOihzPDA/KGkubGVmdD1vLmxlZnQsaS5yaWdodD1vLG8ubGVmdD1udWxsKTpzPjAmJihpLnJpZ2h0PW8ucmlnaHQsaS5sZWZ0PW8sby5yaWdodD1udWxsKSx0aGlzLl9zaXplKyssdGhpcy5fcm9vdD1pKSx0aGlzLl9yb290fSx0LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7dGhpcy5fcm9vdD10aGlzLl9yZW1vdmUodCx0aGlzLl9yb290LHRoaXMuX2NvbXBhcmF0b3IpfSx0LnByb3RvdHlwZS5fcmVtb3ZlPWZ1bmN0aW9uKHQsZSxpKXt2YXIgbjtyZXR1cm4gbnVsbD09PWU/bnVsbDowPT09aSh0LChlPWEodCxlLGkpKS5rZXkpPyhudWxsPT09ZS5sZWZ0P249ZS5yaWdodDoobj1hKHQsZS5sZWZ0LGkpKS5yaWdodD1lLnJpZ2h0LHRoaXMuX3NpemUtLSxuKTplfSx0LnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9yb290O2lmKHQpe2Zvcig7dC5sZWZ0Oyl0PXQubGVmdDtyZXR1cm4gdGhpcy5fcm9vdD1hKHQua2V5LHRoaXMuX3Jvb3QsdGhpcy5fY29tcGFyYXRvciksdGhpcy5fcm9vdD10aGlzLl9yZW1vdmUodC5rZXksdGhpcy5fcm9vdCx0aGlzLl9jb21wYXJhdG9yKSx7a2V5OnQua2V5LGRhdGE6dC5kYXRhfX1yZXR1cm4gbnVsbH0sdC5wcm90b3R5cGUuZmluZFN0YXRpYz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5fcm9vdCxpPXRoaXMuX2NvbXBhcmF0b3I7ZTspe3ZhciBuPWkodCxlLmtleSk7aWYoMD09PW4pcmV0dXJuIGU7ZT1uPDA/ZS5sZWZ0OmUucmlnaHR9cmV0dXJuIG51bGx9LHQucHJvdG90eXBlLmZpbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3Jvb3QmJih0aGlzLl9yb290PWEodCx0aGlzLl9yb290LHRoaXMuX2NvbXBhcmF0b3IpLDAhPT10aGlzLl9jb21wYXJhdG9yKHQsdGhpcy5fcm9vdC5rZXkpKT9udWxsOnRoaXMuX3Jvb3R9LHQucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLl9yb290LGk9dGhpcy5fY29tcGFyYXRvcjtlOyl7dmFyIG49aSh0LGUua2V5KTtpZigwPT09bilyZXR1cm4hMDtlPW48MD9lLmxlZnQ6ZS5yaWdodH1yZXR1cm4hMX0sdC5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgaT10aGlzLl9yb290LG49W10scj0hMTshcjspbnVsbCE9PWk/KG4ucHVzaChpKSxpPWkubGVmdCk6MCE9PW4ubGVuZ3RoPyhpPW4ucG9wKCksdC5jYWxsKGUsaSksaT1pLnJpZ2h0KTpyPSEwO3JldHVybiB0aGlzfSx0LnByb3RvdHlwZS5yYW5nZT1mdW5jdGlvbih0LGUsaSxuKXtmb3IodmFyIHI9W10sYT10aGlzLl9jb21wYXJhdG9yLG89dGhpcy5fcm9vdDswIT09ci5sZW5ndGh8fG87KWlmKG8pci5wdXNoKG8pLG89by5sZWZ0O2Vsc2V7aWYoYSgobz1yLnBvcCgpKS5rZXksZSk+MClicmVhaztpZihhKG8ua2V5LHQpPj0wJiZpLmNhbGwobixvKSlyZXR1cm4gdGhpcztvPW8ucmlnaHR9cmV0dXJuIHRoaXN9LHQucHJvdG90eXBlLmtleXM9ZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gdGhpcy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgaT1lLmtleTtyZXR1cm4gdC5wdXNoKGkpfSkpLHR9LHQucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0aGlzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBpPWUuZGF0YTtyZXR1cm4gdC5wdXNoKGkpfSkpLHR9LHQucHJvdG90eXBlLm1pbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb290P3RoaXMubWluTm9kZSh0aGlzLl9yb290KS5rZXk6bnVsbH0sdC5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Jvb3Q/dGhpcy5tYXhOb2RlKHRoaXMuX3Jvb3QpLmtleTpudWxsfSx0LnByb3RvdHlwZS5taW5Ob2RlPWZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQmJih0PXRoaXMuX3Jvb3QpLHQpZm9yKDt0LmxlZnQ7KXQ9dC5sZWZ0O3JldHVybiB0fSx0LnByb3RvdHlwZS5tYXhOb2RlPWZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQmJih0PXRoaXMuX3Jvb3QpLHQpZm9yKDt0LnJpZ2h0Oyl0PXQucmlnaHQ7cmV0dXJuIHR9LHQucHJvdG90eXBlLmF0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLl9yb290LGk9ITEsbj0wLHI9W107IWk7KWlmKGUpci5wdXNoKGUpLGU9ZS5sZWZ0O2Vsc2UgaWYoci5sZW5ndGg+MCl7aWYoZT1yLnBvcCgpLG49PT10KXJldHVybiBlO24rKyxlPWUucmlnaHR9ZWxzZSBpPSEwO3JldHVybiBudWxsfSx0LnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3Jvb3QsaT1udWxsO2lmKHQucmlnaHQpe2ZvcihpPXQucmlnaHQ7aS5sZWZ0OylpPWkubGVmdDtyZXR1cm4gaX1mb3IodmFyIG49dGhpcy5fY29tcGFyYXRvcjtlOyl7dmFyIHI9bih0LmtleSxlLmtleSk7aWYoMD09PXIpYnJlYWs7cjwwPyhpPWUsZT1lLmxlZnQpOmU9ZS5yaWdodH1yZXR1cm4gaX0sdC5wcm90b3R5cGUucHJldj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9yb290LGk9bnVsbDtpZihudWxsIT09dC5sZWZ0KXtmb3IoaT10LmxlZnQ7aS5yaWdodDspaT1pLnJpZ2h0O3JldHVybiBpfWZvcih2YXIgbj10aGlzLl9jb21wYXJhdG9yO2U7KXt2YXIgcj1uKHQua2V5LGUua2V5KTtpZigwPT09cilicmVhaztyPDA/ZT1lLmxlZnQ6KGk9ZSxlPWUucmlnaHQpfXJldHVybiBpfSx0LnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb290PW51bGwsdGhpcy5fc2l6ZT0wLHRoaXN9LHQucHJvdG90eXBlLnRvTGlzdD1mdW5jdGlvbigpe3JldHVybiBkKHRoaXMuX3Jvb3QpfSx0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKHQsZSxpKXt2b2lkIDA9PT1lJiYoZT1bXSksdm9pZCAwPT09aSYmKGk9ITEpO3ZhciBuPXQubGVuZ3RoLHI9dGhpcy5fY29tcGFyYXRvcjtpZihpJiZfKHQsZSwwLG4tMSxyKSxudWxsPT09dGhpcy5fcm9vdCl0aGlzLl9yb290PWModCxlLDAsbiksdGhpcy5fc2l6ZT1uO2Vsc2V7dmFyIGE9Zyh0aGlzLnRvTGlzdCgpLHAodCxlKSxyKTtuPXRoaXMuX3NpemUrbix0aGlzLl9yb290PWYoe2hlYWQ6YX0sMCxuKX1yZXR1cm4gdGhpc30sdC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5fcm9vdH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2l6ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyb290XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb290fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PWZ1bmN0aW9uKHQpe3JldHVybiBTdHJpbmcodC5rZXkpfSk7dmFyIGU9W107cmV0dXJuIGgodGhpcy5fcm9vdCxcIlwiLCEwLChmdW5jdGlvbih0KXtyZXR1cm4gZS5wdXNoKHQpfSksdCksZS5qb2luKFwiXCIpfSx0LnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24odCxlLGkpe3ZhciBuPXRoaXMuX2NvbXBhcmF0b3Iscj1zKHQsdGhpcy5fcm9vdCxuKSxhPXIubGVmdCxoPXIucmlnaHQ7bih0LGUpPDA/aD1vKGUsaSxoLG4pOmE9byhlLGksYSxuKSx0aGlzLl9yb290PWwoYSxoLG4pfSx0LnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0KXtyZXR1cm4gcyh0LHRoaXMuX3Jvb3QsdGhpcy5fY29tcGFyYXRvcil9LHR9KCk7ZnVuY3Rpb24gYyh0LGUsaSxyKXt2YXIgYT1yLWk7aWYoYT4wKXt2YXIgbz1pK01hdGguZmxvb3IoYS8yKSxzPXRbb10sbD1lW29dLGg9bmV3IG4ocyxsKTtyZXR1cm4gaC5sZWZ0PWModCxlLGksbyksaC5yaWdodD1jKHQsZSxvKzEsciksaH1yZXR1cm4gbnVsbH1mdW5jdGlvbiBwKHQsZSl7Zm9yKHZhciBpPW5ldyBuKG51bGwsbnVsbCkscj1pLGE9MDthPHQubGVuZ3RoO2ErKylyPXIubmV4dD1uZXcgbih0W2FdLGVbYV0pO3JldHVybiByLm5leHQ9bnVsbCxpLm5leHR9ZnVuY3Rpb24gZCh0KXtmb3IodmFyIGU9dCxpPVtdLHI9ITEsYT1uZXcgbihudWxsLG51bGwpLG89YTshcjspZT8oaS5wdXNoKGUpLGU9ZS5sZWZ0KTppLmxlbmd0aD4wP2U9KGU9bz1vLm5leHQ9aS5wb3AoKSkucmlnaHQ6cj0hMDtyZXR1cm4gby5uZXh0PW51bGwsYS5uZXh0fWZ1bmN0aW9uIGYodCxlLGkpe3ZhciBuPWktZTtpZihuPjApe3ZhciByPWUrTWF0aC5mbG9vcihuLzIpLGE9Zih0LGUsciksbz10LmhlYWQ7cmV0dXJuIG8ubGVmdD1hLHQuaGVhZD10LmhlYWQubmV4dCxvLnJpZ2h0PWYodCxyKzEsaSksb31yZXR1cm4gbnVsbH1mdW5jdGlvbiBnKHQsZSxpKXtmb3IodmFyIHI9bmV3IG4obnVsbCxudWxsKSxhPXIsbz10LHM9ZTtudWxsIT09byYmbnVsbCE9PXM7KWkoby5rZXkscy5rZXkpPDA/KGEubmV4dD1vLG89by5uZXh0KTooYS5uZXh0PXMscz1zLm5leHQpLGE9YS5uZXh0O3JldHVybiBudWxsIT09bz9hLm5leHQ9bzpudWxsIT09cyYmKGEubmV4dD1zKSxyLm5leHR9ZnVuY3Rpb24gXyh0LGUsaSxuLHIpe2lmKCEoaT49bikpe2Zvcih2YXIgYT10W2krbj4+MV0sbz1pLTEscz1uKzE7Oyl7ZG97bysrfXdoaWxlKHIodFtvXSxhKTwwKTtkb3tzLS19d2hpbGUocih0W3NdLGEpPjApO2lmKG8+PXMpYnJlYWs7dmFyIGw9dFtvXTt0W29dPXRbc10sdFtzXT1sLGw9ZVtvXSxlW29dPWVbc10sZVtzXT1sfV8odCxlLGkscyxyKSxfKHQsZSxzKzEsbixyKX19dmFyIG09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5sbC54PD1lLngmJmUueDw9dC51ci54JiZ0LmxsLnk8PWUueSYmZS55PD10LnVyLnl9LHk9ZnVuY3Rpb24odCxlKXtpZihlLnVyLng8dC5sbC54fHx0LnVyLng8ZS5sbC54fHxlLnVyLnk8dC5sbC55fHx0LnVyLnk8ZS5sbC55KXJldHVybiBudWxsO3ZhciBpPXQubGwueDxlLmxsLng/ZS5sbC54OnQubGwueCxuPXQudXIueDxlLnVyLng/dC51ci54OmUudXIueDtyZXR1cm57bGw6e3g6aSx5OnQubGwueTxlLmxsLnk/ZS5sbC55OnQubGwueX0sdXI6e3g6bix5OnQudXIueTxlLnVyLnk/dC51ci55OmUudXIueX19fSx2PU51bWJlci5FUFNJTE9OO3Y9PT11bmRlZmluZWQmJih2PU1hdGgucG93KDIsLTUyKSk7dmFyIEw9dip2LGI9ZnVuY3Rpb24odCxlKXtpZigtdjx0JiZ0PHYmJi12PGUmJmU8dilyZXR1cm4gMDt2YXIgaT10LWU7cmV0dXJuIGkqaTxMKnQqZT8wOnQ8ZT8tMToxfSxrPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3QodGhpcyxlKSx0aGlzLnJlc2V0KCl9cmV0dXJuIGkoZSxbe2tleTpcInJlc2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnhSb3VuZGVyPW5ldyBNLHRoaXMueVJvdW5kZXI9bmV3IE19fSx7a2V5Olwicm91bmRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybnt4OnRoaXMueFJvdW5kZXIucm91bmQodCkseTp0aGlzLnlSb3VuZGVyLnJvdW5kKGUpfX19XSksZX0oKSxNPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3QodGhpcyxlKSx0aGlzLnRyZWU9bmV3IHUsdGhpcy5yb3VuZCgwKX1yZXR1cm4gaShlLFt7a2V5Olwicm91bmRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnRyZWUuYWRkKHQpLGk9dGhpcy50cmVlLnByZXYoZSk7aWYobnVsbCE9PWkmJjA9PT1iKGUua2V5LGkua2V5KSlyZXR1cm4gdGhpcy50cmVlLnJlbW92ZSh0KSxpLmtleTt2YXIgbj10aGlzLnRyZWUubmV4dChlKTtyZXR1cm4gbnVsbCE9PW4mJjA9PT1iKGUua2V5LG4ua2V5KT8odGhpcy50cmVlLnJlbW92ZSh0KSxuLmtleSk6dH19XSksZX0oKSx4PW5ldyBrLHc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC54KmUueS10LnkqZS54fSxDPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQueCplLngrdC55KmUueX0sUD1mdW5jdGlvbih0LGUsaSl7dmFyIG49e3g6ZS54LXQueCx5OmUueS10Lnl9LHI9e3g6aS54LXQueCx5OmkueS10Lnl9LGE9dyhuLHIpO3JldHVybiBiKGEsMCl9LEU9ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguc3FydChDKHQsdCkpfSxTPWZ1bmN0aW9uKHQsZSxpKXt2YXIgbj17eDplLngtdC54LHk6ZS55LXQueX0scj17eDppLngtdC54LHk6aS55LXQueX07cmV0dXJuIHcocixuKS9FKHIpL0Uobil9LE89ZnVuY3Rpb24odCxlLGkpe3ZhciBuPXt4OmUueC10LngseTplLnktdC55fSxyPXt4OmkueC10LngseTppLnktdC55fTtyZXR1cm4gQyhyLG4pL0UocikvRShuKX0sRD1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIDA9PT1lLnk/bnVsbDp7eDp0LngrZS54L2UueSooaS10LnkpLHk6aX19LFI9ZnVuY3Rpb24odCxlLGkpe3JldHVybiAwPT09ZS54P251bGw6e3g6aSx5OnQueStlLnkvZS54KihpLXQueCl9fSxCPWZ1bmN0aW9uKHQsZSxpLG4pe2lmKDA9PT1lLngpcmV0dXJuIFIoaSxuLHQueCk7aWYoMD09PW4ueClyZXR1cm4gUih0LGUsaS54KTtpZigwPT09ZS55KXJldHVybiBEKGksbix0LnkpO2lmKDA9PT1uLnkpcmV0dXJuIEQodCxlLGkueSk7dmFyIHI9dyhlLG4pO2lmKDA9PXIpcmV0dXJuIG51bGw7dmFyIGE9e3g6aS54LXQueCx5OmkueS10Lnl9LG89dyhhLGUpL3Iscz13KGEsbikvcjtyZXR1cm57eDoodC54K3MqZS54KyhpLngrbypuLngpKS8yLHk6KHQueStzKmUueSsoaS55K28qbi55KSkvMn19LFQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7dCh0aGlzLGUpLGkuZXZlbnRzPT09dW5kZWZpbmVkP2kuZXZlbnRzPVt0aGlzXTppLmV2ZW50cy5wdXNoKHRoaXMpLHRoaXMucG9pbnQ9aSx0aGlzLmlzTGVmdD1ufXJldHVybiBpKGUsbnVsbCxbe2tleTpcImNvbXBhcmVcIix2YWx1ZTpmdW5jdGlvbih0LGkpe3ZhciBuPWUuY29tcGFyZVBvaW50cyh0LnBvaW50LGkucG9pbnQpO3JldHVybiAwIT09bj9uOih0LnBvaW50IT09aS5wb2ludCYmdC5saW5rKGkpLHQuaXNMZWZ0IT09aS5pc0xlZnQ/dC5pc0xlZnQ/MTotMTpqLmNvbXBhcmUodC5zZWdtZW50LGkuc2VnbWVudCkpfX0se2tleTpcImNvbXBhcmVQb2ludHNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0Lng8ZS54Py0xOnQueD5lLng/MTp0Lnk8ZS55Py0xOnQueT5lLnk/MTowfX1dKSxpKGUsW3trZXk6XCJsaW5rXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodC5wb2ludD09PXRoaXMucG9pbnQpdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gbGluayBhbHJlYWR5IGxpbmtlZCBldmVudHNcIik7Zm9yKHZhciBlPXQucG9pbnQuZXZlbnRzLGk9MCxuPWUubGVuZ3RoO2k8bjtpKyspe3ZhciByPWVbaV07dGhpcy5wb2ludC5ldmVudHMucHVzaChyKSxyLnBvaW50PXRoaXMucG9pbnR9dGhpcy5jaGVja0ZvckNvbnN1bWluZygpfX0se2tleTpcImNoZWNrRm9yQ29uc3VtaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5wb2ludC5ldmVudHMubGVuZ3RoLGU9MDtlPHQ7ZSsrKXt2YXIgaT10aGlzLnBvaW50LmV2ZW50c1tlXTtpZihpLnNlZ21lbnQuY29uc3VtZWRCeT09PXVuZGVmaW5lZClmb3IodmFyIG49ZSsxO248dDtuKyspe3ZhciByPXRoaXMucG9pbnQuZXZlbnRzW25dO3IuY29uc3VtZWRCeT09PXVuZGVmaW5lZCYmaS5vdGhlclNFLnBvaW50LmV2ZW50cz09PXIub3RoZXJTRS5wb2ludC5ldmVudHMmJmkuc2VnbWVudC5jb25zdW1lKHIuc2VnbWVudCl9fX19LHtrZXk6XCJnZXRBdmFpbGFibGVMaW5rZWRFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTAsaT10aGlzLnBvaW50LmV2ZW50cy5sZW5ndGg7ZTxpO2UrKyl7dmFyIG49dGhpcy5wb2ludC5ldmVudHNbZV07biE9PXRoaXMmJiFuLnNlZ21lbnQucmluZ091dCYmbi5zZWdtZW50LmlzSW5SZXN1bHQoKSYmdC5wdXNoKG4pfXJldHVybiB0fX0se2tleTpcImdldExlZnRtb3N0Q29tcGFyYXRvclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT1uZXcgTWFwLG49ZnVuY3Rpb24obil7dmFyIHI9bi5vdGhlclNFO2kuc2V0KG4se3NpbmU6UyhlLnBvaW50LHQucG9pbnQsci5wb2ludCksY29zaW5lOk8oZS5wb2ludCx0LnBvaW50LHIucG9pbnQpfSl9O3JldHVybiBmdW5jdGlvbih0LGUpe2kuaGFzKHQpfHxuKHQpLGkuaGFzKGUpfHxuKGUpO3ZhciByPWkuZ2V0KHQpLGE9ci5zaW5lLG89ci5jb3NpbmUscz1pLmdldChlKSxsPXMuc2luZSxoPXMuY29zaW5lO3JldHVybiBhPj0wJiZsPj0wP288aD8xOm8+aD8tMTowOmE8MCYmbDwwP288aD8tMTpvPmg/MTowOmw8YT8tMTpsPmE/MTowfX19XSksZX0oKSxJPTAsaj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuLHIsYSl7dCh0aGlzLGUpLHRoaXMuaWQ9KytJLHRoaXMubGVmdFNFPWksaS5zZWdtZW50PXRoaXMsaS5vdGhlclNFPW4sdGhpcy5yaWdodFNFPW4sbi5zZWdtZW50PXRoaXMsbi5vdGhlclNFPWksdGhpcy5yaW5ncz1yLHRoaXMud2luZGluZ3M9YX1yZXR1cm4gaShlLG51bGwsW3trZXk6XCJjb21wYXJlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10LmxlZnRTRS5wb2ludC54LG49ZS5sZWZ0U0UucG9pbnQueCxyPXQucmlnaHRTRS5wb2ludC54LGE9ZS5yaWdodFNFLnBvaW50Lng7aWYoYTxpKXJldHVybiAxO2lmKHI8bilyZXR1cm4tMTt2YXIgbz10LmxlZnRTRS5wb2ludC55LHM9ZS5sZWZ0U0UucG9pbnQueSxsPXQucmlnaHRTRS5wb2ludC55LGg9ZS5yaWdodFNFLnBvaW50Lnk7aWYoaTxuKXtpZihzPG8mJnM8bClyZXR1cm4gMTtpZihzPm8mJnM+bClyZXR1cm4tMTt2YXIgdT10LmNvbXBhcmVQb2ludChlLmxlZnRTRS5wb2ludCk7aWYodTwwKXJldHVybiAxO2lmKHU+MClyZXR1cm4tMTt2YXIgYz1lLmNvbXBhcmVQb2ludCh0LnJpZ2h0U0UucG9pbnQpO3JldHVybiAwIT09Yz9jOi0xfWlmKGk+bil7aWYobzxzJiZvPGgpcmV0dXJuLTE7aWYobz5zJiZvPmgpcmV0dXJuIDE7dmFyIHA9ZS5jb21wYXJlUG9pbnQodC5sZWZ0U0UucG9pbnQpO2lmKDAhPT1wKXJldHVybiBwO3ZhciBkPXQuY29tcGFyZVBvaW50KGUucmlnaHRTRS5wb2ludCk7cmV0dXJuIGQ8MD8xOmQ+MD8tMToxfWlmKG88cylyZXR1cm4tMTtpZihvPnMpcmV0dXJuIDE7aWYocjxhKXt2YXIgZj1lLmNvbXBhcmVQb2ludCh0LnJpZ2h0U0UucG9pbnQpO2lmKDAhPT1mKXJldHVybiBmfWlmKHI+YSl7dmFyIGc9dC5jb21wYXJlUG9pbnQoZS5yaWdodFNFLnBvaW50KTtpZihnPDApcmV0dXJuIDE7aWYoZz4wKXJldHVybi0xfWlmKHIhPT1hKXt2YXIgXz1sLW8sbT1yLWkseT1oLXMsdj1hLW47aWYoXz5tJiZ5PHYpcmV0dXJuIDE7aWYoXzxtJiZ5PnYpcmV0dXJuLTF9cmV0dXJuIHI+YT8xOnI8YXx8bDxoPy0xOmw+aD8xOnQuaWQ8ZS5pZD8tMTp0LmlkPmUuaWQ/MTowfX1dKSxpKGUsW3trZXk6XCJyZXBsYWNlUmlnaHRTRVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMucmlnaHRTRT10LHRoaXMucmlnaHRTRS5zZWdtZW50PXRoaXMsdGhpcy5yaWdodFNFLm90aGVyU0U9dGhpcy5sZWZ0U0UsdGhpcy5sZWZ0U0Uub3RoZXJTRT10aGlzLnJpZ2h0U0V9fSx7a2V5OlwiYmJveFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZWZ0U0UucG9pbnQueSxlPXRoaXMucmlnaHRTRS5wb2ludC55O3JldHVybntsbDp7eDp0aGlzLmxlZnRTRS5wb2ludC54LHk6dDxlP3Q6ZX0sdXI6e3g6dGhpcy5yaWdodFNFLnBvaW50LngseTp0PmU/dDplfX19fSx7a2V5OlwidmVjdG9yXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm57eDp0aGlzLnJpZ2h0U0UucG9pbnQueC10aGlzLmxlZnRTRS5wb2ludC54LHk6dGhpcy5yaWdodFNFLnBvaW50LnktdGhpcy5sZWZ0U0UucG9pbnQueX19fSx7a2V5OlwiaXNBbkVuZHBvaW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQueD09PXRoaXMubGVmdFNFLnBvaW50LngmJnQueT09PXRoaXMubGVmdFNFLnBvaW50Lnl8fHQueD09PXRoaXMucmlnaHRTRS5wb2ludC54JiZ0Lnk9PT10aGlzLnJpZ2h0U0UucG9pbnQueX19LHtrZXk6XCJjb21wYXJlUG9pbnRcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0aGlzLmlzQW5FbmRwb2ludCh0KSlyZXR1cm4gMDt2YXIgZT10aGlzLmxlZnRTRS5wb2ludCxpPXRoaXMucmlnaHRTRS5wb2ludCxuPXRoaXMudmVjdG9yKCk7aWYoZS54PT09aS54KXJldHVybiB0Lng9PT1lLng/MDp0Lng8ZS54PzE6LTE7dmFyIHI9KHQueS1lLnkpL24ueSxhPWUueCtyKm4ueDtpZih0Lng9PT1hKXJldHVybiAwO3ZhciBvPSh0LngtZS54KS9uLngscz1lLnkrbypuLnk7cmV0dXJuIHQueT09PXM/MDp0Lnk8cz8tMToxfX0se2tleTpcImdldEludGVyc2VjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYmJveCgpLGk9dC5iYm94KCksbj15KGUsaSk7aWYobnVsbD09PW4pcmV0dXJuIG51bGw7dmFyIHI9dGhpcy5sZWZ0U0UucG9pbnQsYT10aGlzLnJpZ2h0U0UucG9pbnQsbz10LmxlZnRTRS5wb2ludCxzPXQucmlnaHRTRS5wb2ludCxsPW0oZSxvKSYmMD09PXRoaXMuY29tcGFyZVBvaW50KG8pLGg9bShpLHIpJiYwPT09dC5jb21wYXJlUG9pbnQociksdT1tKGUscykmJjA9PT10aGlzLmNvbXBhcmVQb2ludChzKSxjPW0oaSxhKSYmMD09PXQuY29tcGFyZVBvaW50KGEpO2lmKGgmJmwpcmV0dXJuIGMmJiF1P2E6IWMmJnU/czpudWxsO2lmKGgpcmV0dXJuIHUmJnIueD09PXMueCYmci55PT09cy55P251bGw6cjtpZihsKXJldHVybiBjJiZhLng9PT1vLngmJmEueT09PW8ueT9udWxsOm87aWYoYyYmdSlyZXR1cm4gbnVsbDtpZihjKXJldHVybiBhO2lmKHUpcmV0dXJuIHM7dmFyIHA9QihyLHRoaXMudmVjdG9yKCksbyx0LnZlY3RvcigpKTtyZXR1cm4gbnVsbD09PXA/bnVsbDptKG4scCk/eC5yb3VuZChwLngscC55KTpudWxsfX0se2tleTpcInNwbGl0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGk9W10sbj10LmV2ZW50cyE9PXVuZGVmaW5lZCxyPW5ldyBUKHQsITApLGE9bmV3IFQodCwhMSksbz10aGlzLnJpZ2h0U0U7dGhpcy5yZXBsYWNlUmlnaHRTRShhKSxpLnB1c2goYSksaS5wdXNoKHIpO3ZhciBzPW5ldyBlKHIsbyx0aGlzLnJpbmdzLnNsaWNlKCksdGhpcy53aW5kaW5ncy5zbGljZSgpKTtyZXR1cm4gVC5jb21wYXJlUG9pbnRzKHMubGVmdFNFLnBvaW50LHMucmlnaHRTRS5wb2ludCk+MCYmcy5zd2FwRXZlbnRzKCksVC5jb21wYXJlUG9pbnRzKHRoaXMubGVmdFNFLnBvaW50LHRoaXMucmlnaHRTRS5wb2ludCk+MCYmdGhpcy5zd2FwRXZlbnRzKCksbiYmKHIuY2hlY2tGb3JDb25zdW1pbmcoKSxhLmNoZWNrRm9yQ29uc3VtaW5nKCkpLGl9fSx7a2V5Olwic3dhcEV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yaWdodFNFO3RoaXMucmlnaHRTRT10aGlzLmxlZnRTRSx0aGlzLmxlZnRTRT10LHRoaXMubGVmdFNFLmlzTGVmdD0hMCx0aGlzLnJpZ2h0U0UuaXNMZWZ0PSExO2Zvcih2YXIgZT0wLGk9dGhpcy53aW5kaW5ncy5sZW5ndGg7ZTxpO2UrKyl0aGlzLndpbmRpbmdzW2VdKj0tMX19LHtrZXk6XCJjb25zdW1lXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBpPXRoaXMsbj10O2kuY29uc3VtZWRCeTspaT1pLmNvbnN1bWVkQnk7Zm9yKDtuLmNvbnN1bWVkQnk7KW49bi5jb25zdW1lZEJ5O3ZhciByPWUuY29tcGFyZShpLG4pO2lmKDAhPT1yKXtpZihyPjApe3ZhciBhPWk7aT1uLG49YX1pZihpLnByZXY9PT1uKXt2YXIgbz1pO2k9bixuPW99Zm9yKHZhciBzPTAsbD1uLnJpbmdzLmxlbmd0aDtzPGw7cysrKXt2YXIgaD1uLnJpbmdzW3NdLHU9bi53aW5kaW5nc1tzXSxjPWkucmluZ3MuaW5kZXhPZihoKTstMT09PWM/KGkucmluZ3MucHVzaChoKSxpLndpbmRpbmdzLnB1c2godSkpOmkud2luZGluZ3NbY10rPXV9bi5yaW5ncz1udWxsLG4ud2luZGluZ3M9bnVsbCxuLmNvbnN1bWVkQnk9aSxuLmxlZnRTRS5jb25zdW1lZEJ5PWkubGVmdFNFLG4ucmlnaHRTRS5jb25zdW1lZEJ5PWkucmlnaHRTRX19fSx7a2V5OlwicHJldkluUmVzdWx0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJldkluUmVzdWx0IT09dW5kZWZpbmVkfHwodGhpcy5wcmV2P3RoaXMucHJldi5pc0luUmVzdWx0KCk/dGhpcy5fcHJldkluUmVzdWx0PXRoaXMucHJldjp0aGlzLl9wcmV2SW5SZXN1bHQ9dGhpcy5wcmV2LnByZXZJblJlc3VsdCgpOnRoaXMuX3ByZXZJblJlc3VsdD1udWxsKSx0aGlzLl9wcmV2SW5SZXN1bHR9fSx7a2V5OlwiYmVmb3JlU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuX2JlZm9yZVN0YXRlIT09dW5kZWZpbmVkKXJldHVybiB0aGlzLl9iZWZvcmVTdGF0ZTtpZih0aGlzLnByZXYpe3ZhciB0PXRoaXMucHJldi5jb25zdW1lZEJ5fHx0aGlzLnByZXY7dGhpcy5fYmVmb3JlU3RhdGU9dC5hZnRlclN0YXRlKCl9ZWxzZSB0aGlzLl9iZWZvcmVTdGF0ZT17cmluZ3M6W10sd2luZGluZ3M6W10sbXVsdGlQb2x5czpbXX07cmV0dXJuIHRoaXMuX2JlZm9yZVN0YXRlfX0se2tleTpcImFmdGVyU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuX2FmdGVyU3RhdGUhPT11bmRlZmluZWQpcmV0dXJuIHRoaXMuX2FmdGVyU3RhdGU7dmFyIHQ9dGhpcy5iZWZvcmVTdGF0ZSgpO3RoaXMuX2FmdGVyU3RhdGU9e3JpbmdzOnQucmluZ3Muc2xpY2UoMCksd2luZGluZ3M6dC53aW5kaW5ncy5zbGljZSgwKSxtdWx0aVBvbHlzOltdfTtmb3IodmFyIGU9dGhpcy5fYWZ0ZXJTdGF0ZS5yaW5ncyxpPXRoaXMuX2FmdGVyU3RhdGUud2luZGluZ3Msbj10aGlzLl9hZnRlclN0YXRlLm11bHRpUG9seXMscj0wLGE9dGhpcy5yaW5ncy5sZW5ndGg7cjxhO3IrKyl7dmFyIG89dGhpcy5yaW5nc1tyXSxzPXRoaXMud2luZGluZ3Nbcl0sbD1lLmluZGV4T2Yobyk7LTE9PT1sPyhlLnB1c2gobyksaS5wdXNoKHMpKTppW2xdKz1zfWZvcih2YXIgaD1bXSx1PVtdLGM9MCxwPWUubGVuZ3RoO2M8cDtjKyspaWYoMCE9PWlbY10pe3ZhciBkPWVbY10sZj1kLnBvbHk7aWYoLTE9PT11LmluZGV4T2YoZikpaWYoZC5pc0V4dGVyaW9yKWgucHVzaChmKTtlbHNley0xPT09dS5pbmRleE9mKGYpJiZ1LnB1c2goZik7dmFyIGc9aC5pbmRleE9mKGQucG9seSk7LTEhPT1nJiZoLnNwbGljZShnLDEpfX1mb3IodmFyIF89MCxtPWgubGVuZ3RoO188bTtfKyspe3ZhciB5PWhbX10ubXVsdGlQb2x5Oy0xPT09bi5pbmRleE9mKHkpJiZuLnB1c2goeSl9cmV0dXJuIHRoaXMuX2FmdGVyU3RhdGV9fSx7a2V5OlwiaXNJblJlc3VsdFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5jb25zdW1lZEJ5KXJldHVybiExO2lmKHRoaXMuX2lzSW5SZXN1bHQhPT11bmRlZmluZWQpcmV0dXJuIHRoaXMuX2lzSW5SZXN1bHQ7dmFyIHQ9dGhpcy5iZWZvcmVTdGF0ZSgpLm11bHRpUG9seXMsZT10aGlzLmFmdGVyU3RhdGUoKS5tdWx0aVBvbHlzO3N3aXRjaChxLnR5cGUpe2Nhc2VcInVuaW9uXCI6dmFyIGk9MD09PXQubGVuZ3RoLG49MD09PWUubGVuZ3RoO3RoaXMuX2lzSW5SZXN1bHQ9aSE9PW47YnJlYWs7Y2FzZVwiaW50ZXJzZWN0aW9uXCI6dmFyIHIsYTt0Lmxlbmd0aDxlLmxlbmd0aD8ocj10Lmxlbmd0aCxhPWUubGVuZ3RoKToocj1lLmxlbmd0aCxhPXQubGVuZ3RoKSx0aGlzLl9pc0luUmVzdWx0PWE9PT1xLm51bU11bHRpUG9seXMmJnI8YTticmVhaztjYXNlXCJ4b3JcIjp2YXIgbz1NYXRoLmFicyh0Lmxlbmd0aC1lLmxlbmd0aCk7dGhpcy5faXNJblJlc3VsdD1vJTI9PTE7YnJlYWs7Y2FzZVwiZGlmZmVyZW5jZVwiOnZhciBzPWZ1bmN0aW9uKHQpe3JldHVybiAxPT09dC5sZW5ndGgmJnRbMF0uaXNTdWJqZWN0fTt0aGlzLl9pc0luUmVzdWx0PXModCkhPT1zKGUpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG9wZXJhdGlvbiB0eXBlIGZvdW5kIFwiLmNvbmNhdChxLnR5cGUpKX1yZXR1cm4gdGhpcy5faXNJblJlc3VsdH19XSxbe2tleTpcImZyb21SaW5nXCIsdmFsdWU6ZnVuY3Rpb24odCxpLG4pe3ZhciByLGEsbyxzPVQuY29tcGFyZVBvaW50cyh0LGkpO2lmKHM8MClyPXQsYT1pLG89MTtlbHNle2lmKCEocz4wKSl0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBjcmVhdGUgZGVnZW5lcmF0ZSBzZWdtZW50IGF0IFtcIi5jb25jYXQodC54LFwiLCBcIikuY29uY2F0KHQueSxcIl1cIikpO3I9aSxhPXQsbz0tMX1yZXR1cm4gbmV3IGUobmV3IFQociwhMCksbmV3IFQoYSwhMSksW25dLFtvXSl9fV0pLGV9KCksQT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuLHIpe2lmKHQodGhpcyxlKSwhQXJyYXkuaXNBcnJheShpKXx8MD09PWkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIklucHV0IGdlb21ldHJ5IGlzIG5vdCBhIHZhbGlkIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXCIpO2lmKHRoaXMucG9seT1uLHRoaXMuaXNFeHRlcmlvcj1yLHRoaXMuc2VnbWVudHM9W10sXCJudW1iZXJcIiE9dHlwZW9mIGlbMF1bMF18fFwibnVtYmVyXCIhPXR5cGVvZiBpWzBdWzFdKXRocm93IG5ldyBFcnJvcihcIklucHV0IGdlb21ldHJ5IGlzIG5vdCBhIHZhbGlkIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXCIpO3ZhciBhPXgucm91bmQoaVswXVswXSxpWzBdWzFdKTt0aGlzLmJib3g9e2xsOnt4OmEueCx5OmEueX0sdXI6e3g6YS54LHk6YS55fX07Zm9yKHZhciBvPWEscz0xLGw9aS5sZW5ndGg7czxsO3MrKyl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGlbc11bMF18fFwibnVtYmVyXCIhPXR5cGVvZiBpW3NdWzFdKXRocm93IG5ldyBFcnJvcihcIklucHV0IGdlb21ldHJ5IGlzIG5vdCBhIHZhbGlkIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXCIpO3ZhciBoPXgucm91bmQoaVtzXVswXSxpW3NdWzFdKTtoLng9PT1vLngmJmgueT09PW8ueXx8KHRoaXMuc2VnbWVudHMucHVzaChqLmZyb21SaW5nKG8saCx0aGlzKSksaC54PHRoaXMuYmJveC5sbC54JiYodGhpcy5iYm94LmxsLng9aC54KSxoLnk8dGhpcy5iYm94LmxsLnkmJih0aGlzLmJib3gubGwueT1oLnkpLGgueD50aGlzLmJib3gudXIueCYmKHRoaXMuYmJveC51ci54PWgueCksaC55PnRoaXMuYmJveC51ci55JiYodGhpcy5iYm94LnVyLnk9aC55KSxvPWgpfWEueD09PW8ueCYmYS55PT09by55fHx0aGlzLnNlZ21lbnRzLnB1c2goai5mcm9tUmluZyhvLGEsdGhpcykpfXJldHVybiBpKGUsW3trZXk6XCJnZXRTd2VlcEV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxpPXRoaXMuc2VnbWVudHMubGVuZ3RoO2U8aTtlKyspe3ZhciBuPXRoaXMuc2VnbWVudHNbZV07dC5wdXNoKG4ubGVmdFNFKSx0LnB1c2gobi5yaWdodFNFKX1yZXR1cm4gdH19XSksZX0oKSxHPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe2lmKHQodGhpcyxlKSwhQXJyYXkuaXNBcnJheShpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBnZW9tZXRyeSBpcyBub3QgYSB2YWxpZCBQb2x5Z29uIG9yIE11bHRpUG9seWdvblwiKTt0aGlzLmV4dGVyaW9yUmluZz1uZXcgQShpWzBdLHRoaXMsITApLHRoaXMuYmJveD17bGw6e3g6dGhpcy5leHRlcmlvclJpbmcuYmJveC5sbC54LHk6dGhpcy5leHRlcmlvclJpbmcuYmJveC5sbC55fSx1cjp7eDp0aGlzLmV4dGVyaW9yUmluZy5iYm94LnVyLngseTp0aGlzLmV4dGVyaW9yUmluZy5iYm94LnVyLnl9fSx0aGlzLmludGVyaW9yUmluZ3M9W107Zm9yKHZhciByPTEsYT1pLmxlbmd0aDtyPGE7cisrKXt2YXIgbz1uZXcgQShpW3JdLHRoaXMsITEpO28uYmJveC5sbC54PHRoaXMuYmJveC5sbC54JiYodGhpcy5iYm94LmxsLng9by5iYm94LmxsLngpLG8uYmJveC5sbC55PHRoaXMuYmJveC5sbC55JiYodGhpcy5iYm94LmxsLnk9by5iYm94LmxsLnkpLG8uYmJveC51ci54PnRoaXMuYmJveC51ci54JiYodGhpcy5iYm94LnVyLng9by5iYm94LnVyLngpLG8uYmJveC51ci55PnRoaXMuYmJveC51ci55JiYodGhpcy5iYm94LnVyLnk9by5iYm94LnVyLnkpLHRoaXMuaW50ZXJpb3JSaW5ncy5wdXNoKG8pfXRoaXMubXVsdGlQb2x5PW59cmV0dXJuIGkoZSxbe2tleTpcImdldFN3ZWVwRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5leHRlcmlvclJpbmcuZ2V0U3dlZXBFdmVudHMoKSxlPTAsaT10aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoO2U8aTtlKyspZm9yKHZhciBuPXRoaXMuaW50ZXJpb3JSaW5nc1tlXS5nZXRTd2VlcEV2ZW50cygpLHI9MCxhPW4ubGVuZ3RoO3I8YTtyKyspdC5wdXNoKG5bcl0pO3JldHVybiB0fX1dKSxlfSgpLE49ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7aWYodCh0aGlzLGUpLCFBcnJheS5pc0FycmF5KGkpKXRocm93IG5ldyBFcnJvcihcIklucHV0IGdlb21ldHJ5IGlzIG5vdCBhIHZhbGlkIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXCIpO3RyeXtcIm51bWJlclwiPT10eXBlb2YgaVswXVswXVswXSYmKGk9W2ldKX1jYXRjaChzKXt9dGhpcy5wb2x5cz1bXSx0aGlzLmJib3g9e2xsOnt4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWSx5Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWX0sdXI6e3g6TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLHk6TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfX07Zm9yKHZhciByPTAsYT1pLmxlbmd0aDtyPGE7cisrKXt2YXIgbz1uZXcgRyhpW3JdLHRoaXMpO28uYmJveC5sbC54PHRoaXMuYmJveC5sbC54JiYodGhpcy5iYm94LmxsLng9by5iYm94LmxsLngpLG8uYmJveC5sbC55PHRoaXMuYmJveC5sbC55JiYodGhpcy5iYm94LmxsLnk9by5iYm94LmxsLnkpLG8uYmJveC51ci54PnRoaXMuYmJveC51ci54JiYodGhpcy5iYm94LnVyLng9by5iYm94LnVyLngpLG8uYmJveC51ci55PnRoaXMuYmJveC51ci55JiYodGhpcy5iYm94LnVyLnk9by5iYm94LnVyLnkpLHRoaXMucG9seXMucHVzaChvKX10aGlzLmlzU3ViamVjdD1ufXJldHVybiBpKGUsW3trZXk6XCJnZXRTd2VlcEV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxpPXRoaXMucG9seXMubGVuZ3RoO2U8aTtlKyspZm9yKHZhciBuPXRoaXMucG9seXNbZV0uZ2V0U3dlZXBFdmVudHMoKSxyPTAsYT1uLmxlbmd0aDtyPGE7cisrKXQucHVzaChuW3JdKTtyZXR1cm4gdH19XSksZX0oKSx6PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpKXt0KHRoaXMsZSksdGhpcy5ldmVudHM9aTtmb3IodmFyIG49MCxyPWkubGVuZ3RoO248cjtuKyspaVtuXS5zZWdtZW50LnJpbmdPdXQ9dGhpczt0aGlzLnBvbHk9bnVsbH1yZXR1cm4gaShlLG51bGwsW3trZXk6XCJmYWN0b3J5XCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBpPVtdLG49MCxyPXQubGVuZ3RoO248cjtuKyspe3ZhciBhPXRbbl07aWYoYS5pc0luUmVzdWx0KCkmJiFhLnJpbmdPdXQpe2Zvcih2YXIgbz1udWxsLHM9YS5sZWZ0U0UsbD1hLnJpZ2h0U0UsaD1bc10sdT1zLnBvaW50LGM9W107bz1zLHM9bCxoLnB1c2gocykscy5wb2ludCE9PXU7KWZvcig7Oyl7dmFyIHA9cy5nZXRBdmFpbGFibGVMaW5rZWRFdmVudHMoKTtpZigwPT09cC5sZW5ndGgpe3ZhciBkPWhbMF0ucG9pbnQsZj1oW2gubGVuZ3RoLTFdLnBvaW50O3Rocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb21wbGV0ZSBvdXRwdXQgcmluZyBzdGFydGluZyBhdCBbXCIuY29uY2F0KGQueCxcIixcIikrXCIgXCIuY29uY2F0KGQueSxcIl0uIExhc3QgbWF0Y2hpbmcgc2VnbWVudCBmb3VuZCBlbmRzIGF0XCIpK1wiIFtcIi5jb25jYXQoZi54LFwiLCBcIikuY29uY2F0KGYueSxcIl0uXCIpKX1pZigxPT09cC5sZW5ndGgpe2w9cFswXS5vdGhlclNFO2JyZWFrfWZvcih2YXIgZz1udWxsLF89MCxtPWMubGVuZ3RoO188bTtfKyspaWYoY1tfXS5wb2ludD09PXMucG9pbnQpe2c9XzticmVha31pZihudWxsPT09Zyl7Yy5wdXNoKHtpbmRleDpoLmxlbmd0aCxwb2ludDpzLnBvaW50fSk7dmFyIHk9cy5nZXRMZWZ0bW9zdENvbXBhcmF0b3Iobyk7bD1wLnNvcnQoeSlbMF0ub3RoZXJTRTticmVha312YXIgdj1jLnNwbGljZShnKVswXSxMPWguc3BsaWNlKHYuaW5kZXgpO0wudW5zaGlmdChMWzBdLm90aGVyU0UpLGkucHVzaChuZXcgZShMLnJldmVyc2UoKSkpfWkucHVzaChuZXcgZShoKSl9fXJldHVybiBpfX1dKSxpKGUsW3trZXk6XCJnZXRHZW9tXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ldmVudHNbMF0ucG9pbnQsZT1bdF0saT0xLG49dGhpcy5ldmVudHMubGVuZ3RoLTE7aTxuO2krKyl7dmFyIHI9dGhpcy5ldmVudHNbaV0ucG9pbnQsYT10aGlzLmV2ZW50c1tpKzFdLnBvaW50OzAhPT1QKHIsdCxhKSYmKGUucHVzaChyKSx0PXIpfWlmKDE9PT1lLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgbz1lWzBdLHM9ZVsxXTswPT09UChvLHQscykmJmUuc2hpZnQoKSxlLnB1c2goZVswXSk7Zm9yKHZhciBsPXRoaXMuaXNFeHRlcmlvclJpbmcoKT8xOi0xLGg9dGhpcy5pc0V4dGVyaW9yUmluZygpPzA6ZS5sZW5ndGgtMSx1PXRoaXMuaXNFeHRlcmlvclJpbmcoKT9lLmxlbmd0aDotMSxjPVtdLHA9aDtwIT11O3ArPWwpYy5wdXNoKFtlW3BdLngsZVtwXS55XSk7cmV0dXJuIGN9fSx7a2V5OlwiaXNFeHRlcmlvclJpbmdcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuX2lzRXh0ZXJpb3JSaW5nPT09dW5kZWZpbmVkKXt2YXIgdD10aGlzLmVuY2xvc2luZ1JpbmcoKTt0aGlzLl9pc0V4dGVyaW9yUmluZz0hdHx8IXQuaXNFeHRlcmlvclJpbmcoKX1yZXR1cm4gdGhpcy5faXNFeHRlcmlvclJpbmd9fSx7a2V5OlwiZW5jbG9zaW5nUmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VuY2xvc2luZ1Jpbmc9PT11bmRlZmluZWQmJih0aGlzLl9lbmNsb3NpbmdSaW5nPXRoaXMuX2NhbGNFbmNsb3NpbmdSaW5nKCkpLHRoaXMuX2VuY2xvc2luZ1Jpbmd9fSx7a2V5OlwiX2NhbGNFbmNsb3NpbmdSaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ldmVudHNbMF0sZT0xLGk9dGhpcy5ldmVudHMubGVuZ3RoO2U8aTtlKyspe3ZhciBuPXRoaXMuZXZlbnRzW2VdO1QuY29tcGFyZSh0LG4pPjAmJih0PW4pfWZvcih2YXIgcj10LnNlZ21lbnQucHJldkluUmVzdWx0KCksYT1yP3IucHJldkluUmVzdWx0KCk6bnVsbDs7KXtpZighcilyZXR1cm4gbnVsbDtpZighYSlyZXR1cm4gci5yaW5nT3V0O2lmKGEucmluZ091dCE9PXIucmluZ091dClyZXR1cm4gYS5yaW5nT3V0LmVuY2xvc2luZ1JpbmcoKSE9PXIucmluZ091dD9yLnJpbmdPdXQ6ci5yaW5nT3V0LmVuY2xvc2luZ1JpbmcoKTtyPWEucHJldkluUmVzdWx0KCksYT1yP3IucHJldkluUmVzdWx0KCk6bnVsbH19fV0pLGV9KCksVT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSl7dCh0aGlzLGUpLHRoaXMuZXh0ZXJpb3JSaW5nPWksaS5wb2x5PXRoaXMsdGhpcy5pbnRlcmlvclJpbmdzPVtdfXJldHVybiBpKGUsW3trZXk6XCJhZGRJbnRlcmlvclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuaW50ZXJpb3JSaW5ncy5wdXNoKHQpLHQucG9seT10aGlzfX0se2tleTpcImdldEdlb21cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PVt0aGlzLmV4dGVyaW9yUmluZy5nZXRHZW9tKCldO2lmKG51bGw9PT10WzBdKXJldHVybiBudWxsO2Zvcih2YXIgZT0wLGk9dGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aDtlPGk7ZSsrKXt2YXIgbj10aGlzLmludGVyaW9yUmluZ3NbZV0uZ2V0R2VvbSgpO251bGwhPT1uJiZ0LnB1c2gobil9cmV0dXJuIHR9fV0pLGV9KCksRj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSl7dCh0aGlzLGUpLHRoaXMucmluZ3M9aSx0aGlzLnBvbHlzPXRoaXMuX2NvbXBvc2VQb2x5cyhpKX1yZXR1cm4gaShlLFt7a2V5OlwiZ2V0R2VvbVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxpPXRoaXMucG9seXMubGVuZ3RoO2U8aTtlKyspe3ZhciBuPXRoaXMucG9seXNbZV0uZ2V0R2VvbSgpO251bGwhPT1uJiZ0LnB1c2gobil9cmV0dXJuIHR9fSx7a2V5OlwiX2NvbXBvc2VQb2x5c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxpPTAsbj10Lmxlbmd0aDtpPG47aSsrKXt2YXIgcj10W2ldO2lmKCFyLnBvbHkpaWYoci5pc0V4dGVyaW9yUmluZygpKWUucHVzaChuZXcgVShyKSk7ZWxzZXt2YXIgYT1yLmVuY2xvc2luZ1JpbmcoKTthLnBvbHl8fGUucHVzaChuZXcgVShhKSksYS5wb2x5LmFkZEludGVyaW9yKHIpfX1yZXR1cm4gZX19XSksZX0oKSxWPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06ai5jb21wYXJlO3QodGhpcyxlKSx0aGlzLnF1ZXVlPWksdGhpcy50cmVlPW5ldyB1KG4pLHRoaXMuc2VnbWVudHM9W119cmV0dXJuIGkoZSxbe2tleTpcInByb2Nlc3NcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnNlZ21lbnQsaT1bXTtpZih0LmNvbnN1bWVkQnkpcmV0dXJuIHQuaXNMZWZ0P3RoaXMucXVldWUucmVtb3ZlKHQub3RoZXJTRSk6dGhpcy50cmVlLnJlbW92ZShlKSxpO3ZhciBuPXQuaXNMZWZ0P3RoaXMudHJlZS5pbnNlcnQoZSk6dGhpcy50cmVlLmZpbmQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgc2VnbWVudCAjXCIuY29uY2F0KGUuaWQsXCIgXCIpK1wiW1wiLmNvbmNhdChlLmxlZnRTRS5wb2ludC54LFwiLCBcIikuY29uY2F0KGUubGVmdFNFLnBvaW50LnksXCJdIC0+IFwiKStcIltcIi5jb25jYXQoZS5yaWdodFNFLnBvaW50LngsXCIsIFwiKS5jb25jYXQoZS5yaWdodFNFLnBvaW50LnksXCJdIFwiKStcImluIFN3ZWVwTGluZSB0cmVlLiBQbGVhc2Ugc3VibWl0IGEgYnVnIHJlcG9ydC5cIik7Zm9yKHZhciByPW4sYT1uLG89dW5kZWZpbmVkLHM9dW5kZWZpbmVkO289PT11bmRlZmluZWQ7KW51bGw9PT0ocj10aGlzLnRyZWUucHJldihyKSk/bz1udWxsOnIua2V5LmNvbnN1bWVkQnk9PT11bmRlZmluZWQmJihvPXIua2V5KTtmb3IoO3M9PT11bmRlZmluZWQ7KW51bGw9PT0oYT10aGlzLnRyZWUubmV4dChhKSk/cz1udWxsOmEua2V5LmNvbnN1bWVkQnk9PT11bmRlZmluZWQmJihzPWEua2V5KTtpZih0LmlzTGVmdCl7dmFyIGw9bnVsbDtpZihvKXt2YXIgaD1vLmdldEludGVyc2VjdGlvbihlKTtpZihudWxsIT09aCYmKGUuaXNBbkVuZHBvaW50KGgpfHwobD1oKSwhby5pc0FuRW5kcG9pbnQoaCkpKWZvcih2YXIgdT10aGlzLl9zcGxpdFNhZmVseShvLGgpLGM9MCxwPXUubGVuZ3RoO2M8cDtjKyspaS5wdXNoKHVbY10pfXZhciBkPW51bGw7aWYocyl7dmFyIGY9cy5nZXRJbnRlcnNlY3Rpb24oZSk7aWYobnVsbCE9PWYmJihlLmlzQW5FbmRwb2ludChmKXx8KGQ9ZiksIXMuaXNBbkVuZHBvaW50KGYpKSlmb3IodmFyIGc9dGhpcy5fc3BsaXRTYWZlbHkocyxmKSxfPTAsbT1nLmxlbmd0aDtfPG07XysrKWkucHVzaChnW19dKX1pZihudWxsIT09bHx8bnVsbCE9PWQpe3ZhciB5PW51bGw7eT1udWxsPT09bD9kOm51bGw9PT1kfHxULmNvbXBhcmVQb2ludHMobCxkKTw9MD9sOmQsdGhpcy5xdWV1ZS5yZW1vdmUoZS5yaWdodFNFKSxpLnB1c2goZS5yaWdodFNFKTtmb3IodmFyIHY9ZS5zcGxpdCh5KSxMPTAsYj12Lmxlbmd0aDtMPGI7TCsrKWkucHVzaCh2W0xdKX1pLmxlbmd0aD4wPyh0aGlzLnRyZWUucmVtb3ZlKGUpLGkucHVzaCh0KSk6KHRoaXMuc2VnbWVudHMucHVzaChlKSxlLnByZXY9byl9ZWxzZXtpZihvJiZzKXt2YXIgaz1vLmdldEludGVyc2VjdGlvbihzKTtpZihudWxsIT09ayl7aWYoIW8uaXNBbkVuZHBvaW50KGspKWZvcih2YXIgTT10aGlzLl9zcGxpdFNhZmVseShvLGspLHg9MCx3PU0ubGVuZ3RoO3g8dzt4KyspaS5wdXNoKE1beF0pO2lmKCFzLmlzQW5FbmRwb2ludChrKSlmb3IodmFyIEM9dGhpcy5fc3BsaXRTYWZlbHkocyxrKSxQPTAsRT1DLmxlbmd0aDtQPEU7UCsrKWkucHVzaChDW1BdKX19dGhpcy50cmVlLnJlbW92ZShlKX1yZXR1cm4gaX19LHtrZXk6XCJfc3BsaXRTYWZlbHlcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3RoaXMudHJlZS5yZW1vdmUodCk7dmFyIGk9dC5yaWdodFNFO3RoaXMucXVldWUucmVtb3ZlKGkpO3ZhciBuPXQuc3BsaXQoZSk7cmV0dXJuIG4ucHVzaChpKSx0LmNvbnN1bWVkQnk9PT11bmRlZmluZWQmJnRoaXMudHJlZS5pbnNlcnQodCksbn19XSksZX0oKSxLPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiZwcm9jZXNzLmVudi5QT0xZR09OX0NMSVBQSU5HX01BWF9RVUVVRV9TSVpFfHwxZTYsSD1cInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmcHJvY2Vzcy5lbnYuUE9MWUdPTl9DTElQUElOR19NQVhfU1dFRVBMSU5FX1NFR01FTlRTfHwxZTYscT1uZXcoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dCh0aGlzLGUpfXJldHVybiBpKGUsW3trZXk6XCJydW5cIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7cS50eXBlPXQseC5yZXNldCgpO2Zvcih2YXIgbj1bbmV3IE4oZSwhMCldLHI9MCxhPWkubGVuZ3RoO3I8YTtyKyspbi5wdXNoKG5ldyBOKGlbcl0sITEpKTtpZihxLm51bU11bHRpUG9seXM9bi5sZW5ndGgsXCJkaWZmZXJlbmNlXCI9PT1xLnR5cGUpZm9yKHZhciBvPW5bMF0scz0xO3M8bi5sZW5ndGg7KW51bGwhPT15KG5bc10uYmJveCxvLmJib3gpP3MrKzpuLnNwbGljZShzLDEpO2lmKFwiaW50ZXJzZWN0aW9uXCI9PT1xLnR5cGUpZm9yKHZhciBsPTAsaD1uLmxlbmd0aDtsPGg7bCsrKWZvcih2YXIgYz1uW2xdLHA9bCsxLGQ9bi5sZW5ndGg7cDxkO3ArKylpZihudWxsPT09eShjLmJib3gsbltwXS5iYm94KSlyZXR1cm5bXTtmb3IodmFyIGY9bmV3IHUoVC5jb21wYXJlKSxnPTAsXz1uLmxlbmd0aDtnPF87ZysrKWZvcih2YXIgbT1uW2ddLmdldFN3ZWVwRXZlbnRzKCksdj0wLEw9bS5sZW5ndGg7djxMO3YrKylpZihmLmluc2VydChtW3ZdKSxmLnNpemU+Syl0aHJvdyBuZXcgRXJyb3IoXCJJbmZpbml0ZSBsb29wIHdoZW4gcHV0dGluZyBzZWdtZW50IGVuZHBvaW50cyBpbiBhIHByaW9yaXR5IHF1ZXVlIChxdWV1ZSBzaXplIHRvbyBiaWcpLiBQbGVhc2UgZmlsZSBhIGJ1ZyByZXBvcnQuXCIpO2Zvcih2YXIgYj1uZXcgVihmKSxrPWYuc2l6ZSxNPWYucG9wKCk7TTspe3ZhciB3PU0ua2V5O2lmKGYuc2l6ZT09PWspe3ZhciBDPXcuc2VnbWVudDt0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcG9wKCkgXCIuY29uY2F0KHcuaXNMZWZ0P1wibGVmdFwiOlwicmlnaHRcIixcIiBTd2VlcEV2ZW50IFwiKStcIltcIi5jb25jYXQody5wb2ludC54LFwiLCBcIikuY29uY2F0KHcucG9pbnQueSxcIl0gZnJvbSBzZWdtZW50ICNcIikuY29uY2F0KEMuaWQsXCIgXCIpK1wiW1wiLmNvbmNhdChDLmxlZnRTRS5wb2ludC54LFwiLCBcIikuY29uY2F0KEMubGVmdFNFLnBvaW50LnksXCJdIC0+IFwiKStcIltcIi5jb25jYXQoQy5yaWdodFNFLnBvaW50LngsXCIsIFwiKS5jb25jYXQoQy5yaWdodFNFLnBvaW50LnksXCJdIGZyb20gcXVldWUuIFwiKStcIlBsZWFzZSBmaWxlIGEgYnVnIHJlcG9ydC5cIil9aWYoZi5zaXplPkspdGhyb3cgbmV3IEVycm9yKFwiSW5maW5pdGUgbG9vcCB3aGVuIHBhc3Npbmcgc3dlZXAgbGluZSBvdmVyIGVuZHBvaW50cyAocXVldWUgc2l6ZSB0b28gYmlnKS4gUGxlYXNlIGZpbGUgYSBidWcgcmVwb3J0LlwiKTtpZihiLnNlZ21lbnRzLmxlbmd0aD5IKXRocm93IG5ldyBFcnJvcihcIkluZmluaXRlIGxvb3Agd2hlbiBwYXNzaW5nIHN3ZWVwIGxpbmUgb3ZlciBlbmRwb2ludHMgKHRvbyBtYW55IHN3ZWVwIGxpbmUgc2VnbWVudHMpLiBQbGVhc2UgZmlsZSBhIGJ1ZyByZXBvcnQuXCIpO2Zvcih2YXIgUD1iLnByb2Nlc3ModyksRT0wLFM9UC5sZW5ndGg7RTxTO0UrKyl7dmFyIE89UFtFXTtPLmNvbnN1bWVkQnk9PT11bmRlZmluZWQmJmYuaW5zZXJ0KE8pfWs9Zi5zaXplLE09Zi5wb3AoKX14LnJlc2V0KCk7dmFyIEQ9ei5mYWN0b3J5KGIuc2VnbWVudHMpO3JldHVybiBuZXcgRihEKS5nZXRHZW9tKCl9fV0pLGV9KCkpLEo9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsaT1uZXcgQXJyYXkoZT4xP2UtMTowKSxuPTE7bjxlO24rKylpW24tMV09YXJndW1lbnRzW25dO3JldHVybiBxLnJ1bihcInVuaW9uXCIsdCxpKX0sWT1mdW5jdGlvbih0KXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShlPjE/ZS0xOjApLG49MTtuPGU7bisrKWlbbi0xXT1hcmd1bWVudHNbbl07cmV0dXJuIHEucnVuKFwiaW50ZXJzZWN0aW9uXCIsdCxpKX0sWD1mdW5jdGlvbih0KXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShlPjE/ZS0xOjApLG49MTtuPGU7bisrKWlbbi0xXT1hcmd1bWVudHNbbl07cmV0dXJuIHEucnVuKFwieG9yXCIsdCxpKX0sWj1mdW5jdGlvbih0KXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShlPjE/ZS0xOjApLG49MTtuPGU7bisrKWlbbi0xXT1hcmd1bWVudHNbbl07cmV0dXJuIHEucnVuKFwiZGlmZmVyZW5jZVwiLHQsaSl9O3JldHVybnt1bmlvbjpKLGludGVyc2VjdGlvbjpZLHhvcjpYLGRpZmZlcmVuY2U6Wn19KCl9LDI1ODI6ZnVuY3Rpb24odCl7dC5leHBvcnRzPWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCh0LG4scixhLG8peyFmdW5jdGlvbiBzKHQsaSxuLHIsYSl7Zm9yKDtyPm47KXtpZihyLW4+NjAwKXt2YXIgbz1yLW4rMSxsPWktbisxLGg9TWF0aC5sb2cobyksdT0uNSpNYXRoLmV4cCgyKmgvMyksYz0uNSpNYXRoLnNxcnQoaCp1KihvLXUpL28pKihsLW8vMjwwPy0xOjEpO3ModCxpLE1hdGgubWF4KG4sTWF0aC5mbG9vcihpLWwqdS9vK2MpKSxNYXRoLm1pbihyLE1hdGguZmxvb3IoaSsoby1sKSp1L28rYykpLGEpfXZhciBwPXRbaV0sZD1uLGY9cjtmb3IoZSh0LG4saSksYSh0W3JdLHApPjAmJmUodCxuLHIpO2Q8Zjspe2ZvcihlKHQsZCxmKSxkKyssZi0tO2EodFtkXSxwKTwwOylkKys7Zm9yKDthKHRbZl0scCk+MDspZi0tfTA9PT1hKHRbbl0scCk/ZSh0LG4sZik6ZSh0LCsrZixyKSxmPD1pJiYobj1mKzEpLGk8PWYmJihyPWYtMSl9fSh0LG4scnx8MCxhfHx0Lmxlbmd0aC0xLG98fGkpfWZ1bmN0aW9uIGUodCxlLGkpe3ZhciBuPXRbZV07dFtlXT10W2ldLHRbaV09bn1mdW5jdGlvbiBpKHQsZSl7cmV0dXJuIHQ8ZT8tMTp0PmU/MTowfXZhciBuPWZ1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PTkpLHRoaXMuX21heEVudHJpZXM9TWF0aC5tYXgoNCx0KSx0aGlzLl9taW5FbnRyaWVzPU1hdGgubWF4KDIsTWF0aC5jZWlsKC40KnRoaXMuX21heEVudHJpZXMpKSx0aGlzLmNsZWFyKCl9O2Z1bmN0aW9uIHIodCxlLGkpe2lmKCFpKXJldHVybiBlLmluZGV4T2YodCk7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspaWYoaSh0LGVbbl0pKXJldHVybiBuO3JldHVybi0xfWZ1bmN0aW9uIGEodCxlKXtvKHQsMCx0LmNoaWxkcmVuLmxlbmd0aCxlLHQpfWZ1bmN0aW9uIG8odCxlLGksbixyKXtyfHwocj1mKG51bGwpKSxyLm1pblg9MS8wLHIubWluWT0xLzAsci5tYXhYPS0xLzAsci5tYXhZPS0xLzA7Zm9yKHZhciBhPWU7YTxpO2ErKyl7dmFyIG89dC5jaGlsZHJlblthXTtzKHIsdC5sZWFmP24obyk6byl9cmV0dXJuIHJ9ZnVuY3Rpb24gcyh0LGUpe3JldHVybiB0Lm1pblg9TWF0aC5taW4odC5taW5YLGUubWluWCksdC5taW5ZPU1hdGgubWluKHQubWluWSxlLm1pblkpLHQubWF4WD1NYXRoLm1heCh0Lm1heFgsZS5tYXhYKSx0Lm1heFk9TWF0aC5tYXgodC5tYXhZLGUubWF4WSksdH1mdW5jdGlvbiBsKHQsZSl7cmV0dXJuIHQubWluWC1lLm1pblh9ZnVuY3Rpb24gaCh0LGUpe3JldHVybiB0Lm1pblktZS5taW5ZfWZ1bmN0aW9uIHUodCl7cmV0dXJuKHQubWF4WC10Lm1pblgpKih0Lm1heFktdC5taW5ZKX1mdW5jdGlvbiBjKHQpe3JldHVybiB0Lm1heFgtdC5taW5YKyh0Lm1heFktdC5taW5ZKX1mdW5jdGlvbiBwKHQsZSl7cmV0dXJuIHQubWluWDw9ZS5taW5YJiZ0Lm1pblk8PWUubWluWSYmZS5tYXhYPD10Lm1heFgmJmUubWF4WTw9dC5tYXhZfWZ1bmN0aW9uIGQodCxlKXtyZXR1cm4gZS5taW5YPD10Lm1heFgmJmUubWluWTw9dC5tYXhZJiZlLm1heFg+PXQubWluWCYmZS5tYXhZPj10Lm1pbll9ZnVuY3Rpb24gZih0KXtyZXR1cm57Y2hpbGRyZW46dCxoZWlnaHQ6MSxsZWFmOiEwLG1pblg6MS8wLG1pblk6MS8wLG1heFg6LTEvMCxtYXhZOi0xLzB9fWZ1bmN0aW9uIGcoZSxpLG4scixhKXtmb3IodmFyIG89W2ksbl07by5sZW5ndGg7KWlmKCEoKG49by5wb3AoKSktKGk9by5wb3AoKSk8PXIpKXt2YXIgcz1pK01hdGguY2VpbCgobi1pKS9yLzIpKnI7dChlLHMsaSxuLGEpLG8ucHVzaChpLHMscyxuKX19cmV0dXJuIG4ucHJvdG90eXBlLmFsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLFtdKX0sbi5wcm90b3R5cGUuc2VhcmNoPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZGF0YSxpPVtdO2lmKCFkKHQsZSkpcmV0dXJuIGk7Zm9yKHZhciBuPXRoaXMudG9CQm94LHI9W107ZTspe2Zvcih2YXIgYT0wO2E8ZS5jaGlsZHJlbi5sZW5ndGg7YSsrKXt2YXIgbz1lLmNoaWxkcmVuW2FdLHM9ZS5sZWFmP24obyk6bztkKHQscykmJihlLmxlYWY/aS5wdXNoKG8pOnAodCxzKT90aGlzLl9hbGwobyxpKTpyLnB1c2gobykpfWU9ci5wb3AoKX1yZXR1cm4gaX0sbi5wcm90b3R5cGUuY29sbGlkZXM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kYXRhO2lmKCFkKHQsZSkpcmV0dXJuITE7Zm9yKHZhciBpPVtdO2U7KXtmb3IodmFyIG49MDtuPGUuY2hpbGRyZW4ubGVuZ3RoO24rKyl7dmFyIHI9ZS5jaGlsZHJlbltuXSxhPWUubGVhZj90aGlzLnRvQkJveChyKTpyO2lmKGQodCxhKSl7aWYoZS5sZWFmfHxwKHQsYSkpcmV0dXJuITA7aS5wdXNoKHIpfX1lPWkucG9wKCl9cmV0dXJuITF9LG4ucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24odCl7aWYoIXR8fCF0Lmxlbmd0aClyZXR1cm4gdGhpcztpZih0Lmxlbmd0aDx0aGlzLl9taW5FbnRyaWVzKXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLmluc2VydCh0W2VdKTtyZXR1cm4gdGhpc312YXIgaT10aGlzLl9idWlsZCh0LnNsaWNlKCksMCx0Lmxlbmd0aC0xLDApO2lmKHRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpaWYodGhpcy5kYXRhLmhlaWdodD09PWkuaGVpZ2h0KXRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsaSk7ZWxzZXtpZih0aGlzLmRhdGEuaGVpZ2h0PGkuaGVpZ2h0KXt2YXIgbj10aGlzLmRhdGE7dGhpcy5kYXRhPWksaT1ufXRoaXMuX2luc2VydChpLHRoaXMuZGF0YS5oZWlnaHQtaS5oZWlnaHQtMSwhMCl9ZWxzZSB0aGlzLmRhdGE9aTtyZXR1cm4gdGhpc30sbi5wcm90b3R5cGUuaW5zZXJ0PWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLl9pbnNlcnQodCx0aGlzLmRhdGEuaGVpZ2h0LTEpLHRoaXN9LG4ucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YT1mKFtdKSx0aGlzfSxuLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCxlKXtpZighdClyZXR1cm4gdGhpcztmb3IodmFyIGksbixhLG89dGhpcy5kYXRhLHM9dGhpcy50b0JCb3godCksbD1bXSxoPVtdO298fGwubGVuZ3RoOyl7aWYob3x8KG89bC5wb3AoKSxuPWxbbC5sZW5ndGgtMV0saT1oLnBvcCgpLGE9ITApLG8ubGVhZil7dmFyIHU9cih0LG8uY2hpbGRyZW4sZSk7aWYoLTEhPT11KXJldHVybiBvLmNoaWxkcmVuLnNwbGljZSh1LDEpLGwucHVzaChvKSx0aGlzLl9jb25kZW5zZShsKSx0aGlzfWF8fG8ubGVhZnx8IXAobyxzKT9uPyhpKyssbz1uLmNoaWxkcmVuW2ldLGE9ITEpOm89bnVsbDoobC5wdXNoKG8pLGgucHVzaChpKSxpPTAsbj1vLG89by5jaGlsZHJlblswXSl9cmV0dXJuIHRoaXN9LG4ucHJvdG90eXBlLnRvQkJveD1mdW5jdGlvbih0KXtyZXR1cm4gdH0sbi5wcm90b3R5cGUuY29tcGFyZU1pblg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5taW5YLWUubWluWH0sbi5wcm90b3R5cGUuY29tcGFyZU1pblk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5taW5ZLWUubWluWX0sbi5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sbi5wcm90b3R5cGUuZnJvbUpTT049ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YT10LHRoaXN9LG4ucHJvdG90eXBlLl9hbGw9ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9W107dDspdC5sZWFmP2UucHVzaC5hcHBseShlLHQuY2hpbGRyZW4pOmkucHVzaC5hcHBseShpLHQuY2hpbGRyZW4pLHQ9aS5wb3AoKTtyZXR1cm4gZX0sbi5wcm90b3R5cGUuX2J1aWxkPWZ1bmN0aW9uKHQsZSxpLG4pe3ZhciByLG89aS1lKzEscz10aGlzLl9tYXhFbnRyaWVzO2lmKG88PXMpcmV0dXJuIGEocj1mKHQuc2xpY2UoZSxpKzEpKSx0aGlzLnRvQkJveCkscjtufHwobj1NYXRoLmNlaWwoTWF0aC5sb2cobykvTWF0aC5sb2cocykpLHM9TWF0aC5jZWlsKG8vTWF0aC5wb3cocyxuLTEpKSksKHI9ZihbXSkpLmxlYWY9ITEsci5oZWlnaHQ9bjt2YXIgbD1NYXRoLmNlaWwoby9zKSxoPWwqTWF0aC5jZWlsKE1hdGguc3FydChzKSk7Zyh0LGUsaSxoLHRoaXMuY29tcGFyZU1pblgpO2Zvcih2YXIgdT1lO3U8PWk7dSs9aCl7dmFyIGM9TWF0aC5taW4odStoLTEsaSk7Zyh0LHUsYyxsLHRoaXMuY29tcGFyZU1pblkpO2Zvcih2YXIgcD11O3A8PWM7cCs9bCl7dmFyIGQ9TWF0aC5taW4ocCtsLTEsYyk7ci5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKHQscCxkLG4tMSkpfX1yZXR1cm4gYShyLHRoaXMudG9CQm94KSxyfSxuLnByb3RvdHlwZS5fY2hvb3NlU3VidHJlZT1mdW5jdGlvbih0LGUsaSxuKXtmb3IoO24ucHVzaChlKSwhZS5sZWFmJiZuLmxlbmd0aC0xIT09aTspe2Zvcih2YXIgcj0xLzAsYT0xLzAsbz12b2lkIDAscz0wO3M8ZS5jaGlsZHJlbi5sZW5ndGg7cysrKXt2YXIgbD1lLmNoaWxkcmVuW3NdLGg9dShsKSxjPShwPXQsZD1sLChNYXRoLm1heChkLm1heFgscC5tYXhYKS1NYXRoLm1pbihkLm1pblgscC5taW5YKSkqKE1hdGgubWF4KGQubWF4WSxwLm1heFkpLU1hdGgubWluKGQubWluWSxwLm1pblkpKS1oKTtjPGE/KGE9YyxyPWg8cj9oOnIsbz1sKTpjPT09YSYmaDxyJiYocj1oLG89bCl9ZT1vfHxlLmNoaWxkcmVuWzBdfXZhciBwLGQ7cmV0dXJuIGV9LG4ucHJvdG90eXBlLl9pbnNlcnQ9ZnVuY3Rpb24odCxlLGkpe3ZhciBuPWk/dDp0aGlzLnRvQkJveCh0KSxyPVtdLGE9dGhpcy5fY2hvb3NlU3VidHJlZShuLHRoaXMuZGF0YSxlLHIpO2ZvcihhLmNoaWxkcmVuLnB1c2godCkscyhhLG4pO2U+PTAmJnJbZV0uY2hpbGRyZW4ubGVuZ3RoPnRoaXMuX21heEVudHJpZXM7KXRoaXMuX3NwbGl0KHIsZSksZS0tO3RoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhuLHIsZSl9LG4ucHJvdG90eXBlLl9zcGxpdD1mdW5jdGlvbih0LGUpe3ZhciBpPXRbZV0sbj1pLmNoaWxkcmVuLmxlbmd0aCxyPXRoaXMuX21pbkVudHJpZXM7dGhpcy5fY2hvb3NlU3BsaXRBeGlzKGkscixuKTt2YXIgbz10aGlzLl9jaG9vc2VTcGxpdEluZGV4KGkscixuKSxzPWYoaS5jaGlsZHJlbi5zcGxpY2UobyxpLmNoaWxkcmVuLmxlbmd0aC1vKSk7cy5oZWlnaHQ9aS5oZWlnaHQscy5sZWFmPWkubGVhZixhKGksdGhpcy50b0JCb3gpLGEocyx0aGlzLnRvQkJveCksZT90W2UtMV0uY2hpbGRyZW4ucHVzaChzKTp0aGlzLl9zcGxpdFJvb3QoaSxzKX0sbi5wcm90b3R5cGUuX3NwbGl0Um9vdD1mdW5jdGlvbih0LGUpe3RoaXMuZGF0YT1mKFt0LGVdKSx0aGlzLmRhdGEuaGVpZ2h0PXQuaGVpZ2h0KzEsdGhpcy5kYXRhLmxlYWY9ITEsYSh0aGlzLmRhdGEsdGhpcy50b0JCb3gpfSxuLnByb3RvdHlwZS5fY2hvb3NlU3BsaXRJbmRleD1mdW5jdGlvbih0LGUsaSl7Zm9yKHZhciBuLHIsYSxzLGwsaCxjLHA9MS8wLGQ9MS8wLGY9ZTtmPD1pLWU7ZisrKXt2YXIgZz1vKHQsMCxmLHRoaXMudG9CQm94KSxfPW8odCxmLGksdGhpcy50b0JCb3gpLG09KHI9ZyxhPV8scz12b2lkIDAsbD12b2lkIDAsaD12b2lkIDAsYz12b2lkIDAscz1NYXRoLm1heChyLm1pblgsYS5taW5YKSxsPU1hdGgubWF4KHIubWluWSxhLm1pblkpLGg9TWF0aC5taW4oci5tYXhYLGEubWF4WCksYz1NYXRoLm1pbihyLm1heFksYS5tYXhZKSxNYXRoLm1heCgwLGgtcykqTWF0aC5tYXgoMCxjLWwpKSx5PXUoZykrdShfKTttPHA/KHA9bSxuPWYsZD15PGQ/eTpkKTptPT09cCYmeTxkJiYoZD15LG49Zil9cmV0dXJuIG58fGktZX0sbi5wcm90b3R5cGUuX2Nob29zZVNwbGl0QXhpcz1mdW5jdGlvbih0LGUsaSl7dmFyIG49dC5sZWFmP3RoaXMuY29tcGFyZU1pblg6bCxyPXQubGVhZj90aGlzLmNvbXBhcmVNaW5ZOmg7dGhpcy5fYWxsRGlzdE1hcmdpbih0LGUsaSxuKTx0aGlzLl9hbGxEaXN0TWFyZ2luKHQsZSxpLHIpJiZ0LmNoaWxkcmVuLnNvcnQobil9LG4ucHJvdG90eXBlLl9hbGxEaXN0TWFyZ2luPWZ1bmN0aW9uKHQsZSxpLG4pe3QuY2hpbGRyZW4uc29ydChuKTtmb3IodmFyIHI9dGhpcy50b0JCb3gsYT1vKHQsMCxlLHIpLGw9byh0LGktZSxpLHIpLGg9YyhhKStjKGwpLHU9ZTt1PGktZTt1Kyspe3ZhciBwPXQuY2hpbGRyZW5bdV07cyhhLHQubGVhZj9yKHApOnApLGgrPWMoYSl9Zm9yKHZhciBkPWktZS0xO2Q+PWU7ZC0tKXt2YXIgZj10LmNoaWxkcmVuW2RdO3MobCx0LmxlYWY/cihmKTpmKSxoKz1jKGwpfXJldHVybiBofSxuLnByb3RvdHlwZS5fYWRqdXN0UGFyZW50QkJveGVzPWZ1bmN0aW9uKHQsZSxpKXtmb3IodmFyIG49aTtuPj0wO24tLSlzKGVbbl0sdCl9LG4ucHJvdG90eXBlLl9jb25kZW5zZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGgtMSxpPXZvaWQgMDtlPj0wO2UtLSkwPT09dFtlXS5jaGlsZHJlbi5sZW5ndGg/ZT4wPyhpPXRbZS0xXS5jaGlsZHJlbikuc3BsaWNlKGkuaW5kZXhPZih0W2VdKSwxKTp0aGlzLmNsZWFyKCk6YSh0W2VdLHRoaXMudG9CQm94KX0sbn0oKX19LGU9e307ZnVuY3Rpb24gaShuKXt2YXIgcj1lW25dO2lmKHIhPT11bmRlZmluZWQpcmV0dXJuIHIuZXhwb3J0czt2YXIgYT1lW25dPXtpZDpuLGxvYWRlZDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtuXS5jYWxsKGEuZXhwb3J0cyxhLGEuZXhwb3J0cyxpKSxhLmxvYWRlZD0hMCxhLmV4cG9ydHN9aS5uPXQ9Pnt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/KCk9PnRbXCJkZWZhdWx0XCJdOigpPT50O3JldHVybiBpLmQoZSx7YTplfSksZX0saS5kPSh0LGUpPT57Zm9yKHZhciBuIGluIGUpaS5vKGUsbikmJiFpLm8odCxuKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7ZW51bWVyYWJsZTohMCxnZXQ6ZVtuXX0pfSxpLmc9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsVGhpcylyZXR1cm4gZ2xvYmFsVGhpczt0cnl7cmV0dXJuIHRoaXN8fG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl9Y2F0Y2godCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdylyZXR1cm4gd2luZG93fX0oKSxpLm89KHQsZSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpLGkubm1kPXQ9Pih0LnBhdGhzPVtdLHQuY2hpbGRyZW58fCh0LmNoaWxkcmVuPVtdKSx0KTtpKDQxNCl9KSgpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///845a\n')},"8eb7":function(module,exports){eval("/**\n * Copyright 2004-present Facebook. All Rights Reserved.\n *\n * @providesModule UserAgent_DEPRECATED\n */\n\n/**\n *  Provides entirely client-side User Agent and OS detection. You should prefer\n *  the non-deprecated UserAgent module when possible, which exposes our\n *  authoritative server-side PHP-based detection to the client.\n *\n *  Usage is straightforward:\n *\n *    if (UserAgent_DEPRECATED.ie()) {\n *      //  IE\n *    }\n *\n *  You can also do version checks:\n *\n *    if (UserAgent_DEPRECATED.ie() >= 7) {\n *      //  IE7 or better\n *    }\n *\n *  The browser functions will return NaN if the browser does not match, so\n *  you can also do version compares the other way:\n *\n *    if (UserAgent_DEPRECATED.ie() < 7) {\n *      //  IE6 or worse\n *    }\n *\n *  Note that the version is a float and may include a minor version number,\n *  so you should always use range operators to perform comparisons, not\n *  strict equality.\n *\n *  **Note:** You should **strongly** prefer capability detection to browser\n *  version detection where it's reasonable:\n *\n *    http://www.quirksmode.org/js/support.html\n *\n *  Further, we have a large number of mature wrapper functions and classes\n *  which abstract away many browser irregularities. Check the documentation,\n *  grep for things, or ask on javascript@lists.facebook.com before writing yet\n *  another copy of \"event || window.event\".\n *\n */\n\nvar _populated = false;\n\n// Browsers\nvar _ie, _firefox, _opera, _webkit, _chrome;\n\n// Actual IE browser for compatibility mode\nvar _ie_real_version;\n\n// Platforms\nvar _osx, _windows, _linux, _android;\n\n// Architectures\nvar _win64;\n\n// Devices\nvar _iphone, _ipad, _native;\n\nvar _mobile;\n\nfunction _populate() {\n  if (_populated) {\n    return;\n  }\n\n  _populated = true;\n\n  // To work around buggy JS libraries that can't handle multi-digit\n  // version numbers, Opera 10's user agent string claims it's Opera\n  // 9, then later includes a Version/X.Y field:\n  //\n  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10\n  var uas = navigator.userAgent;\n  var agent = /(?:MSIE.(\\d+\\.\\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\\d+\\.\\d+))|(?:Opera(?:.+Version.|.)(\\d+\\.\\d+))|(?:AppleWebKit.(\\d+(?:\\.\\d+)?))|(?:Trident\\/\\d+\\.\\d+.*rv:(\\d+\\.\\d+))/.exec(uas);\n  var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);\n\n  _iphone = /\\b(iPhone|iP[ao]d)/.exec(uas);\n  _ipad = /\\b(iP[ao]d)/.exec(uas);\n  _android = /Android/i.exec(uas);\n  _native = /FBAN\\/\\w+;/i.exec(uas);\n  _mobile = /Mobile/i.exec(uas);\n\n  // Note that the IE team blog would have you believe you should be checking\n  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming\n  // from either x64 or ia64;  so ultimately, you should just check for Win64\n  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit\n  // Windows will send 'WOW64' instead.\n  _win64 = !!(/Win64/.exec(uas));\n\n  if (agent) {\n    _ie = agent[1] ? parseFloat(agent[1]) : (\n          agent[5] ? parseFloat(agent[5]) : NaN);\n    // IE compatibility mode\n    if (_ie && document && document.documentMode) {\n      _ie = document.documentMode;\n    }\n    // grab the \"true\" ie version from the trident token if available\n    var trident = /(?:Trident\\/(\\d+.\\d+))/.exec(uas);\n    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;\n\n    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;\n    _opera   = agent[3] ? parseFloat(agent[3]) : NaN;\n    _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;\n    if (_webkit) {\n      // We do not add the regexp to the above test, because it will always\n      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in\n      // the userAgent string.\n      agent = /(?:Chrome\\/(\\d+\\.\\d+))/.exec(uas);\n      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;\n    } else {\n      _chrome = NaN;\n    }\n  } else {\n    _ie = _firefox = _opera = _chrome = _webkit = NaN;\n  }\n\n  if (os) {\n    if (os[1]) {\n      // Detect OS X version.  If no version number matches, set _osx to true.\n      // Version examples:  10, 10_6_1, 10.7\n      // Parses version number as a float, taking only first two sets of\n      // digits.  If only one set of digits is found, returns just the major\n      // version number.\n      var ver = /(?:Mac OS X (\\d+(?:[._]\\d+)?))/.exec(uas);\n\n      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;\n    } else {\n      _osx = false;\n    }\n    _windows = !!os[2];\n    _linux   = !!os[3];\n  } else {\n    _osx = _windows = _linux = false;\n  }\n}\n\nvar UserAgent_DEPRECATED = {\n\n  /**\n   *  Check if the UA is Internet Explorer.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  ie: function() {\n    return _populate() || _ie;\n  },\n\n  /**\n   * Check if we're in Internet Explorer compatibility mode.\n   *\n   * @return bool true if in compatibility mode, false if\n   * not compatibility mode or not ie\n   */\n  ieCompatibilityMode: function() {\n    return _populate() || (_ie_real_version > _ie);\n  },\n\n\n  /**\n   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we\n   * only need this because Skype can't handle 64-bit IE yet.  We need to remove\n   * this when we don't need it -- tracked by #601957.\n   */\n  ie64: function() {\n    return UserAgent_DEPRECATED.ie() && _win64;\n  },\n\n  /**\n   *  Check if the UA is Firefox.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  firefox: function() {\n    return _populate() || _firefox;\n  },\n\n\n  /**\n   *  Check if the UA is Opera.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  opera: function() {\n    return _populate() || _opera;\n  },\n\n\n  /**\n   *  Check if the UA is WebKit.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  webkit: function() {\n    return _populate() || _webkit;\n  },\n\n  /**\n   *  For Push\n   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit\n   */\n  safari: function() {\n    return UserAgent_DEPRECATED.webkit();\n  },\n\n  /**\n   *  Check if the UA is a Chrome browser.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  chrome : function() {\n    return _populate() || _chrome;\n  },\n\n\n  /**\n   *  Check if the user is running Windows.\n   *\n   *  @return bool `true' if the user's OS is Windows.\n   */\n  windows: function() {\n    return _populate() || _windows;\n  },\n\n\n  /**\n   *  Check if the user is running Mac OS X.\n   *\n   *  @return float|bool   Returns a float if a version number is detected,\n   *                       otherwise true/false.\n   */\n  osx: function() {\n    return _populate() || _osx;\n  },\n\n  /**\n   * Check if the user is running Linux.\n   *\n   * @return bool `true' if the user's OS is some flavor of Linux.\n   */\n  linux: function() {\n    return _populate() || _linux;\n  },\n\n  /**\n   * Check if the user is running on an iPhone or iPod platform.\n   *\n   * @return bool `true' if the user is running some flavor of the\n   *    iPhone OS.\n   */\n  iphone: function() {\n    return _populate() || _iphone;\n  },\n\n  mobile: function() {\n    return _populate() || (_iphone || _ipad || _android || _mobile);\n  },\n\n  nativeApp: function() {\n    // webviews inside of the native apps\n    return _populate() || _native;\n  },\n\n  android: function() {\n    return _populate() || _android;\n  },\n\n  ipad: function() {\n    return _populate() || _ipad;\n  }\n};\n\nmodule.exports = UserAgent_DEPRECATED;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLXdoZWVsL3NyYy9Vc2VyQWdlbnRfREVQUkVDQVRFRC5qcz84ZWI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI4ZWI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAwNC1wcmVzZW50IEZhY2Vib29rLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBVc2VyQWdlbnRfREVQUkVDQVRFRFxuICovXG5cbi8qKlxuICogIFByb3ZpZGVzIGVudGlyZWx5IGNsaWVudC1zaWRlIFVzZXIgQWdlbnQgYW5kIE9TIGRldGVjdGlvbi4gWW91IHNob3VsZCBwcmVmZXJcbiAqICB0aGUgbm9uLWRlcHJlY2F0ZWQgVXNlckFnZW50IG1vZHVsZSB3aGVuIHBvc3NpYmxlLCB3aGljaCBleHBvc2VzIG91clxuICogIGF1dGhvcml0YXRpdmUgc2VydmVyLXNpZGUgUEhQLWJhc2VkIGRldGVjdGlvbiB0byB0aGUgY2xpZW50LlxuICpcbiAqICBVc2FnZSBpcyBzdHJhaWdodGZvcndhcmQ6XG4gKlxuICogICAgaWYgKFVzZXJBZ2VudF9ERVBSRUNBVEVELmllKCkpIHtcbiAqICAgICAgLy8gIElFXG4gKiAgICB9XG4gKlxuICogIFlvdSBjYW4gYWxzbyBkbyB2ZXJzaW9uIGNoZWNrczpcbiAqXG4gKiAgICBpZiAoVXNlckFnZW50X0RFUFJFQ0FURUQuaWUoKSA+PSA3KSB7XG4gKiAgICAgIC8vICBJRTcgb3IgYmV0dGVyXG4gKiAgICB9XG4gKlxuICogIFRoZSBicm93c2VyIGZ1bmN0aW9ucyB3aWxsIHJldHVybiBOYU4gaWYgdGhlIGJyb3dzZXIgZG9lcyBub3QgbWF0Y2gsIHNvXG4gKiAgeW91IGNhbiBhbHNvIGRvIHZlcnNpb24gY29tcGFyZXMgdGhlIG90aGVyIHdheTpcbiAqXG4gKiAgICBpZiAoVXNlckFnZW50X0RFUFJFQ0FURUQuaWUoKSA8IDcpIHtcbiAqICAgICAgLy8gIElFNiBvciB3b3JzZVxuICogICAgfVxuICpcbiAqICBOb3RlIHRoYXQgdGhlIHZlcnNpb24gaXMgYSBmbG9hdCBhbmQgbWF5IGluY2x1ZGUgYSBtaW5vciB2ZXJzaW9uIG51bWJlcixcbiAqICBzbyB5b3Ugc2hvdWxkIGFsd2F5cyB1c2UgcmFuZ2Ugb3BlcmF0b3JzIHRvIHBlcmZvcm0gY29tcGFyaXNvbnMsIG5vdFxuICogIHN0cmljdCBlcXVhbGl0eS5cbiAqXG4gKiAgKipOb3RlOioqIFlvdSBzaG91bGQgKipzdHJvbmdseSoqIHByZWZlciBjYXBhYmlsaXR5IGRldGVjdGlvbiB0byBicm93c2VyXG4gKiAgdmVyc2lvbiBkZXRlY3Rpb24gd2hlcmUgaXQncyByZWFzb25hYmxlOlxuICpcbiAqICAgIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvc3VwcG9ydC5odG1sXG4gKlxuICogIEZ1cnRoZXIsIHdlIGhhdmUgYSBsYXJnZSBudW1iZXIgb2YgbWF0dXJlIHdyYXBwZXIgZnVuY3Rpb25zIGFuZCBjbGFzc2VzXG4gKiAgd2hpY2ggYWJzdHJhY3QgYXdheSBtYW55IGJyb3dzZXIgaXJyZWd1bGFyaXRpZXMuIENoZWNrIHRoZSBkb2N1bWVudGF0aW9uLFxuICogIGdyZXAgZm9yIHRoaW5ncywgb3IgYXNrIG9uIGphdmFzY3JpcHRAbGlzdHMuZmFjZWJvb2suY29tIGJlZm9yZSB3cml0aW5nIHlldFxuICogIGFub3RoZXIgY29weSBvZiBcImV2ZW50IHx8IHdpbmRvdy5ldmVudFwiLlxuICpcbiAqL1xuXG52YXIgX3BvcHVsYXRlZCA9IGZhbHNlO1xuXG4vLyBCcm93c2Vyc1xudmFyIF9pZSwgX2ZpcmVmb3gsIF9vcGVyYSwgX3dlYmtpdCwgX2Nocm9tZTtcblxuLy8gQWN0dWFsIElFIGJyb3dzZXIgZm9yIGNvbXBhdGliaWxpdHkgbW9kZVxudmFyIF9pZV9yZWFsX3ZlcnNpb247XG5cbi8vIFBsYXRmb3Jtc1xudmFyIF9vc3gsIF93aW5kb3dzLCBfbGludXgsIF9hbmRyb2lkO1xuXG4vLyBBcmNoaXRlY3R1cmVzXG52YXIgX3dpbjY0O1xuXG4vLyBEZXZpY2VzXG52YXIgX2lwaG9uZSwgX2lwYWQsIF9uYXRpdmU7XG5cbnZhciBfbW9iaWxlO1xuXG5mdW5jdGlvbiBfcG9wdWxhdGUoKSB7XG4gIGlmIChfcG9wdWxhdGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgX3BvcHVsYXRlZCA9IHRydWU7XG5cbiAgLy8gVG8gd29yayBhcm91bmQgYnVnZ3kgSlMgbGlicmFyaWVzIHRoYXQgY2FuJ3QgaGFuZGxlIG11bHRpLWRpZ2l0XG4gIC8vIHZlcnNpb24gbnVtYmVycywgT3BlcmEgMTAncyB1c2VyIGFnZW50IHN0cmluZyBjbGFpbXMgaXQncyBPcGVyYVxuICAvLyA5LCB0aGVuIGxhdGVyIGluY2x1ZGVzIGEgVmVyc2lvbi9YLlkgZmllbGQ6XG4gIC8vXG4gIC8vIE9wZXJhLzkuODAgKGZvbykgUHJlc3RvLzIuMi4xNSBWZXJzaW9uLzEwLjEwXG4gIHZhciB1YXMgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB2YXIgYWdlbnQgPSAvKD86TVNJRS4oXFxkK1xcLlxcZCspKXwoPzooPzpGaXJlZm94fEdyYW5QYXJhZGlzb3xJY2V3ZWFzZWwpLihcXGQrXFwuXFxkKykpfCg/Ok9wZXJhKD86LitWZXJzaW9uLnwuKShcXGQrXFwuXFxkKykpfCg/OkFwcGxlV2ViS2l0LihcXGQrKD86XFwuXFxkKyk/KSl8KD86VHJpZGVudFxcL1xcZCtcXC5cXGQrLipydjooXFxkK1xcLlxcZCspKS8uZXhlYyh1YXMpO1xuICB2YXIgb3MgICAgPSAvKE1hYyBPUyBYKXwoV2luZG93cyl8KExpbnV4KS8uZXhlYyh1YXMpO1xuXG4gIF9pcGhvbmUgPSAvXFxiKGlQaG9uZXxpUFthb11kKS8uZXhlYyh1YXMpO1xuICBfaXBhZCA9IC9cXGIoaVBbYW9dZCkvLmV4ZWModWFzKTtcbiAgX2FuZHJvaWQgPSAvQW5kcm9pZC9pLmV4ZWModWFzKTtcbiAgX25hdGl2ZSA9IC9GQkFOXFwvXFx3KzsvaS5leGVjKHVhcyk7XG4gIF9tb2JpbGUgPSAvTW9iaWxlL2kuZXhlYyh1YXMpO1xuXG4gIC8vIE5vdGUgdGhhdCB0aGUgSUUgdGVhbSBibG9nIHdvdWxkIGhhdmUgeW91IGJlbGlldmUgeW91IHNob3VsZCBiZSBjaGVja2luZ1xuICAvLyBmb3IgJ1dpbjY0OyB4NjQnLiAgQnV0IE1TRE4gdGhlbiByZXZlYWxzIHRoYXQgeW91IGNhbiBhY3R1YWxseSBiZSBjb21pbmdcbiAgLy8gZnJvbSBlaXRoZXIgeDY0IG9yIGlhNjQ7ICBzbyB1bHRpbWF0ZWx5LCB5b3Ugc2hvdWxkIGp1c3QgY2hlY2sgZm9yIFdpbjY0XG4gIC8vIGFzIGluIGluZGljYXRvciBvZiB3aGV0aGVyIHlvdSdyZSBpbiA2NC1iaXQgSUUuICAzMi1iaXQgSUUgb24gNjQtYml0XG4gIC8vIFdpbmRvd3Mgd2lsbCBzZW5kICdXT1c2NCcgaW5zdGVhZC5cbiAgX3dpbjY0ID0gISEoL1dpbjY0Ly5leGVjKHVhcykpO1xuXG4gIGlmIChhZ2VudCkge1xuICAgIF9pZSA9IGFnZW50WzFdID8gcGFyc2VGbG9hdChhZ2VudFsxXSkgOiAoXG4gICAgICAgICAgYWdlbnRbNV0gPyBwYXJzZUZsb2F0KGFnZW50WzVdKSA6IE5hTik7XG4gICAgLy8gSUUgY29tcGF0aWJpbGl0eSBtb2RlXG4gICAgaWYgKF9pZSAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpIHtcbiAgICAgIF9pZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbiAgICB9XG4gICAgLy8gZ3JhYiB0aGUgXCJ0cnVlXCIgaWUgdmVyc2lvbiBmcm9tIHRoZSB0cmlkZW50IHRva2VuIGlmIGF2YWlsYWJsZVxuICAgIHZhciB0cmlkZW50ID0gLyg/OlRyaWRlbnRcXC8oXFxkKy5cXGQrKSkvLmV4ZWModWFzKTtcbiAgICBfaWVfcmVhbF92ZXJzaW9uID0gdHJpZGVudCA/IHBhcnNlRmxvYXQodHJpZGVudFsxXSkgKyA0IDogX2llO1xuXG4gICAgX2ZpcmVmb3ggPSBhZ2VudFsyXSA/IHBhcnNlRmxvYXQoYWdlbnRbMl0pIDogTmFOO1xuICAgIF9vcGVyYSAgID0gYWdlbnRbM10gPyBwYXJzZUZsb2F0KGFnZW50WzNdKSA6IE5hTjtcbiAgICBfd2Via2l0ICA9IGFnZW50WzRdID8gcGFyc2VGbG9hdChhZ2VudFs0XSkgOiBOYU47XG4gICAgaWYgKF93ZWJraXQpIHtcbiAgICAgIC8vIFdlIGRvIG5vdCBhZGQgdGhlIHJlZ2V4cCB0byB0aGUgYWJvdmUgdGVzdCwgYmVjYXVzZSBpdCB3aWxsIGFsd2F5c1xuICAgICAgLy8gbWF0Y2ggJ3NhZmFyaScgb25seSBzaW5jZSAnQXBwbGVXZWJLaXQnIGFwcGVhcnMgYmVmb3JlICdDaHJvbWUnIGluXG4gICAgICAvLyB0aGUgdXNlckFnZW50IHN0cmluZy5cbiAgICAgIGFnZW50ID0gLyg/OkNocm9tZVxcLyhcXGQrXFwuXFxkKykpLy5leGVjKHVhcyk7XG4gICAgICBfY2hyb21lID0gYWdlbnQgJiYgYWdlbnRbMV0gPyBwYXJzZUZsb2F0KGFnZW50WzFdKSA6IE5hTjtcbiAgICB9IGVsc2Uge1xuICAgICAgX2Nocm9tZSA9IE5hTjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX2llID0gX2ZpcmVmb3ggPSBfb3BlcmEgPSBfY2hyb21lID0gX3dlYmtpdCA9IE5hTjtcbiAgfVxuXG4gIGlmIChvcykge1xuICAgIGlmIChvc1sxXSkge1xuICAgICAgLy8gRGV0ZWN0IE9TIFggdmVyc2lvbi4gIElmIG5vIHZlcnNpb24gbnVtYmVyIG1hdGNoZXMsIHNldCBfb3N4IHRvIHRydWUuXG4gICAgICAvLyBWZXJzaW9uIGV4YW1wbGVzOiAgMTAsIDEwXzZfMSwgMTAuN1xuICAgICAgLy8gUGFyc2VzIHZlcnNpb24gbnVtYmVyIGFzIGEgZmxvYXQsIHRha2luZyBvbmx5IGZpcnN0IHR3byBzZXRzIG9mXG4gICAgICAvLyBkaWdpdHMuICBJZiBvbmx5IG9uZSBzZXQgb2YgZGlnaXRzIGlzIGZvdW5kLCByZXR1cm5zIGp1c3QgdGhlIG1ham9yXG4gICAgICAvLyB2ZXJzaW9uIG51bWJlci5cbiAgICAgIHZhciB2ZXIgPSAvKD86TWFjIE9TIFggKFxcZCsoPzpbLl9dXFxkKyk/KSkvLmV4ZWModWFzKTtcblxuICAgICAgX29zeCA9IHZlciA/IHBhcnNlRmxvYXQodmVyWzFdLnJlcGxhY2UoJ18nLCAnLicpKSA6IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9vc3ggPSBmYWxzZTtcbiAgICB9XG4gICAgX3dpbmRvd3MgPSAhIW9zWzJdO1xuICAgIF9saW51eCAgID0gISFvc1szXTtcbiAgfSBlbHNlIHtcbiAgICBfb3N4ID0gX3dpbmRvd3MgPSBfbGludXggPSBmYWxzZTtcbiAgfVxufVxuXG52YXIgVXNlckFnZW50X0RFUFJFQ0FURUQgPSB7XG5cbiAgLyoqXG4gICAqICBDaGVjayBpZiB0aGUgVUEgaXMgSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAqXG4gICAqXG4gICAqICBAcmV0dXJuIGZsb2F0fE5hTiBWZXJzaW9uIG51bWJlciAoaWYgbWF0Y2gpIG9yIE5hTi5cbiAgICovXG4gIGllOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX3BvcHVsYXRlKCkgfHwgX2llO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB3ZSdyZSBpbiBJbnRlcm5ldCBFeHBsb3JlciBjb21wYXRpYmlsaXR5IG1vZGUuXG4gICAqXG4gICAqIEByZXR1cm4gYm9vbCB0cnVlIGlmIGluIGNvbXBhdGliaWxpdHkgbW9kZSwgZmFsc2UgaWZcbiAgICogbm90IGNvbXBhdGliaWxpdHkgbW9kZSBvciBub3QgaWVcbiAgICovXG4gIGllQ29tcGF0aWJpbGl0eU1vZGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfcG9wdWxhdGUoKSB8fCAoX2llX3JlYWxfdmVyc2lvbiA+IF9pZSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgYnJvd3NlciBpcyA2NC1iaXQgSUUuICBSZWFsbHksIHRoaXMgaXMga2luZCBvZiB3ZWFrIHNhdWNlOyAgd2VcbiAgICogb25seSBuZWVkIHRoaXMgYmVjYXVzZSBTa3lwZSBjYW4ndCBoYW5kbGUgNjQtYml0IElFIHlldC4gIFdlIG5lZWQgdG8gcmVtb3ZlXG4gICAqIHRoaXMgd2hlbiB3ZSBkb24ndCBuZWVkIGl0IC0tIHRyYWNrZWQgYnkgIzYwMTk1Ny5cbiAgICovXG4gIGllNjQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBVc2VyQWdlbnRfREVQUkVDQVRFRC5pZSgpICYmIF93aW42NDtcbiAgfSxcblxuICAvKipcbiAgICogIENoZWNrIGlmIHRoZSBVQSBpcyBGaXJlZm94LlxuICAgKlxuICAgKlxuICAgKiAgQHJldHVybiBmbG9hdHxOYU4gVmVyc2lvbiBudW1iZXIgKGlmIG1hdGNoKSBvciBOYU4uXG4gICAqL1xuICBmaXJlZm94OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX3BvcHVsYXRlKCkgfHwgX2ZpcmVmb3g7XG4gIH0sXG5cblxuICAvKipcbiAgICogIENoZWNrIGlmIHRoZSBVQSBpcyBPcGVyYS5cbiAgICpcbiAgICpcbiAgICogIEByZXR1cm4gZmxvYXR8TmFOIFZlcnNpb24gbnVtYmVyIChpZiBtYXRjaCkgb3IgTmFOLlxuICAgKi9cbiAgb3BlcmE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfcG9wdWxhdGUoKSB8fCBfb3BlcmE7XG4gIH0sXG5cblxuICAvKipcbiAgICogIENoZWNrIGlmIHRoZSBVQSBpcyBXZWJLaXQuXG4gICAqXG4gICAqXG4gICAqICBAcmV0dXJuIGZsb2F0fE5hTiBWZXJzaW9uIG51bWJlciAoaWYgbWF0Y2gpIG9yIE5hTi5cbiAgICovXG4gIHdlYmtpdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9wb3B1bGF0ZSgpIHx8IF93ZWJraXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqICBGb3IgUHVzaFxuICAgKiAgV0lMTCBCRSBSRU1PVkVEIFZFUlkgU09PTi4gVXNlIFVzZXJBZ2VudF9ERVBSRUNBVEVELndlYmtpdFxuICAgKi9cbiAgc2FmYXJpOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gVXNlckFnZW50X0RFUFJFQ0FURUQud2Via2l0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqICBDaGVjayBpZiB0aGUgVUEgaXMgYSBDaHJvbWUgYnJvd3Nlci5cbiAgICpcbiAgICpcbiAgICogIEByZXR1cm4gZmxvYXR8TmFOIFZlcnNpb24gbnVtYmVyIChpZiBtYXRjaCkgb3IgTmFOLlxuICAgKi9cbiAgY2hyb21lIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9wb3B1bGF0ZSgpIHx8IF9jaHJvbWU7XG4gIH0sXG5cblxuICAvKipcbiAgICogIENoZWNrIGlmIHRoZSB1c2VyIGlzIHJ1bm5pbmcgV2luZG93cy5cbiAgICpcbiAgICogIEByZXR1cm4gYm9vbCBgdHJ1ZScgaWYgdGhlIHVzZXIncyBPUyBpcyBXaW5kb3dzLlxuICAgKi9cbiAgd2luZG93czogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9wb3B1bGF0ZSgpIHx8IF93aW5kb3dzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqICBDaGVjayBpZiB0aGUgdXNlciBpcyBydW5uaW5nIE1hYyBPUyBYLlxuICAgKlxuICAgKiAgQHJldHVybiBmbG9hdHxib29sICAgUmV0dXJucyBhIGZsb2F0IGlmIGEgdmVyc2lvbiBudW1iZXIgaXMgZGV0ZWN0ZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBvdGhlcndpc2UgdHJ1ZS9mYWxzZS5cbiAgICovXG4gIG9zeDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9wb3B1bGF0ZSgpIHx8IF9vc3g7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB1c2VyIGlzIHJ1bm5pbmcgTGludXguXG4gICAqXG4gICAqIEByZXR1cm4gYm9vbCBgdHJ1ZScgaWYgdGhlIHVzZXIncyBPUyBpcyBzb21lIGZsYXZvciBvZiBMaW51eC5cbiAgICovXG4gIGxpbnV4OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX3BvcHVsYXRlKCkgfHwgX2xpbnV4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdXNlciBpcyBydW5uaW5nIG9uIGFuIGlQaG9uZSBvciBpUG9kIHBsYXRmb3JtLlxuICAgKlxuICAgKiBAcmV0dXJuIGJvb2wgYHRydWUnIGlmIHRoZSB1c2VyIGlzIHJ1bm5pbmcgc29tZSBmbGF2b3Igb2YgdGhlXG4gICAqICAgIGlQaG9uZSBPUy5cbiAgICovXG4gIGlwaG9uZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9wb3B1bGF0ZSgpIHx8IF9pcGhvbmU7XG4gIH0sXG5cbiAgbW9iaWxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX3BvcHVsYXRlKCkgfHwgKF9pcGhvbmUgfHwgX2lwYWQgfHwgX2FuZHJvaWQgfHwgX21vYmlsZSk7XG4gIH0sXG5cbiAgbmF0aXZlQXBwOiBmdW5jdGlvbigpIHtcbiAgICAvLyB3ZWJ2aWV3cyBpbnNpZGUgb2YgdGhlIG5hdGl2ZSBhcHBzXG4gICAgcmV0dXJuIF9wb3B1bGF0ZSgpIHx8IF9uYXRpdmU7XG4gIH0sXG5cbiAgYW5kcm9pZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9wb3B1bGF0ZSgpIHx8IF9hbmRyb2lkO1xuICB9LFxuXG4gIGlwYWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfcG9wdWxhdGUoKSB8fCBfaXBhZDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVc2VyQWdlbnRfREVQUkVDQVRFRDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8eb7\n")},9619:function(module,exports,__webpack_require__){eval('var throttle = __webpack_require__("597f");\nvar debounce = __webpack_require__("0e15");\n\nmodule.exports = {\n\tthrottle: throttle,\n\tdebounce: debounce\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvaW5kZXguanM/OTYxOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsTUFBWTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsTUFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOTYxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0aHJvdHRsZSA9IHJlcXVpcmUoJy4vdGhyb3R0bGUnKTtcbnZhciBkZWJvdW5jZSA9IHJlcXVpcmUoJy4vZGVib3VuY2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHRocm90dGxlOiB0aHJvdHRsZSxcblx0ZGVib3VuY2U6IGRlYm91bmNlXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9619\n')},9874:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_f8a82e40_prod_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("69a4");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_f8a82e40_prod_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_f8a82e40_prod_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9jYjEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQSIsImZpbGUiOiI5ODc0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9yZWYtLTExLW9uZU9mLTEtMCEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMS1vbmVPZi0xLTEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMTEtb25lT2YtMS0yIS4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMS1vbmVPZi0xLTMhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXJlc291cmNlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTExLW9uZU9mLTEtNCEuLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FwcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1mOGE4MmU0MCZwcm9kJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9874\n')},"9be6":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaW5kZXgudnVlPzA4MjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiOWJlNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9be6\n")},"9bf0":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYXZvaWQudnVlPzg5NzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiOWJmMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9bf0\n")},a3de:function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ExecutionEnvironment\n */\n\n/*jslint evil: true */\n\n\n\nvar canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners:\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLXdoZWVsL3NyYy9FeGVjdXRpb25FbnZpcm9ubWVudC5qcz9hM2RlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSIsImZpbGUiOiJhM2RlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXhlY3V0aW9uRW52aXJvbm1lbnRcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKFxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICB3aW5kb3cuZG9jdW1lbnQgJiZcbiAgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbik7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczpcbiAgICBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///a3de\n")},a94e:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGdlb21hbi1pby9sZWFmbGV0LWdlb21hbi1mcmVlL2Rpc3QvbGVhZmxldC1nZW9tYW4uY3NzPzQzZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiYTk0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///a94e\n")},acd2:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_23ec8df8_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9be6");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_23ec8df8_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_23ec8df8_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaW5kZXgudnVlPzJjYTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBIiwiZmlsZSI6ImFjZDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tMTEtb25lT2YtMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTExLW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xMS1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTExLW9uZU9mLTEtMyEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtcmVzb3VyY2VzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMTEtb25lT2YtMS00IS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MjNlYzhkZjgmcHJvZCZzY29wZWQ9dHJ1ZSZsYW5nPWxlc3MmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///acd2\n')},c098:function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__("d4af");\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLXdoZWVsL2luZGV4LmpzP2MwOTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsTUFBeUIiLCJmaWxlIjoiYzA5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvbm9ybWFsaXplV2hlZWwuanMnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///c098\n')},c1c5:function(module,exports){eval('module.exports = "data:image/png;base64,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"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdlcy8xLnBuZz80M2YyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiJjMWM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQzBBQUFBekNBWUFBQUFEeG9GeEFBQUlURWxFUVZSb2djVmErNDliUnhYK3pseXY3VjE3MS90c3NrbklZeE9VWnd1aFFnSUJFaFZDUWdnSmlhaFMyMStJRUtwVWtCQS84UmZ3UjJSTG9JaEVKU0dWcWxKS2s5Q0VKRzBUMGk1Skljbm1RZlBhSkp0OVAvMVkrOTZaZytidVhPL1lzZGZYdXc0YzZjanZlNy81N2pmbk8zUEhGRXRMTkNDb0xJTlFBTmhrd3lLeXlnTUZZQjJUVGVhWVpBQjdWalpzQUtzQkxVenFZOFFBTkFPSW0rY0I2THlWQlFBdUFHbUJYOUVBU2tCL3l5SGt6UE1GYzdpRjR1dkZOeDZ5RHlnQUd3WFFBaUFKb0JYQXN3QitBYUFkd0FrQWZ3VXdBaUFESUdzT2x6Zmd2V0FBUGJRSVBtYk9GYWNsaGNYTjQxVzFOTDdRVEJ1d1pJSFZ6Q1lBdEJHd1RRQ3ZFZkFkTEdsNkc0QlhHZmlFZ2ZjVmNBYkFuQUdmTXdQUTdIdmp2Q1NmRFZTYi9acWdQMWRzNnpacUNQSEJDcUMzQ2RndmdIMFdLWFpvalgvRDVKUUNUbm5BT3hLNFdZRjlmd0FQR1JMTWFwdWdxdUJMcW9jdGp3RlpBalppUUdrcHRCTFEyVXg0TVFMOG1JQ09XZ012Q3kyMFFRODRrV2NjbDhDNEdZRE5mc0ZJeDVmUEhrRnN5Nk1pNkFISjVaTXMwRzE3a3ZEZE9QQlRBcmJVQ2JaU0xFamc0d0x3WHBweEFVRGFrazh3aVFQdEY2dFBlWjJ1TnNsU1NlRExyWVNmTzhCWEdnRDJpV0RnVVFINElNMTROd2ZjTSt5WFh3SFBCaDJBZGNvbldZS3dyWXZvdFdqcEpIdWFvVHpnVW81eGZKTDVoQWVNbVFtY0RwalhvQVBBVFVhM0dtd3FEcXhiSjJoL003Q1BLayt5cHg0TXpMdkF5UXpqOENQbWp3endRcVNzTXJRS29HZXJvRmRhQ1Q4UjlVK3lSa2RybFBtYjd1eU1RRnY3UlVOdXNlUnAwTTI3QlgwL1JmaVZBL1Q5bjhGcWxyTlQ4M04zcHNmR3RxZmJVbTh0dmIwRTJwOTg0OHcvU0JMSnhHS0IvMS9vdHlMZXVYemgrb1BoUnh1azYrMlJUVTFuNXp1N3I4RHFYd0xRL2dqR0dVY25KUDhoUVpqYklXaDBMV0VUTGJuclU0K2NsUGR1RHorT1pMTFpYZVpjWGliVmNjQlVrYUIyKzB5ekdZSEx3TDhGY0RiSCtQWmx5YWtvNEcwWGRIZUxRSGRrc2JkNEt1RXhUOTJlbkJvYm1aellibDloTHhwN1A5ZldkdDJBemdkTUI5WERNVldqU3dCZmpRQ0hURFh4UTJ1blQyQmt0ME9SWnFDN1lUb0FDZy9UNlpzM0h3NXZsOHpSa2crSnN0Tzk2MTR1dENTdUFwZ3dwaU1EZWJEVlJtWVVjRU4zWndMNG9YMk1Pd3ByN3lqR2VxTDBYb2ZTbllRMXE5SDlSTDV3NDU4UEhqeVRLeFNlcmZTNUc0Ky9YV2hKM0F2S25PV0lzTTNGTVE3WTdRQTc0NFEvbWRjVm81TWc5em8wdnBHb2h4Wi9HeXB5U2ozOFpQaHhZV1JtdG1xRllxTHA2VTJiWC9TaXNkc0FKbzByZXNIbjlrUlVaa1I2R0VNTUhOTU5VYlVEenpLY014NnZiU0hHYzRLbWRncHFpU3hqUWhLWXZ6dytPWFI5WkdRWDE3aENoVVRpVFM4YUd5MmZnRUdVOXg0UlkrR2RBdGphUmpoS0lUV3NmN2hMVUhhdlE2cDVzVjhKMlBEdVpESTNQcjcvb0svZ2VWV3ZYUEg3UWp5YTNQckZsOWh4aG5RN3ExbnV1VEVveDNmc0tuNm52SitXWm1SYTI2TUtPQndGZmhrR3RMNVUxeFMzRENwR255RDV2S0EwZTk3Y3FidjNtNlp6MlQxaGpxRWpuMng5Z3gxbjBtSlpsWCtuQlBRYUFvOHVyaUowVnpVL3p6aldRL2dSQVJ2RG5sVEhQY1hPUGFsU2NuQXdWYy92bE9QY211OWQ5eGQ5Ym9OQmRnOWU1ZkxWZ0tqMDI0QnRCcVlMd01HSUdWMWRxZFJpdTE5SDV0dmIrMEUwWThxYlc0bmxpcURYTEZxNEROaWVZUndIMFRXSENQV2tZQWJYa1RJU0djaXM2VDFuU3B3K3Q2ZFpyZ2s2UWVTbnpiYnVaYk9NQXhGVDFNT200ek9zd2libnVycTFYYzlhTEROTEQwSFdrb2VlU0FIYjJuRG1wNWt2TUhDK0x0QktocGFHakVaUEwzVDNYTFpZbGwxWFBxdTZzQzJaaUdXZEVac1I2NUhQVGpQMzl4SjlEU0dOUkNubFgvWVFVY2l1NmUyM1dQYVhWS3dxeXJrNjB6cDJscktkbm1GYzlZQ1Q0WmxtSUVSNjhlYjNDdTBkdDZ6bGxPejgxNlZsUjF2Q2RQeEpud3JZMWpZNk84cmMzeWZvaFRETEwxZHJzUmJUUk9ucytpOGNOR3ZBWEpGbFdaMWxMTWUwanIwTzJjMVVlbzV4Tjg5NE93elRwR3BQUWkrUk9PWWxrdzlzSSttNE5GQlRVeVdnNHhYU3NCMFl6dHdROCs4Rk1GTUx0R0MxYk1sVFJCT1p6VnNPV1N5NzdRTVhGU3VKU2htYWFSMWZMMlU3azJFTXB4bHYxZ0xOM3ZMVncydExIVkxSMk5oeWRoMk9hYXFjTDBRb3VOZXNHWm03cGZnSUVZWWpCRlJMOHRuaWlxbEkzTTl1MmZxV1pkZGU2dUlGWDh2VnNpNm1yU2dhamd0TVRqSGVxSzNweWl5N25WMi9aY2VaWGduTFQ0Q09MWlBmaTVCdDczUFhKTDhyZ1Z1T3RRMWdwM1JkeWI2dVMxTkZuR3U1dnEwbjdLWklzN3hpMENGQ0JZYkR3TXhqaGY1cVRDdWxDaFZZNXNJemF3TWpLYkpzMjNXMVhERm93M1pRU2RMWEZaOXpnVThyZ3ZhOEowQ3JhT3dmK1kyYnpodVdmU05wTy85aDNWc1lKZWFTb0REclZBNE1Sek0xZTF2aHdKY2NlcjZjQU5kMVZabTV5UHo2RFFlczNRQzNsbDFYaTNybGdYMU5vc1RlUDFmOFdaWngrZ21tcFpRbExEZTMvTTN0WFhmRlpybjFvN01yMmlnS1BSSHR0QXpIYjZhdUtlNFhRTUdlaUo3bnFhS1pBQXY1elZ0K1k3U2NzMWtPbTFWQmg0MVh5dGdlVXZ5ZkdjYWZTMEM3N2xMcm1VeSs0M1YxMzdidkZDWFAvWDNGKzRrbG9LTjFwTVcyYnppZlNuV1FnUGtBdEpMR0VZbm04dHUyLzY2OEtZSm1yNTVjTGRNNjlpK3lYYnhYTXNFWUhtYytVbVJhU3FHbDRhVlNmMVN0clkrczFsTWx6NXhhMWE1dEtkTlVYNzRhRlVIZDlnM25ROG1IbUREbUVMVDFPaERPYUg3SDdzTm04dmtzSjA1L29LclorM0paRmZRS28yanZhY2I0c09MWGhXOHVVc2lPanRjNUZndTIzS3F1cmxmRjlFcHVGZndzS2txMGZjcmpvLzdtcHVNTUxleDU3b2pSc3Q4VUpVNmQ1RG9XdTZWWmhyTVJFY2drN1FKcVF2R3ZSVnRLUUlpcFd2Y3dWaEtOK3I4SHJCMnlpRVZHOE5lSmhvSnVGTk93MXBQU1BNSUFMZDVYYmxRMEdyU09ZRSs3MG1lckR3RC9CZDB3cnh5VGxua2hBQUFBQUVsRlRrU3VRbUNDXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///c1c5\n')},c293:function(module,exports,__webpack_require__){eval('// extracted by mini-css-extract-plugin\nmodule.exports = {"headerHeight":"100px","menuBg":"#fff","menuText":"#000","menuActiveText":"#076db5","sideBgColor":"#fff"};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL3N0eWxlcy9pbmNsdWRlLmxlc3M/MmYyYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQiIsImZpbGUiOiJjMjkzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcImhlYWRlckhlaWdodFwiOlwiMTAwcHhcIixcIm1lbnVCZ1wiOlwiI2ZmZlwiLFwibWVudVRleHRcIjpcIiMwMDBcIixcIm1lbnVBY3RpdmVUZXh0XCI6XCIjMDc2ZGI1XCIsXCJzaWRlQmdDb2xvclwiOlwiI2ZmZlwifTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///c293\n')},c3c6:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaHVnZS52dWU/Mjc0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJjM2M2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///c3c6\n")},c8ba:function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6ImM4YmEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///c8ba\n')},d2c0:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvd2xlYWZsZXQvdWkvTWFwL2luZGV4LnZ1ZT9mZDQ2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImQyYzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///d2c0\n")},d4af:function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule normalizeWheel\n * @typechecks\n */\n\n\n\nvar UserAgent_DEPRECATED = __webpack_require__(\"8eb7\");\n\nvar isEventSupported = __webpack_require__(\"7b3e\");\n\n\n// Reasonable defaults\nvar PIXEL_STEP  = 10;\nvar LINE_HEIGHT = 40;\nvar PAGE_HEIGHT = 800;\n\n/**\n * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is\n * complicated, thus this doc is long and (hopefully) detailed enough to answer\n * your questions.\n *\n * If you need to react to the mouse wheel in a predictable way, this code is\n * like your bestest friend. * hugs *\n *\n * As of today, there are 4 DOM event types you can listen to:\n *\n *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)\n *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari\n *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!\n *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003\n *\n * So what to do?  The is the best:\n *\n *   normalizeWheel.getEventType();\n *\n * In your event callback, use this code to get sane interpretation of the\n * deltas.  This code will return an object with properties:\n *\n *   spinX   -- normalized spin speed (use for zoom) - x plane\n *   spinY   -- \" - y plane\n *   pixelX  -- normalized distance (to pixels) - x plane\n *   pixelY  -- \" - y plane\n *\n * Wheel values are provided by the browser assuming you are using the wheel to\n * scroll a web page by a number of lines or pixels (or pages).  Values can vary\n * significantly on different platforms and browsers, forgetting that you can\n * scroll at different speeds.  Some devices (like trackpads) emit more events\n * at smaller increments with fine granularity, and some emit massive jumps with\n * linear speed or acceleration.\n *\n * This code does its best to normalize the deltas for you:\n *\n *   - spin is trying to normalize how far the wheel was spun (or trackpad\n *     dragged).  This is super useful for zoom support where you want to\n *     throw away the chunky scroll steps on the PC and make those equal to\n *     the slow and smooth tiny steps on the Mac. Key data: This code tries to\n *     resolve a single slow step on a wheel to 1.\n *\n *   - pixel is normalizing the desired scroll delta in pixel units.  You'll\n *     get the crazy differences between browsers, but at least it'll be in\n *     pixels!\n *\n *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This\n *     should translate to positive value zooming IN, negative zooming OUT.\n *     This matches the newer 'wheel' event.\n *\n * Why are there spinX, spinY (or pixels)?\n *\n *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn\n *     with a mouse.  It results in side-scrolling in the browser by default.\n *\n *   - spinY is what you expect -- it's the classic axis of a mouse wheel.\n *\n *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and\n *     probably is by browsers in conjunction with fancy 3D controllers .. but\n *     you know.\n *\n * Implementation info:\n *\n * Examples of 'wheel' event if you scroll slowly (down) by one step with an\n * average mouse:\n *\n *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)\n *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)\n *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)\n *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)\n *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)\n *\n * On the trackpad:\n *\n *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)\n *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)\n *\n * On other/older browsers.. it's more complicated as there can be multiple and\n * also missing delta values.\n *\n * The 'wheel' event is more standard:\n *\n * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n *\n * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and\n * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain\n * backward compatibility with older events.  Those other values help us\n * better normalize spin speed.  Example of what the browsers provide:\n *\n *                          | event.wheelDelta | event.detail\n *        ------------------+------------------+--------------\n *          Safari v5/OS X  |       -120       |       0\n *          Safari v5/Win7  |       -120       |       0\n *         Chrome v17/OS X  |       -120       |       0\n *         Chrome v17/Win7  |       -120       |       0\n *                IE9/Win7  |       -120       |   undefined\n *         Firefox v4/OS X  |     undefined    |       1\n *         Firefox v4/Win7  |     undefined    |       3\n *\n */\nfunction normalizeWheel(/*object*/ event) /*object*/ {\n  var sX = 0, sY = 0,       // spinX, spinY\n      pX = 0, pY = 0;       // pixelX, pixelY\n\n  // Legacy\n  if ('detail'      in event) { sY = event.detail; }\n  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }\n  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }\n  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }\n\n  // side scrolling on FF with DOMMouseScroll\n  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {\n    sX = sY;\n    sY = 0;\n  }\n\n  pX = sX * PIXEL_STEP;\n  pY = sY * PIXEL_STEP;\n\n  if ('deltaY' in event) { pY = event.deltaY; }\n  if ('deltaX' in event) { pX = event.deltaX; }\n\n  if ((pX || pY) && event.deltaMode) {\n    if (event.deltaMode == 1) {          // delta in LINE units\n      pX *= LINE_HEIGHT;\n      pY *= LINE_HEIGHT;\n    } else {                             // delta in PAGE units\n      pX *= PAGE_HEIGHT;\n      pY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }\n  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }\n\n  return { spinX  : sX,\n           spinY  : sY,\n           pixelX : pX,\n           pixelY : pY };\n}\n\n\n/**\n * The best combination if you prefer spinX + spinY normalization.  It favors\n * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with\n * 'wheel' event, making spin speed determination impossible.\n */\nnormalizeWheel.getEventType = function() /*string*/ {\n  return (UserAgent_DEPRECATED.firefox())\n           ? 'DOMMouseScroll'\n           : (isEventSupported('wheel'))\n               ? 'wheel'\n               : 'mousewheel';\n};\n\nmodule.exports = normalizeWheel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLXdoZWVsL3NyYy9ub3JtYWxpemVXaGVlbC5qcz9kNGFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsMkJBQTJCLG1CQUFPLENBQUMsTUFBd0I7O0FBRTNELHVCQUF1QixtQkFBTyxDQUFDLE1BQW9COzs7QUFHbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQsK0JBQStCLDhCQUE4QjtBQUM3RCwrQkFBK0IsK0JBQStCO0FBQzlELCtCQUErQiwrQkFBK0I7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsbUJBQW1CO0FBQzdDLDBCQUEwQixtQkFBbUI7O0FBRTdDO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxLQUFLLE9BQU87QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUMsa0JBQWtCLHdCQUF3Qjs7QUFFMUMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiZDRhZi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG5vcm1hbGl6ZVdoZWVsXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVzZXJBZ2VudF9ERVBSRUNBVEVEID0gcmVxdWlyZSgnLi9Vc2VyQWdlbnRfREVQUkVDQVRFRCcpO1xuXG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG5cbi8vIFJlYXNvbmFibGUgZGVmYXVsdHNcbnZhciBQSVhFTF9TVEVQICA9IDEwO1xudmFyIExJTkVfSEVJR0hUID0gNDA7XG52YXIgUEFHRV9IRUlHSFQgPSA4MDA7XG5cbi8qKlxuICogTW91c2Ugd2hlZWwgKGFuZCAyLWZpbmdlciB0cmFja3BhZCkgc3VwcG9ydCBvbiB0aGUgd2ViIHN1Y2tzLiAgSXQgaXNcbiAqIGNvbXBsaWNhdGVkLCB0aHVzIHRoaXMgZG9jIGlzIGxvbmcgYW5kIChob3BlZnVsbHkpIGRldGFpbGVkIGVub3VnaCB0byBhbnN3ZXJcbiAqIHlvdXIgcXVlc3Rpb25zLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIHJlYWN0IHRvIHRoZSBtb3VzZSB3aGVlbCBpbiBhIHByZWRpY3RhYmxlIHdheSwgdGhpcyBjb2RlIGlzXG4gKiBsaWtlIHlvdXIgYmVzdGVzdCBmcmllbmQuICogaHVncyAqXG4gKlxuICogQXMgb2YgdG9kYXksIHRoZXJlIGFyZSA0IERPTSBldmVudCB0eXBlcyB5b3UgY2FuIGxpc3RlbiB0bzpcbiAqXG4gKiAgICd3aGVlbCcgICAgICAgICAgICAgICAgLS0gQ2hyb21lKDMxKyksIEZGKDE3KyksIElFKDkrKVxuICogICAnbW91c2V3aGVlbCcgICAgICAgICAgIC0tIENocm9tZSwgSUUoNispLCBPcGVyYSwgU2FmYXJpXG4gKiAgICdNb3pNb3VzZVBpeGVsU2Nyb2xsJyAgLS0gRkYoMy41IG9ubHkhKSAoMjAxMC0yMDEzKSAtLSBkb24ndCBib3RoZXIhXG4gKiAgICdET01Nb3VzZVNjcm9sbCcgICAgICAgLS0gRkYoMC45LjcrKSBzaW5jZSAyMDAzXG4gKlxuICogU28gd2hhdCB0byBkbz8gIFRoZSBpcyB0aGUgYmVzdDpcbiAqXG4gKiAgIG5vcm1hbGl6ZVdoZWVsLmdldEV2ZW50VHlwZSgpO1xuICpcbiAqIEluIHlvdXIgZXZlbnQgY2FsbGJhY2ssIHVzZSB0aGlzIGNvZGUgdG8gZ2V0IHNhbmUgaW50ZXJwcmV0YXRpb24gb2YgdGhlXG4gKiBkZWx0YXMuICBUaGlzIGNvZGUgd2lsbCByZXR1cm4gYW4gb2JqZWN0IHdpdGggcHJvcGVydGllczpcbiAqXG4gKiAgIHNwaW5YICAgLS0gbm9ybWFsaXplZCBzcGluIHNwZWVkICh1c2UgZm9yIHpvb20pIC0geCBwbGFuZVxuICogICBzcGluWSAgIC0tIFwiIC0geSBwbGFuZVxuICogICBwaXhlbFggIC0tIG5vcm1hbGl6ZWQgZGlzdGFuY2UgKHRvIHBpeGVscykgLSB4IHBsYW5lXG4gKiAgIHBpeGVsWSAgLS0gXCIgLSB5IHBsYW5lXG4gKlxuICogV2hlZWwgdmFsdWVzIGFyZSBwcm92aWRlZCBieSB0aGUgYnJvd3NlciBhc3N1bWluZyB5b3UgYXJlIHVzaW5nIHRoZSB3aGVlbCB0b1xuICogc2Nyb2xsIGEgd2ViIHBhZ2UgYnkgYSBudW1iZXIgb2YgbGluZXMgb3IgcGl4ZWxzIChvciBwYWdlcykuICBWYWx1ZXMgY2FuIHZhcnlcbiAqIHNpZ25pZmljYW50bHkgb24gZGlmZmVyZW50IHBsYXRmb3JtcyBhbmQgYnJvd3NlcnMsIGZvcmdldHRpbmcgdGhhdCB5b3UgY2FuXG4gKiBzY3JvbGwgYXQgZGlmZmVyZW50IHNwZWVkcy4gIFNvbWUgZGV2aWNlcyAobGlrZSB0cmFja3BhZHMpIGVtaXQgbW9yZSBldmVudHNcbiAqIGF0IHNtYWxsZXIgaW5jcmVtZW50cyB3aXRoIGZpbmUgZ3JhbnVsYXJpdHksIGFuZCBzb21lIGVtaXQgbWFzc2l2ZSBqdW1wcyB3aXRoXG4gKiBsaW5lYXIgc3BlZWQgb3IgYWNjZWxlcmF0aW9uLlxuICpcbiAqIFRoaXMgY29kZSBkb2VzIGl0cyBiZXN0IHRvIG5vcm1hbGl6ZSB0aGUgZGVsdGFzIGZvciB5b3U6XG4gKlxuICogICAtIHNwaW4gaXMgdHJ5aW5nIHRvIG5vcm1hbGl6ZSBob3cgZmFyIHRoZSB3aGVlbCB3YXMgc3B1biAob3IgdHJhY2twYWRcbiAqICAgICBkcmFnZ2VkKS4gIFRoaXMgaXMgc3VwZXIgdXNlZnVsIGZvciB6b29tIHN1cHBvcnQgd2hlcmUgeW91IHdhbnQgdG9cbiAqICAgICB0aHJvdyBhd2F5IHRoZSBjaHVua3kgc2Nyb2xsIHN0ZXBzIG9uIHRoZSBQQyBhbmQgbWFrZSB0aG9zZSBlcXVhbCB0b1xuICogICAgIHRoZSBzbG93IGFuZCBzbW9vdGggdGlueSBzdGVwcyBvbiB0aGUgTWFjLiBLZXkgZGF0YTogVGhpcyBjb2RlIHRyaWVzIHRvXG4gKiAgICAgcmVzb2x2ZSBhIHNpbmdsZSBzbG93IHN0ZXAgb24gYSB3aGVlbCB0byAxLlxuICpcbiAqICAgLSBwaXhlbCBpcyBub3JtYWxpemluZyB0aGUgZGVzaXJlZCBzY3JvbGwgZGVsdGEgaW4gcGl4ZWwgdW5pdHMuICBZb3UnbGxcbiAqICAgICBnZXQgdGhlIGNyYXp5IGRpZmZlcmVuY2VzIGJldHdlZW4gYnJvd3NlcnMsIGJ1dCBhdCBsZWFzdCBpdCdsbCBiZSBpblxuICogICAgIHBpeGVscyFcbiAqXG4gKiAgIC0gcG9zaXRpdmUgdmFsdWUgaW5kaWNhdGVzIHNjcm9sbGluZyBET1dOL1JJR0hULCBuZWdhdGl2ZSBVUC9MRUZULiAgVGhpc1xuICogICAgIHNob3VsZCB0cmFuc2xhdGUgdG8gcG9zaXRpdmUgdmFsdWUgem9vbWluZyBJTiwgbmVnYXRpdmUgem9vbWluZyBPVVQuXG4gKiAgICAgVGhpcyBtYXRjaGVzIHRoZSBuZXdlciAnd2hlZWwnIGV2ZW50LlxuICpcbiAqIFdoeSBhcmUgdGhlcmUgc3BpblgsIHNwaW5ZIChvciBwaXhlbHMpP1xuICpcbiAqICAgLSBzcGluWCBpcyBhIDItZmluZ2VyIHNpZGUgZHJhZyBvbiB0aGUgdHJhY2twYWQsIGFuZCBhIHNoaWZ0ICsgd2hlZWwgdHVyblxuICogICAgIHdpdGggYSBtb3VzZS4gIEl0IHJlc3VsdHMgaW4gc2lkZS1zY3JvbGxpbmcgaW4gdGhlIGJyb3dzZXIgYnkgZGVmYXVsdC5cbiAqXG4gKiAgIC0gc3BpblkgaXMgd2hhdCB5b3UgZXhwZWN0IC0tIGl0J3MgdGhlIGNsYXNzaWMgYXhpcyBvZiBhIG1vdXNlIHdoZWVsLlxuICpcbiAqICAgLSBJIGRyb3BwZWQgc3BpblovcGl4ZWxaLiAgSXQgaXMgc3VwcG9ydGVkIGJ5IHRoZSBET00gMyAnd2hlZWwnIGV2ZW50IGFuZFxuICogICAgIHByb2JhYmx5IGlzIGJ5IGJyb3dzZXJzIGluIGNvbmp1bmN0aW9uIHdpdGggZmFuY3kgM0QgY29udHJvbGxlcnMgLi4gYnV0XG4gKiAgICAgeW91IGtub3cuXG4gKlxuICogSW1wbGVtZW50YXRpb24gaW5mbzpcbiAqXG4gKiBFeGFtcGxlcyBvZiAnd2hlZWwnIGV2ZW50IGlmIHlvdSBzY3JvbGwgc2xvd2x5IChkb3duKSBieSBvbmUgc3RlcCB3aXRoIGFuXG4gKiBhdmVyYWdlIG1vdXNlOlxuICpcbiAqICAgT1MgWCArIENocm9tZSAgKG1vdXNlKSAgICAgLSAgICA0ICAgcGl4ZWwgZGVsdGEgICh3aGVlbERlbHRhIC0xMjApXG4gKiAgIE9TIFggKyBTYWZhcmkgIChtb3VzZSkgICAgIC0gIE4vQSAgIHBpeGVsIGRlbHRhICAod2hlZWxEZWx0YSAgLTEyKVxuICogICBPUyBYICsgRmlyZWZveCAobW91c2UpICAgICAtICAgIDAuMSBsaW5lICBkZWx0YSAgKHdoZWVsRGVsdGEgIE4vQSlcbiAqICAgV2luOCArIENocm9tZSAgKG1vdXNlKSAgICAgLSAgMTAwICAgcGl4ZWwgZGVsdGEgICh3aGVlbERlbHRhIC0xMjApXG4gKiAgIFdpbjggKyBGaXJlZm94IChtb3VzZSkgICAgIC0gICAgMyAgIGxpbmUgIGRlbHRhICAod2hlZWxEZWx0YSAtMTIwKVxuICpcbiAqIE9uIHRoZSB0cmFja3BhZDpcbiAqXG4gKiAgIE9TIFggKyBDaHJvbWUgICh0cmFja3BhZCkgIC0gICAgMiAgIHBpeGVsIGRlbHRhICAod2hlZWxEZWx0YSAgIC02KVxuICogICBPUyBYICsgRmlyZWZveCAodHJhY2twYWQpICAtICAgIDEgICBwaXhlbCBkZWx0YSAgKHdoZWVsRGVsdGEgIE4vQSlcbiAqXG4gKiBPbiBvdGhlci9vbGRlciBicm93c2Vycy4uIGl0J3MgbW9yZSBjb21wbGljYXRlZCBhcyB0aGVyZSBjYW4gYmUgbXVsdGlwbGUgYW5kXG4gKiBhbHNvIG1pc3NpbmcgZGVsdGEgdmFsdWVzLlxuICpcbiAqIFRoZSAnd2hlZWwnIGV2ZW50IGlzIG1vcmUgc3RhbmRhcmQ6XG4gKlxuICogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtd2hlZWxldmVudHNcbiAqXG4gKiBUaGUgYmFzaWNzIGlzIHRoYXQgaXQgaW5jbHVkZXMgYSB1bml0LCBkZWx0YU1vZGUgKHBpeGVscywgbGluZXMsIHBhZ2VzKSwgYW5kXG4gKiBkZWx0YVgsIGRlbHRhWSBhbmQgZGVsdGFaLiAgU29tZSBicm93c2VycyBwcm92aWRlIG90aGVyIHZhbHVlcyB0byBtYWludGFpblxuICogYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGV2ZW50cy4gIFRob3NlIG90aGVyIHZhbHVlcyBoZWxwIHVzXG4gKiBiZXR0ZXIgbm9ybWFsaXplIHNwaW4gc3BlZWQuICBFeGFtcGxlIG9mIHdoYXQgdGhlIGJyb3dzZXJzIHByb3ZpZGU6XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgZXZlbnQud2hlZWxEZWx0YSB8IGV2ZW50LmRldGFpbFxuICogICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS1cbiAqICAgICAgICAgIFNhZmFyaSB2NS9PUyBYICB8ICAgICAgIC0xMjAgICAgICAgfCAgICAgICAwXG4gKiAgICAgICAgICBTYWZhcmkgdjUvV2luNyAgfCAgICAgICAtMTIwICAgICAgIHwgICAgICAgMFxuICogICAgICAgICBDaHJvbWUgdjE3L09TIFggIHwgICAgICAgLTEyMCAgICAgICB8ICAgICAgIDBcbiAqICAgICAgICAgQ2hyb21lIHYxNy9XaW43ICB8ICAgICAgIC0xMjAgICAgICAgfCAgICAgICAwXG4gKiAgICAgICAgICAgICAgICBJRTkvV2luNyAgfCAgICAgICAtMTIwICAgICAgIHwgICB1bmRlZmluZWRcbiAqICAgICAgICAgRmlyZWZveCB2NC9PUyBYICB8ICAgICB1bmRlZmluZWQgICAgfCAgICAgICAxXG4gKiAgICAgICAgIEZpcmVmb3ggdjQvV2luNyAgfCAgICAgdW5kZWZpbmVkICAgIHwgICAgICAgM1xuICpcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplV2hlZWwoLypvYmplY3QqLyBldmVudCkgLypvYmplY3QqLyB7XG4gIHZhciBzWCA9IDAsIHNZID0gMCwgICAgICAgLy8gc3BpblgsIHNwaW5ZXG4gICAgICBwWCA9IDAsIHBZID0gMDsgICAgICAgLy8gcGl4ZWxYLCBwaXhlbFlcblxuICAvLyBMZWdhY3lcbiAgaWYgKCdkZXRhaWwnICAgICAgaW4gZXZlbnQpIHsgc1kgPSBldmVudC5kZXRhaWw7IH1cbiAgaWYgKCd3aGVlbERlbHRhJyAgaW4gZXZlbnQpIHsgc1kgPSAtZXZlbnQud2hlZWxEZWx0YSAvIDEyMDsgfVxuICBpZiAoJ3doZWVsRGVsdGFZJyBpbiBldmVudCkgeyBzWSA9IC1ldmVudC53aGVlbERlbHRhWSAvIDEyMDsgfVxuICBpZiAoJ3doZWVsRGVsdGFYJyBpbiBldmVudCkgeyBzWCA9IC1ldmVudC53aGVlbERlbHRhWCAvIDEyMDsgfVxuXG4gIC8vIHNpZGUgc2Nyb2xsaW5nIG9uIEZGIHdpdGggRE9NTW91c2VTY3JvbGxcbiAgaWYgKCAnYXhpcycgaW4gZXZlbnQgJiYgZXZlbnQuYXhpcyA9PT0gZXZlbnQuSE9SSVpPTlRBTF9BWElTICkge1xuICAgIHNYID0gc1k7XG4gICAgc1kgPSAwO1xuICB9XG5cbiAgcFggPSBzWCAqIFBJWEVMX1NURVA7XG4gIHBZID0gc1kgKiBQSVhFTF9TVEVQO1xuXG4gIGlmICgnZGVsdGFZJyBpbiBldmVudCkgeyBwWSA9IGV2ZW50LmRlbHRhWTsgfVxuICBpZiAoJ2RlbHRhWCcgaW4gZXZlbnQpIHsgcFggPSBldmVudC5kZWx0YVg7IH1cblxuICBpZiAoKHBYIHx8IHBZKSAmJiBldmVudC5kZWx0YU1vZGUpIHtcbiAgICBpZiAoZXZlbnQuZGVsdGFNb2RlID09IDEpIHsgICAgICAgICAgLy8gZGVsdGEgaW4gTElORSB1bml0c1xuICAgICAgcFggKj0gTElORV9IRUlHSFQ7XG4gICAgICBwWSAqPSBMSU5FX0hFSUdIVDtcbiAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsdGEgaW4gUEFHRSB1bml0c1xuICAgICAgcFggKj0gUEFHRV9IRUlHSFQ7XG4gICAgICBwWSAqPSBQQUdFX0hFSUdIVDtcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsLWJhY2sgaWYgc3BpbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFxuICBpZiAocFggJiYgIXNYKSB7IHNYID0gKHBYIDwgMSkgPyAtMSA6IDE7IH1cbiAgaWYgKHBZICYmICFzWSkgeyBzWSA9IChwWSA8IDEpID8gLTEgOiAxOyB9XG5cbiAgcmV0dXJuIHsgc3BpblggIDogc1gsXG4gICAgICAgICAgIHNwaW5ZICA6IHNZLFxuICAgICAgICAgICBwaXhlbFggOiBwWCxcbiAgICAgICAgICAgcGl4ZWxZIDogcFkgfTtcbn1cblxuXG4vKipcbiAqIFRoZSBiZXN0IGNvbWJpbmF0aW9uIGlmIHlvdSBwcmVmZXIgc3BpblggKyBzcGluWSBub3JtYWxpemF0aW9uLiAgSXQgZmF2b3JzXG4gKiB0aGUgb2xkZXIgRE9NTW91c2VTY3JvbGwgZm9yIEZpcmVmb3gsIGFzIEZGIGRvZXMgbm90IGluY2x1ZGUgd2hlZWxEZWx0YSB3aXRoXG4gKiAnd2hlZWwnIGV2ZW50LCBtYWtpbmcgc3BpbiBzcGVlZCBkZXRlcm1pbmF0aW9uIGltcG9zc2libGUuXG4gKi9cbm5vcm1hbGl6ZVdoZWVsLmdldEV2ZW50VHlwZSA9IGZ1bmN0aW9uKCkgLypzdHJpbmcqLyB7XG4gIHJldHVybiAoVXNlckFnZW50X0RFUFJFQ0FURUQuZmlyZWZveCgpKVxuICAgICAgICAgICA/ICdET01Nb3VzZVNjcm9sbCdcbiAgICAgICAgICAgOiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSlcbiAgICAgICAgICAgICAgID8gJ3doZWVsJ1xuICAgICAgICAgICAgICAgOiAnbW91c2V3aGVlbCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZVdoZWVsO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///d4af\n")},d871:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (exports, module) {\n  'use strict';\n\n  var defaultOptions = {\n    timeout: 5000,\n    jsonpCallback: 'callback',\n    jsonpCallbackFunction: null\n  };\n\n  function generateCallbackFunction() {\n    return 'jsonp_' + Date.now() + '_' + Math.ceil(Math.random() * 100000);\n  }\n\n  function clearFunction(functionName) {\n    // IE8 throws an exception when you try to delete a property on window\n    // http://stackoverflow.com/a/1824228/751089\n    try {\n      delete window[functionName];\n    } catch (e) {\n      window[functionName] = undefined;\n    }\n  }\n\n  function removeScript(scriptId) {\n    var script = document.getElementById(scriptId);\n    if (script) {\n      document.getElementsByTagName('head')[0].removeChild(script);\n    }\n  }\n\n  function fetchJsonp(_url) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    // to avoid param reassign\n    var url = _url;\n    var timeout = options.timeout || defaultOptions.timeout;\n    var jsonpCallback = options.jsonpCallback || defaultOptions.jsonpCallback;\n\n    var timeoutId = undefined;\n\n    return new Promise(function (resolve, reject) {\n      var callbackFunction = options.jsonpCallbackFunction || generateCallbackFunction();\n      var scriptId = jsonpCallback + '_' + callbackFunction;\n\n      window[callbackFunction] = function (response) {\n        resolve({\n          ok: true,\n          // keep consistent with fetch API\n          json: function json() {\n            return Promise.resolve(response);\n          }\n        });\n\n        if (timeoutId) clearTimeout(timeoutId);\n\n        removeScript(scriptId);\n\n        clearFunction(callbackFunction);\n      };\n\n      // Check if the user set their own params, and if not add a ? to start a list of params\n      url += url.indexOf('?') === -1 ? '?' : '&';\n\n      var jsonpScript = document.createElement('script');\n      jsonpScript.setAttribute('src', '' + url + jsonpCallback + '=' + callbackFunction);\n      if (options.charset) {\n        jsonpScript.setAttribute('charset', options.charset);\n      }\n      jsonpScript.id = scriptId;\n      document.getElementsByTagName('head')[0].appendChild(jsonpScript);\n\n      timeoutId = setTimeout(function () {\n        reject(new Error('JSONP request to ' + _url + ' timed out'));\n\n        clearFunction(callbackFunction);\n        removeScript(scriptId);\n        window[callbackFunction] = function () {\n          clearFunction(callbackFunction);\n        };\n      }, timeout);\n\n      // Caught if got 404/500\n      jsonpScript.onerror = function () {\n        reject(new Error('JSONP request to ' + _url + ' failed'));\n\n        clearFunction(callbackFunction);\n        removeScript(scriptId);\n        if (timeoutId) clearTimeout(timeoutId);\n      };\n    });\n  }\n\n  // export as global function\n  /*\n  let local;\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n  local.fetchJsonp = fetchJsonp;\n  */\n\n  module.exports = fetchJsonp;\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmV0Y2gtanNvbnAvYnVpbGQvZmV0Y2gtanNvbnAuanM/ZDg3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQsSUFBSSxpQ0FBTyxDQUFDLE9BQVMsRUFBRSxNQUFRLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUMxQyxHQUFHLE1BQU0sWUFRTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiJkODcxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ2V4cG9ydHMnLCAnbW9kdWxlJ10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZhY3RvcnkoZXhwb3J0cywgbW9kdWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbW9kID0ge1xuICAgICAgZXhwb3J0czoge31cbiAgICB9O1xuICAgIGZhY3RvcnkobW9kLmV4cG9ydHMsIG1vZCk7XG4gICAgZ2xvYmFsLmZldGNoSnNvbnAgPSBtb2QuZXhwb3J0cztcbiAgfVxufSkodGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIG1vZHVsZSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAganNvbnBDYWxsYmFjazogJ2NhbGxiYWNrJyxcbiAgICBqc29ucENhbGxiYWNrRnVuY3Rpb246IG51bGxcbiAgfTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZUNhbGxiYWNrRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdqc29ucF8nICsgRGF0ZS5ub3coKSArICdfJyArIE1hdGguY2VpbChNYXRoLnJhbmRvbSgpICogMTAwMDAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG4gICAgLy8gSUU4IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiB5b3UgdHJ5IHRvIGRlbGV0ZSBhIHByb3BlcnR5IG9uIHdpbmRvd1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE4MjQyMjgvNzUxMDg5XG4gICAgdHJ5IHtcbiAgICAgIGRlbGV0ZSB3aW5kb3dbZnVuY3Rpb25OYW1lXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3aW5kb3dbZnVuY3Rpb25OYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVTY3JpcHQoc2NyaXB0SWQpIHtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2NyaXB0SWQpO1xuICAgIGlmIChzY3JpcHQpIHtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0ucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaEpzb25wKF91cmwpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgLy8gdG8gYXZvaWQgcGFyYW0gcmVhc3NpZ25cbiAgICB2YXIgdXJsID0gX3VybDtcbiAgICB2YXIgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCBkZWZhdWx0T3B0aW9ucy50aW1lb3V0O1xuICAgIHZhciBqc29ucENhbGxiYWNrID0gb3B0aW9ucy5qc29ucENhbGxiYWNrIHx8IGRlZmF1bHRPcHRpb25zLmpzb25wQ2FsbGJhY2s7XG5cbiAgICB2YXIgdGltZW91dElkID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBjYWxsYmFja0Z1bmN0aW9uID0gb3B0aW9ucy5qc29ucENhbGxiYWNrRnVuY3Rpb24gfHwgZ2VuZXJhdGVDYWxsYmFja0Z1bmN0aW9uKCk7XG4gICAgICB2YXIgc2NyaXB0SWQgPSBqc29ucENhbGxiYWNrICsgJ18nICsgY2FsbGJhY2tGdW5jdGlvbjtcblxuICAgICAgd2luZG93W2NhbGxiYWNrRnVuY3Rpb25dID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIC8vIGtlZXAgY29uc2lzdGVudCB3aXRoIGZldGNoIEFQSVxuICAgICAgICAgIGpzb246IGZ1bmN0aW9uIGpzb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aW1lb3V0SWQpIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICAgIHJlbW92ZVNjcmlwdChzY3JpcHRJZCk7XG5cbiAgICAgICAgY2xlYXJGdW5jdGlvbihjYWxsYmFja0Z1bmN0aW9uKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSB1c2VyIHNldCB0aGVpciBvd24gcGFyYW1zLCBhbmQgaWYgbm90IGFkZCBhID8gdG8gc3RhcnQgYSBsaXN0IG9mIHBhcmFtc1xuICAgICAgdXJsICs9IHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnO1xuXG4gICAgICB2YXIganNvbnBTY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIGpzb25wU2NyaXB0LnNldEF0dHJpYnV0ZSgnc3JjJywgJycgKyB1cmwgKyBqc29ucENhbGxiYWNrICsgJz0nICsgY2FsbGJhY2tGdW5jdGlvbik7XG4gICAgICBpZiAob3B0aW9ucy5jaGFyc2V0KSB7XG4gICAgICAgIGpzb25wU2NyaXB0LnNldEF0dHJpYnV0ZSgnY2hhcnNldCcsIG9wdGlvbnMuY2hhcnNldCk7XG4gICAgICB9XG4gICAgICBqc29ucFNjcmlwdC5pZCA9IHNjcmlwdElkO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChqc29ucFNjcmlwdCk7XG5cbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdKU09OUCByZXF1ZXN0IHRvICcgKyBfdXJsICsgJyB0aW1lZCBvdXQnKSk7XG5cbiAgICAgICAgY2xlYXJGdW5jdGlvbihjYWxsYmFja0Z1bmN0aW9uKTtcbiAgICAgICAgcmVtb3ZlU2NyaXB0KHNjcmlwdElkKTtcbiAgICAgICAgd2luZG93W2NhbGxiYWNrRnVuY3Rpb25dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNsZWFyRnVuY3Rpb24oY2FsbGJhY2tGdW5jdGlvbik7XG4gICAgICAgIH07XG4gICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgLy8gQ2F1Z2h0IGlmIGdvdCA0MDQvNTAwXG4gICAgICBqc29ucFNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdKU09OUCByZXF1ZXN0IHRvICcgKyBfdXJsICsgJyBmYWlsZWQnKSk7XG5cbiAgICAgICAgY2xlYXJGdW5jdGlvbihjYWxsYmFja0Z1bmN0aW9uKTtcbiAgICAgICAgcmVtb3ZlU2NyaXB0KHNjcmlwdElkKTtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZXhwb3J0IGFzIGdsb2JhbCBmdW5jdGlvblxuICAvKlxuICBsZXQgbG9jYWw7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG4gIGxvY2FsLmZldGNoSnNvbnAgPSBmZXRjaEpzb25wO1xuICAqL1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZmV0Y2hKc29ucDtcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///d871\n")},dacc:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvdmVjdG9yLnZ1ZT8zYmJmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImRhY2MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///dacc\n")},dead:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_fad4bd8e_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d2c0");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_fad4bd8e_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_11_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_11_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_11_oneOf_1_3_node_modules_style_resources_loader_lib_index_js_ref_11_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_fad4bd8e_prod_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvd2xlYWZsZXQvdWkvTWFwL2luZGV4LnZ1ZT84YzcwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQSIsImZpbGUiOiJkZWFkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9yZWYtLTExLW9uZU9mLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMS1vbmVPZi0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMTEtb25lT2YtMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMS1vbmVPZi0xLTMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXJlc291cmNlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTExLW9uZU9mLTEtNCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWZhZDRiZDhlJnByb2Qmc2NvcGVkPXRydWUmbGFuZz1sZXNzJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///dead\n')},df7c:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"4362\")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzP2RmN2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyw4QkFBOEI7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZGY3Yy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///df7c\n")},e901:function(module,exports,__webpack_require__){eval("(function(self) {\n  'use strict';\n\n  // if __disableNativeFetch is set to true, the it will always polyfill fetch\n  // with Ajax.\n  if (!self.__disableNativeFetch && self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob, options) {\n    var reader = new FileReader()\n    var contentType = options.headers.map['content-type'] ? options.headers.map['content-type'].toString() : ''\n    var regex = /charset\\=[0-9a-zA-Z\\-\\_]*;?/\n    var _charset = blob.type.match(regex) || contentType.match(regex)\n    var args = [blob]\n\n    if(_charset) {\n      args.push(_charset[0].replace(/^charset\\=/, '').replace(/;$/, ''))\n    }\n\n    reader.readAsText.apply(reader, args)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body, options) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n        this._options = options\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob, this._options)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body, options)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this._initBody(bodyInit, options)\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      var __onLoadHandled = false;\n\n      function onload() {\n        if (xhr.readyState !== 4) {\n          return\n        }\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          if (__onLoadHandled) { return; } else { __onLoadHandled = true; }\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n\n        if (__onLoadHandled) { return; } else { __onLoadHandled = true; }\n        resolve(new Response(body, options))\n      }\n      xhr.onreadystatechange = onload;\n      xhr.onload = onload;\n      xhr.onerror = function() {\n        if (__onLoadHandled) { return; } else { __onLoadHandled = true; }\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      // `withCredentials` should be setted after calling `.open` in IE10\n      // http://stackoverflow.com/a/19667959/1219343\n      try {\n        if (request.credentials === 'include') {\n          if ('withCredentials' in xhr) {\n            xhr.withCredentials = true;\n          } else {\n            console && console.warn && console.warn('withCredentials is not supported, you can ignore this warning');\n          }\n        }\n      } catch (e) {\n        console && console.warn && console.warn('set withCredentials error:' + e);\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n\n  // Support CommonJS\n  if ( true && module.exports) {\n    module.exports = self.fetch;\n  }\n})(typeof self !== 'undefined' ? self : this);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmV0Y2gtaWU4L2ZldGNoLmpzP2U5MDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiwwQkFBMEIsZUFBZTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVEsRUFBRSxPQUFPLHdCQUF3QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsUUFBUSxFQUFFLE9BQU8sd0JBQXdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUSxFQUFFLE9BQU8sd0JBQXdCO0FBQ3ZFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxLQUE2QjtBQUNuQztBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJlOTAxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGlmIF9fZGlzYWJsZU5hdGl2ZUZldGNoIGlzIHNldCB0byB0cnVlLCB0aGUgaXQgd2lsbCBhbHdheXMgcG9seWZpbGwgZmV0Y2hcbiAgLy8gd2l0aCBBamF4LlxuICBpZiAoIXNlbGYuX19kaXNhYmxlTmF0aXZlRmV0Y2ggJiYgc2VsZi5mZXRjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5cXF5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuXG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgdmFyIGxpc3QgPSB0aGlzLm1hcFtuYW1lXVxuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IFtdXG4gICAgICB0aGlzLm1hcFtuYW1lXSA9IGxpc3RcbiAgICB9XG4gICAgbGlzdC5wdXNoKHZhbHVlKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICAgIHJldHVybiB2YWx1ZXMgPyB2YWx1ZXNbMF0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldIHx8IFtdXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gW25vcm1hbGl6ZVZhbHVlKHZhbHVlKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMubWFwKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMubWFwW25hbWVdLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcylcbiAgICAgIH0sIHRoaXMpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYiwgb3B0aW9ucykge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gb3B0aW9ucy5oZWFkZXJzLm1hcFsnY29udGVudC10eXBlJ10gPyBvcHRpb25zLmhlYWRlcnMubWFwWydjb250ZW50LXR5cGUnXS50b1N0cmluZygpIDogJydcbiAgICB2YXIgcmVnZXggPSAvY2hhcnNldFxcPVswLTlhLXpBLVpcXC1cXF9dKjs/L1xuICAgIHZhciBfY2hhcnNldCA9IGJsb2IudHlwZS5tYXRjaChyZWdleCkgfHwgY29udGVudFR5cGUubWF0Y2gocmVnZXgpXG4gICAgdmFyIGFyZ3MgPSBbYmxvYl1cblxuICAgIGlmKF9jaGFyc2V0KSB7XG4gICAgICBhcmdzLnB1c2goX2NoYXJzZXRbMF0ucmVwbGFjZSgvXmNoYXJzZXRcXD0vLCAnJykucmVwbGFjZSgvOyQvLCAnJykpXG4gICAgfVxuXG4gICAgcmVhZGVyLnJlYWRBc1RleHQuYXBwbHkocmVhZGVyLCBhcmdzKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIC8vIE9ubHkgc3VwcG9ydCBBcnJheUJ1ZmZlcnMgZm9yIFBPU1QgbWV0aG9kLlxuICAgICAgICAvLyBSZWNlaXZpbmcgQXJyYXlCdWZmZXJzIGhhcHBlbnMgdmlhIEJsb2JzLCBpbnN0ZWFkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IsIHRoaXMuX29wdGlvbnMpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIHJldHVybiByZWplY3RlZCA/IHJlamVjdGVkIDogUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuICAgIGlmIChSZXF1ZXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGlucHV0KSkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IGlucHV0XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnb21pdCdcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSwgb3B0aW9ucylcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhlYWRlcnMoeGhyKSB7XG4gICAgdmFyIGhlYWQgPSBuZXcgSGVhZGVycygpXG4gICAgdmFyIHBhaXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdCgnXFxuJylcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgdmFyIHNwbGl0ID0gaGVhZGVyLnRyaW0oKS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKClcbiAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJzonKS50cmltKClcbiAgICAgIGhlYWQuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICByZXR1cm4gaGVhZFxuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCwgb3B0aW9ucylcbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dFxuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0XG4gICAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgJiYgIWluaXQpIHtcbiAgICAgICAgcmVxdWVzdCA9IGlucHV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICBmdW5jdGlvbiByZXNwb25zZVVSTCgpIHtcbiAgICAgICAgaWYgKCdyZXNwb25zZVVSTCcgaW4geGhyKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVVSTFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgc2VjdXJpdHkgd2FybmluZ3Mgb24gZ2V0UmVzcG9uc2VIZWFkZXIgd2hlbiBub3QgYWxsb3dlZCBieSBDT1JTXG4gICAgICAgIGlmICgvXlgtUmVxdWVzdC1VUkw6L20udGVzdCh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfX29uTG9hZEhhbmRsZWQgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25sb2FkKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMpID8gMjA0IDogeGhyLnN0YXR1c1xuICAgICAgICBpZiAoc3RhdHVzIDwgMTAwIHx8IHN0YXR1cyA+IDU5OSkge1xuICAgICAgICAgIGlmIChfX29uTG9hZEhhbmRsZWQpIHsgcmV0dXJuOyB9IGVsc2UgeyBfX29uTG9hZEhhbmRsZWQgPSB0cnVlOyB9XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzKHhociksXG4gICAgICAgICAgdXJsOiByZXNwb25zZVVSTCgpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG5cbiAgICAgICAgaWYgKF9fb25Mb2FkSGFuZGxlZCkgeyByZXR1cm47IH0gZWxzZSB7IF9fb25Mb2FkSGFuZGxlZCA9IHRydWU7IH1cbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gb25sb2FkO1xuICAgICAgeGhyLm9ubG9hZCA9IG9ubG9hZDtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfX29uTG9hZEhhbmRsZWQpIHsgcmV0dXJuOyB9IGVsc2UgeyBfX29uTG9hZEhhbmRsZWQgPSB0cnVlOyB9XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgLy8gYHdpdGhDcmVkZW50aWFsc2Agc2hvdWxkIGJlIHNldHRlZCBhZnRlciBjYWxsaW5nIGAub3BlbmAgaW4gSUUxMFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTk2Njc5NTkvMTIxOTM0M1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLndhcm4oJ3dpdGhDcmVkZW50aWFscyBpcyBub3Qgc3VwcG9ydGVkLCB5b3UgY2FuIGlnbm9yZSB0aGlzIHdhcm5pbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgY29uc29sZS53YXJuKCdzZXQgd2l0aENyZWRlbnRpYWxzIGVycm9yOicgKyBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxuXG4gIC8vIFN1cHBvcnQgQ29tbW9uSlNcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmLmZldGNoO1xuICB9XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///e901\n")},eb10:function(module,exports){eval('module.exports = "data:image/png;base64,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"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdlcy9uZXh0LWJnLnBuZz82ZDgzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiJlYjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRGtBQUFBeENBWUFBQUJnU3dIb0FBQUdiVWxFUVZSb2djMlphMnhVUlJUSHo4emNkcnRiTEExRnBlR0RXbFRRR01VRWpYNUFGRDlnVUl3a1BCUlRVVFFxeHNvanRLQWhHZzFFb1ZBbDFmRFMrSUVnVDZOb3hFQVROU0JLVUl5SWowVFJHQkd0VVpPMlNmZlIzWmt4Mi9hdXM3Tm5IbmMzS0NlWnpOMDdjK2VlMy96UHpKemJrazlsQmp5TStIVDZuMHk2WGh0WTJzNWxNTlZVUDFGZ0U2UU44RnlBTjZsSHNEWU1Fb013Z2YyWHdLcnpCTG1udGhYZDF5RjlBRjIvYldPNXpLU1FOSVNsQ2JZSTFMWW1kVWQ5cnN1RjA1KzFiU1lTNlllR2FXZ3FwTTFaN0ZxdlhXUFl6S29FQW9qQjZjOFVmcnVVdEVGRmdjWHUrNjR4dFQ5eGdLTG0ybDF0ZFNXd1dKc2Voazdua2I3VzNkVW5ITlZhaHl3WFZIZlV5MmxIVzRuS1B1R0tnZWdGNjZNL1h3bGdlQzA5bmlzeDB4SGlVczFVVEdPNExIUU9xM1U0bndrcU1sZGFwNGVkWHFobEFuUkFERlpYUmlMWCtlZUV4VS9uVHV1VDhkamd5bEhXQkFpYWNtcWh3OWMrc0NVV0dHYlk1bmdCY0dtYWpmK1drNVlhQXQrOG5jaTlGbkdkWWlxcXNHSkdNbWpMU2hoemN5QldyWWlKUDRiZnJZTTZqNkw4cDVadEhXSndoZnJXL3VBWUI3Z3MvMUFWd0pjWFU3bG1hNXgvNUJHNnVvTkZ5alduMk8xbkJIbFNBSXdiSHZ2OXJ0cmNQWXFhRXJuV1MyRjhhcEpZblFoVGlSRTRGSGJLQWt6OFFaQWQwNVBCbG80TWJRSUE1bGxvMkc5bG1rMmMxaC9zUEMzSXF5RmczaElFamlKTEJMUnJNNEJEeVJMMWxIcXd6RWtHOC8rUzBDb0FMbFFWR2sxZzQ1b2F2bUVjbFZsRXphSlFmUzlINjdjTzBKWWVDUStvemdVQVB6VlN1WHBibkw4enJLQmFYS29XM21PRHBBYllrdklaSjRsVkdkYmFLMkdoNmlRRCtMMkp5dlZiNDN5ZktWenZTN0htWHdWWkxBRHFsTkJKbmsvZ3BkMkozTXZEem5NTElBWmNOaVFHeXRUZkwyVFkrTU9jTE91WGNKdEtVZ053L01aQXJuOG14cjhJN3kxTnN5bGZjN0pvQU9CS3RXOGRnZDJ6cTBSN2M1WG9OZ0M2WUN1R1ZFR1pDWFpSbXQzeUhTZXRBd0FUVklEUkJMWmZRZVhCRTRMTTY1TXdUVzJMRXpoNkhaUHJub3Z4NHdZZ2s1cG5EZElJcUpiN1UyeitMNEk4TGdCR0lxRTZhRlVBWjVxbzNMQTV6dC9TSE5maHpnbElocWhORCtWSWZlY0FhL2xUd3IwYUh4OUw1YWJPR3I1eEZNbHZ6aWlnRGRRYjB1Y0lzUm5abTZYMXRnNDNCYkozVHlLMytzNUF6QnBCNEFnRlNOVVQyUDlndFppK1BjNWZHVVVHSFRmYXZpeXRzN1Y3T1ZtSmtqT1R3ZUllQ1V1cUFVNWV6V1I3ZTgzZ2V0STNxS0t6N1RBbkl5Y3oyYXRuTjdxU2o2YlkxQjhGV1o0REdOdElaTnNiQ2I2blhDVXJncHphSDV3VUFHUENHYXNqc09ldVFIUXVxQmEvSVpEcU84QUV1VDVEeDMzQTZkSitaV09xQnZqNFlHMXVwdWRSRWlsYzlZUzM1T0ZMcVZ4SUFickREbjBTWm0vTDBnL3ZUcktXcEN3azFhNVBwY0cybzV6VXprb0dUNzJib3dkVXdBRGcrMnVaWEduNWVIYWFxaVI0NUt3bDVSTk9ScXpOc0dVOUVoNVRCNjRDT04xRVplZm1vV3dGUzc4S0U3WWd4ZWIrTE1nVEFxQkJjU1RkUUdEZDNuOFRBblhqY1lWcWtTRGgvMEtpSk9kNkdRemRWUmsyNFFnbnkxUGErWmNnY093R0pqdWVqdkVUT21Scm1rMCt3Y2tTUFNFNGo4Q3VHWUZvZjNnbzdIMlRnY2lRWUFERVFJdk95WVVwTnUyVUlHMVpnTXRWeCtzSnZQbFF0ZWk0SXhCL2J4cWdsK3pQMGNWNlFoQUQrUHdhSnA5Zlc4T1BXWktBU092UkJHa0xXNmVpWWZ1OEZIdWtleWduVFlRUUZLQTNmNHowU1ppdXd1WFg5VVZVZHJ3ZTU3c3Nxa1ZSMFFxcEEwS1VSRjF2MzVHbEYrek0wbVc5RXVhQ3dSb0liSDQyeGwrOGlzbWtJeUhBMXFJT0N0cTFGZEttcGcwV1BSL2IwbXpTVjV5c1NBTmNINzZrbHNDQktVeXNhWXVKVTRqREpqRHZkYWpXNmo5aHNaRFZZVzFmSmxoZFZKcFRiRTZQSkpNYWllemFFdWRkQmlkdHU2Y05FbFhSQk9sUzA3Uk9zVWt3SlFLcUV5NVFMQ3h0SVZvQzZmUEhaZHVCRzc0d2hKRUtuUFNFeEdCMXBiRGRVNThvbzYrQjFwbG8xMnFObVZCVUMwMFlJc0UyVWFiUXM2MDlXeVpWQk95cnBBcHZnOVdoYkVycVlXVlMxUVZuVmRFRktUWEhYS3BLQkZRZncvWXVFNlRybm1rOEk2UU56QmErcHVjZ2dwSTJXS3pOQ0tVYnBtUzVvR3Bmcko5dDQzR0I2dTFZYlFRMmhhc1BxTTMwL3VqTEhhQXVTR3hNNSs0YUJSUTgxTVFtUkI4UGM5QUdFeGtRUEhaWERCUTgxNlh0ZVp0ekxxQkk2eEVpSmdNdVdLSTVpSVZwRkdBZkdDY2dlRUxxQS9vcWF4dkR0OTNyaUhCWkZFajlCVFpWZktGTlk1ZmJqbG81a0poRHRqT3dVcXQ0ckVvZ1ZYTTU0c3BkejU0QndEL1NSZFhxazBUMkl3QUFBQUJKUlU1RXJrSmdnZz09XCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///eb10\n')}});